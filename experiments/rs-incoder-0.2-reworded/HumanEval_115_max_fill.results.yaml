language: rs
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row.len();\n        for col in row.iter() {\n\
    \            if col == 0 {\n                min_bucket = std::cmp::min(min_bucket,\
    \ min_bucket);\n            }\n        }\n        cnt += min_bucket - min_bucket\
    \ % capacity;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpbbs5mzv6.rs:28:20\n\
    \   |\n28 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbbs5mzv6.rs:32:42\n   |\n32 |         cnt += min_bucket - min_bucket\
    \ % capacity;\n   |                                          ^^^^^^^^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot mod `usize` by `isize`\n  -->\
    \ /tmp/tmpbbs5mzv6.rs:32:40\n   |\n32 |         cnt += min_bucket - min_bucket\
    \ % capacity;\n   |                                        ^ no implementation\
    \ for `usize % isize`\n   |\n   = help: the trait `Rem<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbbs5mzv6.rs:34:5\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n34 |     cnt\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n34 |     cnt.try_into().unwrap()\n   |  \
    \      ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    let mut buckets = vec![vec![0; capacity]; grid.len()];\n\
    \    for row in grid.iter() {\n        let mut bucket = buckets[row.len()].clone();\n\
    \        for cell in row.iter() {\n            if cell == 1 {\n              \
    \  bucket[cell] = 1;\n            } else {\n                bucket[cell] = bucket[cell]\
    \ - 1;\n            }\n        }\n        if bucket.iter().all(|&b| b == 0) &&\
    \ buckets.iter().all(|&b| b.iter().all(|&b| b == 0)) {\n            ans = ans.saturating_sub(1);\n\
    \        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplr9f4ett.rs:24:36\n   |\n\
    24 |     let mut buckets = vec![vec![0; capacity]; grid.len()];\n   |        \
    \                            ^^^^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n24 |     let mut buckets = vec![vec![0; capacity.try_into().unwrap()];\
    \ grid.len()];\n   |                                            ++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmplr9f4ett.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmplr9f4ett.rs:29:17\n   |\n29 | \
    \                bucket[cell] = 1;\n   |                 ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmplr9f4ett.rs:31:17\n   |\n31 | \
    \                bucket[cell] = bucket[cell] - 1;\n   |                 ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  --> /tmp/tmplr9f4ett"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        for col in row.iter() {\n\
    \            if *col == 0 {\n                cnt += 1;\n            }\n      \
    \  }\n    }\n    cnt += max_fill_helper(grid, capacity);\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_fill_helper` in this scope\n  -->\
    \ /tmp/tmp45n1h1_m.rs:31:12\n   |\n31 |     cnt += max_fill_helper(grid, capacity);\n\
    \   |            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    for row in grid.iter() {\n   \
    \     let mut flow = row[0];\n        let mut max_flow = flow;\n        for row\
    \ in grid.iter() {\n            if row[0] == 0 {\n                flow -= 1;\n\
    \            } else {\n                flow += 1;\n            }\n           \
    \ if flow > max_flow {\n                max_flow = flow;\n            }\n    \
    \    }\n    }\n    return max_flow;\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpo_pzm1de.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: -1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n\
    \    let mut min_grid = grid.clone();\n    let mut min_capacity = capacity;\n\
    \    while min_cnt > 0 {\n        let mut min_grid = min_grid.clone();\n     \
    \   for r in 0..min_grid.len() {\n            for c in 0..min_grid[r].len() {\n\
    \                if min_grid[r][c] == 1 {\n                    min_grid[r][c]\
    \ = 0;\n                    min_cnt -= 1;\n                }\n            }\n\
    \        }\n        let mut min_capacity = min_capacity;\n        for r in 0..min_grid.len()\
    \ {\n            for c in 0..min_grid[r].len() {\n                if min_grid[r][c]\
    \ == 0 {\n                    min_capacity -= 1;\n                }\n        \
    \    }\n        }\n        if min_capacity == 0 {\n            cnt += 1;\n   \
    \     }\n        if min_capacity < capacity {\n            max_cnt = cnt;\n  \
    \          cnt = 1;\n            min_cnt = std::i32::MAX;\n            min_grid\
    \ = min_grid.clone();\n            min_capacity = capacity;\n        }\n    }\n\
    \    max_cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for col in row.iter()\
    \ {\n            if col[0] == 0 {\n                cnt += 1;\n               \
    \ min_bucket = min(min_bucket, col[1]);\n            }\n        }\n        if\
    \ min_bucket < capacity {\n            cnt += 1;\n            min_bucket = capacity;\n\
    \        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpcqav4ols.rs:30:30\n\
    \   |\n30 |                 min_bucket = min(min_bucket, col[1]);\n   |      \
    \                        ^^^\n...\n41 | fn main() {\n   | --------- similarly\
    \ named function `main` defined here\n   |\nhelp: a function with a similar name\
    \ exists\n   |\n30 |                 min_bucket = main(min_bucket, col[1]);\n\
    \   |                              ~~~~\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror[E0599]: no method named `len` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpcqav4ols.rs:26:37\n   |\n\
    26 |         let mut min_bucket = row[0].len();\n   |                        \
    \             ^^^ method not found in `isize`\n\nerror[E0608]: cannot index into\
    \ a value of type `&isize`\n  --> /tmp/tmpcqav4ols.rs:28:16\n   |\n28 |      \
    \       if col[0] == 0 {\n   |                ^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `&isize`\n  --> /tmp/tmpcqav4ols.rs:30:46\n   |\n30 | \
    \                min_bucket = min(min_bucket, col[1]);\n   |                 \
    \                             ^^^^^^\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                cnt += 1;\n              \
    \  max_cnt = std::cmp::max(max_cnt, cnt);\n                grid[row][col] = 0;\n\
    \            }\n        }\n    }\n    for row in 0..grid.len() {\n        for\
    \ col in 0..grid[row].len() {\n            if grid[row][col] == 0 {\n        \
    \        grid[row][col] = 1;\n                cnt -= 1;\n                max_cnt\
    \ = std::cmp::max(max_cnt, cnt);\n            }\n        }\n    }\n    max_cnt\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `max_grid`\n  --> /tmp/tmpjp9114k5.rs:25:13\n\
    \   |\n25 |     let mut max_grid = grid.clone();\n   |             ^^^^^^^^ help:\
    \ if this is intentional, prefix it with an underscore: `_max_grid`\n   |\n  \
    \ = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable:\
    \ `capacity`\n  --> /tmp/tmpjp9114k5.rs:22:36\n   |\n22 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |                                    ^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_capacity`\n\n\
    warning: variable does not need to be mutable\n  --> /tmp/tmpjp9114k5.rs:25:9\n\
    \   |\n25 |     let mut max_grid = grid.clone();\n   |         ----^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpjp9114k5.rs:31:17\n   |\n22 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n31 |                 grid[row][col]\
    \ = 0;\n   |                 ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmpjp9114k5.rs:38:17\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n38 |                 grid[row][col] = 1;\n   |                 ^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = vec![vec![0;\
    \ capacity]; grid.len()];\n    let mut min_well = vec![vec![0; capacity]; grid.len()];\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if col == 0 {\n         \
    \       cnt += 1;\n            }\n        }\n        if cnt < min_well[row.len()\
    \ - 1][col.len() - 1] {\n            min_well = row;\n        }\n    }\n    cnt\
    \ += max_cnt - min_well[grid.len() - 1][grid.len() - 1];\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `col` in this scope\n  --> /tmp/tmputoop64l.rs:46:42\n\
    \   |\n46 |         if cnt < min_well[row.len() - 1][col.len() - 1] {\n   |  \
    \                                        ^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmputoop64l.rs:25:37\n   |\n25 |     let mut max_well\
    \ = vec![vec![0; capacity]; grid.len()];\n   |                               \
    \      ^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n25\
    \ |     let mut max_well = vec![vec![0; capacity.try_into().unwrap()]; grid.len()];\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmputoop64l.rs:26:37\n   |\n26 |     let mut min_well\
    \ = vec![vec![0; capacity]; grid.len()];\n   |                               \
    \      ^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n26\
    \ |     let mut min_well = vec![vec![0; capacity.try_into().unwrap()]; grid.len()];\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmputoop64l.rs:30:20\n \
    \  |\n30 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmputoop64l.rs:36:24\n   |\n25 |     let mut max_well = vec![vec![0; capacity];\
    \ grid.len()];\n   |                        -----------------------------------\
    \ expected due to this value\n...\n36 |             max_well = row;\n   |    \
    \                    ^^^ expected struct `Vec`, found `&Vec<isize>`\n   |\n  \
    \ = note: expected struct `"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n\
    \    let mut min_bucket = std::i32::MAX;\n    for row in grid.iter() {\n     \
    \   let mut cnt = 0;\n        let mut max_cnt = 0;\n        let mut min_cnt =\
    \ std::i32::MAX;\n        let mut min_bucket = std::i32::MAX;\n        for col\
    \ in row.iter() {\n            if *col == 1 {\n                cnt += 1;\n   \
    \             if cnt > max_cnt {\n                    max_cnt = cnt;\n       \
    \         }\n                if min_cnt > cnt {\n                    min_cnt =\
    \ cnt;\n                }\n                if min_bucket > cnt {\n           \
    \         min_bucket = cnt;\n                }\n            }\n        }\n   \
    \     if min_cnt > capacity {\n            cnt -= min_cnt - capacity;\n      \
    \  }\n        if cnt > capacity {\n            cnt -= capacity - min_cnt;\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n\
    \        if min_cnt > max_cnt {\n            min_cnt = max_cnt;\n        }\n \
    \       if min_bucket > max_cnt {\n            min_bucket = max_cnt;\n       \
    \ }\n        cnt -= min_bucket - capacity;\n        if cnt > capacity {\n    \
    \        cnt -= capacity - min_bucket;\n        }\n        if cnt > max_cnt {\n\
    \            max_cnt = cnt;\n        }\n        if min_cnt > max_cnt {\n     \
    \       min_cnt = max_cnt;\n        }\n        if min_bucket > max_cnt {\n   \
    \         min_bucket = max_cnt;\n        }\n        cnt -= min_bucket - capacity;\n\
    \        if cnt > capacity {\n            cnt -= capacity - min_bucket;\n    \
    \    }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n  \
    \      if min_cnt > max_cnt {\n            min_cnt = max_cnt;\n        }\n   \
    \     if min_bucket > max_cnt {\n            min_bucket = max_cnt;\n        }\n\
    \        cnt -= min_bucket - capacity;\n        if cnt > capacity {\n        \
    \    cnt -= capacity - min_bucket;\n        }\n        if cnt > max_cnt {\n  \
    \          max_cnt = cnt;\n        }\n        if min_cnt > max_cnt {\n       \
    \     min_cnt = max_cnt;\n        }\n        if min_bucket > max_cnt {\n     \
    \       min_bucket = max_cnt;\n        }\n        cnt -= min_bucket - capacity;\n\
    \        if cnt > capacity {\n            cnt -= capacity - min_bucket;\n    \
    \    }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n  \
    \      if min_cnt > max_cnt {\n            min_cnt = max_cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmppkf1xser.rs:118:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n27  |     for row in grid.iter() {\n    |                  \
    \          - unclosed delimiter\n...\n107 |         if min_cnt > max_cnt {\n \
    \   |                              - this delimiter might not be properly closed...\n\
    108 |             min_cnt = max_cnt\n109 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n118 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppkf1xser.rs:46:22\n   |\n46 |         if min_cnt > capacity\
    \ {\n   |                      ^^^^^^^^ expected `i32`, found `isize`\n   |\n\
    help: you can convert an `isize` to an `i32` and panic if the converted value\
    \ doesn't fit\n   |\n46 |         if min_cnt > capacity.try_into().unwrap() {\n\
    \   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppkf1xser.rs:47:30\n   |\n47 |             cnt -= min_cnt\
    \ - capacity;\n   |                              ^^^^^^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0277]: cannot subtract `isize` from `i32`\n  --> /tmp/tmppkf1xser.rs:47:28\n\
    \   |\n47 |             cnt -= min_cnt - capacity;\n   |                     \
    \       ^ no implementation for `i32 - isize`\n   |\n   = help: the trait `Sub<isize>`\
    \ is not implemented for `i32`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppkf1xser.rs:49:18\n\
    \   |\n49 |         if cnt > capacity {\n   |                  ^^^^^^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value"
  stdout: ''
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                cnt += 1;\n              \
    \  if cnt > max_cnt {\n                    max_cnt = cnt;\n                  \
    \  max_grid = grid.clone();\n                }\n            }\n        }\n   \
    \ }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpkbbllkd8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    let mut max_capacity = 0;\n    for row in grid.iter()\
    \ {\n        let mut max_row = 0;\n        for cell in row.iter() {\n        \
    \    if cell == 1 {\n                max_row += 1;\n            }\n        }\n\
    \        if max_row > max_capacity {\n            max_capacity = max_row;\n  \
    \      }\n    }\n    for row in grid.iter() {\n        let mut max_row = 0;\n\
    \        for cell in row.iter() {\n            if cell == 1 {\n              \
    \  max_row += 1;\n            }\n        }\n        if max_row > max_capacity\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp84g7bk1u.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp84g7bk1u.rs:39:21\n   |\n39 |             if\
    \ cell == 1 {\n   |                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    let mut flow_index = 0;\n    let\
    \ mut flow_index2 = 0;\n    let mut flow_index3 = 0;\n    let mut flow_index4\
    \ = 0;\n    let mut flow_index5 = 0;\n    let mut flow_index6 = 0;\n    let mut\
    \ flow_index7 = 0;\n    let mut flow_index8 = 0;\n    let mut flow_index9 = 0;\n\
    \    let mut flow_index10 = 0;\n    let mut flow_index11 = 0;\n    let mut flow_index12\
    \ = 0;\n    let mut flow_index13 = 0;\n    let mut flow_index14 = 0;\n    let\
    \ mut flow_index15 = 0;\n    let mut flow_index16 = 0;\n    let mut flow_index17\
    \ = 0;\n    let mut flow_index18 = 0;\n    let mut flow_index19 = 0;\n    let\
    \ mut flow_index20 = 0;\n    let mut flow_index21 = 0;\n    let mut flow_index22\
    \ = 0;\n    let mut flow_index23 = 0;\n    let mut flow_index24 = 0;\n    let\
    \ mut flow_index25 = 0;\n    let mut flow_index26 = 0;\n    let mut flow_index27\
    \ = 0;\n    let mut flow_index28 = 0;\n    let mut flow_index29 = 0;\n    let\
    \ mut flow_index30 = 0;\n    let mut flow_index31 = 0;\n    let mut flow_index32\
    \ = 0;\n    let mut flow_index33 = 0;\n    let mut flow_index34 = 0;\n    let\
    \ mut flow_index35 = 0;\n    let mut flow_index36 = 0;\n    let mut flow_index37\
    \ = 0;\n    let mut flow_index38 = 0;\n    let mut flow_index39 = 0;\n    let\
    \ mut flow_index40 = 0;\n    let mut flow_index41 = 0;\n    let mut flow_index42\
    \ = 0;\n    let mut flow_index43 = 0;\n    let mut flow_index44 = 0;\n    let\
    \ mut flow_index45 = 0;\n    let mut flow_index46 = 0;\n    let mut flow_index47\
    \ = 0;\n    let mut flow_index48 = 0;\n    let mut flow_index49 = 0;\n    let\
    \ mut flow_index50 = 0;\n    let mut flow_index51 = 0;\n    let mut flow_index52\
    \ = 0;\n    let mut flow_index53 = 0;\n    let mut flow_index54 = 0;\n    let\
    \ mut flow_index55 = 0;\n    let mut flow_index56 = 0;\n    let mut flow_index57\
    \ = 0;\n    let mut flow_index58 = 0;\n    let mut flow_index59 = 0;\n    let\
    \ mut flow_index60 = 0;\n    let mut flow_index61 = 0;\n    let mut flow_index62\
    \ = 0;\n    let mut flow_index63 = 0;\n\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl12ov3go.rs:22:56\n   |\n\
    22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for cell in row.iter() {\n            if cell == 1 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > capacity {\n            cnt\
    \ -= 1;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp_ka_wfzt.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_capacity = 0;\n    for row in grid.iter() {\n\
    \        let mut max_row = 0;\n        for col in row.iter() {\n            if\
    \ col == 0 {\n                max_row += 1;\n            }\n        }\n      \
    \  if max_row > max_capacity {\n            max_capacity = max_row;\n        }\n\
    \    }\n    for row in grid.iter() {\n        let mut max_row = 0;\n        for\
    \ col in row.iter() {\n            if col == 0 {\n                cnt += 1;\n\
    \            }\n        }\n        if max_row > max_capacity {\n            max_capacity\
    \ = max_row;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpxjgrj5uh.rs:28:20\n\
    \   |\n28 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpxjgrj5uh.rs:39:20\n   |\n39 |             if\
    \ col == 0 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        let mut max_capacity = capacity;\n    \
    \    for cell in row.iter() {\n            if cell == 1 {\n                cnt\
    \ += 1;\n                if cnt > max_capacity {\n                    max_capacity\
    \ = cnt;\n                }\n            }\n        }\n        cnt += 1;\n   \
    \     if cnt > max_capacity {\n            max_capacity = cnt;\n        }\n  \
    \  }\n    return max_capacity;\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpc8_sqpil.rs:29:21\n\
    \   |\n29 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    for row in max_grid.iter() {\n\
    \        for col in row.iter() {\n            if *col == 0 {\n               \
    \ *col = 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n \
    \       for col in row.iter() {\n            if *col == 0 {\n                *col\
    \ = 1;\n            }\n        }\n    }\n    for row in max_grid.iter() {\n  \
    \      for col in row.iter() {\n            if *col == 1 {\n                *col\
    \ = 0;\n            }\n        }\n    }\n    for row in grid.iter() {\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                *col =\
    \ 0;\n            }\n        }\n    }\n    for row in max_grid.iter() {\n    \
    \    for col in row.iter() {\n            if *col == 0 {\n                *col\
    \ = 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                *col =\
    \ 0;\n            }\n        }\n    }\n    for row in max_grid.iter() {\n    \
    \    for col in row.iter() {\n            if *col == 0 {\n                *col\
    \ = 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                *col =\
    \ 0;\n            }\n        }\n    }\n    for row in max_grid.iter() {\n    \
    \    for col in row.iter() {\n            if *col == 0 {\n                *col\
    \ = 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                *col =\
    \ 0;\n            }\n        }\n    }\n    for row in max_grid.iter() {\n    \
    \    for col in row.iter() {\n            if *col == 0 {\n                *col\
    \ = 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                *col =\
    \ 0;\n            }\n        }\n    }\n    for row in max_grid.iter() {\n    \
    \    for col in row.iter() {\n            if *col == 0 {\n                *col\
    \ = 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                *col =\
    \ 0;\n            }\n        }\n    }\n    for row in max_grid.iter() {\n    \
    \    for col in row.iter() {\n            if *col == 0 {\n                *col\
    \ = 1;\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpcks2tj28.rs:149:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n136 |     for row in max_grid.iter() {\n    |              \
    \                  - unclosed delimiter\n137 |         for col in row.iter() {\n\
    \    |                               - unclosed delimiter\n138 |             if\
    \ *col == 0 {\n    |                          - this delimiter might not be properly\
    \ closed...\n139 |                 *col = 1;\n140 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n149 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcks2tj28.rs:35:24\n   |\n25 |     let mut max_grid\
    \ = grid.clone();\n   |                        ------------ expected due to this\
    \ value\n...\n35 |             max_grid = row.clone();\n   |                 \
    \       ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected\
    \ struct `Vec<Vec<isize>>`\n              found struct `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmpcks2tj28.rs:136:5\n    |\n22  |   fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    |                        \
    \                                  ----- expected `isize` because of return type\n\
    ...\n136 | /     for row in max_grid.iter() {\n137 | |         for col in row.iter()\
    \ {\n138 | |             if *col == 0 {\n139 | |                 *col = 1;\n...\
    \   |\n148 | |     assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]],\
    \ 9), 2);\n149 | | }\n    | |__^ expected `isize`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for cell in row.iter() {\n            if cell == 1 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > capacity {\n            cnt\
    \ -= 1;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmppkxjh1ms.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                cnt += 1;\n              \
    \  if cnt > max_cnt {\n                    max_cnt = cnt;\n                  \
    \  max_grid = grid.clone();\n                }\n            }\n        }\n   \
    \ }\n    max_cnt += 1;\n    if max_cnt > capacity {\n        max_cnt = capacity;\n\
    \        max_grid = grid.clone();\n    }\n    max_cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpxoh7lnbw.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n\
    \        if cnt < min_cnt {\n            min_cnt = cnt;\n        }\n    }\n  \
    \  if max_cnt > capacity {\n        max_cnt = capacity;\n    }\n    if min_cnt\
    \ < capacity {\n        min_cnt = capacity;\n    }\n    cnt -= min_cnt;\n    cnt\
    \ += max_cnt;\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ifncrud.rs:40:18\n   |\n\
    40 |     if max_cnt > capacity {\n   |                  ^^^^^^^^ expected `i32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and panic\
    \ if the converted value doesn't fit\n   |\n40 |     if max_cnt > capacity.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2ifncrud.rs:41:19\n   |\n24 |     let mut max_cnt = 0;\n\
    \   |                       - expected due to this value\n...\n41 |         max_cnt\
    \ = capacity;\n   |                   ^^^^^^^^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2ifncrud.rs:43:18\n   |\n43 |\
    \     if min_cnt < capacity {\n   |                  ^^^^^^^^ expected `i32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and panic\
    \ if the converted value doesn't fit\n   |\n43 |     if min_cnt < capacity.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2ifncrud.rs:44:19\n   |\n25 |     let mut min_cnt = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n44\
    \ |         min_cnt = capacity;\n   |                   ^^^^^^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ifncrud.rs:48:5\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n48 |     cnt\n   |     ^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n48 |     cnt.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut cur_cap = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                cur_cap -= 1;\n            }\n\
    \            buckets[cell.len() - 1] += cur_cap;\n        }\n    }\n    for bucket\
    \ in buckets.iter() {\n        if bucket > capacity {\n            cnt += 1;\n\
    \        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp0aeqf13d.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `len`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmp0aeqf13d.rs:31:26\n\
    \   |\n31 |             buckets[cell.len() - 1] += cur_cap;\n   |            \
    \              ^^^ method not found in `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0aeqf13d.rs:35:21\n   |\n35 |         if bucket > capacity {\n\
    \   |                     ^^^^^^^^\n   |                     |\n   |         \
    \            expected reference, found `isize`\n   |                     help:\
    \ consider borrowing here: `&capacity`\n   |\n   = note: expected reference `&_`\n\
    \                   found type `isize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for bucket in row.iter()\
    \ {\n            if *bucket > min_bucket {\n                min_bucket = *bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp2tdqyomx.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = grid[0].len();\n        for col in row.iter()\
    \ {\n            if col == 0 {\n                min_bucket = std::cmp::min(min_bucket,\
    \ grid[col.to_owned()].len());\n            }\n        }\n        cnt += min_bucket\
    \ - grid[0].len();\n        min_bucket = grid[0].len();\n    }\n    cnt\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp9fg3lvoz.rs:28:20\n\
    \   |\n28 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: the type `[Vec<isize>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp9fg3lvoz.rs:29:56\n   |\n29 |         \
    \        min_bucket = std::cmp::min(min_bucket, grid[col.to_owned()].len());\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<isize>]>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<isize>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9fg3lvoz.rs:35:5\n   |\n22 | fn\
    \ max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |          \
    \                                              ----- expected `isize` because\
    \ of return type\n...\n35 |     cnt\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n35 |     cnt.try_into().unwrap()\n   |\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    for row in grid.iter() {\n  \
    \      let mut cnt = 0;\n        for col in row.iter() {\n            if *col\
    \ == 0 {\n                cnt += 1;\n            }\n        }\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n            max_grid = row.clone();\n\
    \        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    if max_cnt > capacity {\n   \
    \     return max_cnt;\n    }\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if *col == 0 {\n        \
    \        cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n   \
    \         max_cnt = cnt;\n            max_grid = row.clone();\n        }\n   \
    \ }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n    return 0;\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa6udpr7g.rs:35:24\n   |\n\
    35 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpa6udpr7g.rs:47:24\n   |\n47 |             max_grid = row.clone();\n\
    \   |                        ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found struct\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa6udpr7g.rs:62:24\n\
    \   |\n62 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpa6udpr7g.rs:77:24\n   |\n77 |             max_grid = row.clone();\n\
    \   |                        ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found struct\
    \ `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; capacity];\n    for row in grid.iter()\
    \ {\n        let mut bucket = 0;\n        for cell in row.iter() {\n         \
    \   bucket += cell;\n            if bucket > capacity {\n                bucket\
    \ = capacity;\n            }\n        }\n        buckets[bucket] += 1;\n     \
    \   cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6bct5ajp.rs:24:31\n   |\n\
    24 |     let mut buckets = vec![0; capacity];\n   |                          \
    \     ^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n24\
    \ |     let mut buckets = vec![0; capacity.try_into().unwrap()];\n   |       \
    \                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp6bct5ajp.rs:33:9\n\
    \   |\n33 |         buckets[bucket] += 1;\n   |         ^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmprx8ql89x.rs:27:20\n\
    \   |\n27 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        for col in row.iter() {\n\
    \            if col == 0 {\n                cnt += 1;\n            }\n       \
    \ }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpxp406gb1.rs:26:20\n\
    \   |\n26 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for cell in row.iter() {\n            if cell == 1 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > capacity {\n            cnt\
    \ -= 1;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmppkxjh1ms.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_capacity = 0;\n    for row in grid.iter() {\n\
    \        let mut cnt = 0;\n        let mut max_capacity = 0;\n        for col\
    \ in row.iter() {\n            if col == 0 {\n                cnt += 1;\n    \
    \            if cnt > max_capacity {\n                    max_capacity = cnt;\n\
    \                }\n            }\n        }\n        cnt += 1;\n        if cnt\
    \ > max_capacity {\n            max_capacity = cnt;\n        }\n    }\n    if\
    \ max_capacity > capacity {\n        max_capacity = capacity;\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpap0bd5j5.rs:29:20\n\
    \   |\n29 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; capacity];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets.clone();\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket[cell] += 1;\n        \
    \    }\n        }\n        if bucket.iter().any(|&x| x == 0) {\n            cnt\
    \ += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpka_jl5t0.rs:24:31\n   |\n\
    24 |     let mut buckets = vec![0; capacity];\n   |                          \
    \     ^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n24\
    \ |     let mut buckets = vec![0; capacity.try_into().unwrap()];\n   |       \
    \                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpka_jl5t0.rs:28:21\n   |\n28 |     \
    \        if cell == 1 {\n   |                     ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpka_jl5t0.rs:29:17\n   |\n29 |                 bucket[cell] += 1;\n\
    \   |                 ^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            cnt += 1;\n          \
    \  buckets[row.len() - 1] = bucket;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpphwqr8jd.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_wells = isize::MAX;\n    let mut max_wells_cnt = 0;\n    let mut min_wells\
    \ = isize::MAX;\n    let mut min_wells_cnt = 0;\n    for row in grid.iter() {\n\
    \        let mut wells_cnt = 0;\n        for cell in row.iter() {\n          \
    \  if cell == 1 {\n                wells_cnt += 1;\n            }\n        }\n\
    \        if wells_cnt > max_wells {\n            max_wells = wells_cnt;\n    \
    \        max_wells_cnt = 0;\n        }\n        if wells_cnt < min_wells {\n \
    \           min_wells = wells_cnt;\n            min_wells_cnt = 0;\n        }\n\
    \    }\n    if max_wells_cnt > capacity {\n        max_wells = max_wells_cnt;\n\
    \    }\n    if min_wells_cnt > capacity {\n        min_wells = min_wells_cnt;\n\
    \    }\n    max_wells - min_wells\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpfcus2ml1.rs:30:21\n\
    \   |\n30 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            cnt += 1;\n          \
    \  bucket = capacity - 1;\n        }\n        buckets[row.len() - 1] = bucket;\n\
    \    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp2zo3ckro.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmprx8ql89x.rs:27:20\n\
    \   |\n27 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut res = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len()];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            bucket = capacity;\n \
    \       }\n        buckets[row.len()] = bucket;\n        res += bucket;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp7m7kc6w_.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    for row in grid.iter() {\n     \
    \   let mut cnt = 0;\n        for col in row.iter() {\n            if col == 0\
    \ {\n                cnt += 1;\n            }\n        }\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n    }\n    if max_cnt > capacity {\n\
    \        max_cnt = capacity;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp4povb6np.rs:28:20\n\
    \   |\n28 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    for row in grid.iter() {\n  \
    \      let mut cnt = 0;\n        for col in row.iter() {\n            if *col\
    \ == 0 {\n                cnt += 1;\n            }\n        }\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n            max_grid = row.clone();\n\
    \        }\n    }\n    if max_cnt == 0 {\n        return 0;\n    }\n    if max_cnt\
    \ == 1 {\n        return 1;\n    }\n    let mut cnt = 0;\n    for row in grid.iter()\
    \ {\n        for col in row.iter() {\n            if *col == 1 {\n           \
    \     cnt += 1;\n            }\n        }\n    }\n    if cnt > max_cnt {\n   \
    \     return cnt;\n    }\n    let mut cnt = 0;\n    for row in grid.iter() {\n\
    \        for col in row.iter() {\n            if *col == 0 {\n               \
    \ cnt += 1;\n            }\n        }\n    }\n    if cnt > max_cnt {\n       \
    \ return cnt;\n    }\n    let mut cnt = 0;\n    for row in grid.iter() {\n   \
    \     for col in row.iter() {\n            if *col == 1 {\n                cnt\
    \ += 1;\n            }\n        }\n    }\n    if cnt > max_cnt {\n        return\
    \ cnt;\n    }\n    let mut cnt = 0;\n    for row in grid.iter() {\n        for\
    \ col in row.iter() {\n            if *col == 0 {\n                cnt += 1;\n\
    \            }\n        }\n    }\n    if cnt > max_cnt {\n        return cnt;\n\
    \    }\n    let mut cnt = 0;\n    for row in grid.iter() {\n        for col in\
    \ row.iter() {\n            if *col == 1 {\n                cnt += 1;\n      \
    \      }\n        }\n    }\n    if cnt > max_cnt {\n        return cnt;\n    }\n\
    \    let mut cnt = 0;\n    for row in grid.iter() {\n        for col in row.iter()\
    \ {\n            if *col == 0 {\n                cnt += 1;\n            }\n  \
    \      }\n    }\n    if cnt > max_cnt {\n        return cnt;\n    }\n    let mut\
    \ cnt = 0;\n    for row in grid.iter() {\n        for col in row.iter() {\n  \
    \          if *col == 1 {\n                cnt += 1;\n            }\n        }\n\
    \    }\n    if cnt > max_cnt {\n        return cnt;\n    }\n    let mut cnt =\
    \ 0;\n    for row in grid.iter() {\n        for col in row.iter() {\n        \
    \    if *col == 0 {\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdg0rywyi.rs:146:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n134 |     for row in grid.iter() {\n    |                  \
    \          - unclosed delimiter\n135 |         for col in row.iter() {\n    |\
    \                               - unclosed delimiter\n136 |             if *col\
    \ == 0 {\n    |                          - this delimiter might not be properly\
    \ closed...\n137 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n146 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdg0rywyi.rs:35:24\n\
    \   |\n35 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpdg0rywyi.rs:47:24\n   |\n47 |             max_grid = row.clone();\n\
    \   |                        ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found struct\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpdg0rywyi.rs:134:5\n\
    \    |\n22  |   fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                          ----- expected\
    \ `isize` because of return type\n...\n134 | /     for row in grid.iter() {\n\
    135 | |         for col in row.iter() {\n136 | |             if *col == 0 {\n\
    137 | | }\n...   |\n145 | |     assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1,\
    \ 1, 1, 1]], 9), 2);\n146 | | }\n    | |__^ expected `isize`, found `()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    for row in grid.iter() {\n        let mut counter = 0;\n\
    \        for cell in row.iter() {\n            if cell == 1 {\n              \
    \  counter += 1;\n            }\n        }\n        if counter > capacity {\n\
    \            return counter;\n        }\n    }\n    return 0;\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpqzeleu8s.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    let mut min_grid = grid.clone();\n    let mut min_cnt = 1;\n    let mut min_max_cnt\
    \ = 1;\n    let mut min_max_grid = grid.clone();\n    let mut min_min_grid = grid.clone();\n\
    \    let mut min_min_cnt = 1;\n    let mut min_min_max_cnt = 1;\n    let mut min_min_max_grid\
    \ = grid.clone();\n    let mut min_min_min_cnt = 1;\n    let mut min_min_min_max_cnt\
    \ = 1;\n    let mut min_min_min_max_grid = grid.clone();\n    let mut min_min_min_min_cnt\
    \ = 1;\n    let mut min_min_min_min_max_cnt = 1;\n    let mut min_min_min_min_max_grid\
    \ = grid.clone();\n    let mut min_min_min_min_cnt = 1;\n    let mut min_min_min_min_max_cnt\
    \ = 1;\n    let mut min_min_min_min_max_grid = grid.clone();\n    let mut min_min_min_min_cnt\
    \ = 1;\n    let mut min_min_min_min_max_cnt = 1;\n    let mut min_min_min_min_max_grid\
    \ = grid.clone();\n    let mut min_min_min_min_cnt = 1;\n    let mut min_min_min_min_max_cnt\
    \ = 1;\n    let mut min_min_min_min_max_grid = grid.clone();\n    let mut min_min_min_min_cnt\
    \ = 1;\n    let mut min_min_min_min_max_cnt = 1;\n    let mut min_min_min_min_max_grid\
    \ = grid.clone();\n    let mut min_min_min_min_cnt = 1;\n    let mut min_min_min_min_max_cnt\
    \ = 1;\n    let mut min_min_min_min_max_grid = grid.clone();\n    let mut min_min_min_min_cnt\
    \ = 1;\n    let mut min_min_min_min_max_cnt = 1;\n    let mut min_min_min_min_max_grid\
    \ = grid.clone();\n    let mut min_min_min_min_cnt = 1;\n    let mut min_min_min_min_max_cnt\
    \ = 1;\n    let mut min_min_min_min_max_grid = grid.clone();\n    let mut min_min_min_min_cnt\
    \ = 1;\n    let mut min_min_min_min_max_cnt = 1;\n    let mut min_min_min_min_max_grid\
    \ = grid.clone();\n    let mut min_min_min_min_cnt = 1;\n    let mut min_min_min_min_max_cnt\
    \ = 1;\n    let mut min_min_min_min_max_grid = grid.clone();\n    let mut min_min_min_min_cnt\
    \ = 1;\n    let mut min_min_min_min_max_cnt = 1;\n    let mut min_min_min_min_max_grid\
    \ = grid.clone();\n    let mu\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvgm1rx31.rs:70:11\n   |\n\
    70 |     let mu\n   |           ^ help: add `;` here\n71 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvgm1rx31.rs:22:56\n \
    \  |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n  \
    \ |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_well = vec![vec![0]; grid.len()];\n    let mut max_wells = vec![];\n\
    \    for row in grid.iter() {\n        let mut well = vec![];\n        for cell\
    \ in row.iter() {\n            if cell == 1 {\n                well.push(cell);\n\
    \            } else {\n                well.push(0);\n            }\n        }\n\
    \        max_well = max_well.iter().max();\n        max_wells.push(well);\n  \
    \  }\n    let mut count = 0;\n    for well in max_wells.iter() {\n        let\
    \ mut new_well = vec![];\n        for cell in well.iter() {\n            if cell\
    \ == 0 {\n                new_well.push(cell);\n            } else {\n       \
    \         new_well.push(0);\n            }\n        }\n        if new_well.len()\
    \ > capacity {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpnci7xv40.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnci7xv40.rs:31:27\n\
    \   |\n31 |                 well.push(0);\n   |                           ^\n\
    \   |                           |\n   |                           expected `&isize`,\
    \ found integer\n   |                           help: consider borrowing here:\
    \ `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnci7xv40.rs:34:20\n  \
    \ |\n34 |         max_well = max_well.iter().max();\n   |                    ^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<Vec<{integer}>>`\n                found enum `Option<&Vec<{integer}>>`\n\
    \nerror[E0277]: can't compare `&&isize` with `{integer}`\n  --> /tmp/tmpnci7xv40.rs:41:21\n\
    \   |\n41 |             if cell == 0 {\n   |                     ^^ no implementation\
    \ for `&&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnci7xv40.rs:44:31\n\
    \   |\n44 |                 new_well.push(0);\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnci7xv40.rs:47:29\n   |\n47 |         if new_well.len() > capacity\
    \ {\n   |                             ^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n47 |         if new_well.len() > capacity.try_into().unwrap()\
    \ {\n   |                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    for row in grid.iter() {\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                counter += 1;\n            }\n\
    \        }\n    }\n    if counter > capacity {\n        counter\n    } else {\n\
    \        max_fill(grid, capacity)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpjul016cy.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        for col in row.iter() {\n\
    \            if col == 0 {\n                cnt += 1;\n            }\n       \
    \ }\n    }\n    cnt += max_fill_helper(grid, capacity);\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_fill_helper` in this scope\n  -->\
    \ /tmp/tmpi053e_vk.rs:31:12\n   |\n31 |     cnt += max_fill_helper(grid, capacity);\n\
    \   |            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpi053e_vk.rs:26:20\n   |\n26\
    \ |             if col == 0 {\n   |                    ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if col == 0 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n        if cnt > 0 {\n            cnt -= 1;\n        }\n    }\n\
    \    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpl2scokh9.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         let mut cnt = 0;\n            for r in 0..capacity {\n             \
    \   for c in 0..capacity {\n                    if grid[row][col] == 1 && grid[row\
    \ + r][col + c] == 1 {\n                        cnt += 1;\n                  \
    \  }\n                }\n            }\n            if cnt > max_cnt {\n     \
    \           max_cnt = cnt;\n                max_grid = grid.clone();\n       \
    \     }\n        }\n    }\n    if max_cnt == 0 {\n        return 0;\n    }\n \
    \   for row in 0..max_grid.len() {\n        for col in 0..max_grid[row].len()\
    \ {\n            if max_grid[row][col] == 1 {\n                cnt += 1;\n   \
    \         }\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4705acdy.rs:31:58\n   |\n\
    31 |                     if grid[row][col] == 1 && grid[row + r][col + c] == 1\
    \ {\n   |                                                          ^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  -->\
    \ /tmp/tmp4705acdy.rs:31:56\n   |\n31 |                     if grid[row][col]\
    \ == 1 && grid[row + r][col + c] == 1 {\n   |                                \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4705acdy.rs:31:67\n   |\n31 |                     if grid[row][col]\
    \ == 1 && grid[row + r][col + c] == 1 {\n   |                                \
    \                                   ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmp4705acdy.rs:31:65\n   |\n31 | \
    \                    if grid[row][col] == 1 && grid[row + r][col + c] == 1 {\n\
    \   |                                                                 ^ no implementation\
    \ for `usize + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented\
    \ for `usize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut cur_capacity = capacity;\n        for cell in row.iter()\
    \ {\n            if *cell == 1 {\n                cur_capacity -= 1;\n       \
    \     }\n        }\n        if cur_capacity > max_capacity {\n            max_capacity\
    \ = cur_capacity;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpjnpco210.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row.len();\n        for col in row.iter() {\n\
    \            if col == 0 {\n                min_bucket = std::cmp::min(min_bucket,\
    \ min_bucket);\n            }\n        }\n        min_bucket = std::cmp::min(min_bucket,\
    \ capacity);\n        cnt += min_bucket - capacity;\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpk3vrlb_x.rs:28:20\n\
    \   |\n28 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk3vrlb_x.rs:32:48\n\
    \   |\n32 |         min_bucket = std::cmp::min(min_bucket, capacity);\n   |  \
    \                                              ^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n32 |         min_bucket = std::cmp::min(min_bucket,\
    \ capacity.try_into().unwrap());\n   |                                       \
    \         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk3vrlb_x.rs:33:29\n   |\n33 |         cnt += min_bucket - capacity;\n\
    \   |                             ^^^^^^^^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpk3vrlb_x.rs:33:27\n\
    \   |\n33 |         cnt += min_bucket - capacity;\n   |                      \
    \     ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>`\
    \ is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk3vrlb_x.rs:35:5\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n35 |     cnt\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |     cnt.try_into().unwrap()\n   |\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = Vec::new();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if col == 0 {\n         \
    \       cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n    \
    \        max_cnt = cnt;\n            max_well = row;\n        }\n    }\n    if\
    \ max_cnt > capacity {\n        return max_cnt;\n    }\n    let mut cnt = 0;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n\
    \    }\n    let mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if col == 0 {\n         \
    \       cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n    \
    \        max_cnt = cnt;\n            max_well = row;\n        }\n    }\n    if\
    \ max_cnt > capacity {\n        return max_cnt;\n    }\n    let mut cnt = 0;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n\
    \    }\n    let mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if col == 0 {\n         \
    \       cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n    \
    \        max_cnt = cnt;\n            max_well = row;\n        }\n    }\n    if\
    \ max_cnt > capacity {\n        return max_cnt;\n    }\n    let mut cnt = 0;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    if max_cnt \n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp9pailcnl.rs:131:1\n    |\n\
    130 |     if max_cnt \n    |     -- this `if` expression has a condition, but\
    \ no block\n131 | }\n    | ^ expected `{`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp9pailcnl.rs:29:20\n   |\n29 |             if\
    \ col == 1 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9pailcnl.rs:35:24\n   |\n35 |\
    \             max_well = row;\n   |                        ^^^- help: try using\
    \ a conversion method: `.to_vec()`\n   |                        |\n   |      \
    \                  expected struct `Vec`, found `&Vec<isize>`\n   |\n   = note:\
    \ expected struct `Vec<_>`\n           found reference `&Vec<isize>`\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmp9pailcnl.rs:41:20\n \
    \  |\n41 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9pailcnl.rs:47:24\n\
    \   |\n47 |             max_well = row;\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |                        |\n\
    \   |                        expected struct `Vec`, found `&Vec<isize>`\n   |\n\
    \   = note: expected struct `Vec<_>`\n           found reference `&Vec<isize>`\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp9pailcnl.rs:57:20\n\
    \   |\n57 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9pailcnl.rs:63:24\n\
    \   |\n63 |             max_well = row;\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |                        |\n\
    \   |                        expected struct `Vec`, found `&Vec<isize>`\n   |\n\
    \   = note: exp"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt2 = 0;\n    \
    \    for col in row.iter() {\n            if col == 1 {\n                cnt2\
    \ += 1;\n            }\n        }\n        if cnt2 > capacity {\n            cnt\
    \ += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpqui2b14c.rs:27:20\n\
    \   |\n27 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    let mut flow_index = 0;\n    let\
    \ mut flow_index2 = 0;\n    let mut flow_index3 = 0;\n    let mut flow_index4\
    \ = 0;\n    let mut flow_index5 = 0;\n    let mut flow_index6 = 0;\n    let mut\
    \ flow_index7 = 0;\n    let mut flow_index8 = 0;\n    let mut flow_index9 = 0;\n\
    \    let mut flow_index10 = 0;\n    let mut flow_index11 = 0;\n    let mut flow_index12\
    \ = 0;\n    let mut flow_index13 = 0;\n    let mut flow_index14 = 0;\n    let\
    \ mut flow_index15 = 0;\n    let mut flow_index16 = 0;\n    let mut flow_index17\
    \ = 0;\n    let mut flow_index18 = 0;\n    let mut flow_index19 = 0;\n    let\
    \ mut flow_index20 = 0;\n    let mut flow_index21 = 0;\n    let mut flow_index22\
    \ = 0;\n    let mut flow_index23 = 0;\n    let mut flow_index24 = 0;\n    let\
    \ mut flow_index25 = 0;\n    let mut flow_index26 = 0;\n    let mut flow_index27\
    \ = 0;\n    let mut flow_index28 = 0;\n    let mut flow_index29 = 0;\n    let\
    \ mut flow_index30 = 0;\n    let mut flow_index31 = 0;\n    let mut flow_index32\
    \ = 0;\n    let mut flow_index33 = 0;\n    let mut flow_index34 = 0;\n    let\
    \ mut flow_index35 = 0;\n    let mut flow_index36 = 0;\n    let mut flow_index37\
    \ = 0;\n    let mut flow_index38 = 0;\n    let mut flow_index39 = 0;\n    let\
    \ mut flow_index40 = 0;\n    let mut flow_index41 = 0;\n    let mut flow_index42\
    \ = 0;\n    let mut flow_index43 = 0;\n    let mut flow_index44 = 0;\n    let\
    \ mut flow_index45 = 0;\n    let mut flow_index46 = 0;\n    let mut flow_index47\
    \ = 0;\n    let mut flow_index48 = 0;\n    let mut flow_index49 = 0;\n    let\
    \ mut flow_index50 = 0;\n    let mut flow_index51 = 0;\n    let mut flow_index52\
    \ = 0;\n    let mut flow_index53 = 0;\n    let mut flow_index54 = 0;\n    let\
    \ mut flow_index55 = 0;\n    let mut flow_index56 = 0;\n    let mut flow_index57\
    \ = 0;\n    let mut flow_index58 = 0;\n    let mut flow_index59 = 0;\n    let\
    \ mut flow_index60 = 0;\n    let mut flow_index61 = 0;\n    let mut flow_index62\
    \ = 0;\n    let mut flow_index63 = 0;\n\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl12ov3go.rs:22:56\n   |\n\
    22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    while max_cnt > capacity {\n\
    \        let mut cnt = 0;\n        for col in max_grid.iter() {\n            if\
    \ *col == 1 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > capacity {\n            max_cnt = cnt;\n            max_grid = max_grid.clone();\n\
    \        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwtwae48d.rs:35:24\n   |\n\
    35 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0277]: can't compare `Vec<isize>`\
    \ with `{integer}`\n  --> /tmp/tmpwtwae48d.rs:41:21\n   |\n41 |             if\
    \ *col == 1 {\n   |                     ^^ no implementation for `Vec<isize> ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur_cap\
    \ = capacity;\n        for cell in row.iter() {\n            if cell == 1 {\n\
    \                cur_cap -= 1;\n            }\n        }\n        if cur_cap <\
    \ 0 {\n            cur_cap = 0;\n        }\n        ans = if cur_cap < ans {\n\
    \            cur_cap\n        } else {\n            ans\n        };\n    }\n \
    \   ans\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpsi5q6x8n.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_wells = isize::MAX;\n    let mut max_wells_cnt = 0;\n    for row in\
    \ grid.iter() {\n        let mut cnt = 0;\n        for cell in row.iter() {\n\
    \            if cell == 1 {\n                cnt += 1;\n            }\n      \
    \  }\n        if cnt > max_wells {\n            max_wells = cnt;\n           \
    \ max_wells_cnt = 0;\n        }\n        if cnt > max_wells_cnt {\n          \
    \  max_wells_cnt = cnt;\n        }\n    }\n    if max_wells_cnt > capacity {\n\
    \        max_wells_cnt = capacity;\n    }\n    max_wells_cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpfzj5gviw.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        let mut max_cnt\
    \ = 0;\n        let mut min_cnt = std::i32::MAX;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n                if\
    \ cnt > max_cnt {\n                    max_cnt = cnt;\n                }\n   \
    \             if cnt < min_cnt {\n                    min_cnt = cnt;\n       \
    \         }\n            }\n        }\n        if max_cnt > min_cnt {\n      \
    \      cnt += max_cnt - min_cnt;\n        }\n        cnt += 1;\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt\
    \ {\n            min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n        }\n        cnt += 1;\n    \
    \    if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n        cnt +=\
    \ 1;\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n    \
    \    cnt += 1;\n        if cnt > max_cnt {\n            max_cnt = cnt;\n     \
    \   }\n        cnt += 1;\n        if cnt > max_cnt {\n            max_cnt = cnt;\n\
    \        }\n        cnt += 1;\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt {\n         \
    \   max_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt {\n\
    \            max_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n        }\n        cnt += 1;\n    \
    \    if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n        cnt +=\
    \ 1;\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n    \
    \    cnt += 1;\n        if cnt > max_cnt {\n            max_cnt = cnt;\n     \
    \   }\n        cnt += 1;\n        if cnt > max_cnt {\n            max_cnt = cnt;\n\
    \        }\n        cnt += 1;\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt {\n         \
    \   max_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt {\n\
    \            max_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpcw5jzuo7.rs:130:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n26  |     for row in grid.iter() {\n    |                  \
    \          - this delimiter might not be properly closed...\n...\n121 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n130 | }\n\
    \    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpcw5jzuo7.rs:121:1\n\
    \    |\n120 |         if cnt > max_\n    |         -- this `if` expression has\
    \ a condition, but no block\n121 | }\n    | ^ expected `{`\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpcw5jzuo7.rs:31:20\n   |\n31\
    \ |             if col == 1 {\n   |                    ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcw5jzuo7.rs:22:56\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur_cap\
    \ = capacity;\n        for cell in row.iter() {\n            if cell == 1 {\n\
    \                cur_cap -= 1;\n            }\n        }\n        if cur_cap <\
    \ 0 {\n            cur_cap = 0;\n        }\n        ans = if cur_cap < ans {\n\
    \            ans - cur_cap\n        } else {\n            ans + cur_cap\n    \
    \    };\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpis8pgg_d.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    while max_cnt > capacity {\n\
    \        cnt += 1;\n        for row in grid.iter() {\n            let mut cnt\
    \ = 0;\n            for col in row.iter() {\n                if *col == 0 {\n\
    \                    cnt += 1;\n                }\n            }\n           \
    \ if cnt > max_cnt {\n                max_cnt = cnt;\n                max_grid\
    \ = row.clone();\n            }\n        }\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkw0okm5a.rs:35:24\n   |\n\
    35 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpkw0okm5a.rs:49:28\n   |\n49 |                 max_grid = row.clone();\n\
    \   |                            ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found struct\
    \ `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket -= 1;\n            }\n\
    \            if bucket < 0 {\n                bucket = 0;\n            }\n   \
    \     }\n        buckets[row.len() - 1] = bucket;\n    }\n    for bucket in buckets.iter()\
    \ {\n        cnt += bucket < capacity;\n    }\n    cnt\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpnb7ezrf_.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnb7ezrf_.rs:38:25\n\
    \   |\n38 |         cnt += bucket < capacity;\n   |                         ^^^^^^^^\n\
    \   |                         |\n   |                         expected reference,\
    \ found `isize`\n   |                         help: consider borrowing here: `&capacity`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `isize`\n\
    \nerror[E0277]: cannot add-assign `bool` to `{integer}`\n  --> /tmp/tmpnb7ezrf_.rs:38:13\n\
    \   |\n38 |         cnt += bucket < capacity;\n   |             ^^ no implementation\
    \ for `{integer} += bool`\n   |\n   = help: the trait `AddAssign<bool>` is not\
    \ implemented for `{integer}`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur_cap\
    \ = capacity;\n        for col in row.iter() {\n            if col == 0 {\n  \
    \              cur_cap -= 1;\n            }\n            ans = if cur_cap < ans\
    \ {\n                cur_cap\n            } else {\n                ans;\n   \
    \         }\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpo5dix6xd.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo5dix6xd.rs:32:20\n\
    \   |\n32 |               } else {\n   |  ____________________^\n33 | |      \
    \           ans;\n   | |                    - help: consider removing this semicolon\n\
    34 | |             }\n   | |_____________^ expected `isize`, found `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    let mut buckets = vec![Vec::new(); capacity + 1];\n\
    \    for row in grid.iter() {\n        let mut cur = buckets[row[0]];\n      \
    \  for cell in row.iter().rev() {\n            if cell == 1 {\n              \
    \  cur.push(cell);\n            } else {\n                cur.push(cell);\n  \
    \              cur.push(cell);\n            }\n        }\n        buckets[row[0]]\
    \ = cur;\n    }\n    for bucket in buckets.iter() {\n        ans = std::cmp::max(ans,\
    \ bucket.iter().filter(|&x| x == 1).count());\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm3leiulw.rs:24:40\n   |\n\
    24 |     let mut buckets = vec![Vec::new(); capacity + 1];\n   |             \
    \                           ^^^^^^^^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n24 |     let mut buckets = vec![Vec::new(); (capacity + 1).try_into().unwrap()];\n\
    \   |                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0277]: the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpm3leiulw.rs:26:23\n\
    \   |\n26 |         let mut cur = buckets[row[0]];\n   |                     \
    \  ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<_>>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpm3leiulw.rs:28:21\n   |\n28 |             if cell == 1 {\n   |\
    \                     ^^ no implementation for `&isize == {integer}`\n   |\n \
    \  = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\n\
    error[E0277]: the type `[Vec<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpm3leiulw.rs:35:9\n\
    \   |\n35 |         buckets[row[0]] = cur;\n   |         ^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ can't compare `&_` with `{integer}`\n  --> /tmp/tmpm3leiulw.rs:38:62\n   |\n\
    38 |         ans = std::cmp::max(ans, bucket.iter().filter(|&x| x == 1).count());\n\
    \   |                                                              ^^ no implementation\
    \ for `&_ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm3leiulw.rs:38:34\n\
    \   |\n38 |         ans = std::cmp::max(ans, bucket.iter().fi"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    let mut flow_inc = 0;\n    let\
    \ mut flow_inc_prev = 0;\n    let mut flow_inc_prev2 = 0;\n    let mut flow_inc_prev3\
    \ = 0;\n    let mut flow_inc_prev4 = 0;\n    let mut flow_inc_prev5 = 0;\n   \
    \ let mut flow_inc_prev6 = 0;\n    let mut flow_inc_prev7 = 0;\n    let mut flow_inc_prev8\
    \ = 0;\n    let mut flow_inc_prev9 = 0;\n    let mut flow_inc_prev10 = 0;\n  \
    \  let mut flow_inc_prev11 = 0;\n    let mut flow_inc_prev12 = 0;\n    let mut\
    \ flow_inc_prev13 = 0;\n    let mut flow_inc_prev14 = 0;\n    let mut flow_inc_prev15\
    \ = 0;\n    let mut flow_inc_prev16 = 0;\n    let mut flow_inc_prev17 = 0;\n \
    \   let mut flow_inc_prev18 = 0;\n    let mut flow_inc_prev19 = 0;\n    let mut\
    \ flow_inc_prev20 = 0;\n    let mut flow_inc_prev21 = 0;\n    let mut flow_inc_prev22\
    \ = 0;\n    let mut flow_inc_prev23 = 0;\n    let mut flow_inc_prev24 = 0;\n \
    \   let mut flow_inc_prev25 = 0;\n    let mut flow_inc_prev26 = 0;\n    let mut\
    \ flow_inc_prev27 = 0;\n    let mut flow_inc_prev28 = 0;\n    let mut flow_inc_prev29\
    \ = 0;\n    let mut flow_inc_prev30 = 0;\n    let mut flow_inc_prev31 = 0;\n \
    \   let mut flow_inc_prev32 = 0;\n    let mut flow_inc_prev33 = 0;\n    let mut\
    \ flow_inc_prev34 = 0;\n    let mut flow_inc_prev35 = 0;\n    let mut flow_inc_prev36\
    \ = 0;\n    let mut flow_inc_prev37 = 0;\n    let mut flow_inc_prev38 = 0;\n \
    \   let mut flow_inc_prev39 = 0;\n    let mut flow_inc_prev40 = 0;\n    let mut\
    \ flow_inc_prev41 = 0;\n    let mut flow_inc_prev42 = 0;\n    let mut flow_inc_prev43\
    \ = 0;\n    let mut flow_inc_prev44 = 0;\n    let mut flow_inc_prev45 = 0;\n \
    \   let mut flow_inc_prev46 = 0;\n    let mut flow_inc_prev47 = 0;\n    let mut\
    \ flow_inc_prev48 = 0;\n    let mut flow_inc_prev49 = 0;\n    let mut flow_inc_\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprzeadl3h.rs:75:22\n   |\n\
    75 |     let mut flow_inc_\n   |                      ^ help: add `;` here\n76\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprzeadl3h.rs:22:56\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = vec![vec![0];\
    \ grid.len()];\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_well = row;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 0 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_well = row;\n \
    \       }\n    }\n    for row in grid.iter() {\n        let mut cnt = 0;\n   \
    \     for col in row.iter() {\n            if col == 1 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_well = row;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 0 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_well = row;\n \
    \       }\n    }\n    for row in grid.iter() {\n        let mut cnt = 0;\n   \
    \     for col in row.iter() {\n            if col == 1 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_well = row;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 0 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_well = row;\n \
    \       }\n    }\n    for row in grid.iter() {\n        let mut cnt = 0;\n   \
    \     for col in row.iter() {\n            if col == 1 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_well = row;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 0 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_well = row;\n \
    \       }\n    }\n    for row in grid.iter() {\n        let mut cnt = 0;\n   \
    \     for col in row.iter() {\n            if col == 1 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpp6pj8l5h.rs:140:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n122 |     for row in grid.iter() {\n    |                  \
    \          - unclosed delimiter\n...\n129 |         if cnt > max_cnt {\n    |\
    \                          - this delimiter might not be properly closed...\n\
    130 |             max_cnt = cnt\n131 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n140 | }\n    |   ^\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpp6pj8l5h.rs:29:20\n   |\n29 |     \
    \        if col == 1 {\n   |                    ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp6pj8l5h.rs:35:24\n\
    \   |\n35 |             max_well = row;\n   |                        ^^^ expected\
    \ struct `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<Vec<{integer}>>`\n\
    \           found reference `&Vec<isize>`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpp6pj8l5h.rs:41:20\n   |\n41 |             if\
    \ col == 0 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp6pj8l5h.rs:47:24\n   |\n47 |\
    \             max_well = row;\n   |                        ^^^ expected struct\
    \ `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<Vec<{integer}>>`\n\
    \           found reference `&Vec<isize>`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpp6pj8l5h.rs:53:20\n   |\n53 |             if\
    \ col == 1 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp6pj8l5h.rs:59:24\n   |\n59 |\
    \             max_well = row"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![Vec::new(); grid.len()];\n    for row\
    \ in grid.iter() {\n        let mut bucket = buckets[row.len() - 1];\n       \
    \ for cell in row.iter() {\n            if cell == 1 {\n                bucket.push(cell);\n\
    \            }\n        }\n    }\n    while buckets.iter().any(|b| b.len() > capacity)\
    \ {\n        cnt += 1;\n        for bucket in buckets.iter_mut() {\n         \
    \   bucket.truncate(capacity);\n        }\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp5s1d3ngy.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5s1d3ngy.rs:33:44\n\
    \   |\n33 |     while buckets.iter().any(|b| b.len() > capacity) {\n   |     \
    \                                       ^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n33 |     while buckets.iter().any(|b| b.len() > capacity.try_into().unwrap())\
    \ {\n   |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5s1d3ngy.rs:36:29\n   |\n36 |\
    \             bucket.truncate(capacity);\n   |                             ^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n36 |           \
    \  bucket.truncate(capacity.try_into().unwrap());\n   |                      \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    let mut min_grid = grid.clone();\n    for row in 0..grid.len() {\n      \
    \  for col in 0..grid[row].len() {\n            if grid[row][col] == 1 {\n   \
    \             cnt += 1;\n                if cnt > max_cnt {\n                \
    \    max_cnt = cnt;\n                    max_grid = grid.clone();\n          \
    \      }\n                if cnt < min_grid[row][col] {\n                    min_grid[row][col]\
    \ = cnt;\n                }\n            }\n        }\n    }\n    if max_cnt ==\
    \ 0 {\n        return 0;\n    }\n    let mut min_cnt = max_cnt;\n    for row in\
    \ 0..grid.len() {\n        for col in 0..grid[row].len() {\n            if grid[row][col]\
    \ == 1 {\n                cnt += 1;\n                if cnt < min_cnt {\n    \
    \                min_cnt = cnt;\n                    min_grid = grid.clone();\n\
    \                }\n            }\n        }\n    }\n    if min_cnt == 0 {\n \
    \       return 0;\n    }\n    let mut min_row = min_grid[0].iter().max().unwrap();\n\
    \    let mut min_col = min_grid[0].iter().max().unwrap();\n    let mut min_cnt2\
    \ = max_cnt;\n    for row in 1..grid.len() {\n        for col in 0..grid[row].len()\
    \ {\n            if grid[row][col] == 1 {\n                cnt += 1;\n       \
    \         if cnt < min_cnt2 {\n                    min_cnt2 = cnt;\n         \
    \           min_row = row;\n                    min_col = col;\n             \
    \   }\n            }\n        }\n    }\n    if min_cnt == min_cnt2 {\n       \
    \ return min_cnt;\n    }\n    if min_cnt == min_cnt2 + 1 {\n        return min_cnt2;\n\
    \    }\n    if min_cnt == min_cnt2 + 2 {\n        return min_cnt2 + 1;\n    }\n\
    \    if min_cnt == min_cnt2 + 3 {\n        return min_cnt2 + 2;\n    }\n    if\
    \ min_cnt == min_cnt2 + 4 {\n        return min_cnt2 + 3;\n    }\n    if min_cnt\
    \ == min_cnt2 + 5 {\n        return min_cnt2 + 4;\n    }\n    if min_cnt == min_cnt2\
    \ + 6 {\n        return min_cnt2 + 5;\n    }\n    if min_cnt == min_cnt2 + 7 {\n\
    \        return min_cnt2 + 6;\n    }\n    if min_cnt == min_cnt2 + 8 {\n     \
    \   return min_cnt2 + 7;\n    }\n    if min_cnt == min_cnt2 + 9 {\n        return\
    \ min_cnt2 + 8;\n    }\n    if min_cnt == min_cnt2 + 10 {\n        return min_cnt2\
    \ + 9;\n    }\n    if min_cnt == min_cnt2 + 11 {\n        return min_cnt2 + 10;\n\
    \n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmppdtdbjlb.rs:119:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n107 |     if min_cnt == min_cnt2 + 11 {\n    |             \
    \                    - this delimiter might not be properly closed...\n...\n110\
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n119\
    \ | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppdtdbjlb.rs:68:31\n\
    \   |\n68 |                     min_row = row;\n   |                         \
    \      ^^^ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppdtdbjlb.rs:69:31\n   |\n69 |                     min_col = col;\n\
    \   |                               ^^^ expected `&isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppdtdbjlb.rs:22:56\n   |\n22 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------             \
    \                               ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    for row in grid.iter() {\n   \
    \     let mut flow = 0;\n        for cell in row.iter() {\n            if cell\
    \ == 0 {\n                flow += 1;\n            }\n        }\n        if flow\
    \ > max_flow {\n            max_flow = flow;\n        }\n    }\n    max_flow -=\
    \ capacity;\n    max_flow\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpn0rj1z6c.rs:28:21\n\
    \   |\n28 |             if cell == 0 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row.len();\n        for bucket in row.iter()\
    \ {\n            if bucket > min_bucket {\n                min_bucket = bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl3z6trpk.rs:28:25\n   |\n\
    28 |             if bucket > min_bucket {\n   |                         ^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl3z6trpk.rs:29:30\n\
    \   |\n29 |                 min_bucket = bucket;\n   |                       \
    \       ^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl3z6trpk.rs:34:5\n   |\n22 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |                                          \
    \              ----- expected `isize` because of return type\n...\n34 |     cnt\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n34 |     cnt.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for bucket in row.iter()\
    \ {\n            if *bucket > min_bucket {\n                min_bucket = bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpyiv77goc.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyiv77goc.rs:29:30\n\
    \   |\n29 |                 min_bucket = bucket;\n   |                       \
    \       ^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n29 |                 min_bucket = *bucket;\n   |         \
    \                     +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = vec![0; grid.len()];\n    for row in grid.iter() {\n        let\
    \ mut flow = vec![0; row.len()];\n        for (i, j) in row.iter().enumerate()\
    \ {\n            flow[j] = if grid[i][j] == 1 { capacity } else { 0 };\n     \
    \   }\n        max_flow.iter_mut().for_each(|&mut flow| {\n            if flow.iter().any(|&flow|\
    \ flow < capacity) {\n                flow = capacity - flow;\n            }\n\
    \        });\n    }\n    max_flow.iter().cloned().sum()\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmpdar0b6hv.rs:27:13\n   |\n27 |             flow[j] = if grid[i][j] ==\
    \ 1 { capacity } else { 0 };\n   |             ^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpdar0b6hv.rs:27:26\n \
    \  |\n27 |             flow[j] = if grid[i][j] == 1 { capacity } else { 0 };\n\
    \   |                          ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0599]: no method named `iter` found\
    \ for type `{integer}` in the current scope\n  --> /tmp/tmpdar0b6hv.rs:30:21\n\
    \   |\n30 |             if flow.iter().any(|&flow| flow < capacity) {\n   |  \
    \                   ^^^^ method not found in `{integer}`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            cnt += bucket - capacity;\n\
    \        }\n        buckets[row.len() - 1] = bucket;\n    }\n    cnt\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpp45264re.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in\
    \ grid.iter() {\n        for bucket in row.iter() {\n            buckets[bucket]\
    \ += 1;\n        }\n    }\n    for bucket in buckets.iter() {\n        if bucket\
    \ > capacity {\n            counter += bucket - capacity;\n        }\n    }\n\
    \    counter\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmpnons_q_j.rs:27:13\n   |\n27 |             buckets[bucket] += 1;\n  \
    \ |             ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnons_q_j.rs:31:21\n   |\n31 |         if bucket > capacity {\n   | \
    \                    ^^^^^^^^\n   |                     |\n   |              \
    \       expected reference, found `isize`\n   |                     help: consider\
    \ borrowing here: `&capacity`\n   |\n   = note: expected reference `&_`\n    \
    \               found type `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n\
    \        if cnt < min_cnt {\n            min_cnt = cnt;\n        }\n    }\n  \
    \  if max_cnt > capacity {\n        max_cnt = capacity;\n    }\n    if min_cnt\
    \ < capacity {\n        min_cnt = capacity;\n    }\n    cnt += min_cnt - max_cnt;\n\
    \    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5014sri8.rs:40:18\n   |\n\
    40 |     if max_cnt > capacity {\n   |                  ^^^^^^^^ expected `i32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and panic\
    \ if the converted value doesn't fit\n   |\n40 |     if max_cnt > capacity.try_into().unwrap()\
    \ {\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5014sri8.rs:41:19\n   |\n41 |         max_cnt = capacity;\n\
    \   |                   ^^^^^^^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5014sri8.rs:43:18\n   |\n43 |     if min_cnt\
    \ < capacity {\n   |                  ^^^^^^^^ expected `i32`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n43 |     if min_cnt < capacity.try_into().unwrap()\
    \ {\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5014sri8.rs:44:19\n   |\n44 |         min_cnt = capacity;\n\
    \   |                   ^^^^^^^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5014sri8.rs:47:5\n   |\n22 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |                         \
    \                               ----- expected `isize` because of return type\n\
    ...\n47 |     cnt\n   |     ^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n47 |     cnt.try_into().unwrap()\n   |\n\nerror: aborting due to\
    \ 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for cell in row.iter() {\n            if cell == 1 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > capacity {\n            cnt\
    \ -= 1;\n        }\n        if cnt == 0 {\n            cnt += 1;\n        }\n\
    \    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmplt15ff2r.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket -= 1;\n            }\n\
    \            bucket += 1;\n        }\n        if bucket > capacity {\n       \
    \     cnt += 1;\n            buckets[row.len() - 1] = bucket;\n        }\n   \
    \ }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp85eizo6j.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        if row.len() < min_bucket {\n            min_bucket = row.len();\n\
    \        }\n    }\n    for row in grid.iter() {\n        for bucket in row.iter()\
    \ {\n            if bucket < min_bucket {\n                cnt += min_bucket -\
    \ bucket;\n            }\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_jv9msuw.rs:32:25\n   |\n\
    32 |             if bucket < min_bucket {\n   |                         ^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_jv9msuw.rs:33:37\n\
    \   |\n33 |                 cnt += min_bucket - bucket;\n   |                \
    \                     ^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `&isize` from `usize`\n  --> /tmp/tmp_jv9msuw.rs:33:35\n   |\n\
    33 |                 cnt += min_bucket - bucket;\n   |                       \
    \            ^ no implementation for `usize - &isize`\n   |\n   = help: the trait\
    \ `Sub<&isize>` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_jv9msuw.rs:37:5\n   |\n22 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |                                          \
    \              ----- expected `isize` because of return type\n...\n37 |     cnt\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n37 |     cnt.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 1 {\n                cnt += 1;\n            }\n        }\n        buckets[row.iter().next().unwrap()]\
    \ += cnt;\n    }\n    for bucket in buckets.iter() {\n        if bucket > capacity\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpb04yf7k6.rs:28:20\n\
    \   |\n28 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpb04yf7k6.rs:32:9\n   |\n32 |         buckets[row.iter().next().unwrap()]\
    \ += cnt;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb04yf7k6.rs:35:21\n   |\n35 |         if bucket > capacity\
    \ {\n   |                     ^^^^^^^^\n   |                     |\n   |     \
    \                expected reference, found `isize`\n   |                     help:\
    \ consider borrowing here: `&capacity`\n   |\n   = note: expected reference `&_`\n\
    \                   found type `isize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt2 = 0;\n    \
    \    for col in row.iter() {\n            if col == 0 {\n                cnt2\
    \ += 1;\n            }\n        }\n        if cnt2 > capacity {\n            cnt\
    \ += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpjz_4k_00.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket = bucket - 1;\n      \
    \      } else {\n                bucket = bucket + 1;\n            }\n       \
    \     if bucket < 0 {\n                bucket = 0;\n            }\n        }\n\
    \        buckets[row.len() - 1] = bucket;\n        cnt += 1;\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp20rsbugr.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for col in row.iter()\
    \ {\n            if col[0] == 0 {\n                cnt += 1;\n               \
    \ if min_bucket > col {\n                    min_bucket = col;\n             \
    \   }\n            }\n        }\n        if min_bucket > capacity {\n        \
    \    cnt += 1;\n            min_bucket = capacity;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpe38m81qp.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror[E0608]: cannot index into a value of type `&isize`\n  -->\
    \ /tmp/tmpe38m81qp.rs:28:16\n   |\n28 |             if col[0] == 0 {\n   |   \
    \             ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe38m81qp.rs:35:25\n\
    \   |\n35 |         if min_bucket > capacity {\n   |                         ^^^^^^^^\n\
    \   |                         |\n   |                         expected `&isize`,\
    \ found `isize`\n   |                         help: consider borrowing here: `&capacity`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe38m81qp.rs:37:26\n   |\n37 |\
    \             min_bucket = capacity;\n   |                          ^^^^^^^^\n\
    \   |                          |\n   |                          expected `&isize`,\
    \ found `isize`\n   |                          help: consider borrowing here:\
    \ `&capacity`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for col in row.iter()\
    \ {\n            if col[0] < min_bucket {\n                min_bucket = col[0];\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n        min_bucket\
    \ = grid[0].len();\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpk_266vmv.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror[E0608]: cannot index into a value of type `&isize`\n  -->\
    \ /tmp/tmpk_266vmv.rs:28:16\n   |\n28 |             if col[0] < min_bucket {\n\
    \   |                ^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `&isize`\n  --> /tmp/tmpk_266vmv.rs:29:30\n   |\n29 |                 min_bucket\
    \ = col[0];\n   |                              ^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk_266vmv.rs:35:5\n   |\n22 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |                                          \
    \              ----- expected `isize` because of return type\n...\n35 |     cnt\n\
    \   |     ^^^ expected `isize`, found `usize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut min_capacity = capacity;\n        for col in row.iter() {\n\
    \            if col == 0 {\n                min_capacity = std::cmp::min(min_capacity,\
    \ capacity);\n                cnt += 1;\n            }\n            capacity -=\
    \ 1;\n        }\n        min_capacity = std::cmp::min(min_capacity, capacity);\n\
    \        cnt += 1;\n        capacity -= 1;\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpjdnlfwrq.rs:28:20\n\
    \   |\n28 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            cnt += 1;\n          \
    \  buckets[row.len() - 1] = bucket;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpphwqr8jd.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur_capacity\
    \ = capacity;\n        for cell in row.iter() {\n            if *cell == 1 {\n\
    \                cur_capacity -= 1;\n            }\n        }\n        if cur_capacity\
    \ < ans {\n            ans = cur_capacity;\n        }\n    }\n    ans\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `6`', /tmp/tmpyc06gt07.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row.len();\n        for col in row.iter() {\n\
    \            if col == 0 {\n                min_bucket = std::cmp::min(min_bucket,\
    \ col);\n            }\n        }\n        cnt += min_bucket - 1;\n        min_bucket\
    \ = grid[0].len();\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpcr8oo5qu.rs:28:20\n\
    \   |\n28 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcr8oo5qu.rs:29:56\n\
    \   |\n29 |                 min_bucket = std::cmp::min(min_bucket, col);\n   |\
    \                                                        ^^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcr8oo5qu.rs:35:5\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n35 |     cnt\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |     cnt.try_into().unwrap()\n   |\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n\
    \    let mut min_bucket = std::i32::MAX;\n    for row in grid.iter() {\n     \
    \   let mut cnt = 0;\n        let mut max_cnt = 0;\n        let mut min_cnt =\
    \ std::i32::MAX;\n        let mut min_bucket = std::i32::MAX;\n        for col\
    \ in row.iter() {\n            if col == 0 {\n                cnt += 1;\n    \
    \            if cnt > max_cnt {\n                    max_cnt = cnt;\n        \
    \        }\n                if cnt < min_cnt {\n                    min_cnt =\
    \ cnt;\n                }\n                if min_bucket > cnt {\n           \
    \         min_bucket = cnt;\n                }\n            }\n        }\n   \
    \     if min_cnt > capacity {\n            cnt += min_bucket - capacity;\n   \
    \     }\n        cnt += min_bucket - capacity;\n        if cnt > max_cnt {\n \
    \           max_cnt = cnt;\n        }\n        cnt += min_bucket - capacity;\n\
    \        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n        cnt\
    \ += min_bucket - capacity;\n        if cnt > max_cnt {\n            max_cnt =\
    \ cnt;\n        }\n        cnt += min_bucket - capacity;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        cnt += min_bucket - capacity;\n\
    \        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n        cnt\
    \ += min_bucket - capacity;\n        if cnt > max_cnt {\n            max_cnt =\
    \ cnt;\n        }\n        cnt += min_bucket - capacity;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        cnt += min_bucket - capacity;\n\
    \        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n        cnt\
    \ += min_bucket - capacity;\n        if cnt > max_cnt {\n            max_cnt =\
    \ cnt;\n        }\n        cnt += min_bucket - capacity;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        cnt += min_bucket - capacity;\n\
    \        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n        cnt\
    \ += min_bucket - capacity;\n        if cnt > max_cnt {\n            max_cnt =\
    \ cnt;\n        }\n        cnt += min_bucket - capacity;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        cnt += min_bucket - capacity;\n\
    \        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n        cnt\
    \ += min_bucket - capacity;\n        if \n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpu1cb5f5a.rs:116:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n27  |     for row in grid.iter() {\n    |                  \
    \          - this delimiter might not be properly closed...\n...\n107 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n116 | }\n\
    \    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmpu1cb5f5a.rs:107:1\n\
    \    |\n107 | }\n    | ^ expected expression\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpu1cb5f5a.rs:33:20\n   |\n33 |             if\
    \ col == 0 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu1cb5f5a.rs:46:22\n   |\n46 |\
    \         if min_cnt > capacity {\n   |                      ^^^^^^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n46 |         if min_cnt > capacity.try_into().unwrap()\
    \ {\n   |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu1cb5f5a.rs:47:33\n   |\n47 |             cnt += min_bucket\
    \ - capacity;\n   |                                 ^^^^^^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0277]: cannot subtract `isize` from `i32`\n  --> /tmp/tmpu1cb5f5a.rs:47:31\n\
    \   |\n47 |             cnt += min_bucket - capacity;\n   |                  \
    \             ^ no implementation for `i32 - isize`\n   |\n   = help: the trait\
    \ `Sub<isize>` is not implemented for `i32`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu1cb5f5a.rs:49:29\n   |\n49 |         cnt += min_bucket - capacity;\n\
    \   |                             ^^^^^^^^ expected `i32`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `i32`\n  --> /tmp/tmpu1cb5f5a.rs:49:27\n   |\n\
    49 |         cnt += min_bucket - capacity;\n   |                           ^ "
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur = isize::MAX;\n\
    \        for cell in row.iter() {\n            cur = if cell == 1 {\n        \
    \        cur\n            } else {\n                cur\n            };\n    \
    \    }\n        if cur > ans {\n            ans = cur;\n        }\n    }\n   \
    \ ans\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpe0hl4x3u.rs:27:27\n\
    \   |\n27 |             cur = if cell == 1 {\n   |                           ^^\
    \ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        for col in row.iter() {\n            buckets[col] += 1;\n       \
    \ }\n    }\n    for bucket in buckets.iter() {\n        if bucket > capacity {\n\
    \            cnt += bucket - capacity;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmpqa_6rm6f.rs:27:13\n   |\n27 |             buckets[col] += 1;\n   | \
    \            ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa_6rm6f.rs:31:21\n\
    \   |\n31 |         if bucket > capacity {\n   |                     ^^^^^^^^\n\
    \   |                     |\n   |                     expected reference, found\
    \ `isize`\n   |                     help: consider borrowing here: `&capacity`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            buckets[i * grid[i].len()\
    \ + j] = grid[i][j];\n        }\n    }\n    while buckets.iter().any(|&b| b ==\
    \ capacity) {\n        cnt += 1;\n        for i in 0..grid.len() {\n         \
    \   for j in 0..grid[i].len() {\n                if buckets[i * grid[i].len()\
    \ + j] == 0 {\n                    buckets[i * grid[i].len() + j] = capacity;\n\
    \                }\n            }\n        }\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmplkfgm1vy.rs:27:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    let mut max_capacity = capacity;\n    while cnt < max_capacity {\n      \
    \  let mut new_grid = grid.clone();\n        for r in 0..grid.len() {\n      \
    \      for c in 0..grid[r].len() {\n                if grid[r][c] == 1 {\n   \
    \                 new_grid[r][c] = 0;\n                }\n            }\n    \
    \    }\n        let new_capacity = max_capacity - cnt;\n        if new_capacity\
    \ == 0 {\n            break;\n        }\n        if new_capacity < new_grid.len()\
    \ {\n            new_grid = new_grid.clone();\n        }\n        let new_cnt\
    \ = max_cnt + 1;\n        if new_cnt > new_capacity {\n            new_cnt = new_capacity;\n\
    \        }\n        max_cnt = new_cnt;\n        max_grid = new_grid;\n       \
    \ cnt += 1;\n    }\n    max_cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj3melj_9.rs:40:27\n   |\n\
    40 |         if new_capacity < new_grid.len() {\n   |                        \
    \   ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    40 |         if new_capacity < new_grid.len().try_into().unwrap() {\n   |    \
    \                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row.len();\n        for col in row.iter() {\n\
    \            if col == 0 {\n                min_bucket = std::cmp::min(min_bucket,\
    \ col);\n            }\n        }\n        cnt += min_bucket - 1;\n        min_bucket\
    \ = min_bucket - 1;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpitbnpuoc.rs:28:20\n\
    \   |\n28 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpitbnpuoc.rs:29:56\n\
    \   |\n29 |                 min_bucket = std::cmp::min(min_bucket, col);\n   |\
    \                                                        ^^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpitbnpuoc.rs:35:5\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n35 |     cnt\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |     cnt.try_into().unwrap()\n   |\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_count = 0\n    let mut min_count = std::i32::MAX;\n    let mut min_bucket\
    \ = std::i32::MAX;\n    let mut min_bucket_idx = std::i32::MAX;\n    let mut min_bucket_size\
    \ = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n    let mut\
    \ min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut min_bucket_size = std::i32::MAX;\n\
    \    let mut min_bucket_size = std::i32::MAX;\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp4frs4viz.rs:23:26\n\
    \   |\n23 |     let mut max_count = 0\n   |                          ^ help: add\
    \ `;` here\n24 |     let mut min_count = std::i32::MAX;\n   |     --- unexpected\
    \ token\n\nerror: expected identifier, found `}`\n  --> /tmp/tmp4frs4viz.rs:67:1\n\
    \   |\n67 | }\n   | ^ expected identifier\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![vec![0; capacity]; grid.len()];\n \
    \   for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n          \
    \  buckets[i][j] = grid[i][j];\n        }\n    }\n    for _ in 0..capacity {\n\
    \        for i in 0..grid.len() {\n            for j in 0..grid[i].len() {\n \
    \               if buckets[i][j] == 0 {\n                    cnt += 1;\n     \
    \               buckets[i][j] = 1;\n                }\n            }\n       \
    \ }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgk2rb72d.rs:24:36\n   |\n\
    24 |     let mut buckets = vec![vec![0; capacity]; grid.len()];\n   |        \
    \                            ^^^^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n24 |     let mut buckets = vec![vec![0; capacity.try_into().unwrap()];\
    \ grid.len()];\n   |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    let mut max_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut max_well = row[0].len();\n        for bucket in row.iter()\
    \ {\n            if *bucket > max_well {\n                max_well = *bucket;\n\
    \            }\n        }\n        if max_well > capacity {\n            max_bucket\
    \ = max_well;\n        }\n    }\n    for row in grid.iter() {\n        for bucket\
    \ in row.iter_mut() {\n            *bucket = *bucket - max_bucket;\n        }\n\
    \    }\n    counter\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpceczlu46.rs:26:35\n   |\n26 |         let mut max_well\
    \ = row[0].len();\n   |                                   ^^^ method not found\
    \ in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpceczlu46.rs:33:26\n\
    \   |\n33 |             max_bucket = max_well;\n   |                         \
    \ ^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpceczlu46.rs:38:33\n   |\n38 |             *bucket = *bucket - max_bucket;\n\
    \   |                                 ^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmpceczlu46.rs:38:31\n\
    \   |\n38 |             *bucket = *bucket - max_bucket;\n   |                \
    \               ^ no implementation for `isize - usize`\n   |\n   = help: the\
    \ trait `Sub<usize>` is not implemented for `isize`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_capacity = capacity;\n    let mut min_capacity\
    \ = capacity;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut max_bucket = row.len();\n        for bucket in row.iter()\
    \ {\n            if bucket > max_bucket {\n                max_bucket = bucket;\n\
    \            }\n        }\n        if max_bucket < min_bucket {\n            min_bucket\
    \ = max_bucket;\n        }\n        if max_capacity < min_capacity {\n       \
    \     max_capacity = min_capacity;\n        }\n        for bucket in row.iter()\
    \ {\n            if bucket > min_capacity {\n                min_capacity = bucket;\n\
    \            }\n        }\n        cnt += min_bucket - max_bucket;\n    }\n  \
    \  cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpycw99f2y.rs:30:25\n   |\n\
    30 |             if bucket > max_bucket {\n   |                         ^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpycw99f2y.rs:31:30\n\
    \   |\n31 |                 max_bucket = bucket;\n   |                       \
    \       ^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpycw99f2y.rs:41:25\n   |\n41 |             if bucket > min_capacity\
    \ {\n   |                         ^^^^^^^^^^^^\n   |                         |\n\
    \   |                         expected `&isize`, found `isize`\n   |         \
    \                help: consider borrowing here: `&min_capacity`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpycw99f2y.rs:42:32\n   |\n42 |              \
    \   min_capacity = bucket;\n   |                                ^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    42 |                 min_capacity = *bucket;\n   |                           \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpycw99f2y.rs:47:5\n  \
    \ |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |\
    \                                                        ----- expected `isize`\
    \ because of return type\n...\n47 |     cnt\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n47 |     cnt.try_into().unwrap()\n   |\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut cur_capacity = capacity;\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                cur_capacity -= 1;\n        \
    \    }\n        }\n        if cur_capacity > max_capacity {\n            max_capacity\
    \ = cur_capacity;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpb4cw5v5a.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = Vec::new();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        let mut well\
    \ = Vec::new();\n        for col in row.iter() {\n            if col == 1 {\n\
    \                well.push(1);\n            } else {\n                well.push(0);\n\
    \            }\n            cnt += 1;\n        }\n        if cnt > max_cnt {\n\
    \            max_cnt = cnt;\n            max_well = well;\n        }\n    }\n\
    \    for _ in 0..capacity {\n        max_well.push(0);\n    }\n    for _ in 0..max_cnt\
    \ {\n        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n\
    \    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _\
    \ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n\
    \        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n\
    \    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _\
    \ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n\
    \        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n\
    \    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _\
    \ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n\
    \        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n\
    \    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _\
    \ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n\
    \        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n\
    \    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _\
    \ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n\
    \        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n\
    \    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _\
    \ in 0..max_cnt {\n        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n\
    \        max_well.push(0);\n    }\n    for _ in 0..max_cnt {\n        max_well.push(0);\n\
    \    }\n    for _ in 0..max_cnt {\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpege9tug7.rs:133:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n123 |     for _ in 0..max_cnt {\n    |                     \
    \    - this delimiter might not be properly closed...\n124 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n133 | }\n    |   ^\n\n\
    error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpege9tug7.rs:30:20\n\
    \   |\n30 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpege9tug7.rs:22:56\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = min_capacity;\n        for col in row.iter()\
    \ {\n            if col == 0 {\n                min_bucket = std::cmp::min(min_bucket,\
    \ capacity);\n            } else {\n                min_bucket = std::cmp::min(min_bucket,\
    \ min_capacity);\n            }\n        }\n        min_capacity = min_bucket;\n\
    \        cnt += min_bucket - capacity;\n    }\n    cnt\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp94bty_fs.rs:28:20\n\
    \   |\n28 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                max_grid[row][col] = 1;\n\
    \                cnt += 1;\n            }\n        }\n    }\n    while cnt < capacity\
    \ {\n        max_cnt += 1;\n        for row in 0..grid.len() {\n            for\
    \ col in 0..grid[row].len() {\n                if max_grid[row][col] == 1 {\n\
    \                    max_grid[row][col] = 0;\n                    cnt += 1;\n\
    \                }\n            }\n        }\n    }\n    max_cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmplw6jdmsy.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut res = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        for col in row.iter() {\n            buckets[col] += 1;\n       \
    \ }\n    }\n    for bucket in buckets.iter() {\n        if bucket > capacity {\n\
    \            res += bucket - capacity;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmpz74givyh.rs:27:13\n   |\n27 |             buckets[col] += 1;\n   | \
    \            ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz74givyh.rs:31:21\n\
    \   |\n31 |         if bucket > capacity {\n   |                     ^^^^^^^^\n\
    \   |                     |\n   |                     expected reference, found\
    \ `isize`\n   |                     help: consider borrowing here: `&capacity`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur_capacity\
    \ = capacity;\n        for cell in row.iter() {\n            if *cell == 1 {\n\
    \                cur_capacity -= 1;\n            }\n        }\n        if cur_capacity\
    \ > ans {\n            ans = cur_capacity;\n        }\n    }\n    ans\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9223372036854775807`,\n right: `6`', /tmp/tmph0wwdc5p.rs:40:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if col == 0 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpk76iwor1.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cnt = 0;\n\
    \        for cell in row.iter() {\n            if cell == 0 {\n              \
    \  cnt += 1;\n            }\n        }\n        if cnt > ans {\n            ans\
    \ = cnt;\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpa1iy0m26.rs:27:21\n\
    \   |\n27 |             if cell == 0 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        for col in row.iter() {\n            if col == 0 {\n            \
    \    buckets[col] += 1;\n            }\n        }\n    }\n    for bucket in buckets.iter()\
    \ {\n        if bucket < capacity {\n            cnt += 1;\n        }\n    }\n\
    \    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp0rt6ntmg.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmp0rt6ntmg.rs:28:17\n   |\n28 |        \
    \         buckets[col] += 1;\n   |                 ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0rt6ntmg.rs:33:21\n   |\n33 |         if bucket < capacity\
    \ {\n   |                     ^^^^^^^^\n   |                     |\n   |     \
    \                expected reference, found `isize`\n   |                     help:\
    \ consider borrowing here: `&capacity`\n   |\n   = note: expected reference `&_`\n\
    \                   found type `isize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    let mut flow_inc = 0;\n    let\
    \ mut flow_inc_prev = 0;\n    let mut flow_inc_prev2 = 0;\n    let mut flow_inc_prev3\
    \ = 0;\n    let mut flow_inc_prev4 = 0;\n    let mut flow_inc_prev5 = 0;\n   \
    \ let mut flow_inc_prev6 = 0;\n    let mut flow_inc_prev7 = 0;\n    let mut flow_inc_prev8\
    \ = 0;\n    let mut flow_inc_prev9 = 0;\n    let mut flow_inc_prev10 = 0;\n  \
    \  let mut flow_inc_prev11 = 0;\n    let mut flow_inc_prev12 = 0;\n    let mut\
    \ flow_inc_prev13 = 0;\n    let mut flow_inc_prev14 = 0;\n    let mut flow_inc_prev15\
    \ = 0;\n    let mut flow_inc_prev16 = 0;\n    let mut flow_inc_prev17 = 0;\n \
    \   let mut flow_inc_prev18 = 0;\n    let mut flow_inc_prev19 = 0;\n    let mut\
    \ flow_inc_prev20 = 0;\n    let mut flow_inc_prev21 = 0;\n    let mut flow_inc_prev22\
    \ = 0;\n    let mut flow_inc_prev23 = 0;\n    let mut flow_inc_prev24 = 0;\n \
    \   let mut flow_inc_prev25 = 0;\n    let mut flow_inc_prev26 = 0;\n    let mut\
    \ flow_inc_prev27 = 0;\n    let mut flow_inc_prev28 = 0;\n    let mut flow_inc_prev29\
    \ = 0;\n    let mut flow_inc_prev30 = 0;\n    let mut flow_inc_prev31 = 0;\n \
    \   let mut flow_inc_prev32 = 0;\n    let mut flow_inc_prev33 = 0;\n    let mut\
    \ flow_inc_prev34 = 0;\n    let mut flow_inc_prev35 = 0;\n    let mut flow_inc_prev36\
    \ = 0;\n    let mut flow_inc_prev37 = 0;\n    let mut flow_inc_prev38 = 0;\n \
    \   let mut flow_inc_prev39 = 0;\n    let mut flow_inc_prev40 = 0;\n    let mut\
    \ flow_inc_prev41 = 0;\n    let mut flow_inc_prev42 = 0;\n    let mut flow_inc_prev43\
    \ = 0;\n    let mut flow_inc_prev44 = 0;\n    let mut flow_inc_prev45 = 0;\n \
    \   let mut flow_inc_prev46 = 0;\n    let mut flow_inc_prev47 = 0;\n    let mut\
    \ flow_inc_prev48 = 0;\n    let mut flow_inc_prev49 = 0;\n    let mut flow_inc_\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprzeadl3h.rs:75:22\n   |\n\
    75 |     let mut flow_inc_\n   |                      ^ help: add `;` here\n76\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprzeadl3h.rs:22:56\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row.len();\n        for bucket in row.iter()\
    \ {\n            if bucket < min_bucket {\n                min_bucket = bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnap0bvpt.rs:28:25\n   |\n\
    28 |             if bucket < min_bucket {\n   |                         ^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnap0bvpt.rs:29:30\n\
    \   |\n29 |                 min_bucket = bucket;\n   |                       \
    \       ^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnap0bvpt.rs:34:5\n   |\n22 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |                                          \
    \              ----- expected `isize` because of return type\n...\n34 |     cnt\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n34 |     cnt.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n \
    \       if cnt < min_cnt {\n            min_cnt = cnt;\n        }\n    }\n   \
    \ if min_cnt > capacity {\n        return 0;\n    }\n    cnt += min_cnt - max_cnt;\n\
    \    cnt += max_cnt - capacity;\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpqepbus4_.rs:29:20\n\
    \   |\n29 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqepbus4_.rs:40:18\n\
    \   |\n40 |     if min_cnt > capacity {\n   |                  ^^^^^^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n40 |     if min_cnt > capacity.try_into().unwrap()\
    \ {\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqepbus4_.rs:44:22\n   |\n44 |     cnt += max_cnt - capacity;\n\
    \   |                      ^^^^^^^^ expected `i32`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `i32`\n  --> /tmp/tmpqepbus4_.rs:44:20\n   |\n\
    44 |     cnt += max_cnt - capacity;\n   |                    ^ no implementation\
    \ for `i32 - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqepbus4_.rs:45:5\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n45 |     cnt\n   |     ^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n45 |     cnt.try_into().unwrap()\n   |\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    let mut max_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut max_row = 0;\n        for cell in row.iter() {\n        \
    \    if cell == 1 {\n                max_row += 1;\n            }\n        }\n\
    \        if max_row > max_capacity {\n            max_capacity = max_row;\n  \
    \      }\n    }\n    for row in grid.iter() {\n        let mut max_row = 0;\n\
    \        for cell in row.iter() {\n            if cell == 0 {\n              \
    \  max_row += 1;\n            }\n        }\n        if max_row > max_capacity\
    \ {\n            max_capacity = max_row;\n        }\n    }\n    counter\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmplptk205v.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmplptk205v.rs:39:21\n   |\n39 |             if cell\
    \ == 0 {\n   |                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut res = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len()];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            res += 1;\n          \
    \  bucket = capacity;\n        }\n        buckets[row.len()] = bucket;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpc6c0hwel.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row.len();\n        for bucket in row.iter()\
    \ {\n            if bucket < min_bucket {\n                min_bucket = bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnap0bvpt.rs:28:25\n   |\n\
    28 |             if bucket < min_bucket {\n   |                         ^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnap0bvpt.rs:29:30\n\
    \   |\n29 |                 min_bucket = bucket;\n   |                       \
    \       ^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnap0bvpt.rs:34:5\n   |\n22 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |                                          \
    \              ----- expected `isize` because of return type\n...\n34 |     cnt\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n34 |     cnt.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    for row in grid.iter() {\n        for col in row.iter()\
    \ {\n            if col == 0 {\n                counter += 1;\n            }\n\
    \        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpypwnptdu.rs:26:20\n\
    \   |\n26 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    for row in grid.iter() {\n  \
    \      for col in row.iter() {\n            if *col == 0 {\n                *col\
    \ = 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                *col =\
    \ 0;\n            }\n        }\n    }\n    for row in grid.iter() {\n        for\
    \ col in row.iter() {\n            if *col == 0 {\n                *col = 1;\n\
    \            }\n        }\n    }\n    for row in grid.iter() {\n        for col\
    \ in row.iter() {\n            if *col == 1 {\n                *col = 0;\n   \
    \         }\n        }\n    }\n    for row in grid.iter() {\n        for col in\
    \ row.iter() {\n            if *col == 0 {\n                *col = 1;\n      \
    \      }\n        }\n    }\n    for row in grid.iter() {\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                *col = 0;\n            }\n  \
    \      }\n    }\n    for row in grid.iter() {\n        for col in row.iter() {\n\
    \            if *col == 0 {\n                *col = 1;\n            }\n      \
    \  }\n    }\n    for row in grid.iter() {\n        for col in row.iter() {\n \
    \           if *col == 1 {\n                *col = 0;\n            }\n       \
    \ }\n    }\n    for row in grid.iter() {\n        for col in row.iter() {\n  \
    \          if *col == 0 {\n                *col = 1;\n            }\n        }\n\
    \    }\n    for row in grid.iter() {\n        for col in row.iter() {\n      \
    \      if *col == 1 {\n                *col = 0;\n            }\n        }\n \
    \   }\n    for row in grid.iter() {\n        for col in row.iter() {\n       \
    \     if *col == 0 {\n                *col = 1;\n            }\n        }\n  \
    \  }\n    for row in grid.iter() {\n        for col in row.iter() {\n        \
    \    if *col == 1 {\n                *col = 0;\n            }\n        }\n   \
    \ }\n    for row in grid.iter() {\n        for col in row.iter() {\n         \
    \   if *col == 0 {\n                *col = 1;\n            }\n        }\n    }\n\
    \    for row in grid.iter() {\n        for col in row.iter() {\n            if\
    \ *col == 1 {\n                *col = 0;\n            }\n        }\n    }\n  \
    \  for row in grid.iter() {\n        for col in row.iter() {\n            if *col\
    \ == 0 {\n                *col = 1;\n            }\n        }\n    }\n    for\
    \ \n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n   --> /tmp/tmppttha54s.rs:144:1\n\
    \    |\n144 | }\n    | ^ expected pattern\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppttha54s.rs:35:24\n   |\n35 |             max_grid = row.clone();\n\
    \   |                        ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found struct\
    \ `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = vec![vec![0];\
    \ grid.len()];\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_well = row;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 0 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_well = row;\n \
    \       }\n    }\n    if max_cnt > capacity {\n        max_cnt = capacity;\n \
    \       max_well = vec![0];\n    }\n    cnt += max_cnt - capacity;\n    cnt\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpc5phgbq8.rs:29:20\n\
    \   |\n29 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5phgbq8.rs:35:24\n\
    \   |\n35 |             max_well = row;\n   |                        ^^^ expected\
    \ struct `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<Vec<{integer}>>`\n\
    \           found reference `&Vec<isize>`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpc5phgbq8.rs:41:20\n   |\n41 |             if\
    \ col == 0 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc5phgbq8.rs:47:24\n   |\n47 |\
    \             max_well = row;\n   |                        ^^^ expected struct\
    \ `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<Vec<{integer}>>`\n\
    \           found reference `&Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc5phgbq8.rs:52:25\n   |\n52 |         max_well = vec![0];\n   |\
    \                         ^ expected struct `Vec`, found integer\n   |\n   = note:\
    \ expected struct `Vec<{integer}>`\n                found type `{integer}`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 0 {\n                cnt += 1;\n            }\n        }\n        buckets[row.len()\
    \ - cnt] += 1;\n    }\n    for bucket in buckets.iter() {\n        if bucket <\
    \ capacity {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpr2qdpxqa.rs:28:20\n\
    \   |\n28 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr2qdpxqa.rs:35:21\n\
    \   |\n35 |         if bucket < capacity {\n   |                     ^^^^^^^^\n\
    \   |                     |\n   |                     expected reference, found\
    \ `isize`\n   |                     help: consider borrowing here: `&capacity`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            cnt += 1;\n          \
    \  buckets[row.len() - 1] = bucket;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpphwqr8jd.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = min_capacity;\n        for bucket in row.iter()\
    \ {\n            if bucket < min_bucket {\n                min_bucket = bucket;\n\
    \            }\n        }\n        min_capacity -= min_bucket;\n        cnt +=\
    \ min_bucket;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuum5ru18.rs:28:25\n   |\n\
    28 |             if bucket < min_bucket {\n   |                         ^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&isize`,\
    \ found `isize`\n   |                         help: consider borrowing here: `&min_bucket`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuum5ru18.rs:29:30\n   |\n29 |\
    \                 min_bucket = bucket;\n   |                              ^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n29 |                 min_bucket = *bucket;\n   |                      \
    \        +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur_capacity\
    \ = capacity;\n        for cell in row.iter() {\n            if cell == 1 {\n\
    \                cur_capacity -= 1;\n            }\n        }\n        if cur_capacity\
    \ < 0 {\n            cur_capacity = 0;\n        }\n        ans = if cur_capacity\
    \ > ans {\n            cur_capacity\n        } else {\n            ans\n     \
    \   };\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp1u4n170j.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len()];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            cnt += 1;\n          \
    \  buckets[row.len()] -= 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpebeub6uk.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = Vec::new();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if col == 0 {\n         \
    \       cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n    \
    \        max_cnt = cnt;\n            max_well = row;\n        }\n    }\n    if\
    \ max_cnt > capacity {\n        return 0;\n    }\n    cnt += max_cnt - capacity;\n\
    \    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp8obduxu3.rs:29:20\n\
    \   |\n29 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8obduxu3.rs:35:24\n\
    \   |\n35 |             max_well = row;\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |                        |\n\
    \   |                        expected struct `Vec`, found `&Vec<isize>`\n   |\n\
    \   = note: expected struct `Vec<_>`\n           found reference `&Vec<isize>`\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp8obduxu3.rs:41:20\n\
    \   |\n41 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8obduxu3.rs:47:24\n\
    \   |\n47 |             max_well = row;\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |                        |\n\
    \   |                        expected struct `Vec`, found `&Vec<isize>`\n   |\n\
    \   = note: expected struct `Vec<_>`\n           found reference `&Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![vec![0; capacity]; grid.len()];\n \
    \   for row in grid.iter() {\n        for col in row.iter() {\n            buckets[col][row[0]]\
    \ += 1;\n        }\n    }\n    for row in buckets.iter() {\n        for col in\
    \ row.iter() {\n            if col == 0 {\n                cnt += 1;\n       \
    \     }\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8lk_rpbd.rs:24:36\n   |\n\
    24 |     let mut buckets = vec![vec![0; capacity]; grid.len()];\n   |        \
    \                            ^^^^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n24 |     let mut buckets = vec![vec![0; capacity.try_into().unwrap()];\
    \ grid.len()];\n   |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmp8lk_rpbd.rs:27:13\n   |\n27 |             buckets[col][row[0]] += 1;\n\
    \   |             ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: can't compare `&{integer}`\
    \ with `{integer}`\n  --> /tmp/tmp8lk_rpbd.rs:32:20\n   |\n32 |             if\
    \ col == 0 {\n   |                    ^^ no implementation for `&{integer} ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&{integer}`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                cnt += 1;\n              \
    \  if cnt > max_cnt {\n                    max_cnt = cnt;\n                  \
    \  max_grid = grid.clone();\n                }\n            }\n        }\n   \
    \ }\n    if cnt > max_cnt {\n        max_cnt = cnt;\n        max_grid = grid.clone();\n\
    \    }\n    max_cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpkn3fmosx.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    let mut flow_index = 0;\n    let\
    \ mut flow_index2 = 0;\n    let mut flow_index3 = 0;\n    let mut flow_index4\
    \ = 0;\n    let mut flow_index5 = 0;\n    let mut flow_index6 = 0;\n    let mut\
    \ flow_index7 = 0;\n    let mut flow_index8 = 0;\n    let mut flow_index9 = 0;\n\
    \    let mut flow_index10 = 0;\n    let mut flow_index11 = 0;\n    let mut flow_index12\
    \ = 0;\n    let mut flow_index13 = 0;\n    let mut flow_index14 = 0;\n    let\
    \ mut flow_index15 = 0;\n    let mut flow_index16 = 0;\n    let mut flow_index17\
    \ = 0;\n    let mut flow_index18 = 0;\n    let mut flow_index19 = 0;\n    let\
    \ mut flow_index20 = 0;\n    let mut flow_index21 = 0;\n    let mut flow_index22\
    \ = 0;\n    let mut flow_index23 = 0;\n    let mut flow_index24 = 0;\n    let\
    \ mut flow_index25 = 0;\n    let mut flow_index26 = 0;\n    let mut flow_index27\
    \ = 0;\n    let mut flow_index28 = 0;\n    let mut flow_index29 = 0;\n    let\
    \ mut flow_index30 = 0;\n    let mut flow_index31 = 0;\n    let mut flow_index32\
    \ = 0;\n    let mut flow_index33 = 0;\n    let mut flow_index34 = 0;\n    let\
    \ mut flow_index35 = 0;\n    let mut flow_index36 = 0;\n    let mut flow_index37\
    \ = 0;\n    let mut flow_index38 = 0;\n    let mut flow_index39 = 0;\n    let\
    \ mut flow_index40 = 0;\n    let mut flow_index41 = 0;\n    let mut flow_index42\
    \ = 0;\n    let mut flow_index43 = 0;\n    let mut flow_index44 = 0;\n    let\
    \ mut flow_index45 = 0;\n    let mut flow_index46 = 0;\n    let mut flow_index47\
    \ = 0;\n    let mut flow_index48 = 0;\n    let mut flow_index49 = 0;\n    let\
    \ mut flow_index50 = 0;\n    let mut flow_index51 = 0;\n    let mut flow_index52\
    \ = 0;\n    let mut flow_index53 = 0;\n    let mut flow_index54 = 0;\n    let\
    \ mut flow_index55 = 0;\n    let mut flow_index56 = 0;\n    let mut flow_index57\
    \ = 0;\n    let mut flow_index58 = 0;\n    let mut flow_index59 = 0;\n    let\
    \ mut flow_index60 = 0;\n    let mut flow_index61 = 0;\n    let mut flow_index62\
    \ = 0;\n    let mut flow_index63 = 0;\n\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl12ov3go.rs:22:56\n   |\n\
    22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_wells = isize::MAX;\n    for row in grid.iter() {\n        let mut max_buckets\
    \ = isize::MAX;\n        for bucket in row.iter() {\n            if bucket > capacity\
    \ {\n                continue;\n            }\n            max_buckets = std::cmp::max(max_buckets,\
    \ bucket);\n        }\n        max_wells = std::cmp::max(max_wells, max_buckets);\n\
    \    }\n    max_wells\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy20thvrv.rs:27:25\n   |\n\
    27 |             if bucket > capacity {\n   |                         ^^^^^^^^\n\
    \   |                         |\n   |                         expected `&isize`,\
    \ found `isize`\n   |                         help: consider borrowing here: `&capacity`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy20thvrv.rs:30:54\n   |\n30 |\
    \             max_buckets = std::cmp::max(max_buckets, bucket);\n   |        \
    \                                              ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n30 |        \
    \     max_buckets = std::cmp::max(max_buckets, *bucket);\n   |               \
    \                                       +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = grid.len();\n    for row in grid.iter() {\n        let mut flow\
    \ = 0;\n        for cell in row.iter() {\n            if cell == 1 {\n       \
    \         flow += 1;\n            }\n        }\n        if flow > capacity {\n\
    \            max_flow -= 1;\n        }\n    }\n    max_flow\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp6f2viexm.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6f2viexm.rs:35:5\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n35 |     max_flow\n   |     ^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n35 |     max_flow.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    let mut min_grid = grid.clone();\n    for i in 0..grid.len() {\n        for\
    \ j in 0..grid[i].len() {\n            if grid[i][j] == 0 {\n                cnt\
    \ += 1;\n                max_grid = grid.clone();\n                min_grid =\
    \ grid.clone();\n            }\n            if grid[i][j] == 1 {\n           \
    \     max_grid[i][j] = 1;\n                min_grid[i][j] = 1;\n            }\n\
    \        }\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 0 {\n                cnt += 1;\n           \
    \     max_grid = grid.clone();\n                min_grid = grid.clone();\n   \
    \         }\n            if grid[i][j] == 1 {\n                max_grid[i][j]\
    \ = 1;\n                min_grid[i][j] = 1;\n            }\n        }\n    }\n\
    \    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n         \
    \   if grid[i][j] == 0 {\n                cnt += 1;\n                max_grid\
    \ = grid.clone();\n                min_grid = grid.clone();\n            }\n \
    \           if grid[i][j] == 1 {\n                max_grid[i][j] = 1;\n      \
    \          min_grid[i][j] = 1;\n            }\n        }\n    }\n    for i in\
    \ 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j]\
    \ == 0 {\n                cnt += 1;\n                max_grid = grid.clone();\n\
    \                min_grid = grid.clone();\n            }\n            if grid[i][j]\
    \ == 1 {\n                max_grid[i][j] = 1;\n                min_grid[i][j]\
    \ = 1;\n            }\n        }\n    }\n    for i in 0..grid.len() {\n      \
    \  for j in 0..grid[i].len() {\n            if grid[i][j] == 0 {\n           \
    \     cnt += 1;\n                max_grid = grid.clone();\n                min_grid\
    \ = grid.clone();\n            }\n            if grid[i][j] == 1 {\n         \
    \       max_grid[i][j] = 1;\n                min_grid[i][j] = 1;\n           \
    \ }\n        }\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 0 {\n                cnt += 1;\n           \
    \     max_grid = grid.clone();\n                min_grid = grid.clone();\n   \
    \         }\n            if grid[i][j] == 1 {\n                max_grid[i][j]\
    \ = 1;\n                min_grid[i][j] = 1;\n            }\n        }\n    }\n\
    \    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n         \
    \   if grid[i][j] == 0 {\n                cnt += 1;\n                max_grid\
    \ = grid.clone();\n                min_grid = grid.clone();\n            }\n \
    \           if grid[i][j] == 1 {\n                max_grid[i][j] = 1;\n      \
    \          min_grid[i][j] = 1;\n            }\n        }\n    }\n    for i in\
    \ 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j]\
    \ == 0 {\n                cnt += 1;\n                max_\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8ywx5105.rs:132:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n118 |     for i in 0..grid.len() {\n    |                  \
    \          - unclosed delimiter\n119 |         for j in 0..grid[i].len() {\n \
    \   |                                   - unclosed delimiter\n120 |          \
    \   if grid[i][j] == 0 {\n    |                                - this delimiter\
    \ might not be properly closed...\n...\n123 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n132 | }\n    |   ^\n\nerror[E0425]: cannot\
    \ find value `max_` in this scope\n   --> /tmp/tmp8ywx5105.rs:122:17\n    |\n\
    122 |                 max_\n    |                 ^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n   --> /tmp/tmp8ywx5105.rs:118:5\n    |\n22\
    \  |   fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    | \
    \                                                         ----- expected `isize`\
    \ because of return type\n...\n118 | /     for i in 0..grid.len() {\n119 | | \
    \        for j in 0..grid[i].len() {\n120 | |             if grid[i][j] == 0 {\n\
    121 | |                 cnt += 1;\n...   |\n131 | |     assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n132 | | }\n    | |__^ expected `isize`,\
    \ found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_capacity = capacity;\n    let mut max_well = grid[0];\n\
    \    for row in grid.iter() {\n        if *row.len() > max_capacity {\n      \
    \      max_capacity = *row.len();\n            max_well = row;\n        }\n  \
    \  }\n    for row in grid.iter() {\n        for col in row.iter() {\n        \
    \    if *col == 0 {\n                *col = max_well[*col];\n            }\n \
    \       }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpy3za42rt.rs:27:12\n\
    \   |\n27 |         if *row.len() > max_capacity {\n   |            ^^^^^^^^^^\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpy3za42rt.rs:28:28\n\
    \   |\n28 |             max_capacity = *row.len();\n   |                     \
    \       ^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy3za42rt.rs:29:24\n\
    \   |\n29 |             max_well = row;\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |                        |\n\
    \   |                        expected struct `Vec`, found `&Vec<isize>`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found reference `&Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpy3za42rt.rs:35:24\n\
    \   |\n35 |                 *col = max_well[*col];\n   |                     \
    \   ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in_max = vec![0;\
    \ grid.len()];\n    let mut flow_out_max = vec![0; grid.len()];\n    let mut flow_in_min\
    \ = vec![0; grid.len()];\n    let mut flow_out_min = vec![0; grid.len()];\n  \
    \  let mut flow_in_max_index = vec![0; grid.len()];\n    let mut flow_out_max_index\
    \ = vec![0; grid.len()];\n    let mut flow_in_min_index = vec![0; grid.len()];\n\
    \    let mut flow_out_min_index = vec![0; grid.len()];\n    let mut flow_in_max_index_max\
    \ = vec![0; grid.len()];\n    let mut flow_out_max_index_max = vec![0; grid.len()];\n\
    \    let mut flow_in_min_index_max = vec![0; grid.len()];\n    let mut flow_out_min_index_max\
    \ = vec![0; grid.len()];\n    let mut flow_in_max_index_min = vec![0; grid.len()];\n\
    \    let mut flow_out_max_index_min = vec![0; grid.len()];\n    let mut flow_in_min_index_min\
    \ = vec![0; grid.len()];\n    let mut flow_out_min_index_min = vec![0; grid.len()];\n\
    \    let mut flow_in_max_index_min_index = vec![0; grid.len()];\n    let mut flow_out_max_index_min_index\
    \ = vec![0; grid.len()];\n    let mut flow_in_min_index_min_index = vec![0; grid.len()];\n\
    \    let mut flow_out_min_index_min_index = vec![0; grid.len()];\n    let mut\
    \ flow_in_max_index_min_index_max = vec![0; grid.len()];\n    let mut flow_out_max_index_min_index_max\
    \ = vec![0; grid.len()];\n    let mut flow_in_min_index_min_index_max = vec![0;\
    \ grid.len()];\n    let mut flow_out_min_index_min_index_max = vec![0; grid.len()];\n\
    \    let mut flow_in_max_index_min_index_min = vec![0; grid.len()];\n    let mut\
    \ flow_out_max_index_min_index_min = vec![0; grid.len()];\n    let mut flow_in_min_index_min_index_min\
    \ = vec![0; grid.len()];\n    let mut flow_out_min_index_min_index_min = vec![0;\
    \ grid.len()];\n    let mut flow_in_max_index_min_index_min_index = vec![0; grid.len()];\n\
    \    let mut flow_out_max_index_min_index_min_index = vec![0; grid.len()];\n \
    \   let mut flow_in_min_index_min_index_min\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplh1xhi47.rs:57:44\n   |\n\
    57 |     let mut flow_in_min_index_min_index_min\n   |                       \
    \                     ^ help: add `;` here\n58 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplh1xhi47.rs:22:56\n   |\n22 | fn\
    \ max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        if row[0].len() < min_bucket {\n            min_bucket = row[0].len();\n\
    \        }\n    }\n    for row in grid.iter() {\n        let mut cnt = 0;\n  \
    \      for col in row.iter() {\n            if col == 0 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > min_bucket {\n           \
    \ cnt -= min_bucket;\n        }\n        if cnt > capacity {\n            cnt\
    \ -= capacity;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpqbzo13m9.rs:26:19\n   |\n26 |         if row[0].len() <\
    \ min_bucket {\n   |                   ^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmpqbzo13m9.rs:27:33\n\
    \   |\n27 |             min_bucket = row[0].len();\n   |                     \
    \            ^^^ method not found in `isize`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpqbzo13m9.rs:33:20\n   |\n33 |             if\
    \ col == 0 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqbzo13m9.rs:40:18\n   |\n40 |\
    \         if cnt > capacity {\n   |                  ^^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n40 |         if cnt > capacity.try_into().unwrap()\
    \ {\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqbzo13m9.rs:41:20\n   |\n41 |             cnt -= capacity;\n\
    \   |                    ^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract-assign `isize` from `usize`\n  --> /tmp/tmpqbzo13m9.rs:41:17\n\
    \   |\n41 |             cnt -= capacity;\n   |                 ^^ no implementation\
    \ for `usize -= isize`\n   |\n   = help: the trait `SubAssign<isize>` is not implemented\
    \ for `usize`\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    let mut max_capacity = 0;\n    for row in grid.iter()\
    \ {\n        let mut max_row = 0;\n        for col in row.iter() {\n         \
    \   if col == 1 {\n                max_row += 1;\n            }\n        }\n \
    \       if max_row > max_capacity {\n            max_capacity = max_row;\n   \
    \     }\n    }\n    for row in grid.iter() {\n        let mut max_row = 0;\n \
    \       for col in row.iter() {\n            if col == 0 {\n                max_row\
    \ += 1;\n            }\n        }\n        if max_row > max_capacity {\n     \
    \       max_capacity = max_row;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut max_row = 0;\n        for col in row.iter() {\n         \
    \   if col == 1 {\n                max_row += 1;\n            }\n        }\n \
    \       if max_row > max_capacity {\n            max_capacity = max_row;\n   \
    \     }\n    }\n    for row in grid.iter() {\n        let mut max_row = 0;\n \
    \       for col in row.iter() {\n            if col == 0 {\n                max_row\
    \ += 1;\n            }\n        }\n        if max_row > max_capacity {\n     \
    \       max_capacity = max_row;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut max_row = 0;\n        for col in row.iter() {\n         \
    \   if col == 1 {\n                max_row += 1;\n            }\n        }\n \
    \       if max_row > max_capacity {\n            max_capacity = max_row;\n   \
    \     }\n    }\n    for row in grid.iter() {\n        let mut max_row = 0;\n \
    \       for col in row.iter() {\n            if col == 0 {\n                max_row\
    \ += 1;\n            }\n        }\n        if max_row > max_capacity {\n     \
    \       max_capacity = max_row;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut max_row = 0;\n        for col in row.iter() {\n         \
    \   if col == 1 {\n                max_row += 1;\n            }\n        }\n \
    \       if max_row > max_capacity {\n            max_capacity = max_row;\n   \
    \     }\n    }\n    for row in grid.iter() {\n        let mut max_row = 0;\n \
    \       for col in row.iter() {\n            if col == 0 {\n                max_row\
    \ += 1;\n            }\n        }\n        if max_row > max_capacity {\n     \
    \       max_capacity = max_row;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut max_row = 0;\n        for col in row.iter() {\n         \
    \   if col == 1 {\n                max_row += 1;\n            }\n        }\n \
    \       if max_row > max_capacity {\n            max_capacity = max_row;\n   \
    \     }\n    }\n    for row in grid.iter() {\n        let mut max_row = 0;\n \
    \       for col in row.iter() {\n            if col == 0 {\n                max_row\
    \ += 1;\n            }\n\n}\n\nfn main() {\n    let candidate = max_fill;\n  \
    \  assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjvj2betk.rs:140:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n124 |     for row in grid.iter() {\n    |                  \
    \          - unclosed delimiter\n125 |         let mut max_row = 0;\n126 |   \
    \      for col in row.iter() {\n    |                               - this delimiter\
    \ might not be properly closed...\n...\n131 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n140 | }\n    |   ^\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpjvj2betk.rs:28:20\n   |\n28\
    \ |             if col == 1 {\n   |                    ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpjvj2betk.rs:39:20\n   |\n39 |             if col == 0 {\n   | \
    \                   ^^ no implementation for `&isize == {integer}`\n   |\n   =\
    \ help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmpjvj2betk.rs:50:20\n \
    \  |\n50 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpjvj2betk.rs:61:20\n   |\n61 |             if col\
    \ == 0 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpjvj2betk.rs:72:20\n\
    \   |\n72 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpjvj2betk.rs:"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n         \
    \   if grid[i][j] == 1 {\n                cnt += 1;\n                max_cnt =\
    \ std::cmp::max(max_cnt, cnt);\n                grid[i][j] = 0;\n            \
    \    max_grid = grid.clone();\n            }\n        }\n    }\n    cnt\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `max_grid` is assigned to, but never used\n  --> /tmp/tmpc4c_xpr1.rs:25:13\n\
    \   |\n25 |     let mut max_grid = grid.clone();\n   |             ^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_max_grid` instead\n\nwarning: value assigned to `max_grid` is never\
    \ read\n  --> /tmp/tmpc4c_xpr1.rs:32:17\n   |\n32 |                 max_grid =\
    \ grid.clone();\n   |                 ^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ unused variable: `capacity`\n  --> /tmp/tmpc4c_xpr1.rs:22:36\n   |\n22 | fn\
    \ max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |          \
    \                          ^^^^^^^^ help: if this is intentional, prefix it with\
    \ an underscore: `_capacity`\n\nerror[E0596]: cannot borrow `grid` as mutable,\
    \ as it is not declared as mutable\n  --> /tmp/tmpc4c_xpr1.rs:31:17\n   |\n22\
    \ | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |     \
    \        ---- help: consider changing this to be mutable: `mut grid`\n...\n31\
    \ |                 grid[i][j] = 0;\n   |                 ^^^^ cannot borrow as\
    \ mutable\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        if row[0].len() > max_bucket {\n            max_bucket = row[0].len();\n\
    \        }\n    }\n    for row in grid.iter() {\n        for col in row.iter()\
    \ {\n            if col == 0 {\n                cnt += 1;\n            }\n   \
    \     }\n    }\n    cnt += max_bucket - capacity + 1;\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpwbrqroqe.rs:26:19\n   |\n26 |         if row[0].len() >\
    \ max_bucket {\n   |                   ^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmpwbrqroqe.rs:27:33\n\
    \   |\n27 |             max_bucket = row[0].len();\n   |                     \
    \            ^^^ method not found in `isize`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpwbrqroqe.rs:32:20\n   |\n32 |             if\
    \ col == 0 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwbrqroqe.rs:37:25\n   |\n37 |\
    \     cnt += max_bucket - capacity + 1;\n   |                         ^^^^^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from\
    \ `usize`\n  --> /tmp/tmpwbrqroqe.rs:37:23\n   |\n37 |     cnt += max_bucket -\
    \ capacity + 1;\n   |                       ^ no implementation for `usize - isize`\n\
    \   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwbrqroqe.rs:38:5\n   |\n22 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |                         \
    \                               ----- expected `isize` because of return type\n\
    ...\n38 |     cnt\n   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n38 |     cnt.try_into().unwrap()\n   |\n\nerror: aborting due to\
    \ 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if col == 0 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwxdkqcse.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    let mut buckets = vec![vec![isize::MAX; capacity];\
    \ grid.len()];\n    for row in grid.iter() {\n        let mut cur = buckets[row.len()\
    \ - 1];\n        for cell in row.iter() {\n            if cell == 1 {\n      \
    \          cur -= 1;\n            }\n            cur += 1;\n        }\n      \
    \  ans = if cur > ans {\n            cur\n        } else {\n            ans\n\
    \        };\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2fdaagvu.rs:24:45\n   |\n\
    24 |     let mut buckets = vec![vec![isize::MAX; capacity]; grid.len()];\n   |\
    \                                             ^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n24 |     let mut buckets = vec![vec![isize::MAX;\
    \ capacity.try_into().unwrap()]; grid.len()];\n   |                          \
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp2fdaagvu.rs:28:21\n   |\n28 |     \
    \        if cell == 1 {\n   |                     ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `Vec<isize>`\n  --> /tmp/tmp2fdaagvu.rs:29:17\n   |\n29 |          \
    \       cur -= 1;\n   |                 ---^^^^^\n   |                 |\n   |\
    \                 cannot use `-=` on type `Vec<isize>`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Vec<isize>`\n  --> /tmp/tmp2fdaagvu.rs:31:13\n\
    \   |\n31 |             cur += 1;\n   |             ---^^^^^\n   |           \
    \  |\n   |             cannot use `+=` on type `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2fdaagvu.rs:33:24\n   |\n33 |         ans = if cur > ans\
    \ {\n   |                        ^^^ expected struct `Vec`, found `isize`\n  \
    \ |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2fdaagvu.rs:34:13\n   |\n34 |\
    \             cur\n   |             ^^^ expected `isize`, found struct `Vec`\n\
    \   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                cnt += 1;\n              \
    \  if cnt > max_cnt {\n                    max_cnt = cnt;\n                  \
    \  max_grid = grid.clone();\n                }\n            }\n        }\n   \
    \ }\n    max_cnt += 1;\n    if cnt > max_cnt {\n        max_cnt = cnt;\n     \
    \   max_grid = grid.clone();\n    }\n    max_cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpher2sbqp.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur_capacity\
    \ = capacity;\n        for cell in row.iter() {\n            if cell == 1 {\n\
    \                cur_capacity -= 1;\n            }\n        }\n        if cur_capacity\
    \ < ans {\n            ans = cur_capacity;\n        }\n    }\n    ans\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmplg4427oc.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    let mut max_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut max_row = 0;\n        for cell in row.iter() {\n        \
    \    if cell == 1 {\n                max_row += 1;\n            }\n        }\n\
    \        if max_row > max_capacity {\n            max_capacity = max_row;\n  \
    \      }\n    }\n    for row in grid.iter() {\n        let mut max_row = 0;\n\
    \        for cell in row.iter() {\n            if cell == 0 {\n              \
    \  max_row += 1;\n            }\n        }\n        if max_row > max_capacity\
    \ {\n            max_capacity = max_row;\n        }\n    }\n    return max_capacity;\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpupv3posk.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpupv3posk.rs:39:21\n   |\n39 |             if cell\
    \ == 0 {\n   |                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for col in row.iter()\
    \ {\n            if col[0] == 0 {\n                cnt += 1;\n               \
    \ if min_bucket > col {\n                    min_bucket = col;\n             \
    \   }\n            }\n        }\n        if min_bucket > capacity {\n        \
    \    cnt += 1;\n            min_bucket = capacity;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpe38m81qp.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror[E0608]: cannot index into a value of type `&isize`\n  -->\
    \ /tmp/tmpe38m81qp.rs:28:16\n   |\n28 |             if col[0] == 0 {\n   |   \
    \             ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe38m81qp.rs:35:25\n\
    \   |\n35 |         if min_bucket > capacity {\n   |                         ^^^^^^^^\n\
    \   |                         |\n   |                         expected `&isize`,\
    \ found `isize`\n   |                         help: consider borrowing here: `&capacity`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe38m81qp.rs:37:26\n   |\n37 |\
    \             min_bucket = capacity;\n   |                          ^^^^^^^^\n\
    \   |                          |\n   |                          expected `&isize`,\
    \ found `isize`\n   |                          help: consider borrowing here:\
    \ `&capacity`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                cnt += 1;\n              \
    \  let mut new_grid = grid.clone();\n                new_grid[row][col] = 0;\n\
    \                max_cnt = max_cnt + (max_grid.len() - new_grid.len()) * max_fill(new_grid,\
    \ capacity);\n            }\n        }\n    }\n    max_cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk5ip1p4v.rs:32:73\n   |\n\
    32 |                 max_cnt = max_cnt + (max_grid.len() - new_grid.len()) * max_fill(new_grid,\
    \ capacity);\n   |                                                           \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot multiply `usize` by `isize`\n  --> /tmp/tmpk5ip1p4v.rs:32:71\n\
    \   |\n32 |                 max_cnt = max_cnt + (max_grid.len() - new_grid.len())\
    \ * max_fill(new_grid, capacity);\n   |                                      \
    \                                 ^ no implementation for `usize * isize`\n  \
    \ |\n   = help: the trait `Mul<isize>` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk5ip1p4v.rs:36:5\n   |\n22 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |                         \
    \                               ----- expected `isize` because of return type\n\
    ...\n36 |     max_cnt\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n36 |     max_cnt.try_into().unwrap()\n   |\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt2 = 0;\n    \
    \    for cell in row.iter() {\n            if cell == 1 {\n                cnt2\
    \ += 1;\n            }\n        }\n        if cnt2 > capacity {\n            cnt\
    \ += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpdgax1maq.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if col == 0 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpk76iwor1.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        if row.len() < min_bucket {\n            min_bucket = row.len();\n\
    \        }\n    }\n    for row in grid.iter() {\n        for col in row.iter()\
    \ {\n            if col == 0 {\n                cnt += min_bucket - row.len();\n\
    \            }\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpzyfhozfa.rs:32:20\n\
    \   |\n32 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzyfhozfa.rs:37:5\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n37 |     cnt\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n37 |     cnt.try_into().unwrap()\n   |\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    let mut max_buckets = grid.len();\n    let mut min_buckets\
    \ = grid.len();\n    for row in grid.iter() {\n        let mut min_buckets = std::cmp::min(min_buckets,\
    \ row.len());\n        for bucket in row.iter() {\n            if bucket > capacity\
    \ {\n                counter += min_buckets - 1;\n                min_buckets\
    \ = 1;\n            } else {\n                min_buckets = std::cmp::min(min_buckets,\
    \ bucket);\n            }\n        }\n        max_buckets = std::cmp::max(max_buckets,\
    \ row.len());\n    }\n    counter\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpafm8zt3z.rs:29:25\n   |\n\
    29 |             if bucket > capacity {\n   |                         ^^^^^^^^\n\
    \   |                         |\n   |                         expected `&isize`,\
    \ found `isize`\n   |                         help: consider borrowing here: `&capacity`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpafm8zt3z.rs:33:58\n   |\n33 |\
    \                 min_buckets = std::cmp::min(min_buckets, bucket);\n   |    \
    \                                                      ^^^^^^ expected `usize`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpafm8zt3z.rs:38:5\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n38 |     counter\n   |     ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n38 |     counter.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for bucket in row.iter()\
    \ {\n            if *bucket > min_bucket {\n                min_bucket = bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpyiv77goc.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyiv77goc.rs:29:30\n\
    \   |\n29 |                 min_bucket = bucket;\n   |                       \
    \       ^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n29 |                 min_bucket = *bucket;\n   |         \
    \                     +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt2 = 0;\n    \
    \    for col in row.iter() {\n            if col == 0 {\n                cnt2\
    \ += 1;\n            }\n        }\n        if cnt2 > capacity {\n            cnt\
    \ += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpjz_4k_00.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    for row in grid.iter() {\n  \
    \      let mut cnt = 0;\n        for col in row.iter() {\n            if *col\
    \ == 0 {\n                cnt += 1;\n            }\n        }\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n            max_grid = row.clone();\n\
    \        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    if max_cnt > capacity {\n   \
    \     return max_cnt;\n    }\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if *col == 0 {\n        \
    \        cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n   \
    \         max_cnt = cnt;\n            max_grid = row.clone();\n        }\n   \
    \ }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n    return max_cnt;\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpskkvwggg.rs:35:24\n   |\n\
    35 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpskkvwggg.rs:47:24\n   |\n47 |             max_grid = row.clone();\n\
    \   |                        ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found struct\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpskkvwggg.rs:62:24\n\
    \   |\n62 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpskkvwggg.rs:77:24\n   |\n77 |             max_grid = row.clone();\n\
    \   |                        ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found struct\
    \ `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur_cap\
    \ = capacity;\n        for cell in row.iter() {\n            if cell == 1 {\n\
    \                cur_cap -= 1;\n            }\n        }\n        if cur_cap <\
    \ 0 {\n            cur_cap = 0;\n        }\n        ans = if cur_cap < ans {\n\
    \            cur_cap\n        } else {\n            ans\n        };\n    }\n \
    \   ans\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpsi5q6x8n.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    for row in grid.iter() {\n        let mut counter = 0;\n\
    \        for cell in row.iter() {\n            if cell == 0 {\n              \
    \  counter += 1;\n            }\n        }\n        if counter > capacity {\n\
    \            counter -= 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpvotzqtjb.rs:27:21\n\
    \   |\n27 |             if cell == 0 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n\
    \        if cnt < min_cnt {\n            min_cnt = cnt;\n        }\n    }\n  \
    \  if min_cnt > capacity {\n        return 0;\n    }\n    if max_cnt > capacity\
    \ {\n        return max_cnt;\n    }\n    let mut min_cnt = std::i32::MAX;\n  \
    \  for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 0 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > min_cnt {\n            min_cnt = cnt;\n        }\n\
    \    }\n    if min_cnt > capacity {\n        return 0;\n    }\n    if max_cnt\
    \ > capacity {\n        return max_cnt;\n    }\n    let mut min_cnt = std::i32::MAX;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > min_cnt {\n            min_cnt = cnt;\n        }\n\
    \    }\n    if min_cnt > capacity {\n        return 0;\n    }\n    if max_cnt\
    \ > capacity {\n        return max_cnt;\n    }\n    let mut min_cnt = std::i32::MAX;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 0 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > min_cnt {\n            min_cnt = cnt;\n        }\n\
    \    }\n    if min_cnt > capacity {\n        return 0;\n    }\n    if max_cnt\
    \ > capacity {\n        return max_cnt;\n    }\n    let mut min_cnt = std::i32::MAX;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > min_cnt {\n            min_cnt = cnt;\n        }\n\
    \    }\n    if min_cnt > capacity {\n        return 0;\n    }\n    if max_cnt\
    \ > capacity {\n        return max_cnt;\n    }\n    let mut min_cnt = std::i32::MAX;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 0 {\n                cnt += 1;\n            }\n  \
    \      }\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpsvga4kv6.rs:135:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n119 |     for row in grid.iter() {\n    |                  \
    \          - this delimiter might not be properly closed...\n...\n126 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n135 | }\n\
    \    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsvga4kv6.rs:40:18\n\
    \   |\n40 |     if min_cnt > capacity {\n   |                  ^^^^^^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n40 |     if min_cnt > capacity.try_into().unwrap()\
    \ {\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsvga4kv6.rs:43:18\n   |\n43 |     if max_cnt > capacity\
    \ {\n   |                  ^^^^^^^^ expected `i32`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to an `i32` and panic if the converted value doesn't\
    \ fit\n   |\n43 |     if max_cnt > capacity.try_into().unwrap() {\n   |      \
    \            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsvga4kv6.rs:44:16\n   |\n22 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |                                          \
    \              ----- expected `isize` because of return type\n...\n44 |      \
    \   return max_cnt;\n   |                ^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n44 |         return max_cnt.try_into().unwrap();\n\
    \   |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsvga4kv6.rs:58:18\n   |\n58 |     if min_cnt > capacity {\n   |\
    \                  ^^^^^^^^ expected `i32`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to an `i32` and panic if the converted value doesn't fit\n\
    \   |\n58 |     if min_cnt > capacity.try_into().unwrap() {\n   | "
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt2 = 0;\n    \
    \    for col in row.iter() {\n            if col == 1 {\n                cnt2\
    \ += 1;\n            }\n        }\n        if cnt2 > cnt {\n            cnt =\
    \ cnt2;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmprftxg44a.rs:27:20\n\
    \   |\n27 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 1 {\n                cnt += 1;\n            }\n        }\n        buckets[row.len()\
    \ - 1] = cnt;\n    }\n    for _ in 0..capacity {\n        cnt += 1;\n    }\n \
    \   cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwcazvjaa.rs:28:20\n\
    \   |\n28 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_bucket = 0;\n    for row in grid.iter() {\n  \
    \      let mut max_well = 0;\n        for well in row.iter() {\n            if\
    \ well > max_well {\n                max_well = well;\n            }\n       \
    \ }\n        max_bucket += max_well;\n        cnt += 1;\n        if max_bucket\
    \ > capacity {\n            break;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy6g6dvaw.rs:28:23\n   |\n\
    28 |             if well > max_well {\n   |                       ^^^^^^^^\n \
    \  |                       |\n   |                       expected `&isize`, found\
    \ integer\n   |                       help: consider borrowing here: `&max_well`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy6g6dvaw.rs:29:28\n   |\n29 |\
    \                 max_well = well;\n   |                            ^^^^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    29 |                 max_well = *well;\n   |                            +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 1 {\n                cnt += 1;\n            }\n        }\n        buckets[row.iter().position(|&x|\
    \ x == 1).unwrap()] += cnt;\n    }\n    for bucket in buckets.iter() {\n     \
    \   if bucket > capacity {\n            cnt += 1;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpqzyppvvw.rs:28:20\n\
    \   |\n28 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqzyppvvw.rs:35:21\n\
    \   |\n35 |         if bucket > capacity {\n   |                     ^^^^^^^^\n\
    \   |                     |\n   |                     expected reference, found\
    \ `isize`\n   |                     help: consider borrowing here: `&capacity`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt2 = 0;\n    \
    \    for col in row.iter() {\n            if col == 1 {\n                cnt2\
    \ += 1;\n            }\n        }\n        if cnt2 > capacity {\n            cnt\
    \ += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpqui2b14c.rs:27:20\n\
    \   |\n27 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                cnt += 1;\n              \
    \  max_cnt = std::cmp::max(max_cnt, cnt);\n                max_grid[row][col]\
    \ = 0;\n            }\n        }\n    }\n    for row in 0..grid.len() {\n    \
    \    for col in 0..grid[row].len() {\n            if grid[row][col] == 0 {\n \
    \               cnt -= 1;\n                max_cnt = std::cmp::max(max_cnt, cnt);\n\
    \                max_grid[row][col] = 1;\n            }\n        }\n    }\n  \
    \  max_cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpd3b6u7wi.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut res = 0;\n    for row in grid.iter() {\n        let mut cur_capacity = capacity;\n\
    \        for cell in row.iter() {\n            if cell == 1 {\n              \
    \  cur_capacity -= 1;\n            }\n        }\n        res += cur_capacity;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp99r_84x2.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        for col in row.iter() {\n            buckets[col] += 1;\n       \
    \ }\n    }\n    for bucket in buckets.iter() {\n        if bucket > capacity {\n\
    \            cnt += bucket - capacity;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmpqa_6rm6f.rs:27:13\n   |\n27 |             buckets[col] += 1;\n   | \
    \            ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa_6rm6f.rs:31:21\n\
    \   |\n31 |         if bucket > capacity {\n   |                     ^^^^^^^^\n\
    \   |                     |\n   |                     expected reference, found\
    \ `isize`\n   |                     help: consider borrowing here: `&capacity`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut cur_capacity = max_capacity;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cur_capacity -= 1;\n        \
    \    }\n        }\n        if cur_capacity > max_capacity {\n            max_capacity\
    \ = cur_capacity;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpccp4o000.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            cnt += bucket - capacity;\n\
    \        }\n        buckets[row.len() - 1] = bucket;\n    }\n    cnt\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpp45264re.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 1 {\n                buckets[col] += 1;\n                cnt += 1;\n\
    \            }\n        }\n        if cnt > capacity {\n            cnt -= 1;\n\
    \        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmphyebmx8i.rs:28:20\n\
    \   |\n28 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmphyebmx8i.rs:29:17\n   |\n29 |        \
    \         buckets[col] += 1;\n   |                 ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&isize>` for `Vec<{integer}>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for bucket in row.iter()\
    \ {\n            if *bucket > min_bucket {\n                min_bucket = *bucket;\n\
    \            }\n        }\n        for bucket in row.iter() {\n            *bucket\
    \ = min_bucket;\n        }\n        for bucket in row.iter() {\n            if\
    \ *bucket < capacity {\n                *bucket -= 1;\n                cnt +=\
    \ 1;\n            }\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp3s5gyqp3.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut res = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut cur_capacity = capacity;\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                cur_capacity -= 1;\n        \
    \    }\n            buckets[cell] += cur_capacity;\n        }\n        res +=\
    \ buckets.iter().filter(|&b| b > 0).count();\n        buckets = vec![0; cur_capacity];\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpy7zkpq35.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpy7zkpq35.rs:31:13\n   |\n31 |        \
    \     buckets[cell] += cur_capacity;\n   |             ^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy7zkpq35.rs:33:47\n   |\n33 |         res += buckets.iter().filter(|&b|\
    \ b > 0).count();\n   |                                               ^\n   |\
    \                                               |\n   |                      \
    \                         expected reference, found integer\n   |            \
    \                                   help: consider borrowing here: `&0`\n   |\n\
    \   = note: expected reference `&_`\n                   found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy7zkpq35.rs:34:27\n   |\n34 |\
    \         buckets = vec![0; cur_capacity];\n   |                           ^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n34 |         buckets\
    \ = vec![0; cur_capacity.try_into().unwrap()];\n   |                         \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy7zkpq35.rs:36:5\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n36 |     res\n   |     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n36 |     res.try_into().unwrap"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        for col in row.iter() {\n            if col == 0 {\n            \
    \    buckets[col] += 1;\n            }\n        }\n    }\n    for bucket in buckets.iter()\
    \ {\n        if bucket > capacity {\n            cnt += bucket - capacity;\n \
    \       }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpce8pey4t.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpce8pey4t.rs:28:17\n   |\n28 |        \
    \         buckets[col] += 1;\n   |                 ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpce8pey4t.rs:33:21\n   |\n33 |         if bucket > capacity\
    \ {\n   |                     ^^^^^^^^\n   |                     |\n   |     \
    \                expected reference, found `isize`\n   |                     help:\
    \ consider borrowing here: `&capacity`\n   |\n   = note: expected reference `&_`\n\
    \                   found type `isize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 1 {\n                cnt += 1;\n            }\n        }\n        buckets[row.len()\
    \ - 1] = cnt;\n    }\n    for bucket in buckets.iter() {\n        if bucket >\
    \ capacity {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp6mwg2doa.rs:28:20\n\
    \   |\n28 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6mwg2doa.rs:35:21\n\
    \   |\n35 |         if bucket > capacity {\n   |                     ^^^^^^^^\n\
    \   |                     |\n   |                     expected reference, found\
    \ `isize`\n   |                     help: consider borrowing here: `&capacity`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    for row in grid.iter() {\n     \
    \   let mut cnt = 0;\n        for col in row.iter() {\n            if col == 1\
    \ {\n                cnt += 1;\n            }\n        }\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n    }\n    if max_cnt > capacity {\n\
    \        max_cnt = capacity;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpxht0p2gb.rs:28:20\n\
    \   |\n28 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if *col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n        *row = (*row + cnt) as isize;\n        cnt += 1;\n  \
    \  }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `isize` to `Vec<isize>`\n  --> /tmp/tmpljktnfux.rs:34:22\n\
    \   |\n34 |         *row = (*row + cnt) as isize;\n   |                 ---- ^\
    \ --- isize\n   |                 |\n   |                 Vec<isize>\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        for col in row.iter() {\n\
    \            if col == 0 {\n                cnt += 1;\n            }\n       \
    \ }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpxp406gb1.rs:26:20\n\
    \   |\n26 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut res = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = vec![0; capacity];\n        for cell in row.iter()\
    \ {\n            bucket[cell] += 1;\n        }\n        buckets[row.len()] +=\
    \ bucket.iter().fold(0, |acc, x| acc + x);\n    }\n    for bucket in buckets.iter()\
    \ {\n        if bucket < capacity {\n            res += 1;\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl4y1l1s8.rs:26:34\n   |\n\
    26 |         let mut bucket = vec![0; capacity];\n   |                       \
    \           ^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    26 |         let mut bucket = vec![0; capacity.try_into().unwrap()];\n   |   \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `&isize`\n  --> /tmp/tmpl4y1l1s8.rs:28:13\n\
    \   |\n28 |             bucket[cell] += 1;\n   |             ^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `&isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl4y1l1s8.rs:33:21\n   |\n33 |\
    \         if bucket < capacity {\n   |                     ^^^^^^^^\n   |    \
    \                 |\n   |                     expected reference, found `isize`\n\
    \   |                     help: consider borrowing here: `&capacity`\n   |\n \
    \  = note: expected reference `&_`\n                   found type `isize`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                cnt += 1;\n              \
    \  if cnt > max_cnt {\n                    max_cnt = cnt;\n                  \
    \  max_grid = grid.clone();\n                }\n                grid[row][col]\
    \ = 0;\n            }\n        }\n    }\n    max_cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `max_grid` is assigned to, but never used\n  --> /tmp/tmp1m4vooed.rs:25:13\n\
    \   |\n25 |     let mut max_grid = grid.clone();\n   |             ^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_max_grid` instead\n\nwarning: value assigned to `max_grid` is never\
    \ read\n  --> /tmp/tmp1m4vooed.rs:32:21\n   |\n32 |                     max_grid\
    \ = grid.clone();\n   |                     ^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ unused variable: `capacity`\n  --> /tmp/tmp1m4vooed.rs:22:36\n   |\n22 | fn\
    \ max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |          \
    \                          ^^^^^^^^ help: if this is intentional, prefix it with\
    \ an underscore: `_capacity`\n\nerror[E0596]: cannot borrow `grid` as mutable,\
    \ as it is not declared as mutable\n  --> /tmp/tmp1m4vooed.rs:34:17\n   |\n22\
    \ | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |     \
    \        ---- help: consider changing this to be mutable: `mut grid`\n...\n34\
    \ |                 grid[row][col] = 0;\n   |                 ^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error; 3 warnings emitted\n\n\
    For more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if *col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n        *row = cnt;\n        cnt += 1;\n    }\n    cnt\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp676baays.rs:34:16\n   |\n\
    34 |         *row = cnt;\n   |                ^^^ expected struct `Vec`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        for bucket in row.iter() {\n            buckets[bucket] += 1;\n \
    \       }\n    }\n    for bucket in buckets.iter() {\n        if bucket > capacity\
    \ {\n            cnt += bucket - capacity;\n        }\n    }\n    cnt\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmpaepkh0ni.rs:27:13\n   |\n27 |             buckets[bucket] += 1;\n  \
    \ |             ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpaepkh0ni.rs:31:21\n   |\n31 |         if bucket > capacity {\n   | \
    \                    ^^^^^^^^\n   |                     |\n   |              \
    \       expected reference, found `isize`\n   |                     help: consider\
    \ borrowing here: `&capacity`\n   |\n   = note: expected reference `&_`\n    \
    \               found type `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_grid\
    \ = row.clone();\n        }\n    }\n    while max_cnt > capacity {\n        let\
    \ mut cnt = 0;\n        for row in max_grid.iter() {\n            let mut cnt\
    \ = 0;\n            for col in row.iter() {\n                if col == 0 {\n \
    \                   cnt += 1;\n                }\n            }\n            if\
    \ cnt > max_cnt {\n                max_cnt = cnt;\n                max_grid =\
    \ row.clone();\n            }\n        }\n    }\n    return max_cnt;\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpkwfjryr4.rs:29:20\n\
    \   |\n29 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkwfjryr4.rs:35:24\n\
    \   |\n35 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpkwfjryr4.rs:43:24\n   |\n43 |              \
    \   if col == 0 {\n   |                        ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkwfjryr4.rs:49:28\n\
    \   |\n49 |                 max_grid = row.clone();\n   |                    \
    \        ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected\
    \ struct `Vec<Vec<isize>>`\n              found struct `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len()-1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            cnt += bucket - capacity;\n\
    \        }\n        buckets[row.len()-1] = bucket;\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmprcyjkr0z.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    let mut max_capacity = 0;\n    for row in grid.iter()\
    \ {\n        let mut max_row = 0;\n        for cell in row.iter() {\n        \
    \    if cell == 0 {\n                max_row += 1;\n            }\n        }\n\
    \        if max_row > max_capacity {\n            max_capacity = max_row;\n  \
    \      }\n    }\n    for row in grid.iter() {\n        let mut max_row = 0;\n\
    \        for cell in row.iter() {\n            if cell == 0 {\n              \
    \  counter += 1;\n            }\n        }\n        if max_row > max_capacity\
    \ {\n            max_capacity = max_row;\n        }\n    }\n    if max_capacity\
    \ > capacity {\n        max_capacity = capacity;\n    }\n    counter\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpqdhd14ex.rs:28:21\n\
    \   |\n28 |             if cell == 0 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmpqdhd14ex.rs:39:21\n   |\n39 |             if cell\
    \ == 0 {\n   |                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut cur_capacity = capacity;\n        for col in row.iter() {\n\
    \            if *col == 1 {\n                cur_capacity -= 1;\n            }\n\
    \        }\n        if cur_capacity > max_capacity {\n            max_capacity\
    \ = cur_capacity;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpz3yp23xz.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cnt = 0;\n\
    \        for col in row.iter() {\n            if col == 1 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > ans {\n            ans = cnt;\n\
    \        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpvl0ztpjb.rs:27:20\n\
    \   |\n27 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = grid[0].clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_well = row.clone();\n        }\n    }\n    for row in grid.iter() {\n  \
    \      let mut cnt = 0;\n        for col in row.iter() {\n            if *col\
    \ == 0 {\n                cnt += 1;\n            }\n        }\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n            max_well = row.clone();\n\
    \        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n\
    \    let mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n\
    \        for col in row.iter() {\n            if *col == 1 {\n               \
    \ cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n          \
    \  max_cnt = cnt;\n            max_well = row.clone();\n        }\n    }\n   \
    \ if max_cnt > capacity {\n        return max_cnt;\n    }\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ *col == 0 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_well = row.clone();\n\
    \        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n\
    \    cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_well = row.clone();\n        }\n    }\n    if max_cnt\
    \ > capacity {\n        return max_cnt;\n    }\n    cnt = 0;\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ *col == 0 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_well = row.clone();\n\
    \        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n\
    \    cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_well = row.clone();\n        }\n    }\n    if max_cnt\
    \ > capacity {\n        return max_\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpw85fs_vq.rs:140:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n129 |     if max_cnt > capacity {\n    |                   \
    \        - this delimiter might not be properly closed...\n130 |         return\
    \ max_\n131 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n140 | }\n    |   ^\n\nerror[E0425]: cannot find value `max_` in this scope\n\
    \   --> /tmp/tmpw85fs_vq.rs:130:16\n    |\n130 |         return max_\n    |  \
    \              ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw85fs_vq.rs:22:56\n   |\n22 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |    --------                              \
    \              ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if *col == 0 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n        *row = cnt;\n        cnt += 1;\n    }\n    cnt\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu7vkz4jm.rs:34:16\n   |\n\
    34 |         *row = cnt;\n   |                ^^^ expected struct `Vec`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = vec![];\n   \
    \ for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if col == 0 {\n         \
    \       cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n    \
    \        max_cnt = cnt;\n            max_well = row;\n        }\n    }\n    if\
    \ max_cnt > capacity {\n        return max_cnt;\n    }\n    if max_cnt == 0 {\n\
    \        return 0;\n    }\n    let mut cnt = 0;\n    for row in grid.iter() {\n\
    \        let mut cnt = 0;\n        for col in row.iter() {\n            if col\
    \ == 1 {\n                cnt += 1;\n            }\n        }\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n            max_well = row;\n     \
    \   }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n  \
    \  if max_cnt == 0 {\n        return 0;\n    }\n    let mut cnt = 0;\n    for\
    \ row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 0 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n\
    \    }\n    if max_cnt == 0 {\n        return 0;\n    }\n    let mut cnt = 0;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n\
    \    }\n    if max_cnt == 0 {\n        return 0;\n    }\n    let mut cnt = 0;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 0 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n\
    \    }\n    if max_cnt == 0 {\n        return 0;\n    }\n    let mut cnt = 0;\n\
    \    for row in grid.iter\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpx385wueh.rs:134:1\n    |\n\
    134 | }\n    | ^ expected `{`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpx385wueh.rs:29:20\n   |\n29 |             if col == 1 {\n   | \
    \                   ^^ no implementation for `&isize == {integer}`\n   |\n   =\
    \ help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx385wueh.rs:35:24\n   |\n35 |             max_well\
    \ = row;\n   |                        ^^^- help: try using a conversion method:\
    \ `.to_vec()`\n   |                        |\n   |                        expected\
    \ struct `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<_>`\n\
    \           found reference `&Vec<isize>`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpx385wueh.rs:41:20\n   |\n41 |             if\
    \ col == 0 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx385wueh.rs:47:24\n   |\n47 |\
    \             max_well = row;\n   |                        ^^^- help: try using\
    \ a conversion method: `.to_vec()`\n   |                        |\n   |      \
    \                  expected struct `Vec`, found `&Vec<isize>`\n   |\n   = note:\
    \ expected struct `Vec<_>`\n           found reference `&Vec<isize>`\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmpx385wueh.rs:60:20\n \
    \  |\n60 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx385wueh.rs:66:24\n\
    \   |\n66 |             max_well = row;\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |                        |\n\
    \   |                        expected struct `Vec`, found `&Vec<isize>`\n   |\n\
    \   = note: expected struct `Vec<_>`\n           found reference `&Vec<isize>`\n\
    \nerror[E0277]: can't co"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur_capacity\
    \ = capacity;\n        for cell in row.iter() {\n            if cell == 1 {\n\
    \                cur_capacity -= 1;\n            }\n        }\n        if cur_capacity\
    \ < ans {\n            ans = cur_capacity;\n        }\n    }\n    ans\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmplg4427oc.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    for row in grid.iter() {\n     \
    \   let mut cnt = 0;\n        for col in row.iter() {\n            if col == 1\
    \ {\n                cnt += 1;\n            }\n        }\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n    }\n    if max_cnt > capacity {\n\
    \        max_cnt = capacity;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpxht0p2gb.rs:28:20\n\
    \   |\n28 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for col in row.iter()\
    \ {\n            if col[0] == 0 {\n                min_bucket = std::cmp::min(min_bucket,\
    \ col[1]);\n            }\n        }\n        cnt += min_bucket - 1;\n       \
    \ min_bucket = grid[0].len();\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpjovixthi.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror[E0608]: cannot index into a value of type `&isize`\n  -->\
    \ /tmp/tmpjovixthi.rs:28:16\n   |\n28 |             if col[0] == 0 {\n   |   \
    \             ^^^^^^\n\nerror[E0608]: cannot index into a value of type `&isize`\n\
    \  --> /tmp/tmpjovixthi.rs:29:56\n   |\n29 |                 min_bucket = std::cmp::min(min_bucket,\
    \ col[1]);\n   |                                                        ^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjovixthi.rs:35:5\n   |\n22 | fn\
    \ max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |          \
    \                                              ----- expected `isize` because\
    \ of return type\n...\n35 |     cnt\n   |     ^^^ expected `isize`, found `usize`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                max_grid[row][col] = capacity;\n\
    \                cnt += 1;\n            }\n        }\n    }\n    while cnt > 0\
    \ {\n        max_cnt += 1;\n        for row in 0..grid.len() {\n            for\
    \ col in 0..grid[row].len() {\n                if grid[row][col] == 1 {\n    \
    \                max_grid[row][col] -= 1;\n                    cnt -= 1;\n   \
    \             }\n            }\n        }\n    }\n    max_cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpbf38qu_8.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for bucket in row.iter()\
    \ {\n            if *bucket > min_bucket {\n                min_bucket = bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpyiv77goc.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyiv77goc.rs:29:30\n\
    \   |\n29 |                 min_bucket = bucket;\n   |                       \
    \       ^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n29 |                 min_bucket = *bucket;\n   |         \
    \                     +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = vec![vec![0;\
    \ capacity]; grid.len()];\n    for row in grid.iter() {\n        let mut cnt =\
    \ 0;\n        for col in row.iter() {\n            if col == 1 {\n           \
    \     cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n      \
    \      max_cnt = cnt;\n            max_well = row;\n        }\n    }\n    for\
    \ row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 0 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    cnt += max_cnt - 1;\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1pj73q80.rs:25:37\n   |\n\
    25 |     let mut max_well = vec![vec![0; capacity]; grid.len()];\n   |       \
    \                              ^^^^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n25 |     let mut max_well = vec![vec![0; capacity.try_into().unwrap()];\
    \ grid.len()];\n   |                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp1pj73q80.rs:29:20\n\
    \   |\n29 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1pj73q80.rs:35:24\n\
    \   |\n35 |             max_well = row;\n   |                        ^^^ expected\
    \ struct `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<Vec<{integer}>>`\n\
    \           found reference `&Vec<isize>`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp1pj73q80.rs:41:20\n   |\n41 |             if\
    \ col == 0 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1pj73q80.rs:47:24\n   |\n47 |\
    \             max_well = row;\n   |                        ^^^ expected struct\
    \ `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<Vec<{integer}>>`\n\
    \           found reference `&Vec<isize>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    let mut flow_in = 0;\n    let\
    \ mut flow_out = 0;\n    let mut flow_in_out = 0;\n    let mut flow_out_in = 0;\n\
    \    let mut flow_out_out = 0;\n    let mut flow_in_in = 0;\n    let mut flow_out_in_in\
    \ = 0;\n    let mut flow_out_out_in = 0;\n    let mut flow_in_out_in = 0;\n  \
    \  let mut flow_out_in_out = 0;\n    let mut flow_in_out_out = 0;\n    let mut\
    \ flow_in_out_in_in = 0;\n    let mut flow_out_in_out_in = 0;\n    let mut flow_in_out_out_in\
    \ = 0;\n    let mut flow_in_out_in_out = 0;\n    let mut flow_out_in_out_in =\
    \ 0;\n    let mut flow_in_out_in_out_in = 0;\n    let mut flow_out_in_out_in_out\
    \ = 0;\n    let mut flow_in_out_in_out_in = 0;\n    let mut flow_out_in_out_in_out_in\
    \ = 0;\n    let mut flow_in_out_in_out_in_out = 0;\n    let mut flow_out_in_out_in_out_in\
    \ = 0;\n    let mut flow_in_out_in_out_in_out_in = 0;\n    let mut flow_out_in_out_in_out_in_out\
    \ = 0;\n    let mut flow_in_out_in_out_in_out_in = 0;\n    let mut flow_out_in_out_in_out_in_out\
    \ = 0;\n    let mut flow_in_out_in_out_in_out_in_out = 0;\n    let mut flow_out_in_out_in_out_in_out_in\
    \ = 0;\n    let mut flow_in_out_in_out_in_out_in_out = 0;\n    let mut flow_out_in_out_in_out_in_out_in\
    \ = 0;\n    let mut flow_in_out_in_out_in_out_in_out_in = 0;\n    let mut flow_out_in_out_in_out_in_out_in_out\
    \ = 0;\n    let mut flow_in_out_in_out_in_out_in_out_in = 0;\n    let mut flow_out_in_out_in_out_in_out_in_out\
    \ = 0;\n    let mut flow_in_out_in_out_in_out_in_out_in_out = 0;\n    let mut\
    \ flow_out_in_out_in_out_in_out_in_out_in = 0;\n    let mut flow_in_out_in_out_in_out_in_out_in_out\
    \ = 0;\n    let mut flow_out_in_out_in_out_in_out_in_out_in = 0;\n    let mut\
    \ flow_in_out_in_out_in_out_in_out_in_out = 0;\n    let mut flow_out_in_out_in_out_in_out_in_out_in\
    \ = 0;\n    let mut flow_in_out_in_out_in_out_in_out_in_out_in = 0;\n    let mut\
    \ flow_out_in_out_in_\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9g04sf_x.rs:66:32\n   |\n\
    66 |     let mut flow_out_in_out_in_\n   |                                ^ help:\
    \ add `;` here\n67 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9g04sf_x.rs:22:56\n   |\n22 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |    --------                              \
    \              ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        let mut max_cnt\
    \ = 0;\n        let mut min_cnt = std::i32::MAX;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n                if\
    \ cnt > max_cnt {\n                    max_cnt = cnt;\n                }\n   \
    \             if cnt < min_cnt {\n                    min_cnt = cnt;\n       \
    \         }\n            }\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt {\n     \
    \       min_cnt = cnt;\n        }\n        cnt += 1;\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpzmlr9rf4.rs:131:3\n\
    \    |\n22  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n26  |     for row in grid.iter() {\n    |                  \
    \          - this delimiter might not be properly closed...\n...\n122 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n131 | }\n\
    \    |   ^\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpzmlr9rf4.rs:31:20\n\
    \   |\n31 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzmlr9rf4.rs:22:56\n\
    \   |\n22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |    --------                                            ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        for col in row.iter() {\n\
    \            if col == 0 {\n                cnt += 1;\n            }\n       \
    \ }\n    }\n    cnt += max_fill_helper(grid, capacity);\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_fill_helper` in this scope\n  -->\
    \ /tmp/tmpi053e_vk.rs:31:12\n   |\n31 |     cnt += max_fill_helper(grid, capacity);\n\
    \   |            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpi053e_vk.rs:26:20\n   |\n26\
    \ |             if col == 0 {\n   |                    ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = Vec::new();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if col == 0 {\n         \
    \       cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n    \
    \        max_cnt = cnt;\n            max_well = row;\n        }\n    }\n    if\
    \ max_cnt > capacity {\n        return max_cnt;\n    }\n    let mut cnt = 0;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n\
    \    }\n    let mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if col == 0 {\n         \
    \       cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n    \
    \        max_cnt = cnt;\n            max_well = row;\n        }\n    }\n    if\
    \ max_cnt > capacity {\n        return max_cnt;\n    }\n    let mut cnt = 0;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n\
    \    }\n    let mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt\
    \ = 0;\n        for col in row.iter() {\n            if col == 0 {\n         \
    \       cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n    \
    \        max_cnt = cnt;\n            max_well = row;\n        }\n    }\n    if\
    \ max_cnt > capacity {\n        return max_cnt;\n    }\n    let mut cnt = 0;\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if col == 1 {\n                cnt += 1;\n            }\n   \
    \     }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_well\
    \ = row;\n        }\n    }\n    if max_cnt \n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp9pailcnl.rs:131:1\n    |\n\
    130 |     if max_cnt \n    |     -- this `if` expression has a condition, but\
    \ no block\n131 | }\n    | ^ expected `{`\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp9pailcnl.rs:29:20\n   |\n29 |             if\
    \ col == 1 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9pailcnl.rs:35:24\n   |\n35 |\
    \             max_well = row;\n   |                        ^^^- help: try using\
    \ a conversion method: `.to_vec()`\n   |                        |\n   |      \
    \                  expected struct `Vec`, found `&Vec<isize>`\n   |\n   = note:\
    \ expected struct `Vec<_>`\n           found reference `&Vec<isize>`\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmp9pailcnl.rs:41:20\n \
    \  |\n41 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9pailcnl.rs:47:24\n\
    \   |\n47 |             max_well = row;\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |                        |\n\
    \   |                        expected struct `Vec`, found `&Vec<isize>`\n   |\n\
    \   = note: expected struct `Vec<_>`\n           found reference `&Vec<isize>`\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp9pailcnl.rs:57:20\n\
    \   |\n57 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9pailcnl.rs:63:24\n\
    \   |\n63 |             max_well = row;\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |                        |\n\
    \   |                        expected struct `Vec`, found `&Vec<isize>`\n   |\n\
    \   = note: exp"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_well = Vec::new();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        let mut max_well\
    \ = Vec::new();\n        for col in row.iter() {\n            if col == 1 {\n\
    \                cnt += 1;\n            } else {\n                if cnt > max_cnt\
    \ {\n                    max_cnt = cnt;\n                    max_well = col;\n\
    \                }\n            }\n        }\n        cnt += 1;\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n            max_well = row;\n     \
    \   }\n    }\n    cnt += 1;\n    if cnt > max_cnt {\n        max_cnt = cnt;\n\
    \        max_well = grid;\n    }\n    max_cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp1i6oigql.rs:30:20\n\
    \   |\n30 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1i6oigql.rs:35:32\n\
    \   |\n35 |                     max_well = col;\n   |                        \
    \        ^^^ expected struct `Vec`, found `&isize`\n   |\n   = note: expected\
    \ struct `Vec<_>`\n           found reference `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1i6oigql.rs:42:24\n   |\n42 |             max_well = row;\n\
    \   |                        ^^^- help: try using a conversion method: `.to_vec()`\n\
    \   |                        |\n   |                        expected struct `Vec`,\
    \ found `&Vec<isize>`\n   |\n   = note: expected struct `Vec<_>`\n           found\
    \ reference `&Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for bucket in row.iter()\
    \ {\n            if *bucket < min_bucket {\n                min_bucket = *bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpqpoy01i7.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmprx8ql89x.rs:27:20\n\
    \   |\n27 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n    let mut flow_in = vec![0; grid.len()];\n\
    \    let mut flow_out = vec![0; grid.len()];\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6p3uxgxi.rs:22:56\n   |\n\
    22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    for row in grid.iter() {\n  \
    \      let mut cnt = 0;\n        for col in row.iter() {\n            if *col\
    \ == 0 {\n                cnt += 1;\n            }\n        }\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n            max_grid = row.clone();\n\
    \        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n\
    \    let mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n\
    \        for col in row.iter() {\n            if *col == 1 {\n               \
    \ cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n          \
    \  max_cnt = cnt;\n            max_grid = row.clone();\n        }\n    }\n   \
    \ if max_cnt > capacity {\n        return max_cnt;\n    }\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ *col == 0 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_grid = row.clone();\n\
    \        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n\
    \    cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_grid = row.clone();\n        }\n    }\n    if max_cnt\
    \ > capacity {\n        return max_cnt;\n    }\n    cnt = 0;\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ *col == 0 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_grid = row.clone();\n\
    \        }\n    }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n\
    \    cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n      \
    \  for col in row.iter() {\n            if *col == 1 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > max_cnt {\n            max_cnt\
    \ = cnt;\n            max_grid = row.clone();\n        }\n    }\n    if max_cnt\
    \ > capacity {\n        return max_cnt;\n    }\n    cnt = 0;\n\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppnrijvps.rs:35:24\n   |\n\
    35 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmppnrijvps.rs:47:24\n   |\n47 |             max_grid = row.clone();\n\
    \   |                        ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found struct\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppnrijvps.rs:63:24\n\
    \   |\n63 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmppnrijvps.rs:78:24\n   |\n78 |             max_grid = row.clone();\n\
    \   |                        ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found struct\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppnrijvps.rs:94:24\n\
    \   |\n94 |             max_grid = row.clone();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n \
    \  --> /tmp/tmppnrijvps.rs:110:24\n    |\n110 |             max_grid = row.clone();\n\
    \    |                        ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n\
    \    |\n    = note: expected struct `Vec<Vec<isize>>`\n               found struct\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n   --> /tmp/tmppnrijvps.rs:126:24\n\
    \    |\n126 |             max_grid = row.clone();\n    |                     \
    \   ^^^^^^^^^^^ expected struct `Vec`, found `isize`\n    |\n    = note: expected\
    \ struct `Vec<Vec<isize>>`\n               found struct `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppnrijvps.rs:22:56\n   |\n22 | fn max_fill(grid:\
    \ Ve"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        for col in row.iter() {\n\
    \            if col == 0 {\n                cnt += 1;\n            }\n       \
    \ }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpxp406gb1.rs:26:20\n\
    \   |\n26 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747102
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    let mut min_grid = grid.clone();\n    let mut min_cnt = 0;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt3674hbc.rs:22:56\n   |\n\
    22 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur_capacity\
    \ = capacity;\n        for cell in row.iter() {\n            if cell == 1 {\n\
    \                cur_capacity -= 1;\n            }\n        }\n        if cur_capacity\
    \ < ans {\n            ans = cur_capacity;\n        }\n    }\n    ans\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmplg4427oc.rs:27:21\n\
    \   |\n27 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n     \
    \   for col in row.iter() {\n            if col == 0 {\n                cnt +=\
    \ 1;\n            }\n        }\n        if cnt > capacity {\n            cnt -=\
    \ 1;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwxdkqcse.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut ans = isize::MAX;\n    for row in grid.iter() {\n        let mut cur = isize::MAX;\n\
    \        for col in row.iter() {\n            cur = if col == 1 {\n          \
    \      cur\n            } else {\n                cur\n            };\n      \
    \  }\n        if cur > ans {\n            ans = cur;\n        }\n    }\n    ans\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp40fm5_kj.rs:27:26\n\
    \   |\n27 |             cur = if col == 1 {\n   |                          ^^\
    \ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt2 = 0;\n    \
    \    for col in row.iter() {\n            if col == 0 {\n                cnt2\
    \ += 1;\n            }\n        }\n        if cnt2 > capacity {\n            cnt\
    \ += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpjz_4k_00.rs:27:20\n\
    \   |\n27 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut counter = 0;\n    let mut max_capacity = capacity;\n    for row in grid.iter()\
    \ {\n        let mut max_bucket = max_capacity;\n        for bucket in row.iter()\
    \ {\n            if bucket > max_bucket {\n                max_bucket = bucket;\n\
    \            }\n        }\n        max_capacity -= max_bucket;\n        counter\
    \ += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzbvzxexd.rs:28:25\n   |\n\
    28 |             if bucket > max_bucket {\n   |                         ^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&isize`,\
    \ found `isize`\n   |                         help: consider borrowing here: `&max_bucket`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzbvzxexd.rs:29:30\n   |\n29 |\
    \                 max_bucket = bucket;\n   |                              ^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n29 |                 max_bucket = *bucket;\n   |                      \
    \        +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for bucket in row.iter()\
    \ {\n            if *bucket < min_bucket {\n                min_bucket = *bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpqpoy01i7.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut max_flow = 0;\n    let mut flow = 0;\n    let mut flow2 = 0;\n    for row\
    \ in grid.iter() {\n        let mut flow = 0;\n        for col in row.iter() {\n\
    \            if col == 0 {\n                flow += 1;\n            }\n      \
    \  }\n        max_flow = if flow > max_flow {\n            flow\n        } else\
    \ {\n            max_flow\n        };\n    }\n    for row in grid.iter() {\n \
    \       let mut flow = 0;\n        for col in row.iter() {\n            if col\
    \ == 0 {\n                flow += 1;\n            }\n        }\n        flow2\
    \ = if flow > flow2 {\n            flow\n        } else {\n            flow2\n\
    \        };\n    }\n    if max_flow == 0 {\n        max_flow = flow2;\n    }\n\
    \    if max_flow > capacity {\n        max_flow\n    } else {\n        max_flow\
    \ - capacity\n    }\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp1u6_eebc.rs:29:20\n\
    \   |\n29 |             if col == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmp1u6_eebc.rs:42:20\n   |\n42 |             if col\
    \ == 0 {\n   |                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut max_capacity = capacity;\n    let mut min_capacity\
    \ = capacity;\n    for row in grid.iter() {\n        let mut cur_capacity = capacity;\n\
    \        for col in row.iter() {\n            if col == 1 {\n                cur_capacity\
    \ -= 1;\n            }\n            if cur_capacity < min_capacity {\n       \
    \         min_capacity = cur_capacity;\n            }\n        }\n        if cur_capacity\
    \ > max_capacity {\n            max_capacity = cur_capacity;\n        }\n    }\n\
    \    cnt += max_capacity - min_capacity;\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp12p7wnfi.rs:29:20\n\
    \   |\n29 |             if col == 1 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for col in row.iter()\
    \ {\n            if col[0] == 0 {\n                cnt += 1;\n               \
    \ if min_bucket > col {\n                    min_bucket = col;\n             \
    \   }\n            }\n        }\n        if min_bucket > capacity {\n        \
    \    cnt += 1;\n            min_bucket = capacity;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpe38m81qp.rs:26:37\n   |\n26 |         let mut min_bucket\
    \ = row[0].len();\n   |                                     ^^^ method not found\
    \ in `isize`\n\nerror[E0608]: cannot index into a value of type `&isize`\n  -->\
    \ /tmp/tmpe38m81qp.rs:28:16\n   |\n28 |             if col[0] == 0 {\n   |   \
    \             ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe38m81qp.rs:35:25\n\
    \   |\n35 |         if min_bucket > capacity {\n   |                         ^^^^^^^^\n\
    \   |                         |\n   |                         expected `&isize`,\
    \ found `isize`\n   |                         help: consider borrowing here: `&capacity`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe38m81qp.rs:37:26\n   |\n37 |\
    \             min_bucket = capacity;\n   |                          ^^^^^^^^\n\
    \   |                          |\n   |                          expected `&isize`,\
    \ found `isize`\n   |                          help: consider borrowing here:\
    \ `&capacity`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747103
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
    \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
    \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
    /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1\
    \ <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity\
    \ <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let\
    \ mut res = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            bucket = capacity;\n \
    \       }\n        buckets[row.len() - 1] = bucket;\n        res += 1;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp1zsmmkk3.rs:28:21\n\
    \   |\n28 |             if cell == 1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747104
