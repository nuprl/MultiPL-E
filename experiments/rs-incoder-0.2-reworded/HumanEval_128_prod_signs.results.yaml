language: rs
name: HumanEval_128_prod_signs
results:
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = 0;\n    for\
    \ x in arr {\n        if x < 0 {\n            res -= x;\n        } else {\n  \
    \          res += x;\n        }\n    }\n    Some(res)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmpdiq47yoj.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for &x in &arr\
    \ {\n        product *= x;\n    }\n\n    let mut sum = 0;\n    for &x in &arr\
    \ {\n        sum += if x < 0 {\n            -1\n        } else {\n           \
    \ 1\n        };\n    }\n\n    Some(product * sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-32)`,\n right: `Some(-9)`', /tmp/tmpuuz7s8ue.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for x in arr {\n   \
    \     product *= x;\n    }\n    let mut sum = 0;\n    for x in arr {\n       \
    \ sum += if x < 0 {\n            -1\n        } else {\n            1\n       \
    \ } * x;\n    }\n    Some(sum * product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpsgznaa7f.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = isize::one();\n\
    \    for &i in arr {\n        res *= i as isize;\n        if *i as isize < 0 {\n\
    \            res *= -1;\n        }\n    }\n    Some(res)\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error: `<` is interpreted as a start of generic arguments for `isize`,\
    \ not a comparison\n  --> /tmp/tmpipa68gmx.rs:16:24\n   |\n16 |         if *i\
    \ as isize < 0 {\n   |                        ^ --- interpreted as generic arguments\n\
    \   |                        |\n   |                        not interpreted as\
    \ comparison\n   |\nhelp: try comparing the cast value\n   |\n16 |         if\
    \ (*i as isize) < 0 {\n   |            +           +\n\nerror[E0599]: no function\
    \ or associated item named `one` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpipa68gmx.rs:13:26\n   |\n13 |     let mut res = isize::one();\n\
    \   |                          ^^^ function or associated item not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpipa68gmx.rs:14:9\n   |\n14 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for &i in &arr\
    \ {\n        product *= i;\n    }\n\n    let mut sign = 1;\n    for &i in &arr\
    \ {\n        sign *= i;\n    }\n\n    Some(sign * product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmpy20nk_ta.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = arr[0];\n    for i in 1..arr.len()\
    \ {\n        res *= if arr[i] < 0 { -1 } else { 1 };\n        res += arr[i];\n\
    \    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpd2elr5vd.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for &i in arr {\n  \
    \      product *= i;\n    }\n    let mut sum = 0;\n    for &i in arr {\n     \
    \   sum += if i == -1 {\n            -1\n        } else if i == 1 {\n        \
    \    1\n        } else {\n            0\n        };\n    }\n    Some(product *\
    \ sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqkvoubio.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqkvoubio.rs:21:9\n   |\n21 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for i in arr {\n       \
    \ res += if i < 0 {\n            1\n        } else {\n            -1\n       \
    \ };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmp_tprr715.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = arr[0];\n\
    \    for x in arr.iter().rev() {\n        product *= x;\n    }\n    if product\
    \ == 0 {\n        return None;\n    }\n    let mut sign = 1;\n    for x in arr.iter()\
    \ {\n        product *= x;\n        if product < 0 {\n            product *= sign;\n\
    \        }\n        sign *= -1;\n    }\n    Some(product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmpdez1y0c4.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sum = 0;\n\
    \n    for i in arr.iter() {\n        sum += i;\n        product *= i;\n    }\n\
    \n    if sum < 0 {\n        None\n    } else {\n        Some(product * sum)\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp3howx8dx.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr.iter() {\n        if *i < 0 {\n            sign *= -1;\n   \
    \     }\n        product *= sign;\n    }\n    Some(product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmp0jkzo2cd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    for x in arr {\n      \
    \  prod *= x;\n    }\n    let mut sum = 0;\n    for x in arr {\n        sum +=\
    \ if x < 0 {\n            1\n        } else {\n            -1\n        };\n  \
    \  }\n    Some(prod * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpa428igkp.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = arr[0] as isize;\n    for &i\
    \ in &arr {\n        product *= i as isize;\n    }\n    Some(product)\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpw1sadbui.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        product *= x;\n        sign *= if x < 0 {\n     \
    \       -1\n        } else {\n            1\n        };\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp1gpp0k9i.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut prod = 1;\n    for x in arr {\n    \
    \    if x < 0 {\n            prod *= -1;\n        }\n        prod *= x;\n    }\n\
    \    Some(prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpmv1684ho.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = 0;\n    for i in arr {\n     \
    \   res += if i >= 0 {\n            1\n        } else {\n            -1\n    \
    \    };\n    }\n\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmpcxmqkgj1.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for i in arr {\n       \
    \ res += if i >= 0 {\n            1\n        } else {\n            -1\n      \
    \  };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmpcywsgs7h.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for &x in arr {\n        product *= x;\n        sign *= sign;\n    }\n\n\
    \    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphhlvxb1h.rs:20:9\n   |\n\
    20 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = isize::one();\n    for x in arr\
    \ {\n        res *= x;\n        if x < 0 {\n            res *= -1;\n        }\n\
    \    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpvvg8dvfh.rs:16:26\n   |\n16 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for x in arr {\n   \
    \     product *= x;\n    }\n    let mut sum = 0;\n    for x in arr {\n       \
    \ sum += x * product;\n    }\n    Some(sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpjls5fwa0.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = arr[0] as isize;\n    for i\
    \ in arr.iter().rev() {\n        product *= i as isize;\n    }\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpl4zpfr2d.rs:18:20\n\
    \   |\n18 |         product *= i as isize;\n   |                    -^^^^^^^^^\n\
    \   |                    |\n   |                    cannot cast `&isize` as `isize`\n\
    \   |                    help: dereference the expression: `*i`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for i in arr {\n       \
    \ res += if i < 0 {\n            1\n        } else {\n            -1\n       \
    \ };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmp_tprr715.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = 1;\n \
    \   for x in arr {\n        product *= x;\n    }\n    Some(product)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpng03og59.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = isize::one();\n    for i in arr.iter()\
    \ {\n        res *= i;\n        res *= if *i < 0 { -1 } else { 1 };\n    }\n \
    \   Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpx79a21rj.rs:17:26\n   |\n17 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for &x in arr {\n      \
    \  res += if x < 0 {\n            -1\n        } else {\n            1\n      \
    \  };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2y14o4ex.rs:17:9\n   |\n\
    17 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for i in arr.iter().rev()\
    \ {\n        product *= i;\n    }\n\n    let mut sum = 0;\n    for i in arr.iter()\
    \ {\n        sum += if i == -1 {\n            -1\n        } else {\n         \
    \   1\n        };\n    }\n\n    Some(product * sum)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmppl9knn7v.rs:24:21\n\
    \   |\n24 |         sum += if i == -1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = arr[0];\n    for &x in &arr {\n\
    \        res *= x;\n        res -= x;\n    }\n\n    Some(res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(28)`,\n right: `Some(-9)`', /tmp/tmp1x5_c05s.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = arr[0];\n    for i in 1..arr.len()\
    \ {\n        res *= if arr[i] > 0 { 1 } else { -1 };\n        res += arr[i];\n\
    \    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpmxnsrkp1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = vec![0];\n    for i in arr.iter()\
    \ {\n        res.iter_mut().for_each(|&x| {\n            *x = *x * i as isize;\n\
    \        });\n    }\n    Some(res.iter().product().unwrap())\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr3orni06.rs:18:34\n   |\n\
    18 |         res.iter_mut().for_each(|&x| {\n   |                            \
    \      ^--\n   |                                  ||\n   |                   \
    \               |expected due to this\n   |                                  types\
    \ differ in mutability\n   |                                  help: did you mean\
    \ `x`: `&&mut {integer}`\n   |\n   = note: expected mutable reference `&mut {integer}`\n\
    \                      found reference `&_`\n\nerror[E0606]: casting `&isize`\
    \ as `isize` is invalid\n  --> /tmp/tmpr3orni06.rs:19:23\n   |\n19 |         \
    \    *x = *x * i as isize;\n   |                       -^^^^^^^^^\n   |      \
    \                 |\n   |                       cannot cast `&isize` as `isize`\n\
    \   |                       help: dereference the expression: `*i`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0606.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = arr[0];\n    for i in 1..arr.len()\
    \ {\n        res *= if arr[i] >= 0 { 1 } else { -1 };\n        res += arr[i];\n\
    \    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpfzxy_hrc.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = arr[0] as isize;\n    for i\
    \ in arr.iter().rev() {\n        product *= i as isize;\n    }\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpl4zpfr2d.rs:18:20\n\
    \   |\n18 |         product *= i as isize;\n   |                    -^^^^^^^^^\n\
    \   |                    |\n   |                    cannot cast `&isize` as `isize`\n\
    \   |                    help: dereference the expression: `*i`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr.iter() {\n        product *= x;\n        sign *= match x {\n\
    \            1 => 1,\n            -1 => -1,\n            _ => 0,\n        };\n\
    \    }\n\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `Some(-9)`', /tmp/tmp3ak_yny1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for &i in arr {\n        product *= i;\n        sign *= match i {\n     \
    \       1 => 1,\n            -1 => -1,\n            _ => 0,\n        };\n    }\n\
    \    Some(sign * product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx_m26rf7.rs:19:9\n   |\n\
    19 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = arr.iter().product();\n    let\
    \ mut sign = 1;\n    for x in arr {\n        if x < 0 {\n            sign *= -1;\n\
    \        }\n        product *= sign;\n    }\n    Some(product)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmps90sgxef.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sign = 1;\n   \
    \ for x in arr {\n        if x < 0 {\n            sign *= -1;\n        }\n   \
    \     prod *= x;\n    }\n    Some(prod * sign)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmphhp4c5uw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = arr[0];\n    for i in 1..arr.len()\
    \ {\n        res *= if arr[i] < 0 { -1 } else { 1 };\n        res += arr[i];\n\
    \    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpd2elr5vd.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sum = 0;\n\
    \n    for x in arr {\n        if x < 0 {\n            product *= -1;\n       \
    \ }\n\n        sum += x;\n    }\n\n    Some(sum * product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpguc9l6vp.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = arr[0];\n    for x in arr.iter().rev()\
    \ {\n        product *= x;\n    }\n    let mut sum = 0;\n    for x in arr.iter()\
    \ {\n        sum += if x < 0 {\n            -1\n        } else {\n           \
    \ 1\n        } * x;\n    }\n    Some(product * sum)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8pkxhxw2.rs:22:23\n   |\n\
    22 |         sum += if x < 0 {\n   |                       ^\n   |           \
    \            |\n   |                       expected `&isize`, found integer\n\
    \   |                       help: consider borrowing here: `&0`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for &i in arr {\n        product *= i;\n        sign *= if i < 0 { -1 } else\
    \ { 1 };\n    }\n    Some(sign * product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpydbwknzb.rs:19:9\n   |\n\
    19 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0] as isize;\n    for\
    \ &i in arr {\n        product *= i;\n    }\n\n    let mut magnitude = product;\n\
    \    for &i in arr {\n        magnitude *= i as isize;\n    }\n\n    Some(magnitude)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6axyaaq8.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6axyaaq8.rs:23:9\n   |\n23 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    for &i in arr {\n\
    \        product *= i;\n    }\n\n    let mut sum = 0;\n    for &i in arr {\n \
    \       sum += if i == -1 {\n            -1\n        } else if i == 1 {\n    \
    \        1\n        } else {\n            0\n        };\n    }\n\n    Some(product\
    \ * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvl7_by4t.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvl7_by4t.rs:23:9\n   |\n23 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr.iter() {\n        product *= sign;\n        sign *= i;\n   \
    \ }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n  \
    \  assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(8)`,\n right: `Some(-9)`', /tmp/tmpna_k53me.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    for &i in arr {\n\
    \        product *= i;\n    }\n\n    let mut sum = 0;\n    for &i in arr {\n \
    \       sum += i * product;\n    }\n\n    Some(sum)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgvwfir4b.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgvwfir4b.rs:23:9\n   |\n23 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        if x < 0 {\n            product *= -1;\n        \
    \    sign *= -1;\n        } else {\n            product *= 1;\n        }\n   \
    \ }\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(-9)`', /tmp/tmpceoeoqd7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = 0;\n    let mut sign = 1;\n  \
    \  for x in arr {\n        res += sign * x;\n        sign *= -1;\n    }\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmp5bg_d80p.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0] as isize;\n    for\
    \ &i in arr {\n        product *= i as isize;\n    }\n\n    let mut sign = 1;\n\
    \    for i in arr {\n        sign *= i as isize;\n    }\n\n    Some(sign * product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4qcssduj.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0] as isize;\n    for\
    \ &i in &arr {\n        product *= i;\n    }\n\n    let mut sign = 1;\n    for\
    \ &i in &arr {\n        sign *= i;\n    }\n\n    Some(sign * product)\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmpzq7zg5st.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr.iter() {\n        if *i < 0 {\n            sign *= -1;\n   \
    \     }\n        product *= sign;\n    }\n    Some(product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpmco8m45e.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr.iter() {\n        product *= x;\n        sign *= if x < 0 {\
    \ -1 } else { 1 };\n    }\n    Some(sign * product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmploqasc9q.rs:20:24\n   |\n\
    20 |         sign *= if x < 0 { -1 } else { 1 };\n   |                       \
    \ ^\n   |                        |\n   |                        expected `&isize`,\
    \ found integer\n   |                        help: consider borrowing here: `&0`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for &i in arr {\n        product *= i;\n        sign *= if i == -1 { -1\
    \ } else { 1 };\n    }\n\n    Some(product * sign)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7kdm_i3l.rs:20:9\n   |\n\
    20 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    for x in arr {\n      \
    \  prod *= x;\n    }\n    let mut sign = 1;\n    for x in arr {\n        if x\
    \ < 0 {\n            sign *= -1;\n        }\n    }\n    Some(prod * sign)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmppt5rxq01.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = isize::one();\n\
    \    for i in arr.iter() {\n        res *= if *i < 0 { -1 } else { 1 };\n    \
    \    res += *i;\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpu3vy653l.rs:13:26\n   |\n13 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        product *= x;\n        sign *= if x < 0 { -1 } else\
    \ { 1 };\n    }\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpzeiz8wtg.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = arr[0];\n    for i in 1..arr.len()\
    \ {\n        res *= if arr[i] >= 0 { 1 } else { -1 };\n        res += arr[i];\n\
    \    }\n\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n \
    \   assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpae9omigm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    for &i in arr {\n\
    \        product *= i;\n    }\n\n    let mut sum = 0;\n    for &i in arr {\n \
    \       sum += i * product;\n    }\n\n    Some(sum)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgvwfir4b.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgvwfir4b.rs:23:9\n   |\n23 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for x in arr {\n        if x < 0 {\n            sign *= -1;\n        }\n\
    \        product *= x;\n    }\n\n    Some(sign * product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpklian009.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = arr[0] as isize;\n    for i\
    \ in arr.iter().rev() {\n        product *= i as isize;\n    }\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpl4zpfr2d.rs:18:20\n\
    \   |\n18 |         product *= i as isize;\n   |                    -^^^^^^^^^\n\
    \   |                    |\n   |                    cannot cast `&isize` as `isize`\n\
    \   |                    help: dereference the expression: `*i`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = vec![0; arr.len()];\n    for i in\
    \ 0..arr.len() {\n        let mut sign = 1;\n        for j in 0..i {\n       \
    \     if arr[j] > 0 {\n                sign *= -1;\n            }\n        }\n\
    \        res[i] = sign * arr[i];\n    }\n    Some(\n        arr.iter()\n     \
    \       .map(|x| x * res[0])\n            .sum()\n            .unwrap(),\n   \
    \ )\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp2xt3nhrp.rs:29:14\n\
    \   |\n29 |             .sum()\n   |              ^^^ cannot infer type for type\
    \ parameter `S` declared on the associated function `sum`\n   |\n   = note: type\
    \ must be known at this point\nhelp: consider specifying the type argument in\
    \ the method call\n   |\n29 |             .sum::<S>()\n   |                 +++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0] as isize;\n    for\
    \ &i in arr.iter().skip(1) {\n        product *= i as isize;\n    }\n\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpd0b2l0r1.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for &i in arr {\n  \
    \      product *= i;\n    }\n    let mut sum = 0;\n    for &i in arr {\n     \
    \   sum += if i == -1 {\n            -1\n        } else if i == 1 {\n        \
    \    1\n        } else {\n            0\n        };\n    }\n    Some(product *\
    \ sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqkvoubio.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqkvoubio.rs:21:9\n   |\n21 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = arr[0];\n    for x in arr.iter().rev()\
    \ {\n        res *= x;\n        res += x;\n    }\n    Some(res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-25)`,\n right: `Some(-9)`', /tmp/tmp_dofeo6x.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for i in arr.iter() {\n        product *= sign;\n        sign *= i;\n  \
    \  }\n\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(8)`,\n right: `Some(-9)`', /tmp/tmp6zbdo33t.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = arr[0];\n    for i in 1..arr.len()\
    \ {\n        res *= if arr[i] >= 0 {\n            1\n        } else {\n      \
    \      -1\n        };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmprndnr77f.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for x in arr {\n   \
    \     product *= x;\n    }\n    let mut sum = 0;\n    for x in arr {\n       \
    \ sum += if x == -1 {\n            -1\n        } else if x == 1 {\n          \
    \  1\n        } else {\n            0\n        };\n    }\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpqmi0gakf.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for x in arr.iter().rev()\
    \ {\n        product *= x;\n    }\n\n    let mut sign = 1;\n    for x in arr.iter()\
    \ {\n        sign *= x;\n    }\n\n    Some(sign * product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmplwspigk0.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr.iter() {\n        if *i < 0 {\n            sign *= -1;\n   \
    \     }\n        product *= sign;\n    }\n    Some(product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpmco8m45e.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = isize::one();\n    for x in arr\
    \ {\n        res *= x;\n        if x < 0 {\n            res *= -1;\n        }\n\
    \    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpvvg8dvfh.rs:16:26\n   |\n16 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = vec![0];\n    for &x in arr {\n\
    \        if x < 0 {\n            res.push(-x);\n        } else {\n           \
    \ res.push(x);\n        }\n    }\n\n    let mut prod = 1;\n    for &x in res {\n\
    \        prod *= x;\n    }\n\n    Some(prod)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8vkjkaqo.rs:18:9\n   |\n\
    18 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8vkjkaqo.rs:27:9\n   |\n27 |     for &x in res {\n   |\
    \         ^^ expected integer, found reference\n   |\n   = note:   expected type\
    \ `{integer}`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        if x < 0 {\n            sign = -1;\n        }\n \
    \       product *= sign;\n        product *= x;\n    }\n    Some(product)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp041y5s53.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0] as isize;\n    for\
    \ x in arr.iter().skip(1) {\n        product *= x;\n    }\n\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpg2uja113.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut prod = 1;\n    let mut sign = 1;\n\n\
    \    for x in arr {\n        if x < 0 {\n            sign *= -1;\n        }\n\n\
    \        prod *= sign;\n    }\n\n    Some(prod)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmp9oeqgqv9.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0] as isize;\n    for\
    \ &x in arr.iter().skip(1) {\n        product *= x;\n    }\n\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp5eg444aj.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    for i in arr {\n      \
    \  if *i < *i {\n            prod *= -1;\n        } else {\n            prod *=\
    \ 1;\n        }\n    }\n    Some(prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp8eaiidf5.rs:18:12\n\
    \   |\n18 |         if *i < *i {\n   |            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp8eaiidf5.rs:18:17\n   |\n18 |        \
    \ if *i < *i {\n   |                 ^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for &i in arr\
    \ {\n        product *= i;\n    }\n\n    let mut magnitude = product;\n    for\
    \ i in arr.iter().rev() {\n        magnitude *= i;\n    }\n\n    Some(magnitude)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsrq3bos1.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = 0;\n    for\
    \ x in arr {\n        if x < 0 {\n            res -= x;\n        } else {\n  \
    \          res += x;\n        }\n    }\n    Some(res)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmpdiq47yoj.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for &i in arr {\n        product *= i;\n        sign *= if i < 0 {\n    \
    \        -1\n        } else {\n            1\n        };\n    }\n    Some(sign\
    \ * product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqrr0trdp.rs:19:9\n   |\n\
    19 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for &x in arr {\n      \
    \  if x < 0 {\n            res -= x;\n        } else {\n            res += x;\n\
    \        }\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspkwzi9u.rs:17:9\n   |\n\
    17 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for i in arr {\n       \
    \ res += if i < 0 {\n            1\n        } else {\n            -1\n       \
    \ };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmp_tprr715.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for x in arr.iter() {\n        product *= x;\n        sign *= match x {\n\
    \            1 => 1,\n            -1 => -1,\n            0 => 0,\n           \
    \ _ => panic!(\"Invalid input\"),\n        };\n    }\n\n    Some(product * sign)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid input'', /tmp/tmpvxo5cuac.rs:26:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr {\n        if *i < 0 {\n            sign *= -1;\n        }\n\
    \        product *= sign;\n    }\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpmb3xo9jn.rs:20:12\n\
    \   |\n20 |         if *i < 0 {\n   |            ^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    for x in arr {\n \
    \       product *= x;\n    }\n\n    let mut sum = 0;\n    for x in arr {\n   \
    \     sum += if x < 0 {\n            -1\n        } else {\n            1\n   \
    \     } * x;\n    }\n\n    Some(sum * product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmprpw6ts8k.rs:23:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n18  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n23  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for x in arr {\n   \
    \     if x < 0 {\n            product *= -1;\n        } else {\n            product\
    \ *= 1;\n        }\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmplq8x7oib.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr.iter().product();\n  \
    \  let mut sign = 1;\n    for x in arr.iter() {\n        product *= sign;\n  \
    \      sign *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-128)`,\n right: `Some(-9)`', /tmp/tmp5cx6sam7.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for x in arr {\n        product *= x;\n        sign *= match x {\n     \
    \       1 => 1,\n            -1 => -1,\n            0 => 0,\n            _ =>\
    \ panic!(\"Invalid input\"),\n        };\n    }\n\n    Some(product * sign)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid input'', /tmp/tmprhhgk3q1.rs:26:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        product *= x;\n        sign *= match x {\n      \
    \      1 => 1,\n            -1 => -1,\n            0 => 0,\n            _ => panic!(\"\
    Invalid input\"),\n        };\n    }\n    Some(sign * product)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid input'', /tmp/tmpozsbby5n.rs:25:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for &i in arr\
    \ {\n        product *= i;\n    }\n\n    let mut sum = 0;\n    for &i in arr {\n\
    \        sum += if i == -1 { -1 } else { 1 };\n    }\n\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvb1tifw1.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvb1tifw1.rs:23:9\n   |\n23 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    for x in arr {\n \
    \       product *= x;\n    }\n\n    let mut sum = 0;\n    for x in arr {\n   \
    \     sum += if x < 0 {\n            -1\n        } else {\n            1\n   \
    \     } * x;\n    }\n\n    Some(sum * product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmprpw6ts8k.rs:23:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n18  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n23  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        product *= x;\n        sign *= match x {\n      \
    \      1 => 1,\n            -1 => -1,\n            _ => 0,\n        };\n    }\n\
    \    Some(sign * product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `Some(-9)`', /tmp/tmp56nm3pn0.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for i in arr.iter().rev()\
    \ {\n        product *= i;\n    }\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpkumw7762.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = arr[0];\n\
    \    for x in arr.iter().rev() {\n        product *= x;\n    }\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpsogh4hux.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = arr[0];\n    for i in arr.iter().rev()\
    \ {\n        product *= i;\n    }\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp3zy5acxa.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr {\n        product *= sign;\n        sign *= i;\n    }\n   \
    \ Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(8)`,\n right: `Some(-9)`', /tmp/tmp3gz_uye_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sum = 0;\n\
    \n    for &x in arr {\n        if x < 0 {\n            product *= -1;\n      \
    \  }\n        sum += x;\n    }\n\n    Some(sum * product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwc0g88t3.rs:20:9\n   |\n\
    20 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        product *= x;\n        sign *= match x {\n      \
    \      1 => 1,\n            -1 => -1,\n            0 => 0,\n            _ => panic!(\"\
    Invalid input\"),\n        };\n    }\n    Some(sign * product)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid input'', /tmp/tmpozsbby5n.rs:25:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = 0;\n    let mut sign = 1;\n\n\
    \    for x in arr.iter() {\n        res += sign * x;\n        sign *= -1;\n  \
    \  }\n\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmp9yir70wu.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for x in arr {\n       \
    \ res += if x < 0 {\n            1\n        } else {\n            -1\n       \
    \ };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmp5fm38nn3.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    for &x in arr {\n\
    \        product *= x;\n    }\n\n    let mut sum = 0;\n    for &x in arr {\n \
    \       sum += x * product;\n    }\n\n    Some(sum)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo2t0lr57.rs:18:9\n   |\n\
    18 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo2t0lr57.rs:23:9\n   |\n23 |     for &x in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = 0;\n    for &i in arr {\n    \
    \    res += if i == -1 {\n            1\n        } else if i == 1 {\n        \
    \    -1\n        } else {\n            0\n        };\n    }\n    Some(res)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptafdbekc.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for x in arr {\n       \
    \ res += x * sign(x);\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmp3h66qxez.rs:18:20\n\
    \   |\n18 |         res += x * sign(x);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        if x < 0 {\n            product *= -1;\n        \
    \    sign *= -1;\n        } else {\n            product *= 1;\n        }\n   \
    \ }\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(-9)`', /tmp/tmpceoeoqd7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for i in arr.iter().rev()\
    \ {\n        product *= i;\n    }\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpkumw7762.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        product *= x;\n        sign *= if x < 0 { -1 } else\
    \ { 1 };\n    }\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpg_cff2wx.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = 0;\n    for\
    \ i in arr {\n        res += if i < 0 {\n            1\n        } else {\n   \
    \         -1\n        };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmp771xx_ql.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for x in arr.iter().rev()\
    \ {\n        product *= x;\n    }\n\n    let mut sum = 0;\n    for x in arr.iter()\
    \ {\n        sum += if x < 0 {\n            -1\n        } else {\n           \
    \ 1\n        };\n    }\n\n    Some(product * sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpatclaxi1.rs:24:23\n   |\n\
    24 |         sum += if x < 0 {\n   |                       ^\n   |           \
    \            |\n   |                       expected `&isize`, found integer\n\
    \   |                       help: consider borrowing here: `&0`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = isize::one();\n    for x in arr\
    \ {\n        res *= x;\n        if x < 0 {\n            res *= -1;\n        }\n\
    \    }\n\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n \
    \   assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp_zt1d6pv.rs:17:26\n   |\n17 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for i in arr.iter() {\n        product *= i;\n        sign *= if i < 0 {\
    \ -1 } else { 1 };\n    }\n\n    Some(sign * product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8g0p2p4q.rs:22:24\n   |\n\
    22 |         sign *= if i < 0 { -1 } else { 1 };\n   |                       \
    \ ^\n   |                        |\n   |                        expected `&isize`,\
    \ found integer\n   |                        help: consider borrowing here: `&0`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = arr.iter().product();\n\
    \    let mut sign = 1;\n    for x in arr.iter() {\n        product *= sign;\n\
    \        sign *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-128)`,\n right: `Some(-9)`', /tmp/tmpqq5_nm_e.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = isize::one();\n    for i in arr.iter()\
    \ {\n        res *= i as isize;\n        res *= if *i < 0 {\n            -1\n\
    \        } else {\n            1\n        };\n    }\n    Some(res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpva52fmzn.rs:16:26\n   |\n16 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmpva52fmzn.rs:18:16\n   |\n18 |         res *= i as\
    \ isize;\n   |                -^^^^^^^^^\n   |                |\n   |        \
    \        cannot cast `&isize` as `isize`\n   |                help: dereference\
    \ the expression: `*i`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0606.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = arr[0];\n    for &x in &arr {\n\
    \        res *= x;\n        res += if x < 0 { 1 } else { -1 };\n    }\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(13)`,\n right: `Some(-9)`', /tmp/tmp5j2l0e39.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for i in arr {\n       \
    \ res += if i < 0 {\n            1\n        } else {\n            -1\n       \
    \ };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmp_tprr715.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut prod = 1;\n    for &i in arr {\n   \
    \     prod *= i;\n    }\n\n    let mut sum = 0;\n    for i in arr {\n        sum\
    \ += if i == -1 {\n            -1\n        } else if i == 1 {\n            1\n\
    \        } else {\n            0\n        };\n    }\n\n    Some(prod * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwudnxghc.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for &i in arr {\n      \
    \  res += if i >= 0 {\n            1\n        } else {\n            -1\n     \
    \   };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsdenudow.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for i in arr {\n   \
    \     if *i < 0 {\n            product *= -1;\n        }\n        product *= i;\n\
    \    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpzgf1dt4u.rs:18:12\n\
    \   |\n18 |         if *i < 0 {\n   |            ^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr.iter() {\n        product *= sign;\n        sign *= i;\n   \
    \ }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n  \
    \  assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(8)`,\n right: `Some(-9)`', /tmp/tmpsaihofwa.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    let mut sign = 1;\n    for\
    \ x in arr {\n        res += sign * x;\n        sign = -sign;\n    }\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmpt01q7bgi.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = arr.iter().product();\n    let\
    \ mut sign = 1;\n    for x in arr.iter() {\n        product *= sign;\n       \
    \ sign *= x;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-128)`,\n right: `Some(-9)`', /tmp/tmp05u9_e_f.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for i in arr.iter().rev()\
    \ {\n        product *= i;\n    }\n\n    let mut sign = 1;\n    for i in arr.iter().rev()\
    \ {\n        sign *= i;\n    }\n\n    Some(product * sign)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmptuz1fq0k.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr.iter() {\n        product *= sign;\n        sign *= i;\n   \
    \ }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n  \
    \  assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(8)`,\n right: `Some(-9)`', /tmp/tmpsaihofwa.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        product *= x;\n        sign *= if x < 0 { -1 } else\
    \ { 1 };\n    }\n\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpozha5msq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0] as isize;\n    for\
    \ &x in arr.iter() {\n        product *= x;\n    }\n\n    let mut magnitude =\
    \ product;\n    for &x in arr.iter() {\n        if x < 0 {\n            magnitude\
    \ *= -1;\n        }\n    }\n\n    Some(magnitude)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp98h4xyah.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for x in arr {\n   \
    \     if x < 0 {\n            product *= -1;\n        }\n        product *= x;\n\
    \    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmplw8mg6mz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    for x in arr {\n      \
    \  prod *= x;\n    }\n    let mut sum = 0;\n    for x in arr {\n        sum +=\
    \ if x > 0 { 1 } else { -1 };\n    }\n    Some(prod * sum)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpf_ztprlo.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = vec![0];\n\
    \    for x in arr {\n        res.iter().for_each(|&x| {\n            if x == 0\
    \ {\n                *res += 1;\n            } else {\n                *res +=\
    \ -1;\n            }\n        });\n    }\n    if res.len() == 0 {\n        return\
    \ None;\n    }\n    Some(*res.iter().product())\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `[{integer}]`\n  --> /tmp/tmp3fwf70py.rs:17:17\n   |\n17 |                 *res\
    \ += 1;\n   |                 ----^^^^^\n   |                 |\n   |        \
    \         cannot use `+=` on type `[{integer}]`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `[{integer}]`\n  --> /tmp/tmp3fwf70py.rs:19:17\n\
    \   |\n19 |                 *res += -1;\n   |                 ----^^^^^^\n   |\
    \                 |\n   |                 cannot use `+=` on type `[{integer}]`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    for x in arr {\n      \
    \  if x < 0 {\n            prod *= -1;\n        }\n        prod *= x;\n    }\n\
    \    Some(prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp2vlvaw15.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        product *= x;\n        sign *= match x {\n      \
    \      1 => 1,\n            -1 => -1,\n            0 => 0,\n            _ => panic!(\"\
    Invalid input\"),\n        };\n    }\n    Some(sign * product)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid input'', /tmp/tmpvaartue4.rs:24:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for x in arr {\n   \
    \     product *= x;\n    }\n    let mut res = 0;\n    for x in arr {\n       \
    \ res += x * product;\n        product *= x;\n    }\n    Some(res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpf8g0mju1.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = arr.iter().product();\n\
    \    let mut sign = 1;\n    for x in arr.iter() {\n        product *= sign;\n\
    \        sign *= -1;\n    }\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpl6lahpx_.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr.iter().product();\n  \
    \  let mut sign = 1;\n\n    for x in arr {\n        product *= sign;\n       \
    \ sign *= x;\n    }\n\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-128)`,\n right: `Some(-9)`', /tmp/tmplp2ujyqx.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for &i in arr {\n  \
    \      product *= i;\n    }\n    let mut sum = 0;\n    for &i in arr {\n     \
    \   sum += if i == -1 {\n            -1\n        } else if i == 1 {\n        \
    \    1\n        } else {\n            0\n        };\n    }\n    Some(product *\
    \ sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqkvoubio.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqkvoubio.rs:21:9\n   |\n21 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = arr[0];\n\
    \    for &x in arr.iter() {\n        product *= x;\n    }\n    if product == 0\
    \ {\n        return None;\n    }\n    let mut sum = 0;\n    for &x in arr.iter()\
    \ {\n        sum += if x < 0 {\n            -1\n        } else {\n           \
    \ 1\n        };\n    }\n    Some(sum * product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-32)`,\n right: `Some(-9)`', /tmp/tmpl6gm9xbh.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for x in arr {\n       \
    \ res += if x > 0 { 1 } else { -1 };\n    }\n    Some(res)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmphouvhsfr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = 0;\n    let mut sign = 1;\n  \
    \  for x in arr {\n        res += sign * x;\n        sign = -sign;\n    }\n  \
    \  Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(5)`,\n right: `Some(-9)`', /tmp/tmpi83yd32g.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0] as isize;\n    for\
    \ x in arr.iter().skip(1) {\n        product *= x;\n    }\n\n    let mut sum =\
    \ 0;\n    for x in arr.iter() {\n        sum += if x < 0 { -1 } else { 1 } * x;\n\
    \    }\n\n    Some(product * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi3r5l4vt.rs:24:23\n   |\n\
    24 |         sum += if x < 0 { -1 } else { 1 } * x;\n   |                    \
    \   ^\n   |                       |\n   |                       expected `&isize`,\
    \ found integer\n   |                       help: consider borrowing here: `&0`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = isize::one();\n    for i in arr.iter()\
    \ {\n        res *= i as isize;\n        res *= (i as isize).signum();\n    }\n\
    \    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpy_k5eih9.rs:17:26\n   |\n17 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmpy_k5eih9.rs:19:16\n   |\n19 |         res *= i as\
    \ isize;\n   |                -^^^^^^^^^\n   |                |\n   |        \
    \        cannot cast `&isize` as `isize`\n   |                help: dereference\
    \ the expression: `*i`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n\
    \  --> /tmp/tmpy_k5eih9.rs:20:16\n   |\n20 |         res *= (i as isize).signum();\n\
    \   |                ^-^^^^^^^^^^\n   |                ||\n   |              \
    \  |help: dereference the expression: `*i`\n   |                cannot cast `&isize`\
    \ as `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0606.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr.iter().product();\n  \
    \  let mut sign = 1;\n\n    for x in arr {\n        if x < 0 {\n            product\
    \ *= sign;\n            sign *= -1;\n        } else {\n            product *=\
    \ sign;\n        }\n    }\n\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpiopof74c.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr.iter().product();\n  \
    \  let mut sign = 1;\n\n    for &i in arr {\n        if *i < 0 {\n           \
    \ sign = -sign;\n        }\n        product *= sign;\n    }\n\n    Some(product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0b3j7hay.rs:20:9\n   |\n\
    20 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for &i in arr {\n  \
    \      product *= i;\n    }\n    let mut sum = 0;\n    for &i in arr {\n     \
    \   sum += i * product;\n    }\n    Some(sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph66_s766.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph66_s766.rs:21:9\n   |\n21 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for x in arr {\n        if x < 0 {\n            sign *= -1;\n        }\n\
    \n        product *= x;\n    }\n\n    Some(sign * product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpxoe0kzci.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for x in arr {\n        if x < 0 {\n            sign *= -1;\n        }\n\
    \        product *= x;\n    }\n\n    Some(sign * product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpklian009.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr {\n        if i < 0 {\n            sign *= -1;\n        }\n\
    \        product *= sign;\n    }\n\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmp_3z2ejw7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        if x < 0 {\n            product *= -1;\n        \
    \    sign *= -1;\n        } else {\n            product *= 1;\n        }\n   \
    \ }\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(-9)`', /tmp/tmpceoeoqd7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sign = 1;\n   \
    \ for x in arr {\n        if x < 0 {\n            sign *= -1;\n        }\n   \
    \     prod *= x;\n    }\n    Some(sign * prod)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpnbhsskx4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for x in arr {\n        if x < 0 {\n            sign *= -1;\n        }\n\
    \n        product *= x;\n    }\n\n    Some(sign * product)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpxoe0kzci.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = 0;\n    for\
    \ x in arr {\n        res += if x < 0 {\n            -1\n        } else {\n  \
    \          1\n        };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmp4wze8gbo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr.iter().product();\n  \
    \  let mut sign = 1;\n    for x in arr.iter() {\n        product *= sign;\n  \
    \      sign *= x;\n    }\n\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-128)`,\n right: `Some(-9)`', /tmp/tmpz3srg8l9.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr.iter().product();\n  \
    \  let mut sign = 1;\n\n    for x in arr.iter() {\n        if x < 0 {\n      \
    \      product *= -1;\n            sign *= -1;\n        }\n    }\n\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgdt9s6ig.rs:21:16\n   |\n\
    21 |         if x < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n    for\
    \ x in arr {\n        if x < 0 {\n            prod *= -1;\n        } else {\n\
    \            prod *= 1;\n        }\n    }\n    Some(prod)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpsgrm8uwf.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for i in arr {\n       \
    \ res += if i >= 0 {\n            1\n        } else {\n            -1\n      \
    \  };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmpcywsgs7h.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for &i in arr.iter().rev()\
    \ {\n        product *= i;\n    }\n\n    let mut sum = 0;\n    for i in arr.iter()\
    \ {\n        sum += if i == -1 {\n            -1\n        } else if i == 1 {\n\
    \            1\n        } else {\n            0\n        };\n    }\n\n    Some(product\
    \ * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp9zsykeh3.rs:24:21\n\
    \   |\n24 |         sum += if i == -1 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmp9zsykeh3.rs:26:21\n   |\n26 |         } else if i\
    \ == 1 {\n   |                     ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = isize::one();\n    for i in arr.iter()\
    \ {\n        res *= i;\n        if *i < *i {\n            res *= -1;\n       \
    \ }\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp6_14jzgy.rs:16:26\n   |\n16 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr.iter().product();\n  \
    \  let mut signs = vec![];\n    for x in arr.iter() {\n        signs.push(match\
    \ x {\n            1 => 1,\n            -1 => -1,\n            _ => 0,\n     \
    \   });\n    }\n\n    Some(product * signs.iter().sum())\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpvasnsphl.rs:17:9\n\
    \   |\n17 |     let mut product = arr.iter().product();\n   |         ^^^^^^^^^^^\
    \ consider giving `product` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for &x in arr {\n      \
    \  if x == 0 {\n            continue;\n        }\n        res += x;\n    }\n \
    \   Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkcvkp40p.rs:17:9\n   |\n\
    17 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for &i in arr {\n        if i == 0 {\n            sign *= -1;\n        }\
    \ else {\n            product *= sign;\n            sign *= -1;\n        }\n \
    \   }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkcnc4wd.rs:19:9\n   |\n\
    19 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = vec![0; arr.len()];\n\
    \    for i in 0..arr.len() {\n        let mut sign = 1;\n        for j in 0..i\
    \ {\n            if arr[j] < 0 {\n                sign *= -1;\n            }\n\
    \        }\n        res[i] = sign * arr[i];\n    }\n    if res.iter().all(|&x|\
    \ x == 0) {\n        return None;\n    }\n    Some(res.iter().product().unwrap())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpbzguw_x4.rs:26:21\n\
    \   |\n26 |     Some(res.iter().product().unwrap())\n   |                    \
    \ ^^^^^^^ cannot infer type for type parameter `P` declared on the associated\
    \ function `product`\n   |\n   = note: type must be known at this point\nhelp:\
    \ consider specifying the type argument in the method call\n   |\n26 |     Some(res.iter().product::<P>().unwrap())\n\
    \   |                            +++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0] as isize;\n    for\
    \ &x in arr.iter().skip(1) {\n        product *= x;\n    }\n\n    let mut magnitude\
    \ = product;\n    for &x in arr.iter().rev() {\n        if *x != 0 {\n       \
    \     magnitude *= *x;\n        }\n    }\n\n    Some(magnitude)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpm5lqk0m3.rs:24:12\n\
    \   |\n24 |         if *x != 0 {\n   |            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpm5lqk0m3.rs:25:26\n   |\n25 |        \
    \     magnitude *= *x;\n   |                          ^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for i in arr.iter().rev()\
    \ {\n        product *= i;\n    }\n\n    let mut magnitude = product;\n    for\
    \ i in arr.iter().rev() {\n        magnitude *= i;\n    }\n\n    Some(magnitude)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(256)`,\n right: `Some(-9)`', /tmp/tmpdj11q718.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for x in arr {\n       \
    \ res += if x < 0 {\n            -1\n        } else {\n            1\n       \
    \ };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmpy6vxw_h_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sign = 1;\n   \
    \ for x in arr {\n        if x < 0 {\n            sign *= -1;\n        }\n   \
    \     prod *= sign;\n    }\n    Some(prod)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpwip3icst.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for x in arr {\n       \
    \ res += if x < 0 {\n            -1\n        } else {\n            1\n       \
    \ };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmpy6vxw_h_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr.iter().product();\n  \
    \  let mut sign = 1;\n\n    for &i in arr {\n        product *= sign;\n      \
    \  sign *= i;\n    }\n\n    Some(product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpimm2nz6_.rs:20:9\n   |\n\
    20 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = isize::one();\n\
    \    for x in arr {\n        if x < 0 {\n            res *= -1;\n        }\n \
    \       res *= x;\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp_kyf_nf0.rs:13:26\n   |\n13 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = isize::one();\n\
    \    for &i in arr {\n        if *i > 0\n            || (*i == 0 && *i != isize::one())\n\
    \            || (*i < 0 && *i != -isize::one())\n        {\n            res =\
    \ res.checked_mul(*i).unwrap();\n        }\n    }\n    Some(res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpwml8o6ye.rs:13:26\n   |\n13 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwml8o6ye.rs:14:9\n   |\n14 |     for &i in arr {\n   |         ^^  \
    \  --- this expression has type `isize`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0599]: no function or associated item named\
    \ `one` found for type `isize` in the current scope\n  --> /tmp/tmpwml8o6ye.rs:16:41\n\
    \   |\n16 |             || (*i == 0 && *i != isize::one())\n   |             \
    \                            ^^^ function or associated item not found in `isize`\n\
    \nerror[E0599]: no function or associated item named `one` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpwml8o6ye.rs:17:41\n   |\n17 |          \
    \   || (*i < 0 && *i != -isize::one())\n   |                                 \
    \        ^^^ function or associated item not found in `isize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for &i in arr {\n  \
    \      if *i < 0 {\n            product *= -1;\n        } else {\n           \
    \ product *= 1;\n        }\n    }\n    Some(product)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqv4v2ujx.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr.iter() {\n        product *= sign;\n        sign *= i;\n   \
    \ }\n\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(8)`,\n right: `Some(-9)`', /tmp/tmp7rp98ro5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for x in arr {\n        if x < 0 {\n            sign *= -1;\n        }\n\
    \n        product *= sign;\n    }\n\n    Some(product)\n}\n\nfn main() {\n   \
    \ let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmp6vgf55e8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = arr[0];\n    for i in 1..arr.len()\
    \ {\n        res *= if arr[i] > 0 { 1 } else { -1 };\n        res += arr[i];\n\
    \    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpmxnsrkp1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = isize::one();\n\
    \    for x in arr {\n        res *= if x < 0 { -1 } else { 1 };\n        res +=\
    \ x;\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp01kf630x.rs:13:26\n   |\n13 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for i in arr {\n       \
    \ if *i < 0 {\n            *i = -(*i);\n        }\n        res += *i;\n    }\n\
    \    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp55p4cto2.rs:18:12\n\
    \   |\n18 |         if *i < 0 {\n   |            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp55p4cto2.rs:19:13\n   |\n19 |        \
    \     *i = -(*i);\n   |             ^^\n\nerror[E0614]: type `isize` cannot be\
    \ dereferenced\n  --> /tmp/tmp55p4cto2.rs:19:19\n   |\n19 |             *i = -(*i);\n\
    \   |                   ^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmp55p4cto2.rs:21:16\n   |\n21 |         res += *i;\n   |        \
    \        ^^\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for x in arr {\n   \
    \     product *= x;\n    }\n    let mut sum = 0;\n    for x in arr {\n       \
    \ sum += if x < 0 {\n            -1\n        } else {\n            1\n       \
    \ } * x;\n    }\n    Some(sum * product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpsgznaa7f.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sign = 1;\n   \
    \ for i in arr.iter() {\n        prod *= sign;\n        sign *= i;\n    }\n  \
    \  Some(prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(8)`,\n right: `Some(-9)`', /tmp/tmpxca80qzr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for x in arr {\n   \
    \     product *= x;\n    }\n    let mut sum = 0;\n    for x in arr {\n       \
    \ sum += if x < 0 { -1 } else { 1 } * x;\n    }\n    Some(sum * product)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpci5984hk.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = arr.iter().product();\n    let\
    \ mut sign = 1;\n    for x in arr {\n        sign *= x;\n        product *= sign;\n\
    \    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2048)`,\n right: `Some(-9)`', /tmp/tmpi239pef3.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        if x < 0 {\n            product *= -1;\n        \
    \    sign *= -1;\n        } else {\n            product *= 1;\n        }\n   \
    \ }\n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(-9)`', /tmp/tmpceoeoqd7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \n    for x in arr.iter() {\n        if x < 0 {\n            product *= -1;\n\
    \            sign *= -1;\n        } else {\n            product *= 1;\n      \
    \      sign *= 1;\n        }\n    }\n\n    Some(product * sign)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6rk8gty.rs:21:16\n   |\n\
    21 |         if x < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for x in arr {\n   \
    \     product *= x;\n    }\n    let mut sum = 0;\n    for x in arr {\n       \
    \ sum += if x == -1 {\n            -1\n        } else if x == 1 {\n          \
    \  1\n        } else {\n            0\n        };\n    }\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpqmi0gakf.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for &i in arr {\n  \
    \      product *= i;\n    }\n    let mut sum = 0;\n    for &i in arr {\n     \
    \   sum += i * product;\n    }\n    Some(sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph66_s766.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph66_s766.rs:21:9\n   |\n21 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        product *= x;\n        if x < 0 {\n            sign\
    \ *= -1;\n        }\n    }\n    Some(product * sign)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmpbg6nzkcl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = 0;\n    for\
    \ x in arr {\n        res += if x < 0 {\n            -1\n        } else {\n  \
    \          1\n        };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmp4wze8gbo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        if x < 0 {\n            product *= -1;\n        \
    \    sign *= -1;\n        } else {\n            product *= 1;\n            sign\
    \ *= 1;\n        }\n    }\n    Some(product * sign)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(-9)`', /tmp/tmp123ywcoy.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for &x in arr {\n  \
    \      if x < 0 {\n            product *= -1;\n        }\n        product *= x;\n\
    \    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdx0ue3xj.rs:17:9\n   |\n\
    17 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = 0;\n    for x in arr {\n     \
    \   res += if x < 0 {\n            1\n        } else {\n            -1\n     \
    \   };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmp3r1od0dm.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = arr[0] as isize;\n    for x\
    \ in arr.iter().rev() {\n        product *= x;\n    }\n    Some(product)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpn9wzu_se.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for &i in arr {\n        product *= i;\n        sign *= match i {\n     \
    \       1 => 1,\n            -1 => -1,\n            0 => 0,\n            _ =>\
    \ panic!(\"Invalid input\"),\n        };\n    }\n    Some(sign * product)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvgvchvlw.rs:19:9\n   |\n\
    19 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for &i in arr {\n        if i == 0 {\n            sign = 1;\n        } else\
    \ {\n            product *= sign;\n            sign *= i;\n        }\n    }\n\
    \    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwmq4m3bi.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr[0];\n    for &x in arr.iter().rev()\
    \ {\n        product *= x;\n    }\n\n    let mut sum = 0;\n    for &x in arr.iter()\
    \ {\n        sum += if x < 0 {\n            -1\n        } else {\n           \
    \ 1\n        };\n    }\n\n    Some(product * sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-32)`,\n right: `Some(-9)`', /tmp/tmpx72b050g.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = isize::one();\n    for i in arr.iter()\
    \ {\n        res *= if *i < 0 { -1 } else { 1 };\n        res += *i;\n    }\n\
    \    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `one` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpwynuf4a_.rs:16:26\n   |\n16 |  \
    \   let mut res = isize::one();\n   |                          ^^^ function or\
    \ associated item not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for i in arr {\n   \
    \     product *= i;\n    }\n    let mut sum = 0;\n    for i in arr {\n       \
    \ sum += i * product;\n    }\n    Some(sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmp8ies3zl0.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for i in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for i in arr {\n   \
    \     if *i < 0 {\n            product *= -1;\n        }\n        product *= *i;\n\
    \    }\n    Some(product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpw6wa2r1b.rs:18:12\n\
    \   |\n18 |         if *i < 0 {\n   |            ^^\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpw6wa2r1b.rs:21:20\n   |\n21 |        \
    \ product *= *i;\n   |                    ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = 0;\n    for i in arr {\n     \
    \   res += if i < 0 { -1 } else { 1 };\n    }\n    Some(res)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmpdcsvc9_u.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for &i in arr {\n  \
    \      product *= i;\n    }\n    let mut magnitude = 0;\n    for &i in arr {\n\
    \        magnitude += i * (product as isize);\n    }\n    Some(magnitude)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjoi5joz4.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjoi5joz4.rs:21:9\n   |\n21 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for x in arr {\n        product *= x;\n        sign *= match x {\n      \
    \      1 => 1,\n            -1 => -1,\n            _ => 0,\n        };\n    }\n\
    \n    Some(product * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `Some(-9)`', /tmp/tmpvpcpwp8m.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for x in arr {\n       \
    \ res += if x < 0 {\n            1\n        } else {\n            -1\n       \
    \ };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-2)`,\n right: `Some(-9)`', /tmp/tmp5fm38nn3.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747899
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr {\n        product *= i;\n        sign *= if i < 0 {\n     \
    \       -1\n        } else {\n            1\n        };\n    }\n    Some(product\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(16)`,\n right: `Some(-9)`', /tmp/tmp0dn124hd.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = 1;\n    let mut sign = 1;\n\
    \    for i in arr.iter() {\n        product *= i;\n        sign *= match i {\n\
    \            1 => 1,\n            -1 => -1,\n            0 => 0,\n           \
    \ _ => panic!(\"Invalid input\"),\n        };\n    }\n    Some(sign * product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid input'', /tmp/tmp83iyw1jv.rs:25:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut product = arr.iter().product();\n  \
    \  let mut signs = arr.iter().map(|x| if x < 0 { -1 } else { 1 }).collect::<Vec<_>>();\n\
    \n    signs.iter_mut().for_each(|x| {\n        if *x == -1 {\n            *x =\
    \ -1;\n            product *= -1;\n        } else {\n            *x = 1;\n   \
    \         product *= 1;\n        }\n    });\n\n    Some(product * signs.iter().sum())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9dziqdzh.rs:18:47\n   |\n\
    18 |     let mut signs = arr.iter().map(|x| if x < 0 { -1 } else { 1 }).collect::<Vec<_>>();\n\
    \   |                                               ^\n   |                  \
    \                             |\n   |                                        \
    \       expected `&isize`, found integer\n   |                               \
    \                help: consider borrowing here: `&0`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    for x in arr {\n   \
    \     product *= x;\n    }\n    let mut sum = 0;\n    for x in arr {\n       \
    \ sum += if x < 0 {\n            -1\n        } else {\n            1\n       \
    \ } * x;\n    }\n    Some(sum * product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpsgznaa7f.rs:21:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for x in arr {\n    |              ---\n  \
    \  |              |\n    |              `arr` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&arr`\n...\n21  |     for x in arr {\n    |            \
    \  ^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `arr`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n\n    let mut res = 0;\n    for &i in arr {\n    \
    \    res += if i == 0 {\n            1\n        } else if i == -1 {\n        \
    \    -1\n        } else {\n            0\n        };\n    }\n\n    Some(res)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3abvi8gu.rs:18:9\n   |\n\
    18 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    for i in arr {\n       \
    \ res += if i >= 0 {\n            1\n        } else {\n            -1\n      \
    \  };\n    }\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(2)`,\n right: `Some(-9)`', /tmp/tmpcywsgs7h.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747898
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = arr[0];\n\
    \    for &i in arr.iter().rev() {\n        product *= i;\n    }\n    if product\
    \ == 0 {\n        None\n    } else {\n        Some(product)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmp4plhkzvk.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    for x in arr {\n      \
    \  if x != 0 {\n            prod *= x;\n        }\n    }\n    Some(prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpbc7whma6.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747900
