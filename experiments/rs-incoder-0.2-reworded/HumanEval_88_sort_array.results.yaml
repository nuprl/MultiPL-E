name: HumanEval_88_sort_array
language: rs
results:
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut n = array.len();\n    while i < n {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap().reverse());\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpbnrvmc0j.rs:18:9\n\
    \   |\n18 |     let mut j = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpbnrvmc0j.rs:19:9\n\
    \   |\n19 |     let mut n = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpbnrvmc0j.rs:25:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n25 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror[E0502]: cannot borrow `array` as immutable because it is\
    \ also borrowed as mutable\n  --> /tmp/tmpbnrvmc0j.rs:25:27\n   |\n25 |      \
    \   array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |         ------------------^^^^-----------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpbnrvmc0j.rs:27:9\n   |\n15 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |               ----- help: consider changing this to be mutable:\
    \ `mut array`\n...\n27 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpbnrvmc0j.rs:27:27\n  \
    \ |\n27 |         array.sort_by_key(|&x| x.partial_cmp(&arra"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpp4dld72x.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut len = array.len();\n    while i < len {\n        sum += array[i];\n\
    \        i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap().reverse());\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpjut0spvq.rs:18:9\n\
    \   |\n18 |     let mut j = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpjut0spvq.rs:19:9\n\
    \   |\n19 |     let mut len = array.len();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpjut0spvq.rs:25:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n25 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror[E0502]: cannot borrow `array` as immutable because it is\
    \ also borrowed as mutable\n  --> /tmp/tmpjut0spvq.rs:25:27\n   |\n25 |      \
    \   array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |         ------------------^^^^-----------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpjut0spvq.rs:27:9\n   |\n15 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |               ----- help: consider changing this to be mutable:\
    \ `mut array`\n...\n27 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpjut0spvq.rs:27:27\n  \
    \ |\n27 |         array.sort_by_key(|&x| x.partial_cmp(&"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    if sum % 2 == 1 {\n        array.swap(0, array.len() -\
    \ 1);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpynpzwb8a.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpynpzwb8a.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpynpzwb8a.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpynpzwb8a.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpynpzwb8a.rs:27:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for value in array {\n    |     \
    \             ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n27  |     let mut array = array.clone();\n    |                     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n19\
    \  |     for value in &array {\n    |                  +\n\nerror[E0502]: cannot\
    \ borrow `array` as immutable because it is also borrowed as mutable\n  --> /tmp/tmpynpzwb8a.rs:30:23\n\
    \   |\n30 |         array.swap(0, array.len() - 1);\n   |         --------------^^^^^^^^^^^-----\n\
    \   |         |     |       |\n   |         |     |       immutable borrow occurs\
    \ here\n   |         |     mutable borr"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmp6wdla35z.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmp6wdla35z.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmp6wdla35z.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmp6wdla35z.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0596]: cannot borrow `array` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmp6wdla35z.rs:27:5\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n27 |     array.sort_unstable();\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of\
    \ moved value: `array`\n   --> /tmp/tmp6wdla35z.rs:27:5\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |\
    \     for value in array {\n    |                  ----- `array` moved due to\
    \ this implicit call to `.into_iter()`\n...\n27  |     array.sort_unstable();\n\
    \    |     ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `array`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |     for value in &array {\n    |         \
    \         +\n\ner"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in &array {\n        sum += value;\n        if sum % 2 == 0 {\n      \
    \      min_value = value;\n        } else {\n            max_value = value;\n\
    \        }\n    }\n    array.sort();\n    array[0] = min_value;\n    array[array.len()\
    \ - 1] = max_value;\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps8_x8cl2.rs:23:25\n   |\n\
    18 |     let mut min_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n23 |             min_value = value;\n   | \
    \                        ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |             min_value = *value;\n   | \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps8_x8cl2.rs:25:25\n\
    \   |\n19 |     let mut max_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n25 |             max_value = value;\n   | \
    \                        ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |             max_value = *value;\n   | \
    \                        +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpi4wyaq3p.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpi4wyaq3p.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpi4wyaq3p.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpi4wyaq3p.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0596]: cannot borrow `array` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmpi4wyaq3p.rs:27:5\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n27 |     array.sort_unstable();\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of\
    \ moved value: `array`\n   --> /tmp/tmpi4wyaq3p.rs:27:5\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |\
    \     for value in array {\n    |                  ----- `array` moved due to\
    \ this implicit call to `.into_iter()`\n...\n27  |     array.sort_unstable();\n\
    \    |     ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `array`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |     for value in &array {\n    |         \
    \         +\n\ner"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        let sum = value + max_value;\n        if sum > max_sum {\n   \
    \         max_sum = sum;\n            max_pos = value;\n        }\n    }\n   \
    \ let mut min_pos = min_pos - min_value;\n    let mut max_pos = max_pos - max_value;\n\
    \    let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        let sum = value + max_value;\n        if sum > max_sum {\n   \
    \         max_sum = sum;\n            max_pos = value;\n        }\n    }\n   \
    \ let mut min_pos = min_pos - min_value;\n    let mut max_pos = max_pos - max_value;\n\
    \    let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        let sum = value + max_value;\n        if sum > max_sum {\n   \
    \         max_sum = sum;\n            max_pos = value;\n        }\n    }\n   \
    \ let mut min_pos = min_pos - min_value;\n    let mut max_pos = max_pos - max_value;\n\
    \    let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        let sum = value + max_value;\n        if sum > max_sum {\n   \
    \         max_sum = sum;\n            max_pos = value;\n        }\n    }\n   \
    \ let mut min_pos = min_pos - min_value;\n    let mut max_pos = max_pos - max_value;\n\
    \    let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpsmqflo52.rs:112:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n95  |    \
    \ for value in array {\n    |                        - this delimiter might not\
    \ be properly closed...\n...\n101 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n112 | }\n    |   ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsmqflo52.rs:15:37\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                       ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    if min_pos == max_pos {\n\
    \        return array;\n    }\n    if min_pos == max_pos {\n        return vec![min_value];\n\
    \    }\n    if min_pos > max_pos {\n        let mut min_pos = 0;\n        let\
    \ mut max_pos = 0;\n        let mut min_pos = 0;\n        let mut max_pos = 0;\n\
    \        let mut min_pos = 0;\n        let mut max_pos = 0;\n        for value\
    \ in array {\n            if value < min_value {\n                min_pos = value;\n\
    \                min_value = value;\n            }\n            if value > max_value\
    \ {\n                max_pos = value;\n                max_value = value;\n  \
    \          }\n        }\n        if min_pos == max_pos {\n            return vec![min_value];\n\
    \        }\n        if min_pos == max_pos {\n            return vec![max_value];\n\
    \        }\n        if min_pos > max_pos {\n            let mut min_pos = 0;\n\
    \            let mut max_pos = 0;\n            let mut min_pos = 0;\n        \
    \    let mut max_pos = 0;\n            let mut min_pos = 0;\n            let mut\
    \ max_pos = 0;\n            for value in array {\n                if value < min_value\
    \ {\n                    min_pos = value;\n                    min_value = value;\n\
    \                }\n                if value > max_value {\n                 \
    \   max_pos = value;\n                    max_value = value;\n               \
    \ }\n            }\n            if min_pos == max_pos {\n                return\
    \ vec![min_value];\n            }\n            if min_pos == max_pos {\n     \
    \           return vec![max_value];\n            }\n            if min_pos > max_pos\
    \ {\n                let mut min_pos = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpb0jp6evw.rs:125:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n65  |    \
    \ if min_pos > max_pos {\n    |                          - unclosed delimiter\n\
    ...\n88  |         if min_pos > max_pos {\n    |                             \
    \ - unclosed delimiter\n...\n111 |             if min_pos > max_pos {\n    | \
    \                                 - this delimiter might not be properly closed...\n\
    ...\n114 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n125 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpb0jp6evw.rs:88:30\n\
    \    |\n88  |           if min_pos > max_pos {\n    |  ______________________________^\n\
    89  | |             let mut min_pos = 0;\n90  | |             let mut max_pos\
    \ = 0;\n91  | |             let mut min_pos = 0;\n...   |\n124 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n125 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpgy3zrsq2.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < k {\n        sum += array[j];\n        j\
    \ += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n \
    \   } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpw1899q_g.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpw1899q_g.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| -x);\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpw1899q_g.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    array.sort_by_key(|&x|\
    \ x.clone());\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpwypsa045.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    array.sort();\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp3mjzqhv7.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp4erjr6c7.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by(|a, b| b.cmp(a));\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp4erjr6c7.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by(|a, b| a.cmp(b));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    array.sort();\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpo_6pm82d.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_val = array[0];\n   \
    \ let mut max_val = array[0];\n    for val in array {\n        sum += val;\n \
    \       if sum % 2 == 1 {\n            min_val = val;\n        } else {\n    \
    \        max_val = val;\n        }\n    }\n    let mut min_idx = array.iter().min_by_key(|&x|\
    \ x).unwrap();\n    let mut max_idx = array.iter().max_by_key(|&x| x).unwrap();\n\
    \    let mut res = vec![];\n    while min_idx < max_idx {\n        res.push(min_idx);\n\
    \        min_idx += 1;\n    }\n    while min_idx < max_idx {\n        res.push(max_idx);\n\
    \        max_idx -= 1;\n    }\n    res.sort();\n    res\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmpzlwtp3a5.rs:32:9\n   |\n32 |         min_idx += 1;\n\
    \   |         -------^^^^^\n   |         |\n   |         cannot use `+=` on type\
    \ `&isize`\n   |\nhelp: `+=` can be used on `isize`, you can dereference `min_idx`\n\
    \   |\n32 |         *min_idx += 1;\n   |         +\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpzlwtp3a5.rs:36:9\n\
    \   |\n36 |         max_idx -= 1;\n   |         -------^^^^^\n   |         |\n\
    \   |         cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can be used on\
    \ `isize`, you can dereference `max_idx`\n   |\n36 |         *max_idx -= 1;\n\
    \   |         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzlwtp3a5.rs:39:5\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n...\n39 |     res\n   |     ^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n\
    \    } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpecuqo56w.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| -x);\n   |  \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmpecuqo56w.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| -x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpecuqo56w.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0596.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.cmp(&x[array.len()\
    \ - 1]));\n    } else {\n        array.sort_by_key(|&x| x.cmp(&x[array.len() -\
    \ 1]).reverse());\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpu3b2dz_a.rs:21:39\n\
    \   |\n21 |         array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]));\n   |\
    \                                       ^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `isize`\n  --> /tmp/tmpu3b2dz_a.rs:23:39\n   |\n\
    23 |         array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]).reverse());\n \
    \  |                                       ^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n\
    \    let mut temp = 0;\n    let mut flag = false;\n    while i < array.len() {\n\
    \        if flag {\n            flag = false;\n            i += 1;\n         \
    \   continue;\n        }\n        if sum % 2 == 0 {\n            flag = true;\n\
    \            i += 1;\n            continue;\n        }\n        if sum % 2 ==\
    \ 1 {\n            flag = true;\n            j += 1;\n            continue;\n\
    \        }\n        if array[i] > array[j] {\n            temp = array[i];\n \
    \           array[i] = array[j];\n            array[j] = temp;\n            i\
    \ += 1;\n            j += 1;\n        } else {\n            temp = array[i];\n\
    \            array[i] = array[j];\n            array[j] = temp;\n            i\
    \ += 1;\n            j += 1;\n        }\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `k`\n  --> /tmp/tmps2vj67kx.rs:22:13\n   |\n\
    22 |     let mut k = 0;\n   |             ^ help: if this is intentional, prefix\
    \ it with an underscore: `_k`\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n\nwarning: value assigned to `temp` is never read\n  --> /tmp/tmps2vj67kx.rs:23:13\n\
    \   |\n23 |     let mut temp = 0;\n   |             ^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmps2vj67kx.rs:22:9\n   |\n\
    22 |     let mut k = 0;\n   |         ----^\n   |         |\n   |         help:\
    \ remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\n\
    error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmps2vj67kx.rs:25:15\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n16  |     let mut sum = 0;\n17  |     for value\
    \ in array {\n    |                  ----- `array` moved due to this implicit\
    \ call to `.into_iter()`\n...\n25  |     while i < array.len() {\n    |      \
    \         ^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `array`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n17  |     for value in &array {\n    |                  +\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmps2vj67kx.rs:43:13\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n43 |             array[i] = array[j];\n   |     \
    \        ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmps2vj67kx.rs:44:13\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be m"
  exit_code: 1
  status: SyntaxError
