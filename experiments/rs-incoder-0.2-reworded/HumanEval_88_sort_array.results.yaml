language: rs
name: HumanEval_88_sort_array
results:
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut n = array.len();\n    while i < n {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap().reverse());\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpbnrvmc0j.rs:18:9\n\
    \   |\n18 |     let mut j = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpbnrvmc0j.rs:19:9\n\
    \   |\n19 |     let mut n = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpbnrvmc0j.rs:25:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n25 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror[E0502]: cannot borrow `array` as immutable because it is\
    \ also borrowed as mutable\n  --> /tmp/tmpbnrvmc0j.rs:25:27\n   |\n25 |      \
    \   array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |         ------------------^^^^-----------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpbnrvmc0j.rs:27:9\n   |\n15 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |               ----- help: consider changing this to be mutable:\
    \ `mut array`\n...\n27 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpbnrvmc0j.rs:27:27\n  \
    \ |\n27 |         array.sort_by_key(|&x| x.partial_cmp(&arra"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpp4dld72x.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut len = array.len();\n    while i < len {\n        sum += array[i];\n\
    \        i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap().reverse());\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpjut0spvq.rs:18:9\n\
    \   |\n18 |     let mut j = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpjut0spvq.rs:19:9\n\
    \   |\n19 |     let mut len = array.len();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpjut0spvq.rs:25:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n25 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror[E0502]: cannot borrow `array` as immutable because it is\
    \ also borrowed as mutable\n  --> /tmp/tmpjut0spvq.rs:25:27\n   |\n25 |      \
    \   array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |         ------------------^^^^-----------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpjut0spvq.rs:27:9\n   |\n15 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |               ----- help: consider changing this to be mutable:\
    \ `mut array`\n...\n27 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpjut0spvq.rs:27:27\n  \
    \ |\n27 |         array.sort_by_key(|&x| x.partial_cmp(&"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    if sum % 2 == 1 {\n        array.swap(0, array.len() -\
    \ 1);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpynpzwb8a.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpynpzwb8a.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpynpzwb8a.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpynpzwb8a.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpynpzwb8a.rs:27:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for value in array {\n    |     \
    \             ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n27  |     let mut array = array.clone();\n    |                     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n19\
    \  |     for value in &array {\n    |                  +\n\nerror[E0502]: cannot\
    \ borrow `array` as immutable because it is also borrowed as mutable\n  --> /tmp/tmpynpzwb8a.rs:30:23\n\
    \   |\n30 |         array.swap(0, array.len() - 1);\n   |         --------------^^^^^^^^^^^-----\n\
    \   |         |     |       |\n   |         |     |       immutable borrow occurs\
    \ here\n   |         |     mutable borr"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmp6wdla35z.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmp6wdla35z.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmp6wdla35z.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmp6wdla35z.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0596]: cannot borrow `array` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmp6wdla35z.rs:27:5\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n27 |     array.sort_unstable();\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of\
    \ moved value: `array`\n   --> /tmp/tmp6wdla35z.rs:27:5\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |\
    \     for value in array {\n    |                  ----- `array` moved due to\
    \ this implicit call to `.into_iter()`\n...\n27  |     array.sort_unstable();\n\
    \    |     ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `array`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |     for value in &array {\n    |         \
    \         +\n\ner"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in &array {\n        sum += value;\n        if sum % 2 == 0 {\n      \
    \      min_value = value;\n        } else {\n            max_value = value;\n\
    \        }\n    }\n    array.sort();\n    array[0] = min_value;\n    array[array.len()\
    \ - 1] = max_value;\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps8_x8cl2.rs:23:25\n   |\n\
    18 |     let mut min_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n23 |             min_value = value;\n   | \
    \                        ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |             min_value = *value;\n   | \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps8_x8cl2.rs:25:25\n\
    \   |\n19 |     let mut max_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n25 |             max_value = value;\n   | \
    \                        ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |             max_value = *value;\n   | \
    \                        +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpi4wyaq3p.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpi4wyaq3p.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpi4wyaq3p.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpi4wyaq3p.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0596]: cannot borrow `array` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmpi4wyaq3p.rs:27:5\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n27 |     array.sort_unstable();\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of\
    \ moved value: `array`\n   --> /tmp/tmpi4wyaq3p.rs:27:5\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |\
    \     for value in array {\n    |                  ----- `array` moved due to\
    \ this implicit call to `.into_iter()`\n...\n27  |     array.sort_unstable();\n\
    \    |     ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `array`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |     for value in &array {\n    |         \
    \         +\n\ner"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        let sum = value + max_value;\n        if sum > max_sum {\n   \
    \         max_sum = sum;\n            max_pos = value;\n        }\n    }\n   \
    \ let mut min_pos = min_pos - min_value;\n    let mut max_pos = max_pos - max_value;\n\
    \    let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        let sum = value + max_value;\n        if sum > max_sum {\n   \
    \         max_sum = sum;\n            max_pos = value;\n        }\n    }\n   \
    \ let mut min_pos = min_pos - min_value;\n    let mut max_pos = max_pos - max_value;\n\
    \    let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        let sum = value + max_value;\n        if sum > max_sum {\n   \
    \         max_sum = sum;\n            max_pos = value;\n        }\n    }\n   \
    \ let mut min_pos = min_pos - min_value;\n    let mut max_pos = max_pos - max_value;\n\
    \    let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        let sum = value + max_value;\n        if sum > max_sum {\n   \
    \         max_sum = sum;\n            max_pos = value;\n        }\n    }\n   \
    \ let mut min_pos = min_pos - min_value;\n    let mut max_pos = max_pos - max_value;\n\
    \    let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpsmqflo52.rs:112:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n95  |    \
    \ for value in array {\n    |                        - this delimiter might not\
    \ be properly closed...\n...\n101 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n112 | }\n    |   ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsmqflo52.rs:15:37\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                       ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    if min_pos == max_pos {\n\
    \        return array;\n    }\n    if min_pos == max_pos {\n        return vec![min_value];\n\
    \    }\n    if min_pos > max_pos {\n        let mut min_pos = 0;\n        let\
    \ mut max_pos = 0;\n        let mut min_pos = 0;\n        let mut max_pos = 0;\n\
    \        let mut min_pos = 0;\n        let mut max_pos = 0;\n        for value\
    \ in array {\n            if value < min_value {\n                min_pos = value;\n\
    \                min_value = value;\n            }\n            if value > max_value\
    \ {\n                max_pos = value;\n                max_value = value;\n  \
    \          }\n        }\n        if min_pos == max_pos {\n            return vec![min_value];\n\
    \        }\n        if min_pos == max_pos {\n            return vec![max_value];\n\
    \        }\n        if min_pos > max_pos {\n            let mut min_pos = 0;\n\
    \            let mut max_pos = 0;\n            let mut min_pos = 0;\n        \
    \    let mut max_pos = 0;\n            let mut min_pos = 0;\n            let mut\
    \ max_pos = 0;\n            for value in array {\n                if value < min_value\
    \ {\n                    min_pos = value;\n                    min_value = value;\n\
    \                }\n                if value > max_value {\n                 \
    \   max_pos = value;\n                    max_value = value;\n               \
    \ }\n            }\n            if min_pos == max_pos {\n                return\
    \ vec![min_value];\n            }\n            if min_pos == max_pos {\n     \
    \           return vec![max_value];\n            }\n            if min_pos > max_pos\
    \ {\n                let mut min_pos = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpb0jp6evw.rs:125:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n65  |    \
    \ if min_pos > max_pos {\n    |                          - unclosed delimiter\n\
    ...\n88  |         if min_pos > max_pos {\n    |                             \
    \ - unclosed delimiter\n...\n111 |             if min_pos > max_pos {\n    | \
    \                                 - this delimiter might not be properly closed...\n\
    ...\n114 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n125 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpb0jp6evw.rs:88:30\n\
    \    |\n88  |           if min_pos > max_pos {\n    |  ______________________________^\n\
    89  | |             let mut min_pos = 0;\n90  | |             let mut max_pos\
    \ = 0;\n91  | |             let mut min_pos = 0;\n...   |\n124 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n125 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpgy3zrsq2.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < k {\n        sum += array[j];\n        j\
    \ += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n \
    \   } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpw1899q_g.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpw1899q_g.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| -x);\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpw1899q_g.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    array.sort_by_key(|&x|\
    \ x.clone());\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpwypsa045.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    array.sort();\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp3mjzqhv7.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp4erjr6c7.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by(|a, b| b.cmp(a));\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp4erjr6c7.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by(|a, b| a.cmp(b));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    array.sort();\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpo_6pm82d.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_val = array[0];\n   \
    \ let mut max_val = array[0];\n    for val in array {\n        sum += val;\n \
    \       if sum % 2 == 1 {\n            min_val = val;\n        } else {\n    \
    \        max_val = val;\n        }\n    }\n    let mut min_idx = array.iter().min_by_key(|&x|\
    \ x).unwrap();\n    let mut max_idx = array.iter().max_by_key(|&x| x).unwrap();\n\
    \    let mut res = vec![];\n    while min_idx < max_idx {\n        res.push(min_idx);\n\
    \        min_idx += 1;\n    }\n    while min_idx < max_idx {\n        res.push(max_idx);\n\
    \        max_idx -= 1;\n    }\n    res.sort();\n    res\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmpzlwtp3a5.rs:32:9\n   |\n32 |         min_idx += 1;\n\
    \   |         -------^^^^^\n   |         |\n   |         cannot use `+=` on type\
    \ `&isize`\n   |\nhelp: `+=` can be used on `isize`, you can dereference `min_idx`\n\
    \   |\n32 |         *min_idx += 1;\n   |         +\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpzlwtp3a5.rs:36:9\n\
    \   |\n36 |         max_idx -= 1;\n   |         -------^^^^^\n   |         |\n\
    \   |         cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can be used on\
    \ `isize`, you can dereference `max_idx`\n   |\n36 |         *max_idx -= 1;\n\
    \   |         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzlwtp3a5.rs:39:5\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n...\n39 |     res\n   |     ^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n\
    \    } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpecuqo56w.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| -x);\n   |  \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmpecuqo56w.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| -x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpecuqo56w.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0596.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.cmp(&x[array.len()\
    \ - 1]));\n    } else {\n        array.sort_by_key(|&x| x.cmp(&x[array.len() -\
    \ 1]).reverse());\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpu3b2dz_a.rs:21:39\n\
    \   |\n21 |         array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]));\n   |\
    \                                       ^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `isize`\n  --> /tmp/tmpu3b2dz_a.rs:23:39\n   |\n\
    23 |         array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]).reverse());\n \
    \  |                                       ^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0608`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n\
    \    let mut temp = 0;\n    let mut flag = false;\n    while i < array.len() {\n\
    \        if flag {\n            flag = false;\n            i += 1;\n         \
    \   continue;\n        }\n        if sum % 2 == 0 {\n            flag = true;\n\
    \            i += 1;\n            continue;\n        }\n        if sum % 2 ==\
    \ 1 {\n            flag = true;\n            j += 1;\n            continue;\n\
    \        }\n        if array[i] > array[j] {\n            temp = array[i];\n \
    \           array[i] = array[j];\n            array[j] = temp;\n            i\
    \ += 1;\n            j += 1;\n        } else {\n            temp = array[i];\n\
    \            array[i] = array[j];\n            array[j] = temp;\n            i\
    \ += 1;\n            j += 1;\n        }\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `k`\n  --> /tmp/tmps2vj67kx.rs:22:13\n   |\n\
    22 |     let mut k = 0;\n   |             ^ help: if this is intentional, prefix\
    \ it with an underscore: `_k`\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n\nwarning: value assigned to `temp` is never read\n  --> /tmp/tmps2vj67kx.rs:23:13\n\
    \   |\n23 |     let mut temp = 0;\n   |             ^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmps2vj67kx.rs:22:9\n   |\n\
    22 |     let mut k = 0;\n   |         ----^\n   |         |\n   |         help:\
    \ remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\n\
    error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmps2vj67kx.rs:25:15\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n16  |     let mut sum = 0;\n17  |     for value\
    \ in array {\n    |                  ----- `array` moved due to this implicit\
    \ call to `.into_iter()`\n...\n25  |     while i < array.len() {\n    |      \
    \         ^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `array`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n17  |     for value in &array {\n    |                  +\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmps2vj67kx.rs:43:13\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n43 |             array[i] = array[j];\n   |     \
    \        ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmps2vj67kx.rs:44:13\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be m"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    for value in array {\n        if value == min_value\
    \ {\n            min_pos = 0;\n        }\n        if value == max_value {\n  \
    \          max_pos = 0;\n        }\n        if value == min_value + max_value\
    \ {\n            break;\n        }\n        if value < min_value {\n         \
    \   min_pos = 0;\n        }\n        if value > max_value {\n            max_pos\
    \ = 0;\n        }\n        if value < min_value + max_value {\n            min_pos\
    \ = 0;\n        }\n        if value > max_value {\n            max_pos = 0;\n\
    \        }\n    }\n    if min_pos == max_pos {\n        return array;\n    }\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        if value == min_value {\n            min_value = value;\n\
    \        }\n        if value == max_value {\n            max_value = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for\
    \ value in array {\n        if value == min_value {\n            min_pos = 0;\n\
    \        }\n        if value == max_value {\n            max_pos = 0;\n      \
    \  }\n        if value == min_value + max_value {\n            break;\n      \
    \  }\n        if value < min_value {\n            min_pos = 0;\n        }\n  \
    \      if value > max_value {\n            max_pos = 0;\n        }\n        if\
    \ value < min_value + max_value {\n            min_pos = 0;\n        }\n     \
    \   if value > max_value {\n            max_pos = 0;\n        }\n    }\n    if\
    \ min_pos == max_pos {\n        return array;\n    }\n    let mut min_value =\
    \ array[0];\n    let mut max_value = array[0];\n    for value in array {\n   \
    \     if value == min_value {\n            min_value = value;\n        }\n   \
    \     if value == max_value {\n            max_value = value;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array\
    \ {\n        if value == min_value {\n            min_pos = 0;\n        }\n  \
    \      if value == max_value {\n            max_pos = 0;\n        }\n        if\
    \ value == min_value + max_value {\n            break;\n        }\n        if\
    \ value < min_value {\n            min_pos = 0;\n        }\n        if value >\
    \ max_value {\n            max_pos = 0;\n        }\n        if value < min_value\
    \ + max_value {\n            min_pos = 0;\n        }\n        if value > max_value\
    \ {\n            max_pos = 0;\n        }\n    }\n    if min_pos == max_pos {\n\
    \        return array;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6jdypcwe.rs:142:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n128 |    \
    \ if min_pos == max_pos {\n    |                           - this delimiter might\
    \ not be properly closed...\n...\n131 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n142 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6jdypcwe.rs:15:37\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                       ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    array.sort();\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpo_6pm82d.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n\
    \    } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpecuqo56w.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| -x);\n   |  \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmpecuqo56w.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| -x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpecuqo56w.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0596.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpi4wyaq3p.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpi4wyaq3p.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpi4wyaq3p.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpi4wyaq3p.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0596]: cannot borrow `array` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmpi4wyaq3p.rs:27:5\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n27 |     array.sort_unstable();\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of\
    \ moved value: `array`\n   --> /tmp/tmpi4wyaq3p.rs:27:5\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |\
    \     for value in array {\n    |                  ----- `array` moved due to\
    \ this implicit call to `.into_iter()`\n...\n27  |     array.sort_unstable();\n\
    \    |     ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `array`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |     for value in &array {\n    |         \
    \         +\n\ner"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_unstable();\n\
    \    if min_value < max_value {\n        array\n    } else {\n        array.iter().rev().cloned().collect::<Vec<_>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpyr24rpy2.rs:27:5\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n27 |     array.sort_unstable();\n   |     ^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpyr24rpy2.rs:27:5\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for value in array {\n    |     \
    \             -----\n    |                  |\n    |                  `array`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&array`\n...\n27  | \
    \    array.sort_unstable();\n    |     ^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `array`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0382, E0596.\nFor more information about an error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        } else if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        } else if value > max_value {\n            max_pos = value;\n       \
    \     max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n    let\
    \ mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for\
    \ value in array {\n        if value < min_value {\n            min_pos = value;\n\
    \            min_value = value;\n        } else if value > max_value {\n     \
    \       max_pos = value;\n            max_value = value;\n        }\n    }\n \
    \   let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    for value in array {\n        if value < min_value\
    \ {\n            min_pos = value;\n            min_value = value;\n        } else\
    \ if value > max_value {\n            max_pos = value;\n            max_value\
    \ = value;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos =\
    \ 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array\
    \ {\n        if value < min_value {\n            min_pos = value;\n          \
    \  min_value = value;\n        } else if value > max_value {\n            max_pos\
    \ = value;\n            max_value = value;\n        }\n    }\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    for value in array {\n        if value < min_value {\n           \
    \ min_pos = value;\n            min_value = value;\n        } else if value >\
    \ max_value {\n            max_pos = value;\n            max_value = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n     \
    \   if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        } else if value > max_value {\n            max_pos = value;\n\
    \n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpwz72nf8v.rs:127:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n109 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    113 |         } else if value > max_value {\n    |                           \
    \          - this delimiter might not be properly closed...\n...\n116 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n127 | }\n\
    \    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpwz72nf8v.rs:109:5\n\
    \    |\n15  |   fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |      \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n109 | /     for value in array {\n110 | |         if value\
    \ < min_value {\n111 | |             min_pos = value;\n112 | |             min_value\
    \ = value;\n...   |\n126 | |     assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n127 | | }\n    | |__^ expected struct `Vec`, found `()`\n   \
    \ |\n    = note: expected struct `Vec<isize>`\n            found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    let mut min_value = array[0];\n    let mut max_value =\
    \ array[0];\n    for value in array {\n        sum += value;\n        if sum %\
    \ 2 == 1 {\n            min_value = value;\n        } else {\n            max_value\
    \ = value;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpid64e7ty.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpid64e7ty.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpid64e7ty.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpid64e7ty.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: variable `min_value` is assigned to, but never\
    \ used\n  --> /tmp/tmpid64e7ty.rs:29:13\n   |\n29 |     let mut min_value = array[0];\n\
    \   |             ^^^^^^^^^\n   |\n   = note: consider using `_min_value` instead\n\
    \nwarning: variable `max_value` is assigned to, but never used\n  --> /tmp/tmpid64e7ty.rs:30:13\n\
    \   |\n30 |     let mut max_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: consider using `_max_value` instead\n\nwarning: value assigned\
    \ to `min_value` is never read\n  --> /tmp/tmpid64e7ty.rs:34:13\n   |\n34 |  \
    \           min_value = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe\
    \ it is overwritten before being read?\n\nwarning: value assigned to `max_value`\
    \ is never read\n  --> /tmp/tmpid64e7ty.rs:36:13\n   |\n36 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpid64e7ty.rs:27:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, whic"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmp4e9d_jhk.rs:22:47\n\
    \   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmp4e9d_jhk.rs:22:67\n   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len()\
    \ - 1]).reverse());\n   |                                                    \
    \               ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0608]:\
    \ cannot index into a value of type `isize`\n  --> /tmp/tmp4e9d_jhk.rs:24:47\n\
    \   |\n24 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    if sum % 2 == 1 {\n        array.reverse();\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpt3eg9sjn.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpt3eg9sjn.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpt3eg9sjn.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpt3eg9sjn.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpt3eg9sjn.rs:27:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for value in array {\n    |     \
    \             -----\n    |                  |\n    |                  `array`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&array`\n...\n27  | \
    \    let mut array = array.clone();\n    |                     ^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `array`\n\nerror: aborting due to previous error; 4 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut len = array.len();\n    while i < len {\n        sum += array[i];\n\
    \        if sum % 2 == 1 {\n            array[j++] = array[i];\n        } else\
    \ {\n            array[j--] = array[i];\n        }\n        i += 1;\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpoj6is61e.rs:23:21\n\
    \   |\n23 |             array[j++] = array[i];\n   |                     ^ expected\
    \ expression\n\nerror: expected expression, found `]`\n  --> /tmp/tmpoj6is61e.rs:25:22\n\
    \   |\n25 |             array[j--] = array[i];\n   |                      ^ expected\
    \ expression\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    }\
    \ else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgmqjwlx8.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut max_value = array[0];\n \
    \   let mut min_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            max_value = value;\n        } else {\n\
    \            min_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    for value in array {\n        if value == max_value {\n\
    \            array.remove(value);\n            array.insert(value, min_value);\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnwoz74yb.rs:31:26\n   |\n\
    31 |             array.remove(value);\n   |                          ^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n31 |             array.remove(value.try_into().unwrap());\n\
    \   |                          ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnwoz74yb.rs:32:26\n   |\n32 |             array.insert(value,\
    \ min_value);\n   |                          ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n32 |             array.insert(value.try_into().unwrap(),\
    \ min_value);\n   |                          ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_by_key(|x| x.partial_cmp(&min_value).unwrap());\n\
    \    array.sort_by_key(|x| x.partial_cmp(&max_value).unwrap());\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp9ovjsiw1.rs:27:5\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n27 |     array.sort_by_key(|x| x.partial_cmp(&min_value).unwrap());\n\
    \   |     ^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of moved value:\
    \ `array`\n   --> /tmp/tmp9ovjsiw1.rs:27:5\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |\
    \     for value in array {\n    |                  -----\n    |              \
    \    |\n    |                  `array` moved due to this implicit call to `.into_iter()`\n\
    \    |                  help: consider borrowing to avoid moving into the for\
    \ loop: `&array`\n...\n27  |     array.sort_by_key(|x| x.partial_cmp(&min_value).unwrap());\n\
    \    |     ^^^^^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `array`\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp9ovjsiw1.rs:28:5\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n28 |\
    \     array.sort_by_key(|x| x.partial_cmp(&max_value).unwrap());\n   |     ^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for &x in array {\n        sum += x;\n    }\n    if sum % 2 == 1 {\n    \
    \    array.sort();\n    } else {\n        array.sort();\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp17jziqmu.rs:18:9\n   |\n\
    18 |     for &x in array {\n   |         ^^    ----- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    array.sort();\n   \
    \ if array.len() % 2 != 0 {\n        array.sort();\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp1s07ah4i.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    array.sort();\n    array[0] = min_value;\n    array[array.len()\
    \ - 1] = max_value;\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpdjet4ybj.rs:28:5\n\
    \    |\n16  |     let mut array = array.to_owned();\n    |         --------- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n20  |     for value in array {\n    |                  -----\n \
    \   |                  |\n    |                  `array` moved due to this implicit\
    \ call to `.into_iter()`\n    |                  help: consider borrowing to avoid\
    \ moving into the for loop: `&array`\n...\n28  |     array.sort();\n    |    \
    \ ^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `array`\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpdjet4ybj.rs:30:11\n\
    \   |\n30 |     array[array.len() - 1] = max_value;\n   |     ------^^^^^-----------\n\
    \   |     |     |\n   |     |     immutable borrow occurs here\n   |     mutable\
    \ borrow occurs here\n   |     mutable borrow later used here\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0502.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut max_index = 0;\n    let mut\
    \ min_index = array.len() - 1;\n    while min_index >= 0 {\n        sum += array[min_index];\n\
    \        if sum % 2 == 0 {\n            sum += array[min_index];\n        } else\
    \ {\n            sum -= array[min_index];\n        }\n        if sum < 0 {\n \
    \           sum += array[min_index];\n        }\n        if sum > 0 {\n      \
    \      sum -= array[min_index];\n        }\n        if sum == 0 {\n          \
    \  break;\n        }\n        max_index = min_index;\n        min_index -= 1;\n\
    \    }\n    let mut result = vec![0; array.len()];\n    for i in 0..array.len()\
    \ {\n        result[i] = array[i];\n    }\n    for i in max_index..array.len()\
    \ {\n        result[i] = array[i];\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp2gg7u9jn.rs:18:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ i in array.iter() {\n        sum += i;\n        if sum % 2 == 1 {\n        \
    \    min_value = i;\n        } else {\n            max_value = i;\n        }\n\
    \    }\n    array.sort_unstable();\n    array[0] = min_value;\n    array.append(max_value);\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpknd86vok.rs:23:25\n   |\n\
    23 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpknd86vok.rs:25:25\n   |\n25 |             max_value = i;\n\
    \   |                         ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n25 |             max_value = *i;\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpknd86vok.rs:30:18\n\
    \   |\n30 |     array.append(max_value);\n   |                  ^^^^^^^^^ expected\
    \ `&mut Vec<isize>`, found `isize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<isize>`\n                           found type `isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    }\
    \ else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgmqjwlx8.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    }\
    \ else {\n        array.sort_by_key(|&i| -i).rev();\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcgjqmbts.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0599]:\
    \ the method `rev` exists for unit type `()`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpcgjqmbts.rs:23:36\n   |\n23 |         array.sort_by_key(|&i| -i).rev();\n\
    \   |                                    ^^^ method cannot be called on `()` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `(): Iterator`\n           which is required by `&mut\
    \ (): Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x.last()));\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x.first()));\n  \
    \  }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `last` exists for type `isize`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp4ogq2kl6.rs:21:49\n   |\n21 |     \
    \    array.sort_by_key(|&x| x.partial_cmp(&x.last()));\n   |                 \
    \                                ^^^^ method cannot be called on `isize` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `isize: Iterator`\n           which is required by `&mut\
    \ isize: Iterator`\n\nerror[E0599]: no method named `first` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp4ogq2kl6.rs:23:49\n   |\n23 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&x.first()));\n   |                                          \
    \       ^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n            max_pos = value;\n        }\n    }\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut\
    \ max_value = array[0];\n    for value in array {\n        sum += value;\n   \
    \     if sum % 2 == 1 {\n            min_value = value;\n            min_pos =\
    \ value;\n        } else {\n            max_value = value;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos =\
    \ 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n \
    \   for value in array {\n        sum += value;\n        if sum % 2 == 1 {\n \
    \           min_value = value;\n            min_pos = value;\n        } else {\n\
    \            max_value = value;\n            max_pos = value;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 1 {\n            min_value = value;\n\
    \            min_pos = value;\n        } else {\n            max_value = value;\n\
    \            max_pos = value;\n        }\n    }\n    let mut min_pos = 0;\n  \
    \  let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpv3ccozlh.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n115 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    120 |         } else {\n    |                - this delimiter might not be properly\
    \ closed...\n...\n123 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpv3ccozlh.rs:115:5\n    |\n15  |   fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                       ---------- expected\
    \ `Vec<isize>` because of return type\n...\n115 | /     for value in array {\n\
    116 | |         sum += value;\n117 | |         if sum % 2 == 1 {\n118 | |    \
    \         min_value = value;\n...   |\n133 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n134 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        if sum > max_sum {\n            max_sum = sum;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut\
    \ max_value = max_value;\n    let mut min_pos = min_pos;\n    let mut max_pos\
    \ = max_pos;\n    let mut min_sum = min_sum;\n    let mut max_sum = max_sum;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        if sum > max_sum {\n            max_sum = sum;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut\
    \ max_value = max_value;\n    let mut min_pos = min_pos;\n    let mut max_pos\
    \ = max_pos;\n    let mut min_sum = min_sum;\n    let mut max_sum = max_sum;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        if sum > max_sum {\n            max_sum = sum;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut\
    \ max_value = max_value;\n    let mut min_pos = min_pos;\n    let mut max_pos\
    \ = max_pos;\n    let mut min_sum = min_sum;\n    let mut max_sum = max_sum;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        if sum > max_sum {\n            max_sum = sum;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_value = min_value;\n    let mut\
    \ max_value = max_value;\n    let mut min_pos = min_pos;\n    let mut max_pos\
    \ = max_pos;\n    let mut min_sum = min_sum;\n    let mut max_sum = max_sum;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpujqngqc2.rs:115:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n99  |    \
    \ for value in array {\n    |                        - unclosed delimiter\n100\
    \ |         let sum = value + min_value;\n101 |         if sum < min_sum {\n \
    \   |                          - this delimiter might not be properly closed...\n\
    ...\n104 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n115 | }\n    |   ^\n\nerror[E0425]: cannot find value `min_` in this scope\n\
    \   --> /tmp/tmpujqngqc2.rs:103:13\n    |\n103 |             min_\n    |     \
    \        ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpujqngqc2.rs:99:5\n    |\n15  |   fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                       ---------- expected\
    \ `Vec<isize>` because of return type\n...\n99  | /     for value in array {\n\
    100 | |         let sum = value + min_value;\n101 | |         if sum < min_sum\
    \ {\n102 | |             min_sum = sum;\n...   |\n114 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n115 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut flag = false;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        if flag {\n            sum +=\
    \ value;\n        } else {\n            sum += value;\n            flag = true;\n\
    \        }\n        if sum % 2 == 1 {\n            flag = false;\n           \
    \ j = i;\n        }\n        if sum % 2 == 0 {\n            flag = true;\n   \
    \         i = j;\n        }\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_value =\
    \ value;\n        }\n    }\n    let mut result = vec![min_value];\n    for i in\
    \ 0..(array.len() - 1) {\n        if array[i] < min_value {\n            result.push(min_value);\n\
    \        } else {\n            result.push(array[i]);\n        }\n    }\n    for\
    \ i in 0..(array.len() - 1) {\n        if array[i] > max_value {\n           \
    \ result.push(max_value);\n        } else {\n            result.push(array[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmp654tbp_g.rs:45:18\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n22  |     for value in array {\n    |     \
    \             -----\n    |                  |\n    |                  `array`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&array`\n...\n45  | \
    \    for i in 0..(array.len() - 1) {\n    |                  ^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `array`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    array.sort_by_key(|&x| {\n        if x < min_value {\n \
    \           x.to_owned()\n        } else if x > max_value {\n            x.to_owned()\n\
    \        } else {\n            x.to_owned()\n        }\n    });\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmp4pcqmiz9.rs:28:5\n\
    \    |\n16  |     let mut array = array.to_owned();\n    |         --------- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n20  |     for value in array {\n    |                  -----\n \
    \   |                  |\n    |                  `array` moved due to this implicit\
    \ call to `.into_iter()`\n    |                  help: consider borrowing to avoid\
    \ moving into the for loop: `&array`\n...\n28  |     array.sort_by_key(|&x| {\n\
    \    |     ^^^^^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `array`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpl7knck7a.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ i in array.iter() {\n        sum += i;\n        if sum % 2 == 1 {\n        \
    \    min_value = i;\n        } else {\n            max_value = i;\n        }\n\
    \    }\n    array.sort_by_key(|x| {\n        if x < min_value {\n            -1\n\
    \        } else if x > max_value {\n            1\n        } else {\n        \
    \    0\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn612o8f0.rs:23:25\n   |\n\
    23 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn612o8f0.rs:25:25\n   |\n25 |             max_value = i;\n\
    \   |                         ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n25 |             max_value = *i;\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn612o8f0.rs:29:16\n\
    \   |\n29 |         if x < min_value {\n   |                ^^^^^^^^^\n   |  \
    \              |\n   |                expected `&isize`, found `isize`\n   | \
    \               help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn612o8f0.rs:31:23\n   |\n31 |         } else if x > max_value\
    \ {\n   |                       ^^^^^^^^^\n   |                       |\n   |\
    \                       expected `&isize`, found `isize`\n   |               \
    \        help: consider borrowing here: `&max_value`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        if array[i] > array[j]\
    \ {\n            sum += array[i];\n            i += 1;\n        } else {\n   \
    \         sum += array[j];\n            j += 1;\n        }\n    }\n    if sum\
    \ % 2 != 0 {\n        array.sort_by_key(|&x| -x);\n    } else {\n        array.sort_by_key(|&x|\
    \ x);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp0ogr3w3i.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp0ogr3w3i.rs:30:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n30 |         array.sort_by_key(|&x| -x);\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp0ogr3w3i.rs:32:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n32 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    if min_value < max_value {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmptvoryj7_.rs:27:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for value in array {\n    |     \
    \             -----\n    |                  |\n    |                  `array`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&array`\n...\n27  | \
    \    let mut array = array.clone();\n    |                     ^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `array`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       if sum % 2 == 1 {\n            j = i;\n        } else {\n            k\
    \ = i;\n        }\n        while j < k {\n            if array[j] > array[j +\
    \ 1] {\n                let tmp = array[j];\n                array[j] = array[j\
    \ + 1];\n                array[j + 1] = tmp;\n            }\n            i +=\
    \ 1;\n            j += 1;\n        }\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp7ju3j7zd.rs:30:17\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n30 |                 array[j] = array[j + 1];\n \
    \  |                 ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp7ju3j7zd.rs:31:17\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \                 array[j + 1] = tmp;\n   |                 ^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in 0..array.len() {\n     \
    \   sum += array[i];\n    }\n    if sum % 2 != 0 {\n        array.sort_by_key(|&i|\
    \ i);\n    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpi82_42a8.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpi82_42a8.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut max_index = 0;\n    let mut\
    \ min_index = array.len() - 1;\n    while min_index >= 0 {\n        sum += array[min_index];\n\
    \        if sum % 2 == 0 {\n            sum += array[min_index];\n        } else\
    \ {\n            sum -= array[min_index];\n        }\n        if sum < 0 {\n \
    \           sum += array[min_index];\n        }\n        if sum > 0 {\n      \
    \      sum += array[min_index];\n        }\n        if sum % 2 == 0 {\n      \
    \      sum += array[min_index];\n        } else {\n            sum -= array[min_index];\n\
    \        }\n        if sum < 0 {\n            sum += array[min_index];\n     \
    \   }\n        if sum > 0 {\n            sum += array[min_index];\n        }\n\
    \        if sum % 2 == 0 {\n            sum += array[min_index];\n        } else\
    \ {\n            sum -= array[min_index];\n        }\n        if sum < 0 {\n \
    \           sum += array[min_index];\n        }\n        if sum > 0 {\n      \
    \      sum += array[min_index];\n        }\n        if sum % 2 == 0 {\n      \
    \      sum += array[min_index];\n        } else {\n            sum -= array[min_index];\n\
    \        }\n        if sum < 0 {\n            sum += array[min_index];\n     \
    \   }\n        if sum > 0 {\n            sum += array[min_index];\n        }\n\
    \        if sum % 2 == 0 {\n            sum += array[min_index];\n        } else\
    \ {\n            sum -= array[min_index];\n        }\n        if sum < 0 {\n \
    \           sum += array[min_index];\n        }\n        if sum > 0 {\n      \
    \      sum += array[min_index];\n        }\n        if sum % 2 == 0 {\n      \
    \      sum += array[min_index];\n        } else {\n            sum -= array[min_index];\n\
    \        }\n        if sum < 0 {\n            sum += array[min_index];\n     \
    \   }\n        if sum > 0 {\n            sum += array[min_index];\n        }\n\
    \        if sum % 2 == 0 {\n            sum += array[min_index];\n        } else\
    \ {\n            sum -= array[min_index];\n        }\n        if sum < 0 {\n \
    \           sum += array[min_index];\n        }\n        if sum > 0 {\n      \
    \      sum += array[min_index];\n        }\n        if sum % 2 == 0 {\n      \
    \      sum += array[min_index];\n        } else {\n            sum -= array[min_index];\n\
    \        }\n        if sum < 0 {\n            sum += array[min_index];\n     \
    \   }\n        if sum > 0 {\n            sum += array[min_index];\n        }\n\
    \        if sum % 2 == 0 {\n            sum += array[min_index];\n        } else\
    \ {\n            sum -= array[min_index];\n        }\n        if sum < 0 {\n \
    \           sum += array[min_index];\n        }\n        if sum > 0 {\n      \
    \      sum += array[min_index];\n        }\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpla0i7q9s.rs:131:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n19  |    \
    \ while min_index >= 0 {\n    |                          - this delimiter might\
    \ not be properly closed...\n...\n120 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n131 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpla0i7q9s.rs:15:37\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                       ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = 0;\n     \
    \       max_pos = 0;\n        } else {\n            max_value = value;\n     \
    \       max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let mut\
    \ max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n\
    \    for value in array {\n        sum += value;\n        if sum % 2 == 1 {\n\
    \            min_value = value;\n            min_pos = 0;\n            max_pos\
    \ = 0;\n        } else {\n            max_value = value;\n            max_pos\
    \ = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n            min_pos = 0;\n            max_pos = 0;\n\
    \        } else {\n            max_value = value;\n            max_pos = 0;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = 0;\n            max_pos = 0;\n        } else\
    \ {\n            max_value = value;\n            max_pos = 0;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 1 {\n            min_value = value;\n\
    \            min_pos = 0;\n            max_pos = 0;\n        } else {\n      \
    \      max_value = value;\n            max_pos = 0;\n        }\n    }\n    let\
    \ mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n\
    \    let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n            min_pos\
    \ = 0;\n            max_pos = 0;\n        } else {\n            max_value = value;\n\
    \            max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let\
    \ mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value =\
    \ array[0];\n    for value in array {\n\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpab1gn2mw.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n121 |    \
    \ for value in array {\n    |                        - this delimiter might not\
    \ be properly closed...\n122 | \n123 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpab1gn2mw.rs:15:37\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                       ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n        while j < k {\n            if sum % 2 == 0 {\n      \
    \          array[j + 1] = array[j];\n                j += 1;\n            } else\
    \ {\n                array[j + 1] = array[j + 1];\n                j += 1;\n \
    \           }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpmao5j9_p.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpmao5j9_p.rs:25:17\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n25 |                 array[j + 1] = array[j];\n\
    \   |                 ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpmao5j9_p.rs:28:17\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n28 |\
    \                 array[j + 1] = array[j + 1];\n   |                 ^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    array.sort();\n    array[0] = min_value;\n    array[array.len()\
    \ - 1] = max_value;\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpdjet4ybj.rs:28:5\n\
    \    |\n16  |     let mut array = array.to_owned();\n    |         --------- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n20  |     for value in array {\n    |                  -----\n \
    \   |                  |\n    |                  `array` moved due to this implicit\
    \ call to `.into_iter()`\n    |                  help: consider borrowing to avoid\
    \ moving into the for loop: `&array`\n...\n28  |     array.sort();\n    |    \
    \ ^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `array`\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpdjet4ybj.rs:30:11\n\
    \   |\n30 |     array[array.len() - 1] = max_value;\n   |     ------^^^^^-----------\n\
    \   |     |     |\n   |     |     immutable borrow occurs here\n   |     mutable\
    \ borrow occurs here\n   |     mutable borrow later used here\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0502.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    for value in array {\n        if value < min_value\
    \ {\n            min_pos = value;\n            min_value = value;\n        }\n\
    \        if value > max_value {\n            max_pos = value;\n            max_value\
    \ = value;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos =\
    \ 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n   \
    \ let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n \
    \   let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpku855nzk.rs:15:37\n   |\n\
    15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------    \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n            max_pos = value;\n        }\n    }\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut\
    \ max_value = array[0];\n    for value in array {\n        sum += value;\n   \
    \     if sum % 2 == 1 {\n            min_value = value;\n            min_pos =\
    \ value;\n        } else {\n            max_value = value;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos =\
    \ 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n \
    \   for value in array {\n        sum += value;\n        if sum % 2 == 1 {\n \
    \           min_value = value;\n            min_pos = value;\n        } else {\n\
    \            max_value = value;\n            max_pos = value;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 1 {\n            min_value = value;\n\
    \            min_pos = value;\n        } else {\n            max_value = value;\n\
    \            max_pos = value;\n        }\n    }\n    let mut min_pos = 0;\n  \
    \  let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpv3ccozlh.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n115 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    120 |         } else {\n    |                - this delimiter might not be properly\
    \ closed...\n...\n123 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpv3ccozlh.rs:115:5\n    |\n15  |   fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                       ---------- expected\
    \ `Vec<isize>` because of return type\n...\n115 | /     for value in array {\n\
    116 | |         sum += value;\n117 | |         if sum % 2 == 1 {\n118 | |    \
    \         min_value = value;\n...   |\n133 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n134 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 0 {\n            min_value = value;\n            min_pos = 0;\n     \
    \       max_pos = 0;\n        } else {\n            max_value = value;\n     \
    \       max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let mut\
    \ max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n\
    \    for value in array {\n        sum += value;\n        if sum % 2 == 0 {\n\
    \            min_value = value;\n            min_pos = 0;\n            max_pos\
    \ = 0;\n        } else {\n            max_value = value;\n            max_pos\
    \ = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 0 {\n       \
    \     min_value = value;\n            min_pos = 0;\n            max_pos = 0;\n\
    \        } else {\n            max_value = value;\n            max_pos = 0;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 0 {\n            min_value\
    \ = value;\n            min_pos = 0;\n            max_pos = 0;\n        } else\
    \ {\n            max_value = value;\n            max_pos = 0;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 0 {\n            min_value = value;\n\
    \            min_pos = 0;\n            max_pos = 0;\n        } else {\n      \
    \      max_value = value;\n            max_pos = 0;\n        }\n    }\n    let\
    \ mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n\
    \    let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n            min_pos\
    \ = 0;\n            max_pos = 0;\n        } else {\n            max_value = value;\n\
    \            max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let\
    \ mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value =\
    \ array[0];\n    for value in array {\n\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0czjfubm.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n121 |    \
    \ for value in array {\n    |                        - this delimiter might not\
    \ be properly closed...\n122 | \n123 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0czjfubm.rs:15:37\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                       ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut max_value = array[0];\n \
    \   for value in array {\n        sum += value;\n        if sum % 2 == 0 {\n \
    \           max_value = value;\n        }\n    }\n    let mut min_value = array[0];\n\
    \    for value in array {\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n    }\n    let mut new_array: Vec<isize> = vec![];\n  \
    \  let mut new_array_size = array.len();\n    let mut i = 0;\n    while i < new_array_size\
    \ {\n        let mut j = i;\n        while j < new_array_size && array[j] < min_value\
    \ {\n            j += 1\n        }\n        let mut k = j;\n        while k <\
    \ new_array_size && array[k] > max_value {\n            k += 1\n        }\n  \
    \      if k == new_array_size {\n            new_array.push(array[i]);\n     \
    \       i += 1;\n        } else {\n            new_array.push(array[k]);\n   \
    \         i += 1;\n        }\n    }\n    new_array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpmmjqrq0c.rs:31:9\n\
    \   |\n31 |     let mut new_array_size = array.len();\n   |         ----^^^^^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpmmjqrq0c.rs:24:25\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n18  |     for value in array {\n    |     \
    \             -----\n    |                  |\n    |                  `array`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&array`\n...\n24  | \
    \    let mut min_value = array[0];\n    |                         ^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\n\nerror[E0382]: borrow of moved value:\
    \ `array`\n  --> /tmp/tmpmmjqrq0c.rs:31:30\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- move occurs because `array` has type\
    \ `Vec<isize>`, which does not implement the `Copy` trait\n...\n25 |     for value\
    \ in array {\n   |                  -----\n   |                  |\n   |     \
    \             `array` moved due to this implicit call to `.into_iter()`\n   |\
    \                  help: consider borrowing to avoid moving into the for loop:\
    \ `&array`\n...\n31 |     let mut new_array_size = array.len();\n   |        \
    \                      ^^^^^ value borrowed here after move\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x.last().unwrap()).unwrap());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x.first().unwrap()).unwrap());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `last` exists for type `isize`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpbc5jiio0.rs:21:49\n   |\n21 |     \
    \    array.sort_by_key(|&x| x.partial_cmp(&x.last().unwrap()).unwrap());\n   |\
    \                                                 ^^^^ method cannot be called\
    \ on `isize` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `isize: Iterator`\n           which is\
    \ required by `&mut isize: Iterator`\n\nerror[E0599]: no method named `first`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpbc5jiio0.rs:23:49\n\
    \   |\n23 |         array.sort_by_key(|&x| x.partial_cmp(&x.first().unwrap()).unwrap());\n\
    \   |                                                 ^^^^^ method not found in\
    \ `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x.last()));\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x.first()));\n  \
    \  }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `last` exists for type `isize`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp4ogq2kl6.rs:21:49\n   |\n21 |     \
    \    array.sort_by_key(|&x| x.partial_cmp(&x.last()));\n   |                 \
    \                                ^^^^ method cannot be called on `isize` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `isize: Iterator`\n           which is required by `&mut\
    \ isize: Iterator`\n\nerror[E0599]: no method named `first` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp4ogq2kl6.rs:23:49\n   |\n23 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&x.first()));\n   |                                          \
    \       ^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjctw4oen.rs:15:37\n   |\n\
    15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------    \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x.last()));\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x.first()));\n  \
    \  }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `last` exists for type `isize`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp4ogq2kl6.rs:21:49\n   |\n21 |     \
    \    array.sort_by_key(|&x| x.partial_cmp(&x.last()));\n   |                 \
    \                                ^^^^ method cannot be called on `isize` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `isize: Iterator`\n           which is required by `&mut\
    \ isize: Iterator`\n\nerror[E0599]: no method named `first` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp4ogq2kl6.rs:23:49\n   |\n23 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&x.first()));\n   |                                          \
    \       ^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    while i < array.len() {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < array.len() {\n        sum += array[j];\n\
    \        j += 1;\n    }\n    while k < array.len() {\n        sum += array[k];\n\
    \        k += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[k]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap());\n    }\n    array\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpgoiq25d0.rs:33:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n33 |         array.sort_by_key(|&x| x.partial_cmp(&array[k]).unwrap());\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpgoiq25d0.rs:33:27\n\
    \   |\n33 |         array.sort_by_key(|&x| x.partial_cmp(&array[k]).unwrap());\n\
    \   |         ----- ----------- ^^^^                ----- second borrow occurs\
    \ due to use of `array` in closure\n   |         |     |           |\n   |   \
    \      |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpgoiq25d0.rs:35:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n35 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as\
    \ immutable because it is also borrowed as mutable\n  --> /tmp/tmpgoiq25d0.rs:35:27\n\
    \   |\n35 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \   |         ----- ----------- ^^^^                ----- second borrow occurs\
    \ due to use of `array` in closure\n   |         |     |           |\n   |   \
    \      |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0502, E0596.\nFor more information about an error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x.last()));\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x.first()));\n  \
    \  }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `last` exists for type `isize`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp4ogq2kl6.rs:21:49\n   |\n21 |     \
    \    array.sort_by_key(|&x| x.partial_cmp(&x.last()));\n   |                 \
    \                                ^^^^ method cannot be called on `isize` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `isize: Iterator`\n           which is required by `&mut\
    \ isize: Iterator`\n\nerror[E0599]: no method named `first` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp4ogq2kl6.rs:23:49\n   |\n23 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&x.first()));\n   |                                          \
    \       ^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjctw4oen.rs:15:37\n   |\n\
    15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------    \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = 0;\n     \
    \   } else {\n            max_value = value;\n            max_pos = 0;\n     \
    \   }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut\
    \ min_value = array[0];\n    let mut max_value = array[0];\n    for value in array\
    \ {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value =\
    \ value;\n            min_pos = 0;\n        } else {\n            max_value =\
    \ value;\n            max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = 0;\n     \
    \   } else {\n            max_value = value;\n            max_pos = 0;\n     \
    \   }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut\
    \ min_value = array[0];\n    let mut max_value = array[0];\n    for value in array\
    \ {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value =\
    \ value;\n            min_pos = 0;\n        } else {\n            max_value =\
    \ value;\n            max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = 0;\n     \
    \   } else {\n            max_value = value;\n            max_pos = 0;\n     \
    \   }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut\
    \ min_value = array[0];\n    let mut max_value = array[0];\n    for value in array\
    \ {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value =\
    \ value;\n            min_pos = 0;\n        } else {\n            max_value =\
    \ value;\n            max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = 0;\n     \
    \   } else {\n            max_value = value;\n\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpzabr1jxv.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n115 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    120 |         } else {\n    |                - this delimiter might not be properly\
    \ closed...\n...\n123 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpzabr1jxv.rs:115:5\n    |\n15  |   fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                       ---------- expected\
    \ `Vec<isize>` because of return type\n...\n115 | /     for value in array {\n\
    116 | |         sum += value;\n117 | |         if sum % 2 == 1 {\n118 | |    \
    \         min_value = value;\n...   |\n133 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n134 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut max_index = 0;\n    let mut min_index = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for i in array.iter() {\n\
    \        sum += i;\n        if sum % 2 == 1 {\n            max_value = i;\n  \
    \          max_index = i;\n        } else {\n            min_value = i;\n    \
    \        min_index = i;\n        }\n    }\n    array.swap(0, min_index);\n   \
    \ array.swap(max_index, array.len());\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8ev2zkrk.rs:25:25\n   |\n\
    25 |             max_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n25 |  \
    \           max_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8ev2zkrk.rs:26:25\n   |\n26 |             max_index = i;\n\
    \   |                         ^ expected integer, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n26 |             max_index = *i;\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8ev2zkrk.rs:28:25\n\
    \   |\n28 |             min_value = i;\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    28 |             min_value = *i;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8ev2zkrk.rs:29:25\n   |\n29 |             min_index\
    \ = i;\n   |                         ^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n29 |             min_index = *i;\n\
    \   |                         +\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_pos = min_value;\n            min_sum = sum;\n\
    \        }\n        if sum > max_sum {\n            max_pos = max_value;\n   \
    \         max_sum = sum;\n        }\n        min_value = value;\n        max_value\
    \ = value;\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_sum = 0;\n    let mut max_sum = 0;\n    for value in array {\n     \
    \   let sum = value + min_value;\n        if sum < min_sum {\n            min_pos\
    \ = min_value;\n            min_sum = sum;\n        }\n        if sum > max_sum\
    \ {\n            max_pos = max_value;\n            max_sum = sum;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_sum\
    \ = 0;\n    let mut max_sum = 0;\n    for value in array {\n        let sum =\
    \ value + min_value;\n        if sum < min_sum {\n            min_pos = min_value;\n\
    \            min_sum = sum;\n        }\n        if sum > max_sum {\n         \
    \   max_pos = max_value;\n            max_sum = sum;\n        }\n    }\n    let\
    \ mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_sum = 0;\n    let\
    \ mut max_sum = 0;\n    for value in array {\n        let sum = value + min_value;\n\
    \        if sum < min_sum {\n            min_pos = min_value;\n            min_sum\
    \ = sum;\n        }\n        if sum > max_sum {\n            max_pos = max_value;\n\
    \            max_sum = sum;\n        }\n    }\n    let mut min_pos = 0;\n    let\
    \ mut max_pos = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n    for\
    \ value in array {\n        let sum = value + min_value;\n        if sum < min_sum\
    \ {\n            min_pos = min_value;\n            min_sum = sum;\n        }\n\
    \        if sum > max_sum {\n            max_pos = max_value;\n            max_sum\
    \ = sum;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_sum = 0;\n    let mut max_sum = 0;\n    for value in array {\n\
    \        let sum = value + min_value;\n        if sum < min_sum {\n          \
    \  min_pos = min_value;\n            min_\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpanwwsew9.rs:124:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n108 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n109\
    \ |         let sum = value + min_value;\n110 |         if sum < min_sum {\n \
    \   |                          - this delimiter might not be properly closed...\n\
    ...\n113 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n124 | }\n    |   ^\n\nerror[E0425]: cannot find value `min_` in this scope\n\
    \   --> /tmp/tmpanwwsew9.rs:112:13\n    |\n112 |             min_\n    |     \
    \        ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpanwwsew9.rs:108:5\n    |\n15  |   fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                       ---------- expected\
    \ `Vec<isize>` because of return type\n...\n108 | /     for value in array {\n\
    109 | |         let sum = value + min_value;\n110 | |         if sum < min_sum\
    \ {\n111 | |             min_pos = min_value;\n...   |\n123 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n124 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    array.sort_by_key(|&x| {\n        if x < min_value {\n\
    \            Some(min_value)\n        } else if x > max_value {\n            Some(max_value)\n\
    \        } else {\n            None\n        }\n    });\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpsb1it7c5.rs:27:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for value in array {\n    |     \
    \             -----\n    |                  |\n    |                  `array`\
    \ moved due to this implicit call to `.into_iter()`\n    |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&array`\n...\n27  | \
    \    let mut array = array.clone();\n    |                     ^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `array`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    for value in array {\n        if value == min_value\
    \ {\n            min_pos = 0;\n        }\n        if value == max_value {\n  \
    \          max_pos = 0;\n        }\n        if value < min_value {\n         \
    \   min_pos = min_pos + 1;\n        }\n        if value > max_value {\n      \
    \      max_pos = max_pos + 1;\n        }\n    }\n    let mut min_pos = min_pos\
    \ - 1;\n    let mut max_pos = max_pos + 1;\n    let mut min_value = array[min_pos];\n\
    \    let mut max_value = array[max_pos];\n    let mut min_pos = min_pos - 1;\n\
    \    let mut max_pos = max_pos + 1;\n    let mut min_value = array[min_pos];\n\
    \    let mut max_value = array[max_pos];\n    let mut min_pos = min_pos - 1;\n\
    \    let mut max_pos = max_pos + 1;\n    let mut min_value = array[min_pos];\n\
    \    let mut max_value = array[max_pos];\n    let mut min_pos = min_pos - 1;\n\
    \    let mut max_pos = max_pos + 1;\n    let mut min_value = array[min_pos];\n\
    \    let mut max_value = array[max_pos];\n    let mut min_pos = min_pos - 1;\n\
    \    let mut max_pos = max_pos + 1;\n    let mut min_value = array[min_pos];\n\
    \    let mut max_value = array[max_pos];\n    let mut min_pos = min_pos - 1;\n\
    \    let mut max_pos = max_pos + 1;\n    let mut min_value = array[min_pos];\n\
    \    let mut max_value = array[max_pos];\n    let mut min_pos = min_pos - 1;\n\
    \    let mut max_pos = max_pos + 1;\n    let mut min_value = array[min_pos];\n\
    \    let mut max_value = array[max_pos];\n    let mut min_pos = min_pos - 1;\n\
    \    let mut max_pos = max_pos + 1;\n    let mut min_value = array[min_pos];\n\
    \    let mut max_value = array[max_pos];\n    let mut min_pos = min_pos - 1;\n\
    \    let mut max_pos = max_pos + 1;\n    let mut min_value = array[min_pos];\n\
    \    let mut max_value = array[max_pos];\n    let mut min_pos = min_pos - 1;\n\
    \    let mut max_pos = max_pos + 1;\n    let mut min_value = array[min_pos];\n\
    \    let mut max_value = array[max_pos\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp4uflafrc.rs:83:1\n   |\n83 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp4uflafrc.rs:82:30\n   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                                - closing delimiter possibly\
    \ meant for this\n...\n82 |     let mut max_value = array[max_pos\n   |      \
    \                        ^ unclosed delimiter\n83 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x)\n\
    \    } else {\n        array.sort_by_key(|&x| x)\n    }\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp27121kbc.rs:21:9\n   |\n\
    15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n21 |         array.sort_by_key(|&x| -x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp27121kbc.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n...\n23 |         array.sort_by_key(|&x| x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut size = array.len();\n    while i < size {\n \
    \       sum += array[i];\n        i += 1;\n    }\n    if sum % 2 == 1 {\n    \
    \    array.sort_by_key(|&x| x.cmp(&array[j]));\n    } else {\n        array.sort_by_key(|&x|\
    \ x.cmp(&array[k]));\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp9htka8b6.rs:18:9\n\
    \   |\n18 |     let mut j = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmp9htka8b6.rs:19:9\n\
    \   |\n19 |     let mut k = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n\nwarning: variable does not need to be mutable\n\
    \  --> /tmp/tmp9htka8b6.rs:20:9\n   |\n20 |     let mut size = array.len();\n\
    \   |         ----^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp9htka8b6.rs:26:9\n   |\n15 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |               ----- help: consider changing this to be mutable:\
    \ `mut array`\n...\n26 |         array.sort_by_key(|&x| x.cmp(&array[j]));\n \
    \  |         ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmp9htka8b6.rs:26:27\n\
    \   |\n26 |         array.sort_by_key(|&x| x.cmp(&array[j]));\n   |         -----\
    \ ----------- ^^^^        ----- second borrow occurs due to use of `array` in\
    \ closure\n   |         |     |           |\n   |         |     |           immutable\
    \ borrow occurs here\n   |         |     mutable borrow later used by call\n \
    \  |         mutable borrow occurs here\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp9htka8b6.rs:28:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n28 |\
    \         array.sort_by_key(|&x| x.cmp(&array[k]));\n   |         ^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmp9htka8b6.rs:28:27\n   |\n28 |\
    \         array.sort_by_key(|&x| x.cmp(&array[k]));\n   |         ----- -----------\
    \ ^^^^        ----- second borrow occurs due to use of "
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ i in array.iter().rev() {\n        sum += i;\n        if sum % 2 == 1 {\n  \
    \          array.swap(0, i);\n        }\n        if sum < min_value {\n      \
    \      min_value = sum;\n        }\n        if sum > max_value {\n           \
    \ max_value = sum;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm0vc6tzo.rs:23:27\n   |\n\
    23 |             array.swap(0, i);\n   |                           ^ expected\
    \ `usize`, found `&isize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: -1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       if sum % 2 == 1 {\n            i += 1;\n        } else {\n           \
    \ j += 1;\n        }\n    }\n    let mut result = vec![];\n    while i < k {\n\
    \        result.push(array[i]);\n        i += 1;\n    }\n    while j < k {\n \
    \       result.push(array[j]);\n        j += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749462
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.cmp(&x[array.len()\
    \ - 1]));\n    } else {\n        array.sort_by_key(|&x| x.cmp(&x[array.len() -\
    \ 1]).reverse());\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpu3b2dz_a.rs:21:39\n\
    \   |\n21 |         array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]));\n   |\
    \                                       ^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `isize`\n  --> /tmp/tmpu3b2dz_a.rs:23:39\n   |\n\
    23 |         array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]).reverse());\n \
    \  |                                       ^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0608`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpi4wyaq3p.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpi4wyaq3p.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpi4wyaq3p.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpi4wyaq3p.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0596]: cannot borrow `array` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmpi4wyaq3p.rs:27:5\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n27 |     array.sort_unstable();\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of\
    \ moved value: `array`\n   --> /tmp/tmpi4wyaq3p.rs:27:5\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |\
    \     for value in array {\n    |                  ----- `array` moved due to\
    \ this implicit call to `.into_iter()`\n...\n27  |     array.sort_unstable();\n\
    \    |     ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `array`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |     for value in &array {\n    |         \
    \         +\n\ner"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut len = array.len();\n    while i < len {\n        sum += array[i];\n\
    \        i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap().reverse());\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpjut0spvq.rs:18:9\n\
    \   |\n18 |     let mut j = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpjut0spvq.rs:19:9\n\
    \   |\n19 |     let mut len = array.len();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpjut0spvq.rs:25:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n25 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror[E0502]: cannot borrow `array` as immutable because it is\
    \ also borrowed as mutable\n  --> /tmp/tmpjut0spvq.rs:25:27\n   |\n25 |      \
    \   array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |         ------------------^^^^-----------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpjut0spvq.rs:27:9\n   |\n15 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |               ----- help: consider changing this to be mutable:\
    \ `mut array`\n...\n27 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpjut0spvq.rs:27:27\n  \
    \ |\n27 |         array.sort_by_key(|&x| x.partial_cmp(&"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    for value in array {\n        if value == min_value {\n\
    \            array.swap(0, array.len() - 1);\n        }\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `max_value` is assigned to, but never used\n  --> /tmp/tmpbj0d7wj4.rs:18:13\n\
    \   |\n18 |     let mut max_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_max_value` instead\n\nwarning: value assigned to `max_value` is never\
    \ read\n  --> /tmp/tmpbj0d7wj4.rs:24:13\n   |\n24 |             max_value = value;\n\
    \   |             ^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on\
    \ by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0382]:\
    \ borrow of moved value: `array`\n   --> /tmp/tmpbj0d7wj4.rs:27:21\n    |\n15\
    \  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |               -----\
    \ move occurs because `array` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n19  |     for value in array {\n    |               \
    \   -----\n    |                  |\n    |                  `array` moved due\
    \ to this implicit call to `.into_iter()`\n    |                  help: consider\
    \ borrowing to avoid moving into the for loop: `&array`\n...\n27  |     let mut\
    \ array = array.clone();\n    |                     ^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `array`\n\nerror[E0382]: borrow of moved value: `array`\n  --> /tmp/tmpbj0d7wj4.rs:31:13\n\
    \   |\n27 |     let mut array = array.clone();\n   |         --------- move occurs\
    \ because `array` has type `Vec<isize>`, which does not implement the `Copy` trait\n\
    28 |     array.sort();\n29 |     for value in array {\n   |                  -----\n\
    \   |                  |\n   |                  `array` moved due to this implicit\
    \ call to `.into_iter()`\n   |                  help: consider borrowing to avoid\
    \ moving into the for loop: `&array`\n30 |         if value == min_value {\n31\
    \ |             array.swap(0, array.len() - 1);\n   |             ^^^^^ value\
    \ borrowed here after move\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpbj0d7wj4.rs:31:27\n  \
    \ |\n31 |           "
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut max_sum = 0;\n    for x in\
    \ array {\n        sum += x;\n        if sum > max_sum {\n            max_sum\
    \ = sum;\n        }\n    }\n    let mut min_sum = 0;\n    for x in array {\n \
    \       sum += x;\n        if sum < min_sum {\n            min_sum = sum;\n  \
    \      }\n    }\n    if max_sum % 2 == 1 {\n        array.sort_by_key(|x| -x)\n\
    \    } else {\n        array.sort_by_key(|x| -x)\n    }\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5rgff_xi.rs:32:9\n   |\n\
    15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n32 |         array.sort_by_key(|x| -x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5rgff_xi.rs:34:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n...\n34 |         array.sort_by_key(|x| -x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < k {\n        sum += array[j];\n        j\
    \ += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpdoezt1ag.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpdoezt1ag.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpdoezt1ag.rs:29:27\n\
    \   |\n29 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \   |         ----- ----------- ^^^^                ----- second borrow occurs\
    \ due to use of `array` in closure\n   |         |     |           |\n   |   \
    \      |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpdoezt1ag.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpdoezt1ag.rs:31:27\n\
    \   |\n31 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ----- ----------- ^^^^                ----- second borrow occurs\
    \ due to use of `array` in closure\n   |         |     |           |\n   |   \
    \      |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror:\
    \ aborting due to 4 previous errors; 1 warning "
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len() - 1;\n    while i < k {\n        sum += array[i];\n\
    \        if sum % 2 == 1 {\n            j = i;\n        } else {\n           \
    \ k = i;\n        }\n        i += 1;\n    }\n    array.sort_by_key(|x| {\n   \
    \     if x < array[j] {\n            -1\n        } else {\n            1\n   \
    \     }\n    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcpgfkt1a.rs:30:16\n   |\n\
    30 |         if x < array[j] {\n   |                ^^^^^^^^\n   |           \
    \     |\n   |                expected `&isize`, found `isize`\n   |          \
    \      help: consider borrowing here: `&array[j]`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut size = array.len();\n    while i < size {\n        sum += array[i];\n\
    \        i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ -x);\n    } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `j`\n  --> /tmp/tmpqhtvqpqe.rs:18:13\n   |\n\
    18 |     let mut j = 0;\n   |             ^ help: if this is intentional, prefix\
    \ it with an underscore: `_j`\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpqhtvqpqe.rs:18:9\n\
    \   |\n18 |     let mut j = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpqhtvqpqe.rs:19:9\n\
    \   |\n19 |     let mut size = array.len();\n   |         ----^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpqhtvqpqe.rs:25:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n25 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpqhtvqpqe.rs:27:9\n   |\n15 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |               ----- help: consider changing this to be mutable:\
    \ `mut array`\n...\n27 |         array.sort_by_key(|&x| x);\n   |         ^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors; 3 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        if array[i] < array[j]\
    \ {\n            sum += array[i];\n            i += 1;\n        } else {\n   \
    \         sum += array[j];\n            j += 1;\n        }\n    }\n    if sum\
    \ % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n    } else {\n        array.sort_by_key(|&x|\
    \ x);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmprbq0vezy.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmprbq0vezy.rs:30:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n30 |         array.sort_by_key(|&x| -x);\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmprbq0vezy.rs:32:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n32 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut max_value = array[0];\n \
    \   let mut min_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            max_value = value;\n        } else {\n\
    \            min_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    for value in array {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    for value in array {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    for value in array {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    for value in array {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    for value in array {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    for value in array {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_value = min_value;\n    let\
    \ mut max_value = max_value;\n    for value in array {\n        if value < min_value\
    \ {\n            min_value = value;\n        }\n        if value > max_value {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n   --> /tmp/tmpzcl1xude.rs:113:17\n   \
    \ |\n113 |     let mut min_\n    |                 ^ help: add `;` here\n114 |\
    \ }\n    | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzcl1xude.rs:15:37\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------\
    \                       ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpi4wyaq3p.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpi4wyaq3p.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpi4wyaq3p.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpi4wyaq3p.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0596]: cannot borrow `array` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmpi4wyaq3p.rs:27:5\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n27 |     array.sort_unstable();\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of\
    \ moved value: `array`\n   --> /tmp/tmpi4wyaq3p.rs:27:5\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |\
    \     for value in array {\n    |                  ----- `array` moved due to\
    \ this implicit call to `.into_iter()`\n...\n27  |     array.sort_unstable();\n\
    \    |     ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `array`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |     for value in &array {\n    |         \
    \         +\n\ner"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n   \
    \ let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n \
    \   for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n   \
    \ let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n \
    \   for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n   \
    \ let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n \
    \   for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8bnhpeg2.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n115 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    120 |         if value > max_value {\n    |                              - this\
    \ delimiter might not be properly closed...\n...\n123 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp8bnhpeg2.rs:115:5\n    |\n15  |   fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |                                       ----------\
    \ expected `Vec<isize>` because of return type\n...\n115 | /     for value in\
    \ array {\n116 | |         if value < min_value {\n117 | |             min_pos\
    \ = value;\n118 | |             min_value = value;\n...   |\n133 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n134 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 0 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 0 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n            max_pos = value;\n        }\n    }\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut\
    \ max_value = array[0];\n    for value in array {\n        sum += value;\n   \
    \     if sum % 2 == 0 {\n            min_value = value;\n            min_pos =\
    \ value;\n        } else {\n            max_value = value;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos =\
    \ 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n \
    \   for value in array {\n        sum += value;\n        if sum % 2 == 0 {\n \
    \           min_value = value;\n            min_pos = value;\n        } else {\n\
    \            max_value = value;\n            max_pos = value;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 0 {\n            min_value = value;\n\
    \            min_pos = value;\n        } else {\n            max_value = value;\n\
    \            max_pos = value;\n        }\n    }\n    let mut min_pos = 0;\n  \
    \  let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 0 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 0 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6rz2x7vt.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n115 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    120 |         } else {\n    |                - this delimiter might not be properly\
    \ closed...\n...\n123 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmp6rz2x7vt.rs:115:5\n    |\n15  |   fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                       ---------- expected\
    \ `Vec<isize>` because of return type\n...\n115 | /     for value in array {\n\
    116 | |         sum += value;\n117 | |         if sum % 2 == 0 {\n118 | |    \
    \         min_value = value;\n...   |\n133 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n134 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    array.sort();\n    array[0] = min_value;\n    array[array.len()\
    \ - 1] = max_value;\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpdjet4ybj.rs:28:5\n\
    \    |\n16  |     let mut array = array.to_owned();\n    |         --------- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n20  |     for value in array {\n    |                  -----\n \
    \   |                  |\n    |                  `array` moved due to this implicit\
    \ call to `.into_iter()`\n    |                  help: consider borrowing to avoid\
    \ moving into the for loop: `&array`\n...\n28  |     array.sort();\n    |    \
    \ ^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `array`\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpdjet4ybj.rs:30:11\n\
    \   |\n30 |     array[array.len() - 1] = max_value;\n   |     ------^^^^^-----------\n\
    \   |     |     |\n   |     |     immutable borrow occurs here\n   |     mutable\
    \ borrow occurs here\n   |     mutable borrow later used here\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0502.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut len = array.len();\n    while i < len {\n        sum += array[i];\n\
    \        if sum % 2 == 1 {\n            array[j] = array[i];\n            i +=\
    \ 1;\n        } else {\n            j += 1;\n        }\n    }\n    array[j..].sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpa1d6f2az.rs:19:9\n\
    \   |\n19 |     let mut len = array.len();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpa1d6f2az.rs:23:13\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n23 |             array[j] = array[i];\n\
    \   |             ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpa1d6f2az.rs:29:5\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n29 |\
    \     array[j..].sort();\n   |     ^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for &i in &array {\n        sum += i;\n    }\n    if sum % 2 == 1 {\n   \
    \     array.sort_by_key(|&i| i);\n    } else {\n        array.sort_by_key(|&i|\
    \ -i);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpz1djdey4.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j > 0 {\n        sum += array[j];\n        j\
    \ -= 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n \
    \   } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp9ww2oosw.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp9ww2oosw.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| -x);\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp9ww2oosw.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        } else if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_value = min_value;\n    let mut max_value = max_value;\n\
    \    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos\
    \ = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_pos = min_pos;\n    let mut\
    \ max_pos = max_pos;\n    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n\
    \    let mut min_value = min_value;\n    let mut max_value = max_value;\n    let\
    \ mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos\
    \ = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_pos = min_pos;\n    let mut\
    \ max_pos = max_pos;\n    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n\
    \    let mut min_value = min_value;\n    let mut max_value = max_value;\n    let\
    \ mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos\
    \ = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_pos = min_pos;\n    let mut\
    \ max_pos = max_pos;\n    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n\
    \    let mut min_value = min_value;\n    let mut max_value = max_value;\n    let\
    \ mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos\
    \ = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_pos = min_pos;\n    let mut\
    \ max_pos = \n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp_lmqe6t1.rs:86:1\n\
    \   |\n86 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_by_key(|x| x.partial_cmp(&min_value).unwrap());\n\
    \    array.sort_by_key(|x| x.partial_cmp(&max_value).unwrap());\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpg0s665yi.rs:27:5\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n27 |     array.sort_by_key(|x| x.partial_cmp(&min_value).unwrap());\n\
    \   |     ^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of moved value:\
    \ `array`\n   --> /tmp/tmpg0s665yi.rs:27:5\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |\
    \     for value in array {\n    |                  -----\n    |              \
    \    |\n    |                  `array` moved due to this implicit call to `.into_iter()`\n\
    \    |                  help: consider borrowing to avoid moving into the for\
    \ loop: `&array`\n...\n27  |     array.sort_by_key(|x| x.partial_cmp(&min_value).unwrap());\n\
    \    |     ^^^^^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `array`\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpg0s665yi.rs:28:5\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n28 |\
    \     array.sort_by_key(|x| x.partial_cmp(&max_value).unwrap());\n   |     ^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut n = array.len();\n    while i < n {\n       \
    \ sum += array[i];\n        i += 1;\n    }\n    while j < n {\n        sum +=\
    \ array[j];\n        j += 1;\n    }\n    while k < n {\n        if sum % 2 ==\
    \ 1 {\n            array.swap(k, j);\n            k += 1;\n            j += 1;\n\
    \        } else {\n            array.swap(k, j);\n            k += 1;\n      \
    \      i += 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpdrvve85s.rs:20:9\n\
    \   |\n20 |     let mut n = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpdrvve85s.rs:31:13\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n31 |             array.swap(k, j);\n \
    \  |             ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpdrvve85s.rs:35:13\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n35 |\
    \             array.swap(k, j);\n   |             ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    }\
    \ else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgmqjwlx8.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n            min_value\
    \ = value;\n        }\n        if value > max_value {\n            max_pos = value;\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    for value in array {\n\
    \        if value < min_value {\n            min_pos = value;\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpx57ww633.rs:127:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n113 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n114\
    \ |         if value < min_value {\n    |                              - this\
    \ delimiter might not be properly closed...\n115 |             min_pos = value;\n\
    116 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    127 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpx57ww633.rs:113:5\n\
    \    |\n15  |   fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |      \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n113 | /     for value in array {\n114 | |         if value\
    \ < min_value {\n115 | |             min_pos = value;\n116 | | }\n...   |\n126\
    \ | |     assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);\n\
    127 | | }\n    | |__^ expected struct `Vec`, found `()`\n    |\n    = note: expected\
    \ struct `Vec<isize>`\n            found unit type `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     array.swap(0, array.len() - 1);\n        }\n        if sum % 2 == 0 {\n\
    \            array.swap(0, array.len() - 1);\n        }\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `min_value`\n  --> /tmp/tmp0hu5tw4y.rs:18:13\n\
    \   |\n18 |     let mut min_value = array[0];\n   |             ^^^^^^^^^ help:\
    \ if this is intentional, prefix it with an underscore: `_min_value`\n   |\n \
    \  = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable:\
    \ `max_value`\n  --> /tmp/tmp0hu5tw4y.rs:19:13\n   |\n19 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^ help: if this is intentional, prefix\
    \ it with an underscore: `_max_value`\n\nwarning: variable does not need to be\
    \ mutable\n  --> /tmp/tmp0hu5tw4y.rs:18:9\n   |\n18 |     let mut min_value =\
    \ array[0];\n   |         ----^^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmp0hu5tw4y.rs:19:9\n   |\n\
    19 |     let mut max_value = array[0];\n   |         ----^^^^^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `array`\n   --> /tmp/tmp0hu5tw4y.rs:23:13\n    |\n16  |     let mut array\
    \ = array.to_owned();\n    |         --------- move occurs because `array` has\
    \ type `Vec<isize>`, which does not implement the `Copy` trait\n...\n20  |   \
    \  for value in array {\n    |                  -----\n    |                 \
    \ |\n    |                  `array` moved due to this implicit call to `.into_iter()`\n\
    \    |                  help: consider borrowing to avoid moving into the for\
    \ loop: `&array`\n...\n23  |             array.swap(0, array.len() - 1);\n   \
    \ |             ^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `array`\n\nerror[E0502]:\
    \ cannot borrow `array` as immutable because it is also borrowed as mutable\n\
    \  --> /tmp/tmp0hu5tw4y.rs:23:27\n   |\n23 |             array.swap(0, array.len()\
    \ - 1);\n   |             ----- ----    ^^^^^ immutable borrow occurs here\n \
    \  |             |     |\n   |             |     mutable borrow later used by\
    \ call\n   |             mutable borrow occurs here\n\nerror[E0502]: cannot borrow\
    \ `array` "
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ i in array.iter() {\n        sum += i;\n        if sum % 2 == 1 {\n        \
    \    min_value = i;\n        } else {\n            max_value = i;\n        }\n\
    \    }\n    array.sort_by_key(|&x| {\n        if x == min_value {\n          \
    \  -1\n        } else if x == max_value {\n            1\n        } else {\n \
    \           x\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf951i3dj.rs:23:25\n   |\n\
    23 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf951i3dj.rs:25:25\n   |\n25 |             max_value = i;\n\
    \   |                         ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n25 |             max_value = *i;\n\
    \   |                         +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = 0;\n     \
    \       max_pos = 0;\n        } else {\n            max_value = value;\n     \
    \       max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let mut\
    \ max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n\
    \    for value in array {\n        sum += value;\n        if sum % 2 == 1 {\n\
    \            min_value = value;\n            min_pos = 0;\n            max_pos\
    \ = 0;\n        } else {\n            max_value = value;\n            max_pos\
    \ = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n            min_pos = 0;\n            max_pos = 0;\n\
    \        } else {\n            max_value = value;\n            max_pos = 0;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = 0;\n            max_pos = 0;\n        } else\
    \ {\n            max_value = value;\n            max_pos = 0;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 1 {\n            min_value = value;\n\
    \            min_pos = 0;\n            max_pos = 0;\n        } else {\n      \
    \      max_value = value;\n            max_pos = 0;\n        }\n    }\n    let\
    \ mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n\
    \    let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n            min_pos\
    \ = 0;\n            max_pos = 0;\n        } else {\n            max_value = value;\n\
    \            max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let\
    \ mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value =\
    \ array[0];\n    for value in array {\n\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpab1gn2mw.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n121 |    \
    \ for value in array {\n    |                        - this delimiter might not\
    \ be properly closed...\n122 | \n123 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpab1gn2mw.rs:15:37\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                       ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    }\
    \ else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgmqjwlx8.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpup5hxi5m.rs:15:37\n   |\n\
    15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------    \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_idx = array.iter().position(|&x|\
    \ x == min_value);\n    let mut max_idx = array.iter().position(|&x| x == max_value);\n\
    \    if min_idx < max_idx {\n        array.swap(min_idx, max_idx);\n    }\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4utgi_q2.rs:30:20\n   |\n\
    30 |         array.swap(min_idx, max_idx);\n   |                    ^^^^^^^ expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4utgi_q2.rs:30:29\n   |\n30 |         array.swap(min_idx, max_idx);\n\
    \   |                             ^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min = array[0];\n    let\
    \ mut max = array[0];\n    for x in array {\n        sum += x;\n        if sum\
    \ % 2 == 1 {\n            max = x;\n        } else {\n            min = x;\n \
    \       }\n    }\n    let mut result = vec![];\n    while min < max {\n      \
    \  result.push(min);\n        sum += min;\n        if sum % 2 == 1 {\n       \
    \     sum += min;\n        } else {\n            sum -= min;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpl84psmcl.rs:17:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort_by_key(|&x|\
    \ x.partial_cmp(&x[1..].iter().sum()));\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpy9fd8oh4.rs:17:43\n\
    \   |\n17 |     array.sort_by_key(|&x| x.partial_cmp(&x[1..].iter().sum()));\n\
    \   |                                           ^^^^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n            max_pos = value;\n        }\n    }\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut\
    \ max_value = array[0];\n    for value in array {\n        sum += value;\n   \
    \     if sum % 2 == 1 {\n            min_value = value;\n            min_pos =\
    \ value;\n        } else {\n            max_value = value;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos =\
    \ 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n \
    \   for value in array {\n        sum += value;\n        if sum % 2 == 1 {\n \
    \           min_value = value;\n            min_pos = value;\n        } else {\n\
    \            max_value = value;\n            max_pos = value;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 1 {\n            min_value = value;\n\
    \            min_pos = value;\n        } else {\n            max_value = value;\n\
    \            max_pos = value;\n        }\n    }\n    let mut min_pos = 0;\n  \
    \  let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpv3ccozlh.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n115 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    120 |         } else {\n    |                - this delimiter might not be properly\
    \ closed...\n...\n123 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpv3ccozlh.rs:115:5\n    |\n15  |   fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                       ---------- expected\
    \ `Vec<isize>` because of return type\n...\n115 | /     for value in array {\n\
    116 | |         sum += value;\n117 | |         if sum % 2 == 1 {\n118 | |    \
    \         min_value = value;\n...   |\n133 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n134 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmp4e9d_jhk.rs:22:47\n\
    \   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmp4e9d_jhk.rs:22:67\n   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len()\
    \ - 1]).reverse());\n   |                                                    \
    \               ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0608]:\
    \ cannot index into a value of type `isize`\n  --> /tmp/tmp4e9d_jhk.rs:24:47\n\
    \   |\n24 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[k]).unwrap());\n    }\n    array\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpzi3j7p75.rs:18:9\n\
    \   |\n18 |     let mut j = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpzi3j7p75.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpzi3j7p75.rs:25:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n25 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as\
    \ immutable because it is also borrowed as mutable\n  --> /tmp/tmpzi3j7p75.rs:25:27\n\
    \   |\n25 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \   |         ----- ----------- ^^^^                ----- second borrow occurs\
    \ due to use of `array` in closure\n   |         |     |           |\n   |   \
    \      |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpzi3j7p75.rs:27:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n27 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[k]).unwrap());\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as\
    \ immutable because it is also borrowed as mutable\n  --> /tmp/tmpzi3j7p75.rs:27:27\n\
    \   |\n27 |         array.sort_by_key(|&x| x.partial_cmp(&array[k]).unwrap());\n\
    \   |         ----- ----------- ^^^^                ----- second borrow occurs\
    \ due to use of `array` in closure\n   |         |     |           |\n   |   \
    \      |     |           immutable borrow "
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < k {\n        sum += array[j];\n        j\
    \ += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpdoezt1ag.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpdoezt1ag.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpdoezt1ag.rs:29:27\n\
    \   |\n29 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \   |         ----- ----------- ^^^^                ----- second borrow occurs\
    \ due to use of `array` in closure\n   |         |     |           |\n   |   \
    \      |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpdoezt1ag.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpdoezt1ag.rs:31:27\n\
    \   |\n31 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ----- ----------- ^^^^                ----- second borrow occurs\
    \ due to use of `array` in closure\n   |         |     |           |\n   |   \
    \      |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror:\
    \ aborting due to 4 previous errors; 1 warning "
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        if array[i] > array[j]\
    \ {\n            sum += array[i];\n            i += 1;\n        } else {\n   \
    \         sum += array[j];\n            j += 1;\n        }\n    }\n    if sum\
    \ % 2 == 0 {\n        array.sort_by_key(|&x| x.cmp(&array[j]));\n    } else {\n\
    \        array.sort_by_key(|&x| x.cmp(&array[i]));\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpy9fdg3bv.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpy9fdg3bv.rs:30:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n30 |         array.sort_by_key(|&x| x.cmp(&array[j]));\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpy9fdg3bv.rs:30:27\n\
    \   |\n30 |         array.sort_by_key(|&x| x.cmp(&array[j]));\n   |         -----\
    \ ----------- ^^^^        ----- second borrow occurs due to use of `array` in\
    \ closure\n   |         |     |           |\n   |         |     |           immutable\
    \ borrow occurs here\n   |         |     mutable borrow later used by call\n \
    \  |         mutable borrow occurs here\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpy9fdg3bv.rs:32:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n32 |\
    \         array.sort_by_key(|&x| x.cmp(&array[i]));\n   |         ^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpy9fdg3bv.rs:32:27\n   |\n32 |\
    \         array.sort_by_key(|&x| x.cmp(&array[i]));\n   |         ----- -----------\
    \ ^^^^        ----- second borrow occurs due to use of `array` in closure\n  \
    \ |         |     |           |\n   |         |     |           immutable borrow\
    \ occurs here\n   |         |     mutable borrow later used by call\n   |    \
    \     mutable borrow occurs here\n\nerror: aborting due to 4 previous errors;\
    \ 1 warning emitted\n\nSome errors have detailed explanations: E0502, E0596.\n\
    For more information about an error, try "
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x.iter().rev().take(array.len()\
    \ - 1).unwrap()).reverse());\n    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x.iter().rev().take(array.len()\
    \ - 1).unwrap()).reversed());\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp6qwq988x.rs:21:49\n   |\n21 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&x.iter().rev().take(array.len() - 1).unwrap()).reverse());\n\
    \   |                                                 ^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `reverse` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmp6qwq988x.rs:21:94\n   |\n21 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&x.iter().rev().take(array.len() - 1).unwrap()).reverse());\n\
    \   |                                                                        \
    \                      ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\
    \nerror[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp6qwq988x.rs:23:49\n   |\n23 |         array.sort_by_key(|&x| x.partial_cmp(&x.iter().rev().take(array.len()\
    \ - 1).unwrap()).reversed());\n   |                                          \
    \       ^^^^ method not found in `isize`\n\nerror[E0599]: no method named `reversed`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmp6qwq988x.rs:23:94\n\
    \   |\n23 |         array.sort_by_key(|&x| x.partial_cmp(&x.iter().rev().take(array.len()\
    \ - 1).unwrap()).reversed());\n   |                                          \
    \                                                    ^^^^^^^^ method not found\
    \ in `Option<std::cmp::Ordering>`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n   \
    \ let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n \
    \   for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n   \
    \ let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n \
    \   for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n   \
    \ let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n \
    \   for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8bnhpeg2.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n115 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    120 |         if value > max_value {\n    |                              - this\
    \ delimiter might not be properly closed...\n...\n123 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp8bnhpeg2.rs:115:5\n    |\n15  |   fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |                                       ----------\
    \ expected `Vec<isize>` because of return type\n...\n115 | /     for value in\
    \ array {\n116 | |         if value < min_value {\n117 | |             min_pos\
    \ = value;\n118 | |             min_value = value;\n...   |\n133 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n134 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut n = array.len();\n    while i < n {\n       \
    \ sum += array[i];\n        i += 1;\n    }\n    while j < n {\n        sum +=\
    \ array[j];\n        j += 1;\n    }\n    while k < n {\n        if sum % 2 ==\
    \ 1 {\n            array.swap(k, j);\n            k += 1;\n            j += 1;\n\
    \        } else {\n            array.swap(k, j);\n            k += 1;\n      \
    \      i += 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpdrvve85s.rs:20:9\n\
    \   |\n20 |     let mut n = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpdrvve85s.rs:31:13\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n31 |             array.swap(k, j);\n \
    \  |             ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpdrvve85s.rs:35:13\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n35 |\
    \             array.swap(k, j);\n   |             ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = min_pos +\
    \ 1;\n        } else {\n            max_value = value;\n            max_pos =\
    \ max_pos + 1;\n        }\n    }\n    if min_pos == max_pos {\n        return\
    \ array;\n    }\n    if min_pos < max_pos {\n        array.swap(0, min_pos);\n\
    \        sort_array(array);\n        array.swap(0, min_pos);\n    } else {\n \
    \       array.swap(0, max_pos);\n        sort_array(array);\n        array.swap(0,\
    \ max_pos);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmp7lrck6z7.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmp7lrck6z7.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmp7lrck6z7.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmp7lrck6z7.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: variable `min_value` is assigned to, but never\
    \ used\n  --> /tmp/tmp7lrck6z7.rs:29:13\n   |\n29 |     let mut min_value = array[0];\n\
    \   |             ^^^^^^^^^\n   |\n   = note: consider using `_min_value` instead\n\
    \nwarning: variable `max_value` is assigned to, but never used\n  --> /tmp/tmp7lrck6z7.rs:30:13\n\
    \   |\n30 |     let mut max_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: consider using `_max_value` instead\n\nwarning: value assigned\
    \ to `min_value` is never read\n  --> /tmp/tmp7lrck6z7.rs:34:13\n   |\n34 |  \
    \           min_value = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe\
    \ it is overwritten before being read?\n\nwarning: value assigned to `max_value`\
    \ is never read\n  --> /tmp/tmp7lrck6z7.rs:37:13\n   |\n37 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmp7lrck6z7.rs:29:25\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, whic"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpi4wyaq3p.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpi4wyaq3p.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpi4wyaq3p.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpi4wyaq3p.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0596]: cannot borrow `array` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmpi4wyaq3p.rs:27:5\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n27 |     array.sort_unstable();\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of\
    \ moved value: `array`\n   --> /tmp/tmpi4wyaq3p.rs:27:5\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |\
    \     for value in array {\n    |                  ----- `array` moved due to\
    \ this implicit call to `.into_iter()`\n...\n27  |     array.sort_unstable();\n\
    \    |     ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `array`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n19  |     for value in &array {\n    |         \
    \         +\n\ner"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       if sum % 2 == 1 {\n            j = i;\n        } else {\n            k\
    \ = i;\n        }\n        i += 1;\n    }\n    let mut result = vec![];\n    while\
    \ i < k {\n        result.push(array[i]);\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5]`', /tmp/tmpzc4y0otg.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut len = array.len();\n    while i < len {\n        sum += array[i];\n\
    \        i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[j]).unwrap().reverse());\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpjut0spvq.rs:18:9\n\
    \   |\n18 |     let mut j = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpjut0spvq.rs:19:9\n\
    \   |\n19 |     let mut len = array.len();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpjut0spvq.rs:25:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n25 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror[E0502]: cannot borrow `array` as immutable because it is\
    \ also borrowed as mutable\n  --> /tmp/tmpjut0spvq.rs:25:27\n   |\n25 |      \
    \   array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |         ------------------^^^^-----------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpjut0spvq.rs:27:9\n   |\n15 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |               ----- help: consider changing this to be mutable:\
    \ `mut array`\n...\n27 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpjut0spvq.rs:27:27\n  \
    \ |\n27 |         array.sort_by_key(|&x| x.partial_cmp(&"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       if sum % 2 == 1 {\n            j = i;\n        } else {\n            k\
    \ = i;\n        }\n        i += 1;\n    }\n    let mut result = vec![];\n    while\
    \ i < k {\n        result.push(array[i]);\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5]`', /tmp/tmpzc4y0otg.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_pos = min_value;\n            min_sum = sum;\n\
    \        }\n        if sum > max_sum {\n            max_pos = max_value;\n   \
    \         max_sum = sum;\n        }\n        min_value = value;\n        max_value\
    \ = value;\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_sum = 0;\n    let mut max_sum = 0;\n    for value in array {\n     \
    \   let sum = value + min_value;\n        if sum < min_sum {\n            min_pos\
    \ = min_value;\n            min_sum = sum;\n        }\n        if sum > max_sum\
    \ {\n            max_pos = max_value;\n            max_sum = sum;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_sum\
    \ = 0;\n    let mut max_sum = 0;\n    for value in array {\n        let sum =\
    \ value + min_value;\n        if sum < min_sum {\n            min_pos = min_value;\n\
    \            min_sum = sum;\n        }\n        if sum > max_sum {\n         \
    \   max_pos = max_value;\n            max_sum = sum;\n        }\n    }\n    let\
    \ mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_sum = 0;\n    let\
    \ mut max_sum = 0;\n    for value in array {\n        let sum = value + min_value;\n\
    \        if sum < min_sum {\n            min_pos = min_value;\n            min_sum\
    \ = sum;\n        }\n        if sum > max_sum {\n            max_pos = max_value;\n\
    \            max_sum = sum;\n        }\n    }\n    let mut min_pos = 0;\n    let\
    \ mut max_pos = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n    for\
    \ value in array {\n        let sum = value + min_value;\n        if sum < min_sum\
    \ {\n            min_pos = min_value;\n            min_sum = sum;\n        }\n\
    \        if sum > max_sum {\n            max_pos = max_value;\n            max_sum\
    \ = sum;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_sum = 0;\n    let mut max_sum = 0;\n    for value in array {\n\
    \        let sum = value + min_value;\n        if sum < min_sum {\n          \
    \  min_pos = min_value;\n            min_\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpel05elmg.rs:124:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n108 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n109\
    \ |         let sum = value + min_value;\n110 |         if sum < min_sum {\n \
    \   |                          - this delimiter might not be properly closed...\n\
    ...\n113 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n124 | }\n    |   ^\n\nerror[E0425]: cannot find value `min_` in this scope\n\
    \   --> /tmp/tmpel05elmg.rs:112:13\n    |\n112 |             min_\n    |     \
    \        ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpel05elmg.rs:108:5\n    |\n15  |   fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                       ---------- expected\
    \ `Vec<isize>` because of return type\n...\n108 | /     for value in array {\n\
    109 | |         let sum = value + min_value;\n110 | |         if sum < min_sum\
    \ {\n111 | |             min_pos = min_value;\n...   |\n123 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n124 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    for value in array {\n        if value == min_value\
    \ {\n            min_pos = 0;\n        }\n        if value == max_value {\n  \
    \          max_pos = array.len();\n        }\n        if value < min_value {\n\
    \            min_pos = array.len();\n        }\n        if value > max_value {\n\
    \            max_pos = 0;\n        }\n    }\n    let mut min_value = min_value;\n\
    \    let mut max_value = max_value;\n    let mut min_pos = min_pos;\n    let mut\
    \ max_pos = max_pos;\n    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n\
    \    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos\
    \ = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos = min_pos;\n\
    \    let mut max_pos = max_pos;\n    let mut min_pos = min_pos;\n    let mut max_pos\
    \ = max_pos;\n    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n\
    \    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos\
    \ = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos = min_pos;\n\
    \    let mut max_pos = max_pos;\n    let mut min_pos = min_pos;\n    let mut max_pos\
    \ = max_pos;\n    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n\
    \    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos\
    \ = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos = min_pos;\n\
    \    let mut max_pos = max_pos;\n    let mut min_pos = min_pos;\n    let mut max_pos\
    \ = max_pos;\n    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n\
    \    let mut min_pos = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos\
    \ = min_pos;\n    let mut max_pos = max_pos;\n    let mut min_pos = min_pos;\n\
    \    let mut max_pos = max_pos;\n    let mut min_pos = min_pos;\n    let mut \n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpg0inhdkc.rs:87:1\n\
    \   |\n87 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &x in array {\n        sum +=\
    \ x;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n    }\
    \ else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd3fy6tt4.rs:17:9\n   |\n\
    17 |     for &x in array {\n   |         ^^    ----- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n\
    \    } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpecuqo56w.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| -x);\n   |  \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmpecuqo56w.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| -x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpecuqo56w.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0596.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut n = array.len();\n    while i < n {\n       \
    \ sum += array[i];\n        if sum % 2 == 0 {\n            array[j++] = array[i];\n\
    \            i += 1;\n        } else {\n            array[k++] = array[i];\n \
    \           i += 1;\n        }\n    }\n    array[j..k].sort();\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp17z3toi6.rs:24:21\n\
    \   |\n24 |             array[j++] = array[i];\n   |                     ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp17z3toi6.rs:27:21\n\
    \   |\n27 |             array[k++] = array[i];\n   |                     ^ expected\
    \ expression\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    if min_pos < max_pos {\n \
    \       array.swap(0, min_pos);\n        array.swap(min_pos + 1, max_pos);\n \
    \   }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4dud5a94.rs:56:23\n   |\n\
    56 |         array.swap(0, min_pos);\n   |                       ^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n56 |         array.swap(0,\
    \ min_pos.try_into().unwrap());\n   |                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4dud5a94.rs:57:20\n   |\n57 |\
    \         array.swap(min_pos + 1, max_pos);\n   |                    ^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n57 |         array.swap((min_pos\
    \ + 1).try_into().unwrap(), max_pos);\n   |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4dud5a94.rs:57:33\n   |\n57 |\
    \         array.swap(min_pos + 1, max_pos);\n   |                            \
    \     ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n57\
    \ |         array.swap(min_pos + 1, max_pos.try_into().unwrap());\n   |      \
    \                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = array.len();\n    let mut max_pos\
    \ = array.len();\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n\
    \    for value in array {\n        sum += value;\n        if sum % 2 == 0 {\n\
    \            min_value = value;\n        } else {\n            max_value = value;\n\
    \        }\n        if value < min_value {\n            min_pos = min_pos;\n \
    \       }\n        if value > max_value {\n            max_pos = max_pos;\n  \
    \      }\n    }\n    if min_pos < max_pos {\n        array.swap(min_pos, max_pos);\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmp4mryl7la.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmp4mryl7la.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmp4mryl7la.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmp4mryl7la.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: unused variable: `min_pos`\n  --> /tmp/tmp4mryl7la.rs:27:13\n\
    \   |\n27 |     let mut min_pos = 0;\n   |             ^^^^^^^ help: if this is\
    \ intentional, prefix it with an underscore: `_min_pos`\n\nwarning: unused variable:\
    \ `max_pos`\n  --> /tmp/tmp4mryl7la.rs:28:13\n   |\n28 |     let mut max_pos =\
    \ 0;\n   |             ^^^^^^^ help: if this is intentional, prefix it with an\
    \ underscore: `_max_pos`\n\nwarning: variable does not need to be mutable\n  -->\
    \ /tmp/tmp4mryl7la.rs:27:9\n   |\n27 |     let mut min_pos = 0;\n   |        \
    \ ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n  \
    \ = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n  --> /tmp/tmp4mryl7la.rs:28:9\n   |\n28 |     let mut max_pos\
    \ = 0;\n   |         ----^^^^^^^\n   |         |\n   |         help: remove this\
    \ `mut`\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmp4mryl7la.rs:29:23\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Co"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_pos = value;\n    \
    \    }\n        if sum > max_sum {\n            max_sum = sum;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_pos = min_pos - min_value;\n   \
    \ let mut max_pos = max_pos - max_value;\n    let mut min_sum = min_sum - min_value;\n\
    \    let mut max_sum = max_sum - max_value;\n    let mut min_value = min_value\
    \ - min_value;\n    let mut max_value = max_value - max_value;\n    let mut min_sum\
    \ = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n    let\
    \ mut min_value = min_value - min_value;\n    let mut max_value = max_value -\
    \ max_value;\n    let mut min_sum = min_sum - min_value;\n    let mut max_sum\
    \ = max_sum - max_value;\n    let mut min_value = min_value - min_value;\n   \
    \ let mut max_value = max_value - max_value;\n    let mut min_sum = min_sum -\
    \ min_value;\n    let mut max_sum = max_sum - max_value;\n    let mut min_value\
    \ = min_value - min_value;\n    let mut max_value = max_value - max_value;\n \
    \   let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n\
    \    let mut min_value = min_value - min_value;\n    let mut max_value = max_value\
    \ - max_value;\n    let mut min_sum = min_sum - min_value;\n    let mut max_sum\
    \ = max_sum - max_value;\n    let mut min_value = min_value - min_value;\n   \
    \ let mut max_value = max_value - max_value;\n    let mut min_sum = min_sum -\
    \ min_value;\n    let mut max_sum = max_sum - max_value;\n    let mut min_value\
    \ = min_value - min_value;\n    let mut max_value = max_value - max_value;\n \
    \   let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n\
    \    let mut min_value = min_value - min_value;\n    let mut max_value = max_value\
    \ - max_value;\n    let mut min_sum = min_sum - min_value;\n    let mut max_sum\
    \ = max_sum - max_value;\n    let mut \n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp4trduhgs.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort_by_key(|&x|\
    \ {\n        if x.is_odd() {\n            x.to_owned()\n        } else {\n   \
    \         -x.to_owned()\n        }\n    });\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_odd` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpoqbbu52_.rs:18:14\n   |\n18 |         if x.is_odd() {\n\
    \   |              ^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       if sum % 2 == 1 {\n            j = i;\n        } else {\n            k\
    \ = i;\n        }\n        i += 1;\n    }\n    let mut result = vec![];\n    while\
    \ i < k {\n        result.push(array[i]);\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5]`', /tmp/tmpzc4y0otg.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    array.sort();\n   \
    \ array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpzdv54qhg.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < array.len() {\n       \
    \ sum += array[i];\n        i += 1;\n    }\n    while j < array.len() {\n    \
    \    if sum % 2 == 1 {\n            array[j].swap(array[j + 1]);\n           \
    \ j += 1;\n        } else {\n            array[j].swap(array[j - 1]);\n      \
    \      j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpnuq5nl9g.rs:26:22\n   |\n26 |             array[j].swap(array[j\
    \ + 1]);\n   |                      ^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `swap` found for type `isize` in the current scope\n  --> /tmp/tmpnuq5nl9g.rs:29:22\n\
    \   |\n29 |             array[j].swap(array[j - 1]);\n   |                   \
    \   ^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort_unstable();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpl7knck7a.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_val = array[0];\n   \
    \ let mut max_val = array[0];\n    for val in array {\n        sum += val;\n \
    \       if sum % 2 == 1 {\n            min_val = val;\n        } else {\n    \
    \        max_val = val;\n        }\n    }\n    array.sort();\n    if min_val ==\
    \ max_val {\n        array\n    } else {\n        array.sort_by(|a, b| {\n   \
    \         if a < b {\n                a\n            } else {\n              \
    \  b\n            }\n        });\n    }\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuzugehfg.rs:33:17\n   |\n\
    33 |                 a\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuzugehfg.rs:35:17\n\
    \   |\n35 |                 b\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuzugehfg.rs:30:12\n\
    \   |\n30 |       } else {\n   |  ____________^\n31 | |         array.sort_by(|a,\
    \ b| {\n32 | |             if a < b {\n33 | |                 a\n...  |\n37 |\
    \ |         });\n38 | |     }\n   | |_____^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min = array[0];\n    let\
    \ mut max = array[0];\n    for x in array {\n        sum += x;\n        if sum\
    \ % 2 == 0 {\n            max = x;\n        } else {\n            min = x;\n \
    \       }\n    }\n    let mut result: Vec<isize> = vec![];\n    for x in array\
    \ {\n        if min <= x && x <= max {\n            result.push(x);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `array`\n   --> /tmp/tmp5d7p2m7s.rs:28:14\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for x in array {\n    |         \
    \     -----\n    |              |\n    |              `array` moved due to this\
    \ implicit call to `.into_iter()`\n    |              help: consider borrowing\
    \ to avoid moving into the for loop: `&array`\n...\n28  |     for x in array {\n\
    \    |              ^^^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `array`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n            max_pos = value;\n        }\n    }\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut\
    \ max_value = array[0];\n    for value in array {\n        sum += value;\n   \
    \     if sum % 2 == 1 {\n            min_value = value;\n            min_pos =\
    \ value;\n        } else {\n            max_value = value;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos =\
    \ 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n \
    \   for value in array {\n        sum += value;\n        if sum % 2 == 1 {\n \
    \           min_value = value;\n            min_pos = value;\n        } else {\n\
    \            max_value = value;\n            max_pos = value;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 1 {\n            min_value = value;\n\
    \            min_pos = value;\n        } else {\n            max_value = value;\n\
    \            max_pos = value;\n        }\n    }\n    let mut min_pos = 0;\n  \
    \  let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpv3ccozlh.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n115 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    120 |         } else {\n    |                - this delimiter might not be properly\
    \ closed...\n...\n123 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpv3ccozlh.rs:115:5\n    |\n15  |   fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                       ---------- expected\
    \ `Vec<isize>` because of return type\n...\n115 | /     for value in array {\n\
    116 | |         sum += value;\n117 | |         if sum % 2 == 1 {\n118 | |    \
    \         min_value = value;\n...   |\n133 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n134 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = vec![];\n    while i < array.len() {\n        sum += array[i];\n\
    \        if sum % 2 == 1 {\n            result.push(array[i]);\n            i\
    \ += 1;\n        } else {\n            result.push(array[j]);\n            j +=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 6 but the
    index is 6'', /tmp/tmpc6u3m6o5.rs:26:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&i| i);\n    } else {\n        array.sort_by_key(|&i|\
    \ -i);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpao9rvtk8.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n   \
    \ let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n \
    \   for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n   \
    \ let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n \
    \   for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n            max_value = value;\n        }\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    for value in array {\n        if value <\
    \ min_value {\n            min_pos = value;\n            min_value = value;\n\
    \        }\n        if value > max_value {\n            max_pos = value;\n   \
    \         max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n   \
    \ let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n \
    \   for value in array {\n        if value < min_value {\n            min_pos\
    \ = value;\n            min_value = value;\n        }\n        if value > max_value\
    \ {\n            max_pos = value;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8bnhpeg2.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n115 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    120 |         if value > max_value {\n    |                              - this\
    \ delimiter might not be properly closed...\n...\n123 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp8bnhpeg2.rs:115:5\n    |\n15  |   fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |                                       ----------\
    \ expected `Vec<isize>` because of return type\n...\n115 | /     for value in\
    \ array {\n116 | |         if value < min_value {\n117 | |             min_pos\
    \ = value;\n118 | |             min_value = value;\n...   |\n133 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n134 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut len = array.len();\n    while i < len {\n        sum += array[i];\n\
    \        if sum % 2 == 0 {\n            i += 1;\n        } else {\n          \
    \  j += 1;\n        }\n    }\n    let mut result = vec![];\n    while i < len\
    \ {\n        result.push(array[i]);\n        i += 1;\n    }\n    while j < len\
    \ {\n        result.push(array[j]);\n        j += 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5]`', /tmp/tmphofc5xq8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < k {\n        sum += array[j];\n        j\
    \ += 1;\n    }\n    if sum % 2 != 0 {\n        array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp8vf8z2kh.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp8vf8z2kh.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmp8vf8z2kh.rs:29:27\n\
    \   |\n29 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \   |         ----- ----------- ^^^^                ----- second borrow occurs\
    \ due to use of `array` in closure\n   |         |     |           |\n   |   \
    \      |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8vf8z2kh.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ^^^^^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmp8vf8z2kh.rs:31:27\n\
    \   |\n31 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ----- ----------- ^^^^                ----- second borrow occurs\
    \ due to use of `array` in closure\n   |         |     |           |\n   |   \
    \      |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror:\
    \ aborting due to 4 previous errors; 1 warning "
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() == 0 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    let mut min = array[0];\n    let mut max = array[0];\n\
    \    for &i in array {\n        sum += i;\n        if sum % 2 == 1 {\n       \
    \     max = i;\n        } else {\n            min = i;\n        }\n    }\n   \
    \ let mut array = array;\n    array.sort();\n    let mut i = 0;\n    let mut j\
    \ = 0;\n    while i < array.len() && j < array.len() {\n        if array[i] >\
    \ array[j] {\n            array[j] = array[i];\n            i += 1;\n        }\
    \ else {\n            j += 1;\n        }\n    }\n    while i < array.len() {\n\
    \        array[j] = array[i];\n        i += 1;\n        j += 1;\n    }\n    array[j..].sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy5cw8ju3.rs:22:9\n   |\n\
    22 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for x in array {\n        sum +=\
    \ x;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|x| -x)\n    } else\
    \ {\n        array.sort_by_key(|x| x)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxiakw5em.rs:21:9\n   |\n\
    15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n21 |         array.sort_by_key(|x| -x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxiakw5em.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n...\n23 |         array.sort_by_key(|x| x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    for value in array {\n        if value == min_value {\n            min_pos\
    \ = min_pos + 1;\n        }\n        if value == max_value {\n            max_pos\
    \ = max_pos + 1;\n        }\n    }\n    if min_pos == max_pos {\n        return\
    \ array;\n    }\n    if min_pos < max_pos {\n        array.swap(0, min_pos);\n\
    \        sort_array(array);\n        array.swap(0, min_pos);\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `min_pos`\n  --> /tmp/tmpn2v60n1c.rs:27:13\n\
    \   |\n27 |     let mut min_pos = 0;\n   |             ^^^^^^^ help: if this is\
    \ intentional, prefix it with an underscore: `_min_pos`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: unused variable: `max_pos`\n  --> /tmp/tmpn2v60n1c.rs:28:13\n\
    \   |\n28 |     let mut max_pos = 0;\n   |             ^^^^^^^ help: if this is\
    \ intentional, prefix it with an underscore: `_max_pos`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpn2v60n1c.rs:27:9\n   |\n27 |     let mut\
    \ min_pos = 0;\n   |         ----^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpn2v60n1c.rs:28:9\n   |\n\
    28 |     let mut max_pos = 0;\n   |         ----^^^^^^^\n   |         |\n   |\
    \         help: remove this `mut`\n\nerror[E0382]: use of moved value: `array`\n\
    \   --> /tmp/tmpn2v60n1c.rs:31:18\n    |\n15  | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    |               ----- move occurs because `array` has type\
    \ `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |     for\
    \ value in array {\n    |                  -----\n    |                  |\n \
    \   |                  `array` moved due to this implicit call to `.into_iter()`\n\
    \    |                  help: consider borrowing to avoid moving into the for\
    \ loop: `&array`\n...\n31  |     for value in array {\n    |                 \
    \ ^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `array`\n\nerror[E0382]: use of moved value:\
    \ `array`\n  --> /tmp/tmpn2v60n1c.rs:40:16\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- move occurs because `array` has type\
    \ `Vec<isize>`, which does not implement the `Copy` trait\n...\n31 |     for value\
    \ in array {\n   |                  -----\n   |                  |\n   |     \
    \             `array` moved due to this implicit call to `.into_iter()`\n   |\
    \                  help: consider borrowing"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 0 {\n            min_value = value;\n            min_pos = 0;\n     \
    \       max_pos = 0;\n        } else {\n            max_value = value;\n     \
    \       max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let mut\
    \ max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n\
    \    for value in array {\n        sum += value;\n        if sum % 2 == 0 {\n\
    \            min_value = value;\n            min_pos = 0;\n            max_pos\
    \ = 0;\n        } else {\n            max_value = value;\n            max_pos\
    \ = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 0 {\n       \
    \     min_value = value;\n            min_pos = 0;\n            max_pos = 0;\n\
    \        } else {\n            max_value = value;\n            max_pos = 0;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 0 {\n            min_value\
    \ = value;\n            min_pos = 0;\n            max_pos = 0;\n        } else\
    \ {\n            max_value = value;\n            max_pos = 0;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 0 {\n            min_value = value;\n\
    \            min_pos = 0;\n            max_pos = 0;\n        } else {\n      \
    \      max_value = value;\n            max_pos = 0;\n        }\n    }\n    let\
    \ mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n\
    \    let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n            min_pos\
    \ = 0;\n            max_pos = 0;\n        } else {\n            max_value = value;\n\
    \            max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let\
    \ mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value =\
    \ array[0];\n    for value in array {\n\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0czjfubm.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n121 |    \
    \ for value in array {\n    |                        - this delimiter might not\
    \ be properly closed...\n122 | \n123 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0czjfubm.rs:15:37\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                       ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = 0;\n     \
    \       max_pos = 0;\n        } else {\n            max_value = value;\n     \
    \       max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let mut\
    \ max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n\
    \    for value in array {\n        sum += value;\n        if sum % 2 == 1 {\n\
    \            min_value = value;\n            min_pos = 0;\n            max_pos\
    \ = 0;\n        } else {\n            max_value = value;\n            max_pos\
    \ = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n            min_pos = 0;\n            max_pos = 0;\n\
    \        } else {\n            max_value = value;\n            max_pos = 0;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = 0;\n            max_pos = 0;\n        } else\
    \ {\n            max_value = value;\n            max_pos = 0;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 1 {\n            min_value = value;\n\
    \            min_pos = 0;\n            max_pos = 0;\n        } else {\n      \
    \      max_value = value;\n            max_pos = 0;\n        }\n    }\n    let\
    \ mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n\
    \    let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n            min_pos\
    \ = 0;\n            max_pos = 0;\n        } else {\n            max_value = value;\n\
    \            max_pos = 0;\n        }\n    }\n    let mut min_pos = 0;\n    let\
    \ mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value =\
    \ array[0];\n    for value in array {\n\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpab1gn2mw.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n121 |    \
    \ for value in array {\n    |                        - this delimiter might not\
    \ be properly closed...\n122 | \n123 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpab1gn2mw.rs:15:37\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |    ----------                       ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 0 {\n            if value < min_value {\n                min_value =\
    \ value;\n                min_pos = 0;\n            } else {\n               \
    \ min_pos = min_pos + 1;\n            }\n        } else {\n            if value\
    \ > max_value {\n                max_value = value;\n                max_pos =\
    \ 0;\n            } else {\n                max_pos = max_pos + 1;\n         \
    \   }\n        }\n    }\n    if min_pos == max_pos {\n        return array;\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 0 {\n            if value < min_value\
    \ {\n                min_value = value;\n                min_pos = 0;\n      \
    \      } else {\n                min_pos = min_pos + 1;\n            }\n     \
    \   } else {\n            if value > max_value {\n                max_value =\
    \ value;\n                max_pos = 0;\n            } else {\n               \
    \ max_pos = max_pos + 1;\n            }\n        }\n    }\n    if min_pos == max_pos\
    \ {\n        return array;\n    }\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n\
    \    for value in array {\n        sum += value;\n        if sum % 2 == 0 {\n\
    \            if value < min_value {\n                min_value = value;\n    \
    \            min_pos = 0;\n            } else {\n                min_pos = min_pos\
    \ + 1;\n            }\n        } else {\n            if value > max_value {\n\
    \                max_value = value;\n                max_pos = 0;\n          \
    \  } else {\n                max_pos = max_pos + 1;\n            }\n        }\n\
    \    }\n    if min_pos == max_pos {\n        return array;\n    }\n    let mut\
    \ min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n\
    \    let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            if value < min_value {\n             \
    \   min_value = value;\n                min_pos = 0;\n            } else {\n \
    \               min_pos = min_pos + 1;\n            }\n        } else {\n    \
    \        if value > max_value {\n                max_value = value;\n        \
    \        max_pos = 0;\n            } else {\n                max_pos = max_pos\
    \ + 1;\n            }\n        }\n    }\n    if min_pos == max_pos {\n       \
    \ return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3xrcn3i5.rs:137:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n124 |    \
    \ if min_pos == max_pos {\n    |                           - this delimiter might\
    \ not be properly closed...\n125 |         return array;\n126 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n137 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3xrcn3i5.rs:15:37\n   |\n15 | fn\
    \ sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------          \
    \             ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |  \
    \  implicitly returns `()` as its body has no tail or `return` expression\n  \
    \ |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    let mut sum = 0;\n\
    \    for &x in &array {\n        sum += x;\n    }\n    if sum % 2 == 1 {\n   \
    \     array.sort_by_key(|&x| x);\n    } else {\n        array.sort_by_key(|&x|\
    \ -x);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpszkjrqaf.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n\
    \    for value in array {\n        let sum = value + min_value;\n        if sum\
    \ < min_sum {\n            min_pos = min_value;\n            min_sum = sum;\n\
    \        }\n        if sum > max_sum {\n            max_pos = max_value;\n   \
    \         max_sum = sum;\n        }\n        min_value = value;\n        max_value\
    \ = value;\n    }\n    let mut min_value = array[0];\n    let mut max_value =\
    \ array[0];\n    for value in array {\n        let sum = value + min_value;\n\
    \        if sum < min_sum {\n            min_pos = min_value;\n            min_sum\
    \ = sum;\n        }\n        if sum > max_sum {\n            max_pos = max_value;\n\
    \            max_sum = sum;\n        }\n        min_value = value;\n        max_value\
    \ = value;\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_sum = 0;\n    let mut max_sum = 0;\n    for value in array {\n     \
    \   let sum = value + min_value;\n        if sum < min_sum {\n            min_pos\
    \ = min_value;\n            min_sum = sum;\n        }\n        if sum > max_sum\
    \ {\n            max_pos = max_value;\n            max_sum = sum;\n        }\n\
    \        min_value = value;\n        max_value = value;\n    }\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       let sum = value + min_value;\n        if sum < min_sum {\n           \
    \ min_pos = min_value;\n            min_sum = sum;\n        }\n        if sum\
    \ > max_sum {\n            max_pos = max_value;\n            max_sum = sum;\n\
    \        }\n        min_value = value;\n        max_value = value;\n    }\n  \
    \  let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_sum = 0;\n\
    \    let mut max_sum = 0;\n    for value in array {\n        let sum = value +\
    \ min_value;\n        if sum < min_sum {\n            min_pos = min_value;\n \
    \           min_sum = sum;\n        }\n        if sum > max_sum {\n          \
    \  max_pos = max_value;\n            max_sum = sum;\n        }\n        min_value\
    \ = value;\n        max_value = value;\n    }\n    let mut min_value = array[0];\n\
    \    let mut max_value = array[0];\n    for value in array {\n        let sum\
    \ = value + min_value;\n        if sum < min_sum {\n            min_pos = min_value;\n\
    \            min_sum = sum;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfi6r5iky.rs:127:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n110 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n111\
    \ |         let sum = value + min_value;\n112 |         if sum < min_sum {\n \
    \   |                          - this delimiter might not be properly closed...\n\
    ...\n116 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n127 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpfi6r5iky.rs:110:5\n\
    \    |\n15  |   fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |      \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n110 | /     for value in array {\n111 | |         let sum\
    \ = value + min_value;\n112 | |         if sum < min_sum {\n113 | |          \
    \   min_pos = min_value;\n...   |\n126 | |     assert_eq!(candidate(vec![21, 14,\
    \ 23, 11]), vec![23, 21, 14, 11]);\n127 | | }\n    | |__^ expected struct `Vec`,\
    \ found `()`\n    |\n    = note: expected struct `Vec<isize>`\n            found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort_by_key(|&x|\
    \ x.partial_cmp(&x.last()));\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `last` exists for type `isize`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpp854_fh1.rs:17:45\n   |\n17 |     array.sort_by_key(|&x|\
    \ x.partial_cmp(&x.last()));\n   |                                           \
    \  ^^^^ method cannot be called on `isize` due to unsatisfied trait bounds\n \
    \  |\n   = note: the following trait bounds were not satisfied:\n           `isize:\
    \ Iterator`\n           which is required by `&mut isize: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &x in array {\n        sum +=\
    \ x;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n    }\
    \ else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd3fy6tt4.rs:17:9\n   |\n\
    17 |     for &x in array {\n   |         ^^    ----- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut max_index = 0;\n    let mut\
    \ min_index = 0;\n    let mut max_value = array[0];\n    let mut min_value = array[0];\n\
    \    for value in array {\n        sum += value;\n        if sum % 2 == 1 {\n\
    \            max_value = value;\n            max_index = array.len() - 1;\n  \
    \      } else {\n            min_value = value;\n            min_index = array.len()\
    \ - 1;\n        }\n    }\n    let mut array = array.clone();\n    array.sort_by_key(|&x|\
    \ {\n        if x > max_value {\n            max_value;\n        } else if x <\
    \ min_value {\n            min_value;\n        } else {\n            sum;\n  \
    \      }\n    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `max_index` is assigned to, but never used\n  --> /tmp/tmplr_k984r.rs:17:13\n\
    \   |\n17 |     let mut max_index = 0;\n   |             ^^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_variables)]` on by default\n   = note: consider using `_max_index`\
    \ instead\n\nwarning: variable `min_index` is assigned to, but never used\n  -->\
    \ /tmp/tmplr_k984r.rs:18:13\n   |\n18 |     let mut min_index = 0;\n   |     \
    \        ^^^^^^^^^\n   |\n   = note: consider using `_min_index` instead\n\nwarning:\
    \ value assigned to `max_index` is never read\n  --> /tmp/tmplr_k984r.rs:25:13\n\
    \   |\n25 |             max_index = array.len() - 1;\n   |             ^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe\
    \ it is overwritten before being read?\n\nwarning: value assigned to `min_index`\
    \ is never read\n  --> /tmp/tmplr_k984r.rs:28:13\n   |\n28 |             min_index\
    \ = array.len() - 1;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0382]: borrow of moved value: `array`\n\
    \   --> /tmp/tmplr_k984r.rs:25:25\n    |\n15  | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    |               ----- move occurs because `array` has type\
    \ `Vec<isize>`, which does not implement the `Copy` trait\n...\n21  |     for\
    \ value in array {\n    |                  -----\n    |                  |\n \
    \   |                  `array` moved due to this implicit call to `.into_iter()`\n\
    \    |                  help: consider borrowing to avoid moving into the for\
    \ loop: `&array`\n...\n25  |             max_index = array.len() - 1;\n    | \
    \                        ^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `array`\n\nerror:\
    \ aborting due to previous error; 4 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut max_index = 0;\n    let mut\
    \ min_index = 0;\n    for index in array.iter().rev() {\n        sum += *index;\n\
    \        if sum % 2 == 1 {\n            max_index = index;\n        } else {\n\
    \            min_index = index;\n        }\n    }\n    let mut result = vec![];\n\
    \    for index in array.iter().rev() {\n        if *index >= min_index {\n   \
    \         result.push(*index);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4xibuvto.rs:22:25\n   |\n\
    22 |             max_index = index;\n   |                         ^^^^^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    22 |             max_index = *index;\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4xibuvto.rs:24:25\n   |\n24 |             min_index\
    \ = index;\n   |                         ^^^^^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |             min_index\
    \ = *index;\n   |                         +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n\
    \    let mut min_pos = 0;\n    let mut max_pos = 0;\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjctw4oen.rs:15:37\n   |\n\
    15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------    \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n            max_pos = value;\n        }\n    }\n    let mut min_pos\
    \ = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut\
    \ max_value = array[0];\n    for value in array {\n        sum += value;\n   \
    \     if sum % 2 == 1 {\n            min_value = value;\n            min_pos =\
    \ value;\n        } else {\n            max_value = value;\n            max_pos\
    \ = value;\n        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos =\
    \ 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n \
    \   for value in array {\n        sum += value;\n        if sum % 2 == 1 {\n \
    \           min_value = value;\n            min_pos = value;\n        } else {\n\
    \            max_value = value;\n            max_pos = value;\n        }\n   \
    \ }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 1 {\n            min_value = value;\n\
    \            min_pos = value;\n        } else {\n            max_value = value;\n\
    \            max_pos = value;\n        }\n    }\n    let mut min_pos = 0;\n  \
    \  let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            min_value = value;\n            min_pos = value;\n \
    \       } else {\n            max_value = value;\n            max_pos = value;\n\
    \        }\n    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let\
    \ mut min_value = array[0];\n    let mut max_value = array[0];\n    for value\
    \ in array {\n        sum += value;\n        if sum % 2 == 1 {\n            min_value\
    \ = value;\n            min_pos = value;\n        } else {\n            max_value\
    \ = value;\n\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpv3ccozlh.rs:134:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n115 |    \
    \ for value in array {\n    |                        - unclosed delimiter\n...\n\
    120 |         } else {\n    |                - this delimiter might not be properly\
    \ closed...\n...\n123 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpv3ccozlh.rs:115:5\n    |\n15  |   fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n    |                                       ---------- expected\
    \ `Vec<isize>` because of return type\n...\n115 | /     for value in array {\n\
    116 | |         sum += value;\n117 | |         if sum % 2 == 1 {\n118 | |    \
    \         min_value = value;\n...   |\n133 | |     assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n134 | | }\n    | |__^ expected struct\
    \ `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n       \
    \     found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() <= 1 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    let mut min_val = array[0];\n    let mut max_val = array[0];\n\
    \    for val in array {\n        sum += val;\n        if sum % 2 == 0 {\n    \
    \        min_val = val;\n        } else {\n            max_val = val;\n      \
    \  }\n    }\n    let mut min_idx = array.iter().position(|&x| x == min_val).unwrap();\n\
    \    let mut max_idx = array.iter().position(|&x| x == max_val).unwrap();\n  \
    \  if min_val < max_val {\n        sort_array(&array[min_idx..max_idx]);\n   \
    \ } else {\n        sort_array(&array[max_idx..min_idx]);\n    }\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprdqgj3l8.rs:33:20\n   |\n\
    33 |         sort_array(&array[min_idx..max_idx]);\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&[isize]`\nhelp: try using a conversion method\n\
    \   |\n33 |         sort_array((&array[min_idx..max_idx]).to_vec());\n   |   \
    \                 +                        ++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprdqgj3l8.rs:32:26\n   |\n32 |       if min_val < max_val\
    \ {\n   |  __________________________^\n33 | |         sort_array(&array[min_idx..max_idx]);\n\
    \   | |                                             - help: consider removing\
    \ this semicolon\n34 | |     } else {\n   | |_____^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type\
    \ `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprdqgj3l8.rs:35:20\n  \
    \ |\n35 |         sort_array(&array[max_idx..min_idx]);\n   |                \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&[isize]`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found reference `&[isize]`\n\
    help: try using a conversion method\n   |\n35 |         sort_array((&array[max_idx..min_idx]).to_vec());\n\
    \   |                    +                        ++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprdqgj3l8.rs:34:12\n   |\n34 |       } else {\n\
    \   |  ____________^\n35 | |         sort_array(&array[max_idx..min_idx]);\n \
    \  | |                                             - help: consider removing this\
    \ semicolon\n36 | |     }\n   | |_____^ expected struct `Vec`, found `()`\n  \
    \ |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    array.sort();\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpo_6pm82d.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n\
    \    for value in array {\n        if value == min_value {\n            min_pos\
    \ = min_pos + 1;\n            min_sum += value;\n        } else {\n          \
    \  if value == max_value {\n                max_pos = max_pos + 1;\n         \
    \       max_sum += value;\n            }\n        }\n    }\n    let mut min_pos\
    \ = min_pos - 1;\n    let mut max_pos = max_pos - 1;\n    let mut min_sum = min_sum\
    \ - min_value;\n    let mut max_sum = max_sum - max_value;\n    if min_pos ==\
    \ max_pos {\n        if min_sum == max_sum {\n            return array;\n    \
    \    }\n        if min_sum > max_sum {\n            array.swap(0, min_pos);\n\
    \            array.swap(min_pos + 1, max_pos);\n            return array;\n  \
    \      }\n        if min_sum < max_sum {\n            array.swap(0, max_pos);\n\
    \            array.swap(max_pos + 1, min_pos);\n            return array;\n  \
    \      }\n    }\n    let mut min_pos = min_pos - 1;\n    let mut max_pos = max_pos\
    \ - 1;\n    let mut min_sum = min_sum - min_value;\n    let mut max_sum = max_sum\
    \ - max_value;\n    if min_pos == max_pos {\n        if min_sum == max_sum {\n\
    \            array.swap(0, min_pos);\n            array.swap(min_pos + 1, max_pos);\n\
    \            return array;\n        }\n        if min_sum > max_sum {\n      \
    \      array.swap(0, min_pos);\n            array.swap(min_pos + 1, max_pos);\n\
    \            array.swap(min_pos + 2, max_pos + 1);\n            return array;\n\
    \        }\n        if min_sum < max_sum {\n            array.swap(0, max_pos);\n\
    \            array.swap(max_pos + 1, min_pos);\n            array.swap(max_pos\
    \ + 2, min_pos + 1);\n            return array;\n        }\n    }\n    let mut\
    \ min_pos = min_pos - 1;\n    let mut max_pos = max_pos - 1;\n    let mut min_sum\
    \ = min_sum - min_value;\n    let mut max_sum = max_sum - max_value;\n    if min_pos\
    \ == max_pos {\n        if min_sum == max_sum {\n            array.swap(0, min_pos);\n\
    \            array.swap(min_pos + 1, max_pos);\n            array.swap(min_pos\
    \ + \n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpwmhw_9gf.rs:104:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n88  |    \
    \ if min_pos == max_pos {\n    |                           - unclosed delimiter\n\
    89  |         if min_sum == max_sum {\n    |                               - this\
    \ delimiter might not be properly closed...\n...\n93  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n104 | }\n    |   ^\n\nerror: expected\
    \ expression, found `)`\n  --> /tmp/tmpwmhw_9gf.rs:93:1\n   |\n93 | }\n   | ^\
    \ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpwmhw_9gf.rs:92:23\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                                     - closing delimiter possibly meant for this\n\
    ...\n92 |             array.swap(min_pos + \n   |                       ^ unclosed\
    \ delimiter\n93 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched\
    \ types\n   --> /tmp/tmpwmhw_9gf.rs:88:27\n    |\n88  |       if min_pos == max_pos\
    \ {\n    |  ___________________________^\n89  | |         if min_sum == max_sum\
    \ {\n90  | |             array.swap(0, min_pos);\n91  | |             array.swap(min_pos\
    \ + 1, max_pos);\n...   |\n103 | |     assert_eq!(candidate(vec![21, 14, 23, 11]),\
    \ vec![23, 21, 14, 11]);\n104 | | }\n    | |__^ expected struct `Vec`, found `()`\n\
    \    |\n    = note: expected struct `Vec<isize>`\n            found unit type\
    \ `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    let mut min_value = array[0];\n    let mut max_value =\
    \ array[0];\n    for value in array {\n        if value < min_value {\n      \
    \      min_value = value;\n        }\n        if value > max_value {\n       \
    \     max_value = value;\n        }\n    }\n    if sum % 2 == 1 {\n        array.sort();\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpxb_o09_c.rs:20:25\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n16  |     let mut sum = 0;\n17  |     for value\
    \ in array {\n    |                  -----\n    |                  |\n    |  \
    \                `array` moved due to this implicit call to `.into_iter()`\n \
    \   |                  help: consider borrowing to avoid moving into the for loop:\
    \ `&array`\n...\n20  |     let mut min_value = array[0];\n    |              \
    \           ^^^^^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `array`\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpxb_o09_c.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort();\n   |         ^^^^^ cannot borrow as mutable\n\nerror[E0382]:\
    \ borrow of moved value: `array`\n  --> /tmp/tmpxb_o09_c.rs:31:9\n   |\n15 | fn\
    \ sort_array(array: Vec<isize>) -> Vec<isize> {\n   |               ----- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n22 |     for value in array {\n   |                  -----\n   |\
    \                  |\n   |                  `array` moved due to this implicit\
    \ call to `.into_iter()`\n   |                  help: consider borrowing to avoid\
    \ moving into the for loop: `&array`\n...\n31 |         array.sort();\n   |  \
    \       ^^^^^ value borrowed here after move\n\nerror[E0596]: cannot borrow `array`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpxb_o09_c.rs:33:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n33 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 4 previous errors\n\nSom"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ i in array.iter() {\n        sum += i;\n        if sum % 2 == 1 {\n        \
    \    min_value = i;\n        } else {\n            max_value = i;\n        }\n\
    \    }\n    array.sort_by_key(|&x| {\n        if x < min_value {\n           \
    \ Some(min_value)\n        } else if x > max_value {\n            Some(max_value)\n\
    \        } else {\n            None\n        }\n    });\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl0lpxtb5.rs:23:25\n   |\n\
    23 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl0lpxtb5.rs:25:25\n   |\n25 |             max_value = i;\n\
    \   |                         ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n25 |             max_value = *i;\n\
    \   |                         +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpikg277h_.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpikg277h_.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659749456
- exit_code: 101
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpe7o66rxq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a vector of non-negative integers, return a cors of the given\
    \ vector after sorting,\n/// you will sort the given vector in ascending order\
    \ if the sum( first index value, last index value) is odd,\n/// or sort it in\
    \ descending order if the sum( first index value, last index value) is even.\n\
    /// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// vec![]\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut min_pos = 0;\n\
    \    let mut max_pos = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 0 {\n            if value < min_value {\n                min_value =\
    \ value;\n                min_pos = 0;\n            } else {\n               \
    \ min_pos = min_pos + 1;\n            }\n        } else {\n            if value\
    \ > max_value {\n                max_value = value;\n                max_pos =\
    \ 0;\n            } else {\n                max_pos = max_pos + 1;\n         \
    \   }\n        }\n    }\n    if min_pos == max_pos {\n        return array;\n\
    \    }\n    let mut min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value\
    \ = array[0];\n    let mut max_value = array[0];\n    for value in array {\n \
    \       sum += value;\n        if sum % 2 == 0 {\n            if value < min_value\
    \ {\n                min_value = value;\n                min_pos = 0;\n      \
    \      } else {\n                min_pos = min_pos + 1;\n            }\n     \
    \   } else {\n            if value > max_value {\n                max_value =\
    \ value;\n                max_pos = 0;\n            } else {\n               \
    \ max_pos = max_pos + 1;\n            }\n        }\n    }\n    if min_pos == max_pos\
    \ {\n        return array;\n    }\n    let mut min_pos = 0;\n    let mut max_pos\
    \ = 0;\n    let mut min_value = array[0];\n    let mut max_value = array[0];\n\
    \    for value in array {\n        sum += value;\n        if sum % 2 == 0 {\n\
    \            if value < min_value {\n                min_value = value;\n    \
    \            min_pos = 0;\n            } else {\n                min_pos = min_pos\
    \ + 1;\n            }\n        } else {\n            if value > max_value {\n\
    \                max_value = value;\n                max_pos = 0;\n          \
    \  } else {\n                max_pos = max_pos + 1;\n            }\n        }\n\
    \    }\n    if min_pos == max_pos {\n        return array;\n    }\n    let mut\
    \ min_pos = 0;\n    let mut max_pos = 0;\n    let mut min_value = array[0];\n\
    \    let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            if value < min_value {\n             \
    \   min_value = value;\n                min_pos = 0;\n            } else {\n \
    \               min_pos = min_pos + 1;\n            }\n        } else {\n    \
    \        if value > max_value {\n                max_value = value;\n        \
    \        max_pos = 0;\n            } else {\n                max_pos = max_pos\
    \ + 1;\n            }\n        }\n    }\n    if min_pos == max_pos {\n       \
    \ return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3xrcn3i5.rs:137:3\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \                                        - unclosed delimiter\n...\n124 |    \
    \ if min_pos == max_pos {\n    |                           - this delimiter might\
    \ not be properly closed...\n125 |         return array;\n126 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n137 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3xrcn3i5.rs:15:37\n   |\n15 | fn\
    \ sort_array(array: Vec<isize>) -> Vec<isize> {\n   |    ----------          \
    \             ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |  \
    \  implicitly returns `()` as its body has no tail or `return` expression\n  \
    \ |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749457
