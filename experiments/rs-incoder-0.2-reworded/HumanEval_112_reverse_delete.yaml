name: HumanEval_112_reverse_delete
language: rs
prompt: "/// Task\n/// We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n/// then check if the result\
  \ string is palindrome.\n/// A string is called palindrome if it reads the same\
  \ backward as forward.\n/// You should return a tuple containing the result string\
  \ and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
  abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
  abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>> reverse_delete(String::from(\"\
  abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"cdedc\"), true)\nfn reverse_delete(s:\
  \ String, c: String) -> (String, bool) {\n"
tests: "}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
  abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
  abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
  dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
  a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"v\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"\
  vabba\"), String::from(\"v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
  mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
completions: ["    let mut s = s;\n    let mut c = c;\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut flag = false;\n    while i < s.len() && j < c.len()\
    \ {\n        if s[i] == c[j] {\n            i += 1;\n            j += 1;\n   \
    \     } else {\n            i += 1;\n        }\n    }\n    if i == s.len() {\n\
    \        flag = true;\n    }\n    (s.clone(), flag)", "    let mut s = s;\n  \
    \  let mut c = c;\n    let mut result = String::new();\n    let mut is_palindrome\
    \ = true;\n    while s.len() > 0 {\n        if s.chars().any(|c| c == c.to_ascii_lowercase())\
    \ {\n            s = s.chars().filter(|c| c != c.to_ascii_lowercase()).collect();\n\
    \        } else {\n            is_palindrome = false;\n            break;\n  \
    \      }\n    }\n    while c.len() > 0 {\n        if c.chars().any(|c| c == c.to_ascii_lowercase())\
    \ {\n            c = c.chars().filter(|c| c != c.to_ascii_lowercase()).collect();\n\
    \        } else {\n            is_palindrome = false;\n            break;\n  \
    \      }\n    }\n    if is_palindrome {\n        result = s.chars().collect();\n\
    \    }\n    (result, is_palindrome)", "    let mut s = s;\n    let mut c = c;\n\
    \    let mut result = String::new();\n    let mut is_palindrome = false;\n   \
    \ let mut i = 0;\n    let mut j = 0;\n    while i < s.len() && j < c.len() {\n\
    \        if s[i] == c[j] {\n            i += 1;\n            j += 1;\n       \
    \ } else {\n            result.push(c[j]);\n            i += 1;\n        }\n \
    \   }\n    if i == s.len() {\n        is_palindrome = true;\n    }\n    (result,\
    \ is_palindrome)", "    let mut s = s;\n    let mut c = c;\n    let mut result\
    \ = String::new();\n    let mut is_palindrome = true;\n    while !s.is_empty()\
    \ {\n        if c.contains(&s[0]) {\n            result = result.to_owned() +\
    \ s[0];\n            s.truncate(1);\n        } else {\n            is_palindrome\
    \ = false;\n        }\n    }\n    if is_palindrome {\n        return (result,\
    \ true);\n    }\n    let mut s = s;\n    let mut c = c;\n    let mut result =\
    \ String::new();\n    let mut is_palindrome = true;\n    while !s.is_empty() {\n\
    \        if c.contains(&s[0]) {\n            result = result.to_owned() + s[0];\n\
    \            s.truncate(1);\n        } else {\n            is_palindrome = false;\n\
    \        }\n    }\n    if is_palindrome {\n        return (result, false);\n \
    \   }\n    return (String::new(), false);", "    let mut s = s;\n    let mut c\
    \ = c;\n    let mut result = String::new();\n    let mut is_palindrome = true;\n\
    \    while !s.is_empty() {\n        if c.contains(&s[0]) {\n            s = s.chars().filter(|&x|\
    \ x != s[0]).collect::<String>();\n        } else {\n            is_palindrome\
    \ = false;\n            break;\n        }\n    }\n    if is_palindrome {\n   \
    \     result = s.chars().collect::<String>();\n    }\n    (result, is_palindrome)",
  "    let mut s = s;\n    let mut c = c;\n    let mut result = String::new();\n \
    \   let mut is_palindrome = true;\n    while s.len() > 0 {\n        if c.contains(&s[0])\
    \ {\n            s = &s[1..];\n        } else {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    if is_palindrome {\n        result\
    \ = s;\n    }\n    (result, is_palindrome)", "    let mut s = String::from(s);\n\
    \    let mut c = String::from(c);\n    let mut i = s.len() - 1;\n    let mut j\
    \ = c.len() - 1;\n    while i >= 0 && j >= 0 {\n        if s[i] != c[j] {\n  \
    \          s.swap(i, j);\n            i -= 1;\n            j -= 1;\n        }\
    \ else {\n            i -= 1;\n        }\n    }\n    if i == -1 {\n        true\n\
    \    } else {\n        (s, false)\n    }", "    let mut s = s;\n    let mut c\
    \ = c;\n    let mut result = String::new();\n    let mut is_palindrome = false;\n\
    \    while !s.is_empty() {\n        if c.contains(&s[0]) {\n            s = s.chars().filter(|&x|\
    \ x != s[0]).collect();\n        } else {\n            is_palindrome = true;\n\
    \            break;\n        }\n    }\n    if is_palindrome {\n        result\
    \ = s.chars().collect();\n    }\n    (result, is_palindrome)", "    let mut s\
    \ = s;\n    let mut c = c;\n    let mut result = String::new();\n    let mut is_palindrome\
    \ = true;\n    while !s.is_empty() {\n        if s.chars().any(|c| c.unwrap()\
    \ == c.unwrap()) {\n            s = s.chars().filter(|c| c != c.unwrap()).collect();\n\
    \        } else {\n            is_palindrome = false;\n            break;\n  \
    \      }\n    }\n    while !c.is_empty() {\n        if c.chars().any(|c| c.unwrap()\
    \ == c.unwrap()) {\n            c = c.chars().filter(|c| c != c.unwrap()).collect();\n\
    \        } else {\n            is_palindrome = false;\n            break;\n  \
    \      }\n    }\n    if is_palindrome {\n        result = s.chars().collect();\n\
    \    }\n    (result, is_palindrome)", "    let mut s = s;\n    let mut c = c;\n\
    \    let mut result = String::new();\n    let mut is_palindrome = false;\n   \
    \ while !s.is_empty() {\n        if c.contains(&s[0]) {\n            s = s.chars().filter(|&c|\
    \ c != s[0]).collect();\n            is_palindrome = true;\n        } else {\n\
    \            result.push(*s);\n            s = s.chars().filter(|&c| c != s[0]).collect();\n\
    \        }\n    }\n    (result, is_palindrome)", "    let mut s = s;\n    let\
    \ mut c = c;\n    let mut result = String::new();\n    let mut is_palindrome =\
    \ true;\n    while !s.is_empty() {\n        if s.chars().any(|&c| c == c.to_ascii_lowercase())\
    \ {\n            s = s.chars().filter(|&c| c != c.to_ascii_lowercase()).collect();\n\
    \        } else {\n            is_palindrome = false;\n            break;\n  \
    \      }\n    }\n    while !c.is_empty() {\n        if c.chars().any(|&c| c ==\
    \ c.to_ascii_lowercase()) {\n            c = c.chars().filter(|&c| c != c.to_ascii_lowercase()).collect();\n\
    \        } else {\n            is_palindrome = false;\n            break;\n  \
    \      }\n    }\n    if is_palindrome {\n        result = s.chars().collect();\n\
    \    }\n    (result, is_palindrome)", "    let mut s = s;\n    let mut c = c;\n\
    \    let mut result = String::new();\n    let mut is_palindrome = false;\n   \
    \ while !s.is_empty() {\n        let mut i = s.len() - 1;\n        while i >=\
    \ 0 {\n            if s[i] == c[0] {\n                s.swap_remove(i);\n    \
    \            c.swap_remove(0);\n                is_palindrome = true;\n      \
    \      }\n            i -= 1;\n        }\n        result.push_str(&s[..]);\n \
    \   }\n    (result, is_palindrome)", "    let mut s = s;\n    let mut c = c;\n\
    \    let mut result = String::new();\n    let mut is_palindrome = false;\n   \
    \ while !s.is_empty() {\n        let mut i = s.len() - 1;\n        let mut j =\
    \ c.len() - 1;\n        while i >= 0 && j >= 0 {\n            if s[i] == c[j]\
    \ {\n                s.swap(i, j);\n                i -= 1;\n                j\
    \ -= 1;\n            } else {\n                i -= 1;\n            }\n      \
    \  }\n        if s.len() == 0 {\n            is_palindrome = true;\n         \
    \   break;\n        }\n        result.push(s.chars().next().unwrap());\n     \
    \   s.truncate(0);\n        c.truncate(0);\n    }\n    (result, is_palindrome)",
  "    let mut s = s;\n    let mut c = c;\n    let mut result = String::new();\n \
    \   let mut is_palindrome = false;\n\n    while !s.is_empty() {\n        let mut\
    \ index = s.len() - 1;\n        while index >= 0 && s[index] == c[index] {\n \
    \           index -= 1;\n        }\n        result.push(s[index]);\n        s\
    \ = &s[..index];\n    }\n\n    if s == &c {\n        is_palindrome = true;\n \
    \   }\n\n    (result, is_palindrome)", "    let mut s = s;\n    let mut c = c;\n\
    \    let mut result = String::new();\n    let mut is_palindrome = false;\n\n \
    \   while !s.is_empty() {\n        if s.chars().any(|c| c.to_string() == c.to_string().rev())\
    \ {\n            result.push(*s);\n            is_palindrome = true;\n       \
    \ }\n        s = s.chars().next().unwrap();\n    }\n\n    while !c.is_empty()\
    \ {\n        if c.chars().any(|c| c.to_string() == c.to_string().rev()) {\n  \
    \          result.push(*c);\n            is_palindrome = true;\n        }\n  \
    \      c = c.chars().next().unwrap();\n    }\n\n    (result, is_palindrome)",
  "    let mut s = s;\n    let mut c = c;\n    let mut result = String::new();\n \
    \   let mut is_palindrome = true;\n\n    while !s.is_empty() {\n        let mut\
    \ i = s.len() - 1;\n        let mut j = c.len() - 1;\n\n        while i >= 0 &&\
    \ j >= 0 {\n            if s[i] == c[j] {\n                s.swap(i, j);\n   \
    \             i -= 1;\n                j -= 1;\n            } else {\n       \
    \         i -= 1;\n            }\n        }\n\n        if s.len() == 0 {\n   \
    \         is_palindrome = false;\n            break;\n        }\n\n        result.push(s.chars().next().unwrap());\n\
    \    }\n\n    (result, is_palindrome)", "    let mut s = s;\n    let mut c = c;\n\
    \    let mut result = \"\";\n    let mut is_palindrome = true;\n    while !s.is_empty()\
    \ {\n        let mut i = s.len() - 1;\n        while i >= 0 && c[i] == s[i] {\n\
    \            i -= 1;\n        }\n        result = s.chars().take(i).collect::<String>()\
    \ + result;\n        s = s.chars().skip(i + 1).collect::<String>();\n        is_palindrome\
    \ = is_palindrome && s.is_empty();\n    }\n    (result, is_palindrome)", "   \
    \ let mut s = s;\n    let mut c = c;\n    let mut result = String::new();\n  \
    \  let mut is_palindrome = true;\n\n    while !s.is_empty() {\n        if c.contains(&s[0])\
    \ {\n            result = result.to_owned() + s[0];\n            s.truncate(1);\n\
    \        } else {\n            is_palindrome = false;\n        }\n    }\n\n  \
    \  if is_palindrome {\n        (result, true)\n    } else {\n        (result,\
    \ false)\n    }", "    let mut s = s;\n    let mut c = c;\n    let mut result\
    \ = String::new();\n    let mut is_palindrome = true;\n    while !s.is_empty()\
    \ {\n        if c.contains(&s[0]) {\n            s = s.chars().filter(|&x| x !=\
    \ s[0]).collect();\n        } else {\n            is_palindrome = false;\n   \
    \         break;\n        }\n    }\n    if is_palindrome {\n        result = s.chars().collect();\n\
    \    }\n    (result, is_palindrome)", "    let mut s = s;\n    let mut c = c;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut is_palindrome = true;\n \
    \   while i < s.len() && j < c.len() {\n        if s[i] == c[j] {\n          \
    \  i += 1;\n            j += 1;\n        } else {\n            is_palindrome =\
    \ false;\n        }\n    }\n    (s.clone(), is_palindrome)"]
stop_tokens:
- "\n}"
