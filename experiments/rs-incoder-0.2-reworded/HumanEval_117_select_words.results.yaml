name: HumanEval_117_select_words
language: rs
results:
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            words.push(s.split_at(i).collect::<Vec<_>>());\n\
    \            i += n;\n        }\n        i += 1;\n    }\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpohsuegpe.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: `(&str, &str)` is not an iterator\n\
    \  --> /tmp/tmpohsuegpe.rs:22:38\n   |\n22 |             words.push(s.split_at(i).collect::<Vec<_>>());\n\
    \   |                                      ^^^^^^^ `(&str, &str)` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `(&str,\
    \ &str): Iterator`\n           which is required by `&mut (&str, &str): Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpohsuegpe.rs:23:18\n   |\n23 |\
    \             i += n;\n   |                  ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpohsuegpe.rs:23:15\n\
    \   |\n23 |             i += n;\n   |               ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n != 0 {\n\
    \        if s.chars().any(|c| c.is_consonant()) {\n            result.push(s);\n\
    \        }\n        n -= 1;\n        s = s.chars().filter(|c| c.is_consonant()).collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpwx46q1q0.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmpwx46q1q0.rs:26:36\n  \
    \ |\n26 |         s = s.chars().filter(|c| c.is_consonant()).collect();\n   |\
    \                                    ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    let mut vowel_counter2 = 0;\n    let mut consonant_counter2 = 0;\n\
    \    let mut vowel_counter3 = 0;\n    let mut consonant_counter3 = 0;\n    let\
    \ mut vowel_counter4 = 0;\n    let mut consonant_counter4 = 0;\n    let mut vowel_counter5\
    \ = 0;\n    let mut consonant_counter5 = 0;\n    let mut vowel_counter6 = 0;\n\
    \    let mut consonant_counter6 = 0;\n    let mut vowel_counter7 = 0;\n    let\
    \ mut consonant_counter7 = 0;\n    let mut vowel_counter8 = 0;\n    let mut consonant_counter8\
    \ = 0;\n    let mut vowel_counter9 = 0;\n    let mut consonant_counter9 = 0;\n\
    \    let mut vowel_counter10 = 0;\n    let mut consonant_counter10 = 0;\n    let\
    \ mut vowel_counter11 = 0;\n    let mut consonant_counter11 = 0;\n    let mut\
    \ vowel_counter12 = 0;\n    let mut consonant_counter12 = 0;\n    let mut vowel_counter13\
    \ = 0;\n    let mut consonant_counter13 = 0;\n    let mut vowel_counter14 = 0;\n\
    \    let mut consonant_counter14 = 0;\n    let mut vowel_counter15 = 0;\n    let\
    \ mut consonant_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let mut\
    \ consonant_counter16 = 0;\n    let mut vowel_counter17 = 0;\n    let mut consonant_counter17\
    \ = 0;\n    let mut vowel_counter18 = 0;\n    let mut consonant_counter18 = 0;\n\
    \    let mut vowel_counter19 = 0;\n    let mut consonant_counter19 = 0;\n    let\
    \ mut vowel_counter20 = 0;\n    let mut consonant_counter20 = 0;\n    let mut\
    \ vowel_counter21 = 0;\n    let mut consonant_counter21 = 0;\n    let mut vowel_counter22\
    \ = 0;\n    let mut consonant_counter22 = 0;\n    let mut vowel_counter23 = 0;\n\
    \    let mut consonant_counter23 = 0;\n    let mut vowel_counter24 = 0;\n    let\
    \ mut conson\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd15xoqpe.rs:68:19\n   |\n\
    68 |     let mut conson\n   |                   ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd15xoqpe.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowel_counter = 0;\n    let mut vowel_counter2 = 0;\n    let mut\
    \ vowel_counter3 = 0;\n    let mut vowel_counter4 = 0;\n    let mut vowel_counter5\
    \ = 0;\n    let mut vowel_counter6 = 0;\n    let mut vowel_counter7 = 0;\n   \
    \ let mut vowel_counter8 = 0;\n    let mut vowel_counter9 = 0;\n    let mut vowel_counter10\
    \ = 0;\n    let mut vowel_counter11 = 0;\n    let mut vowel_counter12 = 0;\n \
    \   let mut vowel_counter13 = 0;\n    let mut vowel_counter14 = 0;\n    let mut\
    \ vowel_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let mut vowel_counter17\
    \ = 0;\n    let mut vowel_counter18 = 0;\n    let mut vowel_counter19 = 0;\n \
    \   let mut vowel_counter20 = 0;\n    let mut vowel_counter21 = 0;\n    let mut\
    \ vowel_counter22 = 0;\n    let mut vowel_counter23 = 0;\n    let mut vowel_counter24\
    \ = 0;\n    let mut vowel_counter25 = 0;\n    let mut vowel_counter26 = 0;\n \
    \   let mut vowel_counter27 = 0;\n    let mut vowel_counter28 = 0;\n    let mut\
    \ vowel_counter29 = 0;\n    let mut vowel_counter30 = 0;\n    let mut vowel_counter31\
    \ = 0;\n    let mut vowel_counter32 = 0;\n    let mut vowel_counter33 = 0;\n \
    \   let mut vowel_counter34 = 0;\n    let mut vowel_counter35 = 0;\n    let mut\
    \ vowel_counter36 = 0;\n    let mut vowel_counter37 = 0;\n    let mut vowel_counter38\
    \ = 0;\n    let mut vowel_counter39 = 0;\n    let mut vowel_counter40 = 0;\n \
    \   let mut vowel_counter41 = 0;\n    let mut vowel_counter42 = 0;\n    let mut\
    \ vowel_counter43 = 0;\n    let mut vowel_counter44 = 0;\n    let mut vowel_counter45\
    \ = 0;\n    let mut vowel_counter46 = 0;\n    let mut vowel_counter47 = 0;\n \
    \   let mut vowel_counter48 = 0;\n    let mut vowel_counter49 = 0;\n    let mut\
    \ vowel_counter50 = 0;\n    let mut vowel_counter51 = 0;\n    let mut vowel_counter52\
    \ = 0;\n    let mut vowel_counter53 = 0;\n    let mut vowel_counter54 = 0;\n \
    \   let mut \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpl13o8muc.rs:76:1\n\
    \   |\n76 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n                j -= 1;\n          \
    \  } else {\n                i += 1;\n            }\n        }\n        if i ==\
    \ j {\n            result.push(s.clone());\n            i += 1;\n        }\n \
    \       if i == n {\n            result.push(s.clone());\n        }\n        s\
    \ = &s[i..];\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkfupdugh.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkfupdugh.rs:35:17\n\
    \   |\n35 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkfupdugh.rs:38:13\n   |\n19 |     let mut s = s;\n   |        \
    \         - expected due to this value\n...\n38 |         s = &s[i..];\n   | \
    \            ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n38 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut i = 0;\n        let mut j = s.len();\n        while i < j {\n\
    \            if s[i] == ' ' {\n                i += 1;\n                j -= 1;\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \     if i == n {\n            result.push(s.clone());\n        }\n        s =\
    \ &s[i..];\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnjdxfpnk.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnjdxfpnk.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnjdxfpnk.rs:34:13\n   |\n19 |     let mut s = String::from(s);\n\
    \   |                 --------------- expected due to this value\n...\n34 |  \
    \       s = &s[i..];\n   |             ^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n34 |         s = (&s[i..]).to_string();\n\
    \   |             +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().all(|c| c == s.chars().nth(j)) {\n   \
    \         j += 1\n        }\n        if j == s.len() {\n            result.push(s.clone());\n\
    \            i += 1;\n        } else {\n            if s.chars().all(|c| c ==\
    \ s.chars().nth(j)) {\n                result.push(s.clone());\n             \
    \   i += 1;\n            } else {\n                i += j - i;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf5zo6ywb.rs:24:53\n   |\n\
    24 |         while j < s.len() && s.chars().all(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf5zo6ywb.rs:31:39\n\
    \   |\n31 |             if s.chars().all(|c| c == s.chars().nth(j)) {\n   |  \
    \                                     ^^^^^^^^^^^^^^^^ expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<char>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut s = String::from(s);\n    let mut n = n;\n    while\
    \ n != 0 {\n        let mut i = 0;\n        while i < s.len() {\n            if\
    \ s.chars().any(|c| c == ' ' || c == '\\t' || c == '\\n') {\n                i\
    \ += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n              \
    \  i += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n              \
    \  i += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'y' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n  \
    \              i += 1;\n                continue;\n            }\n           \
    \ if s.chars().any(|c| c == 'Y' || c == 'A' || c == 'E' || c == 'I' || c == 'O'\
    \ || c == 'U') {\n                i += 1;\n                continue;\n       \
    \     }\n            if s.chars().any(|c| c == 'i' || c == 'o' || c == 'u') {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if s.chars().any(|c| c == 'I' || c == 'O' || c == 'U') {\n               \
    \ i += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'n' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n  \
    \              i += 1;\n                continue;\n            }\n           \
    \ if s.chars().any(|c| c == 'N' || c == 'A' || c == 'E' || c == 'I' || c == 'O'\
    \ || c == 'U') {\n                i += 1;\n                continue;\n       \
    \     }\n            if s.chars().any(|c| c == 't' || c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n                i += 1;\n             \
    \   continue;\n            }\n            if s.chars().any(|c| c == 'T' || c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                i +=\
    \ 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'h' || c == 'e' || c == 'l' || c == 'l' || c == 'o' || c == 'r') {\n  \
    \              i += 1;\n                continue;\n            }\n           \
    \ if s.chars().any(|c| c == 'H' || c == '\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmppccytj0o.rs:72:51\n\
    \   |\n72 |             if s.chars().any(|c| c == 'H' || c == '\n   |        \
    \                                           ^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         if i == s.len() {\n                break;\n            }\n         \
    \   words.push(s.to_string());\n            i += 1;\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpjakc9qkh.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j - i > n {\n            words.push(s.subslice(i, j));\n \
    \           i = j;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8bo1rrzq.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bo1rrzq.rs:25:20\n\
    \   |\n25 |         if j - i > n {\n   |                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i > n.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `subslice` found for struct `String` in the current scope\n  --> /tmp/tmp8bo1rrzq.rs:26:26\n\
    \   |\n26 |             words.push(s.subslice(i, j));\n   |                  \
    \        ^^^^^^^^ method not found in `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            break;\n        }\n        let mut word\
    \ = String::from(&s[i .. j]);\n        let mut count = 0;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n     \
    \       break;\n        }\n        let mut consonants = String::from(&s[i .. j]);\n\
    \        if consonants.chars().count() == n {\n            words.push(word);\n\
    \            i += j - i;\n        }\n        i += j - i;\n    }\n    words\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp23454b0m.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp23454b0m.rs:30:30\n   |\n30 |         while j < s.len() && s[j]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp23454b0m.rs:37:42\n\
    \   |\n37 |         if consonants.chars().count() == n {\n   |               \
    \                           ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n37 |         if consonants.chars().count() == n.try_into().unwrap()\
    \ {\n   |                                           ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut punctuation = vec![];\n    let mut\
    \ letters = vec![];\n    let mut numbers = vec![];\n    let mut spaces_at_start\
    \ = vec![];\n    let mut spaces_at_end = vec![];\n    let mut punctuation_at_start\
    \ = vec![];\n    let mut punctuation_at_end = vec![];\n    let mut letters_at_start\
    \ = vec![];\n    let mut letters_at_end = vec![];\n    let mut numbers_at_start\
    \ = vec![];\n    let mut numbers_at_end = vec![];\n    let mut spaces_at_start_at_end\
    \ = vec![];\n    let mut spaces_at_end_at_start = vec![];\n    let mut punctuation_at_start_at_end\
    \ = vec![];\n    let mut punctuation_at_end_at_start = vec![];\n    let mut letters_at_start_at_end\
    \ = vec![];\n    let mut letters_at_end_at_start = vec![];\n    let mut numbers_at_start_at_end\
    \ = vec![];\n    let mut numbers_at_end_at_start = vec![];\n    let mut spaces_at_start_at_end_at_end\
    \ = vec![];\n    let mut spaces_at_end_at_start_at_end = vec![];\n    let mut\
    \ punctuation_at_start_at_end_at_end = vec![];\n    let mut punctuation_at_end_at_start_at_end\
    \ = vec![];\n    let mut letters_at_start_at_end_at_end = vec![];\n    let mut\
    \ letters_at_end_at_start_at_end = vec![];\n    let mut numbers_at_start_at_end_at_end\
    \ = vec![];\n    let mut numbers_at_end_at_start_at_end = vec![];\n    let mut\
    \ spaces_at_start_at_end_at_end_at_end = vec![];\n    let mut spaces_at_end_at_start_at_end_at_end\
    \ = vec![];\n    let mut punctuation_at_start_at_end_at_end_at_end = vec![];\n\
    \    let mut punctuation_at_end_at_start_at_end_at_end = vec![];\n    let mut\
    \ letters_at_start_at_end_at_end_at_end = vec![];\n    let mut letters_at_end_at_start_at_end_at_end\
    \ = vec![];\n    let mut numbers_at_start_at_end_at_end_at_end = vec![];\n   \
    \ let mut numbers_at_end_at_start_at_end_at_end = vec![];\n\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4y96u3qt.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    let mut n = n as usize;\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c| c.is_uppercase()\
    \ && c.is_consonant()) {\n            result.push(s.subslice(i, i + n));\n   \
    \         i += n;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmppdm3tz68.rs:23:52\n   |\n23 |         if s.chars().any(|c|\
    \ c.is_uppercase() && c.is_consonant()) {\n   |                              \
    \                      ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `subslice` found for struct `String` in the current scope\n\
    \  --> /tmp/tmppdm3tz68.rs:24:27\n   |\n24 |             result.push(s.subslice(i,\
    \ i + n));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    let mut n = n as usize;\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c| c !=\
    \ ' ' && c != '\\t' && c != '\\n' && c != '\\r') {\n            if n == 0 {\n\
    \                break;\n            }\n            n -= 1;\n        } else {\n\
    \            result.push(s.subslice(i, i + 1));\n            i += 1;\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmppaz1x8em.rs:29:27\n   |\n29 |             result.push(s.subslice(i,\
    \ i + 1));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut i = 0;\n        let mut j = s.len();\n        while i < j {\n\
    \            if s[i] == ' ' {\n                i += 1;\n                j -= 1;\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \     if i == n {\n            result.push(s.clone());\n        }\n        s =\
    \ &s[..i];\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxz8r_of0.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxz8r_of0.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxz8r_of0.rs:34:13\n   |\n19 |     let mut s = String::from(s);\n\
    \   |                 --------------- expected due to this value\n...\n34 |  \
    \       s = &s[..i];\n   |             ^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n34 |         s = (&s[..i]).to_string();\n\
    \   |             +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j].is_ascii_letter() {\n            j\
    \ = j + 1;\n        }\n        if j == s.len() {\n            break;\n       \
    \ }\n        let mut k = j;\n        while k < s.len() && s[k].is_ascii_letter()\
    \ {\n            k = k + 1;\n        }\n        if k == s.len() {\n          \
    \  break;\n        }\n        let mut c = s[k];\n        while k < s.len() &&\
    \ s[k].is_ascii_letter() {\n            c = c + s[k];\n            k = k + 1;\n\
    \        }\n        if k == s.len() {\n            break;\n        }\n       \
    \ if c == n {\n            words.push(s.subslice(i, j));\n        }\n        i\
    \ = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppa1nhvbk.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppa1nhvbk.rs:29:30\n\
    \   |\n29 |         while k < s.len() && s[k].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppa1nhvbk.rs:35:21\n\
    \   |\n35 |         let mut c = s[k];\n   |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().any(|c| c.is_consonant() && c != ' ') {\n          \
    \  count += 1;\n            if count == n {\n                words.push(s.to_string());\n\
    \                count = 0;\n            }\n        }\n        i += 1;\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpja23fwx3.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n != 0 {\n\
    \        let mut i = 0;\n        while i < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') {\n                break;\n\
    \            }\n            i += 1;\n        }\n        if i == s.len() {\n  \
    \          break;\n        }\n        let mut j = i;\n        while j < s.len()\
    \ {\n            if s.chars().any(|c| c == ' ' || c == '\\t' || c == '\\n' ||\
    \ c == '\\r') {\n                break;\n            }\n            i += 1;\n\
    \            j += 1\n        }\n        if i == j {\n            break;\n    \
    \    }\n        let mut k = i;\n        while k < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') {\n                break;\n\
    \            }\n            i += 1;\n            k += 1\n        }\n        if\
    \ i == k {\n            break;\n        }\n        let mut m = i;\n        while\
    \ m < s.len() {\n            if s.chars().any(|c| c == ' ' || c == '\\t' || c\
    \ == '\\n' || c == '\\r') {\n                break;\n            }\n         \
    \   i += 1;\n            m += 1\n        }\n        if i == m {\n            break;\n\
    \        }\n        let mut l = i;\n        while l < s.len() {\n            if\
    \ s.chars().any(|c| c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') {\n  \
    \              break;\n            }\n            i += 1;\n            l += 1\n\
    \        }\n        if i == l {\n            break;\n        }\n        let mut\
    \ n = i;\n        while n < s.len() {\n            if s.chars().any(|c| c == '\
    \ ' || c == '\\t' || c == '\\n' || c == '\\r') {\n                break;\n   \
    \         }\n            i += 1;\n            n += 1\n        }\n        if i\
    \ == n {\n            break;\n        }\n        result.push(s.split_whitespace().nth(i).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpotav9dbo.rs:89:5\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n89 |     result\n   |     ^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words(s,\
    \ n, vec![])\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmpuyvhgif2.rs:18:5\n   |\n18 |     select_words(s, n, vec![])\n \
    \  |     ^^^^^^^^^^^^ -  -  ------ supplied 3 arguments\n   |     |\n   |    \
    \ expected 2 arguments\n   |\nnote: function defined here\n  --> /tmp/tmpuyvhgif2.rs:17:4\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^\
    \ ---------  --------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j - i > n {\n            words.push(s.split_whitespace()[i\
    \ .. (j + 1)].collect::<Vec<_>>());\n            i = j;\n        }\n    }\n  \
    \  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplpi8udvr.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplpi8udvr.rs:25:20\n\
    \   |\n25 |         if j - i > n {\n   |                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i > n.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmplpi8udvr.rs:26:24\n\
    \   |\n26 |             words.push(s.split_whitespace()[i .. (j + 1)].collect::<Vec<_>>());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
