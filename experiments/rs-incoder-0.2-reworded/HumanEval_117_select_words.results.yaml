language: rs
name: HumanEval_117_select_words
results:
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            words.push(s.split_at(i).collect::<Vec<_>>());\n\
    \            i += n;\n        }\n        i += 1;\n    }\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpohsuegpe.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: `(&str, &str)` is not an iterator\n\
    \  --> /tmp/tmpohsuegpe.rs:22:38\n   |\n22 |             words.push(s.split_at(i).collect::<Vec<_>>());\n\
    \   |                                      ^^^^^^^ `(&str, &str)` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `(&str,\
    \ &str): Iterator`\n           which is required by `&mut (&str, &str): Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpohsuegpe.rs:23:18\n   |\n23 |\
    \             i += n;\n   |                  ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpohsuegpe.rs:23:15\n\
    \   |\n23 |             i += n;\n   |               ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n != 0 {\n\
    \        if s.chars().any(|c| c.is_consonant()) {\n            result.push(s);\n\
    \        }\n        n -= 1;\n        s = s.chars().filter(|c| c.is_consonant()).collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpwx46q1q0.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmpwx46q1q0.rs:26:36\n  \
    \ |\n26 |         s = s.chars().filter(|c| c.is_consonant()).collect();\n   |\
    \                                    ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    let mut vowel_counter2 = 0;\n    let mut consonant_counter2 = 0;\n\
    \    let mut vowel_counter3 = 0;\n    let mut consonant_counter3 = 0;\n    let\
    \ mut vowel_counter4 = 0;\n    let mut consonant_counter4 = 0;\n    let mut vowel_counter5\
    \ = 0;\n    let mut consonant_counter5 = 0;\n    let mut vowel_counter6 = 0;\n\
    \    let mut consonant_counter6 = 0;\n    let mut vowel_counter7 = 0;\n    let\
    \ mut consonant_counter7 = 0;\n    let mut vowel_counter8 = 0;\n    let mut consonant_counter8\
    \ = 0;\n    let mut vowel_counter9 = 0;\n    let mut consonant_counter9 = 0;\n\
    \    let mut vowel_counter10 = 0;\n    let mut consonant_counter10 = 0;\n    let\
    \ mut vowel_counter11 = 0;\n    let mut consonant_counter11 = 0;\n    let mut\
    \ vowel_counter12 = 0;\n    let mut consonant_counter12 = 0;\n    let mut vowel_counter13\
    \ = 0;\n    let mut consonant_counter13 = 0;\n    let mut vowel_counter14 = 0;\n\
    \    let mut consonant_counter14 = 0;\n    let mut vowel_counter15 = 0;\n    let\
    \ mut consonant_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let mut\
    \ consonant_counter16 = 0;\n    let mut vowel_counter17 = 0;\n    let mut consonant_counter17\
    \ = 0;\n    let mut vowel_counter18 = 0;\n    let mut consonant_counter18 = 0;\n\
    \    let mut vowel_counter19 = 0;\n    let mut consonant_counter19 = 0;\n    let\
    \ mut vowel_counter20 = 0;\n    let mut consonant_counter20 = 0;\n    let mut\
    \ vowel_counter21 = 0;\n    let mut consonant_counter21 = 0;\n    let mut vowel_counter22\
    \ = 0;\n    let mut consonant_counter22 = 0;\n    let mut vowel_counter23 = 0;\n\
    \    let mut consonant_counter23 = 0;\n    let mut vowel_counter24 = 0;\n    let\
    \ mut conson\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd15xoqpe.rs:68:19\n   |\n\
    68 |     let mut conson\n   |                   ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd15xoqpe.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowel_counter = 0;\n    let mut vowel_counter2 = 0;\n    let mut\
    \ vowel_counter3 = 0;\n    let mut vowel_counter4 = 0;\n    let mut vowel_counter5\
    \ = 0;\n    let mut vowel_counter6 = 0;\n    let mut vowel_counter7 = 0;\n   \
    \ let mut vowel_counter8 = 0;\n    let mut vowel_counter9 = 0;\n    let mut vowel_counter10\
    \ = 0;\n    let mut vowel_counter11 = 0;\n    let mut vowel_counter12 = 0;\n \
    \   let mut vowel_counter13 = 0;\n    let mut vowel_counter14 = 0;\n    let mut\
    \ vowel_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let mut vowel_counter17\
    \ = 0;\n    let mut vowel_counter18 = 0;\n    let mut vowel_counter19 = 0;\n \
    \   let mut vowel_counter20 = 0;\n    let mut vowel_counter21 = 0;\n    let mut\
    \ vowel_counter22 = 0;\n    let mut vowel_counter23 = 0;\n    let mut vowel_counter24\
    \ = 0;\n    let mut vowel_counter25 = 0;\n    let mut vowel_counter26 = 0;\n \
    \   let mut vowel_counter27 = 0;\n    let mut vowel_counter28 = 0;\n    let mut\
    \ vowel_counter29 = 0;\n    let mut vowel_counter30 = 0;\n    let mut vowel_counter31\
    \ = 0;\n    let mut vowel_counter32 = 0;\n    let mut vowel_counter33 = 0;\n \
    \   let mut vowel_counter34 = 0;\n    let mut vowel_counter35 = 0;\n    let mut\
    \ vowel_counter36 = 0;\n    let mut vowel_counter37 = 0;\n    let mut vowel_counter38\
    \ = 0;\n    let mut vowel_counter39 = 0;\n    let mut vowel_counter40 = 0;\n \
    \   let mut vowel_counter41 = 0;\n    let mut vowel_counter42 = 0;\n    let mut\
    \ vowel_counter43 = 0;\n    let mut vowel_counter44 = 0;\n    let mut vowel_counter45\
    \ = 0;\n    let mut vowel_counter46 = 0;\n    let mut vowel_counter47 = 0;\n \
    \   let mut vowel_counter48 = 0;\n    let mut vowel_counter49 = 0;\n    let mut\
    \ vowel_counter50 = 0;\n    let mut vowel_counter51 = 0;\n    let mut vowel_counter52\
    \ = 0;\n    let mut vowel_counter53 = 0;\n    let mut vowel_counter54 = 0;\n \
    \   let mut \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpl13o8muc.rs:76:1\n\
    \   |\n76 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n                j -= 1;\n          \
    \  } else {\n                i += 1;\n            }\n        }\n        if i ==\
    \ j {\n            result.push(s.clone());\n            i += 1;\n        }\n \
    \       if i == n {\n            result.push(s.clone());\n        }\n        s\
    \ = &s[i..];\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkfupdugh.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkfupdugh.rs:35:17\n\
    \   |\n35 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkfupdugh.rs:38:13\n   |\n19 |     let mut s = s;\n   |        \
    \         - expected due to this value\n...\n38 |         s = &s[i..];\n   | \
    \            ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n38 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut i = 0;\n        let mut j = s.len();\n        while i < j {\n\
    \            if s[i] == ' ' {\n                i += 1;\n                j -= 1;\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \     if i == n {\n            result.push(s.clone());\n        }\n        s =\
    \ &s[i..];\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnjdxfpnk.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnjdxfpnk.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnjdxfpnk.rs:34:13\n   |\n19 |     let mut s = String::from(s);\n\
    \   |                 --------------- expected due to this value\n...\n34 |  \
    \       s = &s[i..];\n   |             ^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n34 |         s = (&s[i..]).to_string();\n\
    \   |             +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().all(|c| c == s.chars().nth(j)) {\n   \
    \         j += 1\n        }\n        if j == s.len() {\n            result.push(s.clone());\n\
    \            i += 1;\n        } else {\n            if s.chars().all(|c| c ==\
    \ s.chars().nth(j)) {\n                result.push(s.clone());\n             \
    \   i += 1;\n            } else {\n                i += j - i;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf5zo6ywb.rs:24:53\n   |\n\
    24 |         while j < s.len() && s.chars().all(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf5zo6ywb.rs:31:39\n\
    \   |\n31 |             if s.chars().all(|c| c == s.chars().nth(j)) {\n   |  \
    \                                     ^^^^^^^^^^^^^^^^ expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<char>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut s = String::from(s);\n    let mut n = n;\n    while\
    \ n != 0 {\n        let mut i = 0;\n        while i < s.len() {\n            if\
    \ s.chars().any(|c| c == ' ' || c == '\\t' || c == '\\n') {\n                i\
    \ += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n              \
    \  i += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n              \
    \  i += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'y' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n  \
    \              i += 1;\n                continue;\n            }\n           \
    \ if s.chars().any(|c| c == 'Y' || c == 'A' || c == 'E' || c == 'I' || c == 'O'\
    \ || c == 'U') {\n                i += 1;\n                continue;\n       \
    \     }\n            if s.chars().any(|c| c == 'i' || c == 'o' || c == 'u') {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if s.chars().any(|c| c == 'I' || c == 'O' || c == 'U') {\n               \
    \ i += 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'n' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n  \
    \              i += 1;\n                continue;\n            }\n           \
    \ if s.chars().any(|c| c == 'N' || c == 'A' || c == 'E' || c == 'I' || c == 'O'\
    \ || c == 'U') {\n                i += 1;\n                continue;\n       \
    \     }\n            if s.chars().any(|c| c == 't' || c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n                i += 1;\n             \
    \   continue;\n            }\n            if s.chars().any(|c| c == 'T' || c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                i +=\
    \ 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == 'h' || c == 'e' || c == 'l' || c == 'l' || c == 'o' || c == 'r') {\n  \
    \              i += 1;\n                continue;\n            }\n           \
    \ if s.chars().any(|c| c == 'H' || c == '\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmppccytj0o.rs:72:51\n\
    \   |\n72 |             if s.chars().any(|c| c == 'H' || c == '\n   |        \
    \                                           ^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         if i == s.len() {\n                break;\n            }\n         \
    \   words.push(s.to_string());\n            i += 1;\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpjakc9qkh.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j - i > n {\n            words.push(s.subslice(i, j));\n \
    \           i = j;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8bo1rrzq.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bo1rrzq.rs:25:20\n\
    \   |\n25 |         if j - i > n {\n   |                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i > n.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `subslice` found for struct `String` in the current scope\n  --> /tmp/tmp8bo1rrzq.rs:26:26\n\
    \   |\n26 |             words.push(s.subslice(i, j));\n   |                  \
    \        ^^^^^^^^ method not found in `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            break;\n        }\n        let mut word\
    \ = String::from(&s[i .. j]);\n        let mut count = 0;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n     \
    \       break;\n        }\n        let mut consonants = String::from(&s[i .. j]);\n\
    \        if consonants.chars().count() == n {\n            words.push(word);\n\
    \            i += j - i;\n        }\n        i += j - i;\n    }\n    words\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp23454b0m.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp23454b0m.rs:30:30\n   |\n30 |         while j < s.len() && s[j]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp23454b0m.rs:37:42\n\
    \   |\n37 |         if consonants.chars().count() == n {\n   |               \
    \                           ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n37 |         if consonants.chars().count() == n.try_into().unwrap()\
    \ {\n   |                                           ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut punctuation = vec![];\n    let mut\
    \ letters = vec![];\n    let mut numbers = vec![];\n    let mut spaces_at_start\
    \ = vec![];\n    let mut spaces_at_end = vec![];\n    let mut punctuation_at_start\
    \ = vec![];\n    let mut punctuation_at_end = vec![];\n    let mut letters_at_start\
    \ = vec![];\n    let mut letters_at_end = vec![];\n    let mut numbers_at_start\
    \ = vec![];\n    let mut numbers_at_end = vec![];\n    let mut spaces_at_start_at_end\
    \ = vec![];\n    let mut spaces_at_end_at_start = vec![];\n    let mut punctuation_at_start_at_end\
    \ = vec![];\n    let mut punctuation_at_end_at_start = vec![];\n    let mut letters_at_start_at_end\
    \ = vec![];\n    let mut letters_at_end_at_start = vec![];\n    let mut numbers_at_start_at_end\
    \ = vec![];\n    let mut numbers_at_end_at_start = vec![];\n    let mut spaces_at_start_at_end_at_end\
    \ = vec![];\n    let mut spaces_at_end_at_start_at_end = vec![];\n    let mut\
    \ punctuation_at_start_at_end_at_end = vec![];\n    let mut punctuation_at_end_at_start_at_end\
    \ = vec![];\n    let mut letters_at_start_at_end_at_end = vec![];\n    let mut\
    \ letters_at_end_at_start_at_end = vec![];\n    let mut numbers_at_start_at_end_at_end\
    \ = vec![];\n    let mut numbers_at_end_at_start_at_end = vec![];\n    let mut\
    \ spaces_at_start_at_end_at_end_at_end = vec![];\n    let mut spaces_at_end_at_start_at_end_at_end\
    \ = vec![];\n    let mut punctuation_at_start_at_end_at_end_at_end = vec![];\n\
    \    let mut punctuation_at_end_at_start_at_end_at_end = vec![];\n    let mut\
    \ letters_at_start_at_end_at_end_at_end = vec![];\n    let mut letters_at_end_at_start_at_end_at_end\
    \ = vec![];\n    let mut numbers_at_start_at_end_at_end_at_end = vec![];\n   \
    \ let mut numbers_at_end_at_start_at_end_at_end = vec![];\n\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4y96u3qt.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    let mut n = n as usize;\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c| c.is_uppercase()\
    \ && c.is_consonant()) {\n            result.push(s.subslice(i, i + n));\n   \
    \         i += n;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmppdm3tz68.rs:23:52\n   |\n23 |         if s.chars().any(|c|\
    \ c.is_uppercase() && c.is_consonant()) {\n   |                              \
    \                      ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `subslice` found for struct `String` in the current scope\n\
    \  --> /tmp/tmppdm3tz68.rs:24:27\n   |\n24 |             result.push(s.subslice(i,\
    \ i + n));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    let mut n = n as usize;\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c| c !=\
    \ ' ' && c != '\\t' && c != '\\n' && c != '\\r') {\n            if n == 0 {\n\
    \                break;\n            }\n            n -= 1;\n        } else {\n\
    \            result.push(s.subslice(i, i + 1));\n            i += 1;\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmppaz1x8em.rs:29:27\n   |\n29 |             result.push(s.subslice(i,\
    \ i + 1));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut i = 0;\n        let mut j = s.len();\n        while i < j {\n\
    \            if s[i] == ' ' {\n                i += 1;\n                j -= 1;\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \     if i == n {\n            result.push(s.clone());\n        }\n        s =\
    \ &s[..i];\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxz8r_of0.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxz8r_of0.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxz8r_of0.rs:34:13\n   |\n19 |     let mut s = String::from(s);\n\
    \   |                 --------------- expected due to this value\n...\n34 |  \
    \       s = &s[..i];\n   |             ^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n34 |         s = (&s[..i]).to_string();\n\
    \   |             +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j].is_ascii_letter() {\n            j\
    \ = j + 1;\n        }\n        if j == s.len() {\n            break;\n       \
    \ }\n        let mut k = j;\n        while k < s.len() && s[k].is_ascii_letter()\
    \ {\n            k = k + 1;\n        }\n        if k == s.len() {\n          \
    \  break;\n        }\n        let mut c = s[k];\n        while k < s.len() &&\
    \ s[k].is_ascii_letter() {\n            c = c + s[k];\n            k = k + 1;\n\
    \        }\n        if k == s.len() {\n            break;\n        }\n       \
    \ if c == n {\n            words.push(s.subslice(i, j));\n        }\n        i\
    \ = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppa1nhvbk.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppa1nhvbk.rs:29:30\n\
    \   |\n29 |         while k < s.len() && s[k].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppa1nhvbk.rs:35:21\n\
    \   |\n35 |         let mut c = s[k];\n   |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().any(|c| c.is_consonant() && c != ' ') {\n          \
    \  count += 1;\n            if count == n {\n                words.push(s.to_string());\n\
    \                count = 0;\n            }\n        }\n        i += 1;\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpja23fwx3.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n != 0 {\n\
    \        let mut i = 0;\n        while i < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') {\n                break;\n\
    \            }\n            i += 1;\n        }\n        if i == s.len() {\n  \
    \          break;\n        }\n        let mut j = i;\n        while j < s.len()\
    \ {\n            if s.chars().any(|c| c == ' ' || c == '\\t' || c == '\\n' ||\
    \ c == '\\r') {\n                break;\n            }\n            i += 1;\n\
    \            j += 1\n        }\n        if i == j {\n            break;\n    \
    \    }\n        let mut k = i;\n        while k < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') {\n                break;\n\
    \            }\n            i += 1;\n            k += 1\n        }\n        if\
    \ i == k {\n            break;\n        }\n        let mut m = i;\n        while\
    \ m < s.len() {\n            if s.chars().any(|c| c == ' ' || c == '\\t' || c\
    \ == '\\n' || c == '\\r') {\n                break;\n            }\n         \
    \   i += 1;\n            m += 1\n        }\n        if i == m {\n            break;\n\
    \        }\n        let mut l = i;\n        while l < s.len() {\n            if\
    \ s.chars().any(|c| c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') {\n  \
    \              break;\n            }\n            i += 1;\n            l += 1\n\
    \        }\n        if i == l {\n            break;\n        }\n        let mut\
    \ n = i;\n        while n < s.len() {\n            if s.chars().any(|c| c == '\
    \ ' || c == '\\t' || c == '\\n' || c == '\\r') {\n                break;\n   \
    \         }\n            i += 1;\n            n += 1\n        }\n        if i\
    \ == n {\n            break;\n        }\n        result.push(s.split_whitespace().nth(i).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpotav9dbo.rs:89:5\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n89 |     result\n   |     ^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words(s,\
    \ n, vec![])\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmpuyvhgif2.rs:18:5\n   |\n18 |     select_words(s, n, vec![])\n \
    \  |     ^^^^^^^^^^^^ -  -  ------ supplied 3 arguments\n   |     |\n   |    \
    \ expected 2 arguments\n   |\nnote: function defined here\n  --> /tmp/tmpuyvhgif2.rs:17:4\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^\
    \ ---------  --------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j - i > n {\n            words.push(s.split_whitespace()[i\
    \ .. (j + 1)].collect::<Vec<_>>());\n            i = j;\n        }\n    }\n  \
    \  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplpi8udvr.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplpi8udvr.rs:25:20\n\
    \   |\n25 |         if j - i > n {\n   |                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i > n.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmplpi8udvr.rs:26:24\n\
    \   |\n26 |             words.push(s.split_whitespace()[i .. (j + 1)].collect::<Vec<_>>());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n;\n\
    \    while n != 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n      \
    \      result.push(s);\n        }\n        n -= 1;\n        s = s.chars().filter(|c|\
    \ !c.is_consonant()).collect();\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp7srt6dm_.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmp7srt6dm_.rs:26:37\n  \
    \ |\n26 |         s = s.chars().filter(|c| !c.is_consonant()).collect();\n   |\
    \                                     ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n > 0 {\n\
    \        let mut i = 0;\n        while i < s.len() {\n            if s[i] == '\
    \ ' {\n                i += 1;\n                continue;\n            }\n   \
    \         if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i]\
    \ == 'u' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'y' || s[i] == 'u' || s[i] == 'i' || s[i] == 'o' || s[i]\
    \ == 'a' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 's' || s[i] == 'd' || s[i] == 'h' || s[i] == 'e' || s[i]\
    \ == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'n' {\n                i +=\
    \ 1;\n                continue;\n            }\n            if s[i] == 't' ||\
    \ s[i] == 'e' || s[i] == 'a' || s[i] == 'm' || s[i] == 'a' || s[i] == 'i' || s[i]\
    \ == 'o' || s[i] == 'n' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'h' || s[i] == 'a' || s[i] == 'm' || s[i]\
    \ == 'a' || s[i] == 'i' || s[i] == 'o' || s[i] == 'n' {\n                i +=\
    \ 1;\n                continue;\n            }\n            if s[i] == 'r' ||\
    \ s[i] == 'a' || s[i] == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'r' || s[i]\
    \ == 'u' || s[i] == 'e' || s[i] == 's' {\n                i += 1;\n          \
    \      continue;\n            }\n            if s[i] == 'p' || s[i] == 'e' ||\
    \ s[i] == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'r' || s[i] == 'u' || s[i]\
    \ == 'e' || s[i] == 's' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'c' || s[i] == 'o' || s[i] == 'n' || s[i]\
    \ == 't' || s[i] == 'h' || s[i] == 'e' || s[i] == 'r' || s[i] == 'e' || s[i] ==\
    \ 'n' || s[i] == 's' {\n                i += 1;\n                continue;\n \
    \           }\n            if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i]\
    \ == 'o' || s[i] == 'u' || s[i] == 'y' || s[i] == 'u' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'a' {\n                i += 1;\n                continue;\n \
    \           }\n            if s[i] == 'y' || s[i] == 'u' || s[i] == 'i' || s[i]\
    \ == 'o' || s[i] == 'a' || s[i] == 's' || s[i] == 'd' || s[i] == 'h' || s[i] ==\
    \ 'e' || s[i] == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'n' {\n        \
    \        i += 1;\n                continue;\n            }\n            if s[i]\
    \ == 't' || s[i] == 'e\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpf1y721ej.rs:80:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n21\
    \ |     while n > 0 {\n   |                 - unclosed delimiter\n22 |       \
    \  let mut i = 0;\n23 |         while i < s.len() {\n   |                    \
    \       - this delimiter might not be properly closed...\n...\n69 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n80 | }\n   |  \
    \ ^\n\nerror: expected `while`, `for`, `loop` or `{` after a label\n  --> /tmp/tmpf1y721ej.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected `while`, `for`, `loop` or `{` after a label\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmpf1y721ej.rs:69:1\n   |\n\
    69 | }\n   | ^ expected expression\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpf1y721ej.rs:24:16\n   |\n24 |            \
    \ if s[i] == ' ' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf1y721ej.rs:28:16\n\
    \   |\n28 |             if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'u' {\n   |                ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpf1y721ej.rs:28:31\n\
    \   |\n28 |             if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'u' {\n   |                               ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpf1y721ej.rs:28:46\n   |\n28 |             if s[i] == 'a' || s[i]\
    \ == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n   |                \
    \                              ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the tra"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        let mut j = i;\n        while j < s.len() && s.chars().any(|c|\
    \ c != s.chars().nth(j)) {\n            j += 1\n        }\n        if j == i {\n\
    \            v.push(s.to_string());\n            i += 1;\n        } else {\n \
    \           i += j - i;\n        }\n    }\n    v.sort_unstable();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyydhe_4q.rs:23:53\n   |\n\
    23 |         while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyydhe_4q.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n > 0 {\n\
    \        let mut i = s.find(' ').unwrap();\n        let mut j = i;\n        let\
    \ mut k = i;\n        while j < s.len() {\n            let mut c = s[j];\n   \
    \         if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n    \
    \            result.push(s.split_whitespace()[k..j].join(\"\"));\n           \
    \     k = j + 1;\n            }\n            j = j + 1;\n        }\n        s\
    \ = s.split_whitespace()[k..];\n        n = n - 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpiakwr0xc.rs:26:25\n\
    \   |\n26 |             let mut c = s[j];\n   |                         ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpiakwr0xc.rs:28:29\n   |\n28 |         \
    \        result.push(s.split_whitespace()[k..j].join(\"\"));\n   |           \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpiakwr0xc.rs:33:13\n   |\n\
    33 |         s = s.split_whitespace()[k..];\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowel_counter = 0;\n    let mut vowel_counter2 = 0;\n    let mut\
    \ vowel_counter3 = 0;\n    let mut vowel_counter4 = 0;\n    let mut vowel_counter5\
    \ = 0;\n    let mut vowel_counter6 = 0;\n    let mut vowel_counter7 = 0;\n   \
    \ let mut vowel_counter8 = 0;\n    let mut vowel_counter9 = 0;\n    let mut vowel_counter10\
    \ = 0;\n    let mut vowel_counter11 = 0;\n    let mut vowel_counter12 = 0;\n \
    \   let mut vowel_counter13 = 0;\n    let mut vowel_counter14 = 0;\n    let mut\
    \ vowel_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let mut vowel_counter17\
    \ = 0;\n    let mut vowel_counter18 = 0;\n    let mut vowel_counter19 = 0;\n \
    \   let mut vowel_counter20 = 0;\n    let mut vowel_counter21 = 0;\n    let mut\
    \ vowel_counter22 = 0;\n    let mut vowel_counter23 = 0;\n    let mut vowel_counter24\
    \ = 0;\n    let mut vowel_counter25 = 0;\n    let mut vowel_counter26 = 0;\n \
    \   let mut vowel_counter27 = 0;\n    let mut vowel_counter28 = 0;\n    let mut\
    \ vowel_counter29 = 0;\n    let mut vowel_counter30 = 0;\n    let mut vowel_counter31\
    \ = 0;\n    let mut vowel_counter32 = 0;\n    let mut vowel_counter33 = 0;\n \
    \   let mut vowel_counter34 = 0;\n    let mut vowel_counter35 = 0;\n    let mut\
    \ vowel_counter36 = 0;\n    let mut vowel_counter37 = 0;\n    let mut vowel_counter38\
    \ = 0;\n    let mut vowel_counter39 = 0;\n    let mut vowel_counter40 = 0;\n \
    \   let mut vowel_counter41 = 0;\n    let mut vowel_counter42 = 0;\n    let mut\
    \ vowel_counter43 = 0;\n    let mut vowel_counter44 = 0;\n    let mut vowel_counter45\
    \ = 0;\n    let mut vowel_counter46 = 0;\n    let mut vowel_counter47 = 0;\n \
    \   let mut vowel_counter48 = 0;\n    let mut vowel_counter49 = 0;\n    let mut\
    \ vowel_counter50 = 0;\n    let mut vowel_counter51 = 0;\n    let mut vowel_counter52\
    \ = 0;\n    let mut vowel_counter53 = 0;\n    let mut vowel_counter54 = 0;\n \
    \   let mut \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpl13o8muc.rs:76:1\n\
    \   |\n76 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        let mut j = i;\n        while j < s.len() && s.chars().any(|c|\
    \ c != s.chars().nth(j)) {\n            j = j + 1;\n        }\n        if j ==\
    \ i {\n            v.push(s.to_string());\n            i += 1;\n        } else\
    \ {\n            v.push(s.to_string().chars().nth(j).unwrap());\n            i\
    \ += j - i;\n        }\n    }\n    v.sort_unstable();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    \n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsd199pua.rs:23:53\n   |\n\
    23 |         while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsd199pua.rs:30:20\n\
    \   |\n30 |             v.push(s.to_string().chars().nth(j).unwrap());\n   | \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsd199pua.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    for word in s.split_whitespace()\
    \ {\n        if count >= n {\n            words.push(word);\n            count\
    \ -= n;\n        } else {\n            count += 1;\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6izn9vjv.rs:28:5\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n28 |     words\n   |     ^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s = s;\n    let mut words = vec![];\n    while s.len() > 0 {\n        let mut\
    \ word = String::new();\n        let mut consonants = String::new();\n       \
    \ let mut vowels = String::new();\n        let mut spaces = String::new();\n \
    \       let mut letters = String::new();\n        let mut numbers = String::new();\n\
    \        let mut punctuation = String::new();\n        let mut space = false;\n\
    \        let mut vowel = false;\n        let mut consonant = false;\n        let\
    \ mut letter = false;\n        let mut number = false;\n        let mut punctuation\
    \ = false;\n        for c in s.chars() {\n            if c == ' ' {\n        \
    \        space = true;\n                continue;\n            }\n           \
    \ if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            \
    \    vowel = true;\n                continue;\n            }\n            if c\
    \ == 'b' || c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j'\
    \ || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q' || c\
    \ == 'r' || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x' || c == 'y'\
    \ || c == 'z' {\n                consonant = true;\n                continue;\n\
    \            }\n            if c == '0' {\n                number = true;\n  \
    \              continue;\n            }\n            if c == '!' || c == '?' ||\
    \ c == '.' || c == '-' || c == '_' || c == '~' || c == '\\'' || c == '(' || c\
    \ == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == ':' || c == ';'\
    \ || c == '<' || c == '>' || c == '/' || c == '|' || c == '\\\\' || c == '@' ||\
    \ c == '^' || c == '~' || c == '`' || c == '{' || c == '}' || c == '[' || c ==\
    \ ']' || c == '(' || c == ')' || c == '<' || c == '>' || c == '/' || c == '|'\
    \ || c == '\\\\' || c == '@' || c == '^' || c == '~' || c == '`' || c == '{' ||\
    \ c == '}' || c == '[' || c == ']' || c == '(' || c == ')' || c == '<' || c ==\
    \ '>' || c == '/' || c == '|' || c == '\\\\' || c == '@' || c == '^' || c == '~'\
    \ || c == '`' || c == '{' || c\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfne0npb8.rs:63:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n20\
    \ |     while s.len() > 0 {\n   |                       - unclosed delimiter\n\
    ...\n34 |         for c in s.chars() {\n   |                            - this\
    \ delimiter might not be properly closed...\n...\n52 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n63 | }\n   |   ^\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmpfne0npb8.rs:52:1\n   |\n51 |             if c\
    \ == '!' || c == '?' || c == '.' || c == '-' || c == '_' || c == '~' || c == '\\\
    '' || c == '(' || c == ')' || c == '[' || c...\n   |             -- this `if`\
    \ expression has a condition, but no block\n52 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfne0npb8.rs:20:5\n   |\n17 |   fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \        ----------- expected `Vec<String>` because of return type\n...\n20 |\
    \ /     while s.len() > 0 {\n21 | |         let mut word = String::new();\n22\
    \ | |         let mut consonants = String::new();\n23 | |         let mut vowels\
    \ = String::new();\n...  |\n62 | |     assert_eq!(candidate(String::from(\"a b\
    \ c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n63 | | }\n   | |__^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<String>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n                j -= 1;\n          \
    \  } else {\n                i += 1;\n            }\n        }\n        if i ==\
    \ j {\n            result.push(s.clone());\n            i += 1;\n        }\n \
    \       if i == n {\n            i += 1;\n        }\n        s = &s[i..];\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5xutzw_5.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5xutzw_5.rs:35:17\n\
    \   |\n35 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |         if i == n.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5xutzw_5.rs:38:13\n   |\n38 |         s = &s[i..];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n38 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            break;\n        }\n        let mut k\
    \ = i;\n        while k < j && s[k] == ' ' {\n            k += 1\n        }\n\
    \        if k == j {\n            break;\n        }\n        if s[k] == 'a' &&\
    \ s[k+1] == 'p' && s[k+2] == 'p' && s[k+3] == 'i' && s[k+4] == 'n' {\n       \
    \     result.push(s.to_string());\n        }\n        i += k - j;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk49v0d6_.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpk49v0d6_.rs:29:24\n   |\n\
    29 |         while k < j && s[k] == ' ' {\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpk49v0d6_.rs:35:12\n   |\n35 |         if s[k] == 'a'\
    \ && s[k+1] == 'p' && s[k+2] == 'p' && s[k+3] == 'i' && s[k+4] == 'n' {\n   |\
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpk49v0d6_.rs:35:27\n   |\n\
    35 |         if s[k] == 'a' && s[k+1] == 'p' && s[k+2] == 'p' && s[k+3] == 'i'\
    \ && s[k+4] == 'n' {\n   |                           ^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk49v0d6_.rs:35:44\n   |\n35 |         if s[k] == 'a' && s[k+1]\
    \ == 'p' && s[k+2] == 'p' && s[k+3] == 'i' && s[k+4] == 'n' {\n   |          \
    \                                  ^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk49v0d6_.rs:35:61\n\
    \   |\n35 |         if s[k] == 'a' && s[k+1] == 'p' && s[k+2] == 'p' && s[k+3]\
    \ == 'i' && s[k+4] == 'n' {\n   |                                            \
    \                 ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexe"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n > 0 {\n\
    \        let mut i = 0;\n        while i < s.len() {\n            let c = s.chars().nth(i).unwrap();\n\
    \            if c != ' ' && c != '\\t' && c != '\\n' && c != '\\r' && c != '\\\
    0' {\n                result.push(s.subslice(i, i + 1));\n                i +=\
    \ 1;\n            } else {\n                i += 1;\n            }\n        }\n\
    \        n -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpme_xpmxt.rs:26:31\n   |\n26 |                 result.push(s.subslice(i,\
    \ i + 1));\n   |                               ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n > 0 {\n\
    \        let mut i = 0;\n        while i < s.len() {\n            let c = s.chars().nth(i).unwrap();\n\
    \            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \               i += 1;\n            } else {\n                result.push(s.to_string());\n\
    \                break;\n            }\n        }\n        n -= 1;\n        s\
    \ = s.to_string();\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpeuymb9jn.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_helper(s,\
    \ n, 0)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmp8p6hmq8g.rs:18:5\n   |\n18 |     select_words_helper(s, n, 0)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659805232
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut punctuation = vec![];\n    let mut\
    \ letters = vec![];\n    let mut numbers = vec![];\n    let mut spaces_count =\
    \ s.chars().filter(|c| c == ' ').count();\n    let mut punctuation_count = s.chars().filter(|c|\
    \ c == '.' || c == '!' || c == '?' || c == ';' || c == '-' || c == '_').count();\n\
    \    let mut letters_count = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >=\
    \ 'A' && c <= 'Z').count();\n    let mut numbers_count = s.chars().filter(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut spaces_count = s.chars().filter(|c|\
    \ c == ' ').count();\n    let mut punctuation_count = s.chars().filter(|c| c ==\
    \ '.' || c == '!' || c == '?' || c == ';' || c == '-' || c == '_').count();\n\
    \    let mut letters_count = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >=\
    \ 'A' && c <= 'Z').count();\n    let mut numbers_count = s.chars().filter(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut spaces_count = s.chars().filter(|c|\
    \ c == ' ').count();\n    let mut punctuation_count = s.chars().filter(|c| c ==\
    \ '.' || c == '!' || c == '?' || c == ';' || c == '-' || c == '_').count();\n\
    \    let mut letters_count = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >=\
    \ 'A' && c <= 'Z').count();\n    let mut numbers_count = s.chars().filter(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut spaces_count = s.chars().filter(|c|\
    \ c == ' ').count();\n    let mut punctuation_count = s.chars().filter(|c| c ==\
    \ '.' || c == '!' || c == '?' || c == ';' || c == '-' || c == '_').count();\n\
    \    let mut letters_count = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >=\
    \ '\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpue1_cyw2.rs:39:79\n\
    \   |\n39 |     let mut letters_count = s.chars().filter(|c| c >= 'a' && c <=\
    \ 'z' || c >= '\n   |                                                        \
    \                       ^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659805232
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut count = 0;\n        let mut word = String::from(\"\");\n        while\
    \ count < n && index < s.len() {\n            if s[index] == ' ' {\n         \
    \       count++;\n            } else {\n                word += s[index];\n  \
    \              count++;\n            }\n            index += 1;\n        }\n \
    \       if count == n {\n            words.push(word);\n        }\n    }\n   \
    \ words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp8pedv8rn.rs:25:23\n\
    \   |\n25 |                 count++;\n   |                       ^ expected expression\n\
    \nerror: expected expression, found `+`\n  --> /tmp/tmp8pedv8rn.rs:28:23\n   |\n\
    28 |                 count++;\n   |                       ^ expected expression\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8pedv8rn.rs:24:16\n\
    \   |\n24 |             if s[index] == ' ' {\n   |                ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp8pedv8rn.rs:27:25\n   |\n27 |                 word\
    \ += s[index];\n   |                         ^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        while i < s.len() && s.chars().any(|c| c.is_consonant() == true)\
    \ {\n            i += 1;\n        }\n        if i == s.len() {\n            result.push(s);\n\
    \            break;\n        }\n        let mut j = i;\n        while j < s.len()\
    \ && s.chars().any(|c| c.is_consonant() == false) {\n            j += 1;\n   \
    \     }\n        if j == s.len() {\n            result.push(s);\n            break;\n\
    \        }\n        let mut k = j;\n        while k < s.len() && s.chars().any(|c|\
    \ c.is_consonant() == true) {\n            k += 1;\n        }\n        if k ==\
    \ s.len() {\n            result.push(s);\n            break;\n        }\n    \
    \    let mut l = k;\n        while l < s.len() && s.chars().any(|c| c.is_consonant()\
    \ == false) {\n            l += 1;\n        }\n        if l == s.len() {\n   \
    \         result.push(s);\n            break;\n        }\n        let mut m =\
    \ l;\n        while m < s.len() && s.chars().any(|c| c.is_consonant() == true)\
    \ {\n            m += 1;\n        }\n        if m == s.len() {\n            result.push(s);\n\
    \            break;\n        }\n        let mut n = m;\n        while n < s.len()\
    \ && s.chars().any(|c| c.is_consonant() == false) {\n            n += 1;\n   \
    \     }\n        if n == s.len() {\n            result.push(s);\n            break;\n\
    \        }\n        let mut o = n;\n        while o < s.len() && s.chars().any(|c|\
    \ c.is_consonant() == true) {\n            o += 1;\n        }\n        if o ==\
    \ s.len() {\n            result.push(s);\n            break;\n        }\n    \
    \    let mut p = o;\n        while p < s.len() && s.chars().any(|c| c.is_consonant()\
    \ == false) {\n            p += 1;\n        }\n        if p == s.len() {\n   \
    \         result.push(s);\n            break;\n        }\n        let mut q =\
    \ p;\n        while q < s.len() && s.chars().any(|c| c.is_consonant() == true)\
    \ {\n            q += 1;\n        }\n        if q == s.len() {\n            result.push(s);\n\
    \            break;\n        }\n        let mut r = q;\n        while r < s.len()\
    \ && s.chars().any(|c| c.is_consonant() == false) {\n            r += 1;\n   \
    \     }\n        if r == s.len() {\n            result.push(s);\n            break;\n\
    \        }\n        let mut s = r;\n        while s < s.len() && s.\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjq3_zj3c.rs:114:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while s.len() > 0 {\n    |                       - this delimiter might\
    \ not be properly closed...\n...\n103 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n114 | }\n    |   ^\n\nerror: unexpected token:\
    \ `}`\n   --> /tmp/tmpjq3_zj3c.rs:103:1\n    |\n103 | }\n    | ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmpjq3_zj3c.rs:103:1\n    |\n103 | }\n    | ^ expected\
    \ `{`\n\nerror[E0599]: no method named `is_consonant` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpjq3_zj3c.rs:22:50\n   |\n22 |         while\
    \ i < s.len() && s.chars().any(|c| c.is_consonant() == true) {\n   |         \
    \                                         ^^^^^^^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpjq3_zj3c.rs:30:50\n   |\n30 |         while j < s.len()\
    \ && s.chars().any(|c| c.is_consonant() == false) {\n   |                    \
    \                              ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `is_consonant` found for type `char` in the current scope\n\
    \  --> /tmp/tmpjq3_zj3c.rs:38:50\n   |\n38 |         while k < s.len() && s.chars().any(|c|\
    \ c.is_consonant() == true) {\n   |                                          \
    \        ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `is_consonant` found for type `char` in the current scope\n  --> /tmp/tmpjq3_zj3c.rs:46:50\n\
    \   |\n46 |         while l < s.len() && s.chars().any(|c| c.is_consonant() ==\
    \ false) {\n   |                                                  ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_consonant` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpjq3_zj3c.rs:54:50\n   |\n\
    54 |         while m < s.len() && s.chars().any(|c| c.is_consonant() == true)\
    \ {\n   |                 "
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().any(|c| c.is_consonant() && count < n) {\n         \
    \   words.push(s.to_string());\n            i += 1;\n            count += 1;\n\
    \        }\n        else {\n            i += 1;\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp1iqs6aa3.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant() && count < n) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = 0;\n        while i < s.len() && j < n {\n     \
    \       if s[i] == ' ' {\n                i += 1;\n            } else {\n    \
    \            i += 1;\n                j += 1;\n            }\n        }\n    \
    \    if i == s.len() {\n            result.push(s.clone());\n        }\n     \
    \   s = &s[i..];\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe7u93ihg.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe7u93ihg.rs:34:13\n\
    \   |\n34 |         s = &s[i..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n34 |        \
    \ s = (&s[i..]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n                j -= 1;\n          \
    \  } else {\n                i += 1;\n            }\n        }\n        if i ==\
    \ n {\n            result.push(s.clone());\n        }\n        s = &s[i..];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4xjye9ej.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xjye9ej.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4xjye9ej.rs:34:13\n   |\n34 |         s = &s[i..];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n34 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowels_count = vec![];\n    let mut vowels_count_index = vec![];\n\
    \    let mut vowels_count_index2 = vec![];\n    let mut vowels_count_index3 =\
    \ vec![];\n    let mut vowels_count_index4 = vec![];\n    let mut vowels_count_index5\
    \ = vec![];\n    let mut vowels_count_index6 = vec![];\n    let mut vowels_count_index7\
    \ = vec![];\n    let mut vowels_count_index8 = vec![];\n    let mut vowels_count_index9\
    \ = vec![];\n    let mut vowels_count_index10 = vec![];\n    let mut vowels_count_index11\
    \ = vec![];\n    let mut vowels_count_index12 = vec![];\n    let mut vowels_count_index13\
    \ = vec![];\n    let mut vowels_count_index14 = vec![];\n    let mut vowels_count_index15\
    \ = vec![];\n    let mut vowels_count_index16 = vec![];\n    let mut vowels_count_index17\
    \ = vec![];\n    let mut vowels_count_index18 = vec![];\n    let mut vowels_count_index19\
    \ = vec![];\n    let mut vowels_count_index20 = vec![];\n    let mut vowels_count_index21\
    \ = vec![];\n    let mut vowels_count_index22 = vec![];\n    let mut vowels_count_index23\
    \ = vec![];\n    let mut vowels_count_index24 = vec![];\n    let mut vowels_count_index25\
    \ = vec![];\n    let mut vowels_count_index26 = vec![];\n    let mut vowels_count_index27\
    \ = vec![];\n    let mut vowels_count_index28 = vec![];\n    let mut vowels_count_index29\
    \ = vec![];\n    let mut vowels_count_index30 = vec![];\n    let mut vowels_count_index31\
    \ = vec![];\n    let mut vowels_count_index32 = vec![];\n    let mut vowels_count_index33\
    \ = vec![];\n    let mut vowels_count_index34 = vec![];\n    let mut vowels_count_index35\
    \ = vec![];\n    let mut vowels_count_index36 = vec![];\n    let mut vowels_count_index37\
    \ = vec![];\n    let mut vowels_count_\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpilf78qva.rs:59:26\n   |\n\
    59 |     let mut vowels_count_\n   |                          ^ help: add `;`\
    \ here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpilf78qva.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) ->\
    \ Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805232
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n != 0 {\n\
    \        if s.is_empty() {\n            break;\n        }\n        let mut i =\
    \ 0;\n        let mut j = s.len();\n        while i < j {\n            let c =\
    \ s.chars().nth(i).unwrap();\n            if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' {\n                i += 1;\n            } else {\n \
    \               j -= 1;\n            }\n        }\n        if i == j {\n     \
    \       result.push(s.clone());\n        }\n        n -= 1;\n        s = s.chars().nth(j).unwrap();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjr7lhvdk.rs:39:13\n   |\n\
    39 |         s = s.chars().nth(j).unwrap();\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |             |\n  \
    \ |             expected struct `String`, found `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut punctuation = vec![];\n    let mut\
    \ letters = vec![];\n    let mut numbers = vec![];\n    let mut spaces_count =\
    \ s.chars().filter(|c| c == ' ').count();\n    let mut punctuation_count = s.chars().filter(|c|\
    \ c == '.' || c == '!' || c == '?' || c == ';' || c == '-' || c == '_' || c ==\
    \ '/' || c == '\\\\' || c == '@' || c == '$' || c == '^' || c == '&' || c == '*'\
    \ || c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c\
    \ == '<' || c == '>' || c == '|' || c == ':' || c == '~' || c == '?').count();\n\
    \    let mut letters_count = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >=\
    \ 'A' && c <= 'Z').count();\n    let mut numbers_count = s.chars().filter(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut vowels_count = s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count();\n    let\
    \ mut consonants_count = s.chars().filter(|c| c >= 'b' && c <= 'z' || c >= 'B'\
    \ && c <= 'Z').count();\n    let mut spaces_count_2 = s.chars().filter(|c| c ==\
    \ ' ').count();\n    let mut punctuation_count_2 = s.chars().filter(|c| c == '.'\
    \ || c == '!' || c == '?' || c == ';' || c == '-' || c == '_' || c == '/' || c\
    \ == '\\\\' || c == '@' || c == '$' || c == '^' || c == '&' || c == '*' || c ==\
    \ '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == '<'\
    \ || c == '>' || c == '|' || c == ':' || c == '~' || c == '?').count();\n    let\
    \ mut letters_count_2 = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A'\
    \ && c <= 'Z').count();\n    let mut numbers_count_2 = s.char\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdu0mhyse.rs:34:37\n   |\n\
    34 |     let mut numbers_count_2 = s.char\n   |                              \
    \       ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpdu0mhyse.rs:25:51\n   |\n25\
    \ |     let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n   | \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdu0mhyse.rs:26:56\n\
    \   |\n26 |     let mut punctuation_count = s.chars().filter(|c| c == '.' || c\
    \ == '!' || c == '?' || c == ';' || c == '-' || c == '_' || c == '/' || ...\n\
    \   |                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdu0mhyse.rs:26:68\n\
    \   |\n26 |     let mut punctuation_count = s.chars().filter(|c| c == '.' || c\
    \ == '!' || c == '?' || c == ';' || c == '-' || c == '_' || c == '/' || ...\n\
    \   |                                                                    ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpdu0mhyse.rs:26:80\n   |\n26 |     let mut punctuation_count = s.chars().filter(|c|\
    \ c == '.' || c == '!' || c == '?' || c == ';' || c == '-' || c == '_' || c ==\
    \ '/' || ...\n   |                                                           \
    \                     ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpdu0mhyse.rs:26:92\n   |\n26\
    \ |     let mut punctuation_count = s.chars().filter(|c| c == '.' || c == '!'\
    \ || c == '?' || c == ';' || c == '-' || c == '_' || c == '/' || ...\n   |   \
    \                 "
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    for c in s.chars() {\n        if\
    \ c.is_consonant() {\n            count += 1;\n            if count == n {\n \
    \               words.push(c.to_string());\n            }\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpj6i0_qjb.rs:21:14\n   |\n21 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j - i == n {\n            words.push(s.split_whitespace()[i]);\n\
    \            i += j - i;\n        }\n        i += 1;\n    }\n    words\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp8h3syem.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp8h3syem.rs:25:21\n   |\n25 |         if j - i == n {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n25 |         if j - i == n.try_into().unwrap() {\n   |                \
    \     ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpp8h3syem.rs:26:24\n   |\n26 |         \
    \    words.push(s.split_whitespace()[i]);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = s.to_string();\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        let mut j = i;\n        while j < s.len() && s.chars().any(|c|\
    \ c != s.chars().nth(j)) {\n            j += 1\n        }\n        if j == i {\n\
    \            v.push(s.to_string());\n            i += 1;\n        } else {\n \
    \           i += j - i;\n        }\n    }\n    if v.len() == 0 {\n        Vec::new()\n\
    \    } else {\n        v\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa7rhrvm1.rs:23:53\n   |\n\
    23 |         while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == s.len() {\n            words.push(s.to_string());\n \
    \           break;\n        }\n        let mut k = j;\n        while k < s.len()\
    \ && s[k] == ' ' {\n            k += 1\n        }\n        if k == s.len() {\n\
    \            words.push(s.to_string());\n            break;\n        }\n     \
    \   let mut count = 0;\n        while k < s.len() && s[k] == s[(j + k) as usize]\
    \ {\n            count += 1;\n            k += 1\n        }\n        if count\
    \ == n {\n            words.push(s.to_string());\n        }\n        i += k -\
    \ j;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp83ydvzyz.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp83ydvzyz.rs:30:30\n   |\n\
    30 |         while k < s.len() && s[k] == ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp83ydvzyz.rs:38:30\n   |\n38 |  \
    \       while k < s.len() && s[k] == s[(j + k) as usize] {\n   |             \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp83ydvzyz.rs:38:38\n\
    \   |\n38 |         while k < s.len() && s[k] == s[(j + k) as usize] {\n   | \
    \                                     ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j + 1;\n\
    \        }\n        if j - i > n {\n            words.push(s.split_whitespace()[i\
    \ .. j]);\n            i = j;\n        }\n    }\n    words\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpllozjikg.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpllozjikg.rs:25:20\n   |\n25 |         if j - i > n {\n\
    \   |                    ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n25 |         if j - i > n.try_into().unwrap() {\n   |                 \
    \   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpllozjikg.rs:26:24\n   |\n26 |             words.push(s.split_whitespace()[i\
    \ .. j]);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\"\
    , \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels = vec![\"a\"\
    , \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonants = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_pairs = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_triples = vec![\"a\",\
    \ \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_quadruples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_quintuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_sextuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_septuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_octuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_nonuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_pairs = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_triples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_quadruples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_quintuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_sextuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_septuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_octuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_nonuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_pairs = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_triple\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi9kxxdt7.rs:39:35\n   |\n\
    39 |     let mut vowel_consonant_triple\n   |                                \
    \   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi9kxxdt7.rs:17:41\n   |\n17 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        let mut k = j;\n        while k < s.len() && s[k] == ' ' {\n\
    \            k += 1\n        }\n        if k == i {\n            i += 1;\n   \
    \         continue;\n        }\n        if k > i {\n            if s.chars().any(|c|\
    \ c == ' ') {\n                i += 1;\n                continue;\n          \
    \  }\n        }\n        if j > i {\n            if s.chars().any(|c| c == ' ')\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \   }\n        if s.chars().any(|c| c == ' ') {\n            i += 1;\n       \
    \     continue;\n        }\n        if s.chars().any(|c| c != ' ') {\n       \
    \     i += 1;\n            continue;\n        }\n        if s.chars().any(|c|\
    \ c != ' ') {\n            i += 1;\n            continue;\n        }\n       \
    \ if s.chars().any(|c| c != ' ') {\n            i += 1;\n            continue;\n\
    \        }\n        if s.chars().any(|c| c != ' ') {\n            i += 1;\n  \
    \          continue;\n        }\n        if s.chars().any(|c| c != ' ') {\n  \
    \          i += 1;\n            continue;\n        }\n        if s.chars().any(|c|\
    \ c != ' ') {\n            i += 1;\n            continue;\n        }\n       \
    \ if s.chars().any(|c| c != ' ') {\n            i += 1;\n            continue;\n\
    \        }\n        if s.chars().any(|c| c != ' ') {\n            i += 1;\n  \
    \          continue;\n        }\n        if s.chars().any(|c| c != ' ') {\n  \
    \          i += 1;\n            continue;\n        }\n        if s.chars().any(|c|\
    \ c != ' ') {\n            i += 1;\n            continue;\n        }\n       \
    \ if s.chars().any(|c| c != ' ') {\n            i += 1;\n            continue;\n\
    \        }\n        if s.chars().any(|c| c != ' ') {\n            i += 1;\n  \
    \          continue;\n        }\n        if s.chars().any(|c| c != ' ') {\n  \
    \          i += 1;\n            continue;\n        }\n        if s.chars().any(|c|\
    \ c != ' ') {\n            i += 1;\n            continue;\n        }\n       \
    \ if s.chars().any(|c| c != ' ') {\n            i += 1;\n            continue;\n\
    \        }\n        if s.chars().any(|c| c != ' ') {\n            i += 1;\n  \
    \          continue;\n        }\n\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8qht8ce9.rs:125:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < s.len() {\n    |                       - this delimiter might\
    \ not be properly closed...\n...\n114 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n125 | }\n    |   ^\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp8qht8ce9.rs:22:30\n   |\n\
    22 |         while j < s.len() && s[j] == ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp8qht8ce9.rs:26:30\n   |\n26 |  \
    \       while k < s.len() && s[k] == ' ' {\n   |                             \
    \ ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8qht8ce9.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().any(|c| c != ' ' && c != '\\t' && c != '\\\
    n') {\n            if s.chars().all(|c| c != ' ' && c != '\\t' && c != '\\n')\
    \ {\n                if s.chars().count(|c| c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u') {\n                    if s.chars().count(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                       \
    \ v.push(s.subslice(i, i + n));\n                        i += n;\n           \
    \         }\n                }\n            }\n        }\n        i += 1;\n  \
    \  }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpknv2r8y9.rs:24:30\n    |\n24  |                 if s.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n    |         \
    \                     ^^^^^ ------------------------------------------------------------\
    \ supplied 1 argument\n    |                              |\n    |           \
    \                   expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpknv2r8y9.rs:24:20\n  \
    \ |\n24 |                 if s.chars().count(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `usize`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpknv2r8y9.rs:25:34\n    |\n25  |\
    \                     if s.chars().count(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n    |                                  ^^^^^ ------------------------------------------------------------\
    \ supplied 1 argument\n    |                                  |\n    |       \
    \                           expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpknv2r8y9.rs:25:24\n\
    \   |\n25 |                     if s.chars().count(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `usize`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpknv2r8y9.rs:26:34\n\
    \   |\n26 |                         v.push(s.subslice(i, i + n));\n   |      \
    \                            ^^^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpknv2r8y9.rs:26:50\n   |\n26 |              \
    \           v.push(s.subslice(i, i + n));\n   |                              \
    \                    ^ expected `"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        if\
    \ s.chars().any(|c| c != ' ') {\n            if s.chars().all(|c| c == s.chars().nth(i))\
    \ {\n                i += 1;\n            } else {\n                words.push(s.chars().nth(i));\n\
    \                i += 1;\n            }\n        } else {\n            i += 1;\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyegmtwiq.rs:22:39\n   |\n\
    22 |             if s.chars().all(|c| c == s.chars().nth(i)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyegmtwiq.rs:32:5\n   |\n17 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n32 |     words\n   |     ^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Option<char>>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut word = String::from(\"\");\n        let mut found = false;\n     \
    \   for c in s.chars() {\n            if c == ' ' {\n                if word !=\
    \ \"\" {\n                    found = true;\n                    break;\n    \
    \            }\n            } else {\n                if found {\n           \
    \         break;\n                }\n                if c == c.to_ascii_lowercase()[n\
    \ - 1] {\n                    word += c;\n                    found = true;\n\
    \                }\n            }\n        }\n        if found {\n           \
    \ words.push(word);\n        }\n        index += 1;\n    }\n    words\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpng2x4636.rs:33:25\n\
    \   |\n33 |                 if c == c.to_ascii_lowercase()[n - 1] {\n   |    \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpng2x4636.rs:34:29\n   |\n34 |                     word\
    \ += c;\n   |                             ^ expected `&str`, found `char`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    let mut n = n as usize;\n\
    \    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n       \
    \ while j < s.len() && s.chars().any(|c| c != ' ') {\n            j += 1\n   \
    \     }\n        if j == i {\n            break;\n        }\n        let mut k\
    \ = i;\n        while k < j && s.chars().any(|c| c != ' ') {\n            k +=\
    \ 1\n        }\n        if k == i {\n            break;\n        }\n        if\
    \ s.chars().all(|c| c != ' ') {\n            result.push(s.split_whitespace()[k..i].collect::<String>());\n\
    \        }\n        i = k;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp42l9gm6f.rs:38:25\n   |\n38 |             result.push(s.split_whitespace()[k..i].collect::<String>());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut word = String::from(\"\");\n        let mut pos = 0;\n      \
    \  while pos < s.len() {\n            let c = s[pos];\n            if c != ' '\
    \ {\n                word.push(c);\n                pos += 1;\n            } else\
    \ {\n                if word.len() == n {\n                    result.push(word);\n\
    \                }\n                word.clear();\n                pos = 0;\n\
    \            }\n        }\n        s = String::from(&s[pos..]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyptt_apt.rs:24:21\n\
    \   |\n24 |             let c = s[pos];\n   |                     ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyptt_apt.rs:29:34\n\
    \   |\n29 |                 if word.len() == n {\n   |                       \
    \           ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n29\
    \ |                 if word.len() == n.try_into().unwrap() {\n   |           \
    \                       ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         words.push(s.split_whitespace()[i]);\n            i += 1;\n        }\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpb7bqdd_f.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpb7bqdd_f.rs:24:24\n   |\n24 |         \
    \    words.push(s.split_whitespace()[i]);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ word = String::new();\n        let mut i = 0;\n        while i < s.len() &&\
    \ s.chars().any(|c| c != ' ') {\n            word.push(s.chars()[i as usize]);\n\
    \            i += 1;\n        }\n        if word.chars().count() == n {\n    \
    \        result.push(word);\n        }\n        s = &s[word.len()..];\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmphl3gwm74.rs:24:23\n\
    \   |\n24 |             word.push(s.chars()[i as usize]);\n   |              \
    \         ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphl3gwm74.rs:27:36\n\
    \   |\n27 |         if word.chars().count() == n {\n   |                     \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    27 |         if word.chars().count() == n.try_into().unwrap() {\n   |        \
    \                            ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphl3gwm74.rs:30:13\n   |\n30 |         s = &s[word.len()..];\n\
    \   |             ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n  \
    \ |\nhelp: try using a conversion method\n   |\n30 |         s = (&s[word.len()..]).to_string();\n\
    \   |             +                +++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s.chars().all(|c| c != s.chars().nth(j))\
    \ {\n            j = j + 1;\n        }\n        if j == i {\n            break;\n\
    \        }\n        let mut word = String::from(&s[i .. j]);\n        if word.chars().count(|c|\
    \ c != s.chars().nth(j)) >= n {\n            words.push_back(word);\n        }\n\
    \        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplmehi1ao.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().all(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmplmehi1ao.rs:29:25\n    |\n29  |\
    \         if word.chars().count(|c| c != s.chars().nth(j)) >= n {\n    |     \
    \                    ^^^^^ ------------------------- supplied 1 argument\n   \
    \ |                         |\n    |                         expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplmehi1ao.rs:29:61\n   |\n29 |         if word.chars().count(|c|\
    \ c != s.chars().nth(j)) >= n {\n   |                                        \
    \                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    29 |         if word.chars().count(|c| c != s.chars().nth(j)) >= n.try_into().unwrap()\
    \ {\n   |                                                             ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmplmehi1ao.rs:30:19\n   |\n30 |             words.push_back(word);\n\
    \   |                   ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut i = 0;\n        while i < s.len() && s[i] == ' ' {\n        \
    \    i += 1;\n        }\n        if i == s.len() {\n            break;\n     \
    \   }\n        let mut j = i;\n        while j < s.len() && s[j] == ' ' {\n  \
    \          j += 1;\n        }\n        if j == s.len() {\n            break;\n\
    \        }\n        let mut k = j;\n        while k < s.len() && s[k] == ' ' {\n\
    \            k += 1;\n        }\n        if k == s.len() {\n            break;\n\
    \        }\n        if s.chars().all(|c| c == ' ' || c == ' ' || c == ' ') {\n\
    \            break;\n        }\n        if s.chars().all(|c| c != ' ' && c !=\
    \ ' ' && c != ' ') {\n            result.push(s.split_whitespace().nth(i).unwrap());\n\
    \        }\n        s = &s[..k];\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6rohnri1.rs:22:30\n\
    \   |\n22 |         while i < s.len() && s[i] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp6rohnri1.rs:29:30\n   |\n\
    29 |         while j < s.len() && s[j] == ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp6rohnri1.rs:36:30\n   |\n36 |  \
    \       while k < s.len() && s[k] == ' ' {\n   |                             \
    \ ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6rohnri1.rs:48:13\n\
    \   |\n48 |         s = &s[..k];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n48 |        \
    \ s = (&s[..k]).to_string();\n   |             +       +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6rohnri1.rs:50:5\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n50 |  \
    \   result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    for c in s.chars() {\n        if\
    \ c.is_consonant() {\n            count += 1;\n            if count == n {\n \
    \               words.push(c.to_string());\n                count = 0;\n     \
    \       }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpfgz85o4j.rs:21:14\n   |\n21 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut word = String::from(\"\");\n        let mut found = false;\n     \
    \   for c in s.chars() {\n            if c.is_consonant() && found == false {\n\
    \                word += c;\n                found = true;\n            } else\
    \ if found == true {\n                break;\n            }\n        }\n     \
    \   if found == true {\n            if word.len() == n {\n                words.push(word);\n\
    \            }\n        }\n        index += 1;\n    }\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp4mljk6cm.rs:24:18\n   |\n24 |             if c.is_consonant()\
    \ && found == false {\n   |                  ^^^^^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4mljk6cm.rs:25:25\n\
    \   |\n25 |                 word += c;\n   |                         ^ expected\
    \ `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4mljk6cm.rs:32:30\n\
    \   |\n32 |             if word.len() == n {\n   |                           \
    \   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n32 |      \
    \       if word.len() == n.try_into().unwrap() {\n   |                       \
    \       ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == s.len() {\n            v.push(s.to_string());\n     \
    \       break;\n        }\n        let mut k = j;\n        while k < s.len() &&\
    \ s[k] != ' ' {\n            k += 1\n        }\n        if k == s.len() {\n  \
    \          v.push(s.to_string());\n            break;\n        }\n        if s.chars().nth(j).unwrap()\
    \ == s.chars().nth(k).unwrap() && j > k {\n            v.push(s.to_string());\n\
    \            break;\n        }\n        if s.chars().nth(j).unwrap() == s.chars().nth(k).unwrap()\
    \ && j == k {\n            v.push(s.to_string());\n            break;\n      \
    \  }\n        if s.chars().nth(j).unwrap() != s.chars().nth(k).unwrap() && j >\
    \ k {\n            v.push(s.to_string());\n            break;\n        }\n   \
    \     if s.chars().nth(j).unwrap() != s.chars().nth(k).unwrap() && j == k {\n\
    \            v.push(s.to_string());\n            break;\n        }\n        i\
    \ += 1;\n    }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n \
    \   assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp97d1fa8a.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp97d1fa8a.rs:30:30\n   |\n\
    30 |         while k < s.len() && s[k] != ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut count = 0;\n        let mut c = s.chars().nth(index).unwrap();\n \
    \       while c != ' ' && c != '\\t' && c != '\\n' && c != '\\0' {\n         \
    \   if c.is_consonant() {\n                count += 1;\n            }\n      \
    \      c += 1;\n        }\n        if count == n {\n            words.push(s.chars().nth(index).unwrap());\n\
    \            index += 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmprp7vekex.rs:24:18\n   |\n24 |             if c.is_consonant()\
    \ {\n   |                  ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmprp7vekex.rs:27:13\n\
    \   |\n27 |             c += 1;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprp7vekex.rs:34:5\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n34 |     words\n   |     ^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().any(|c| c != ' ') {\n            if s.chars().all(|c|\
    \ c == s.chars().nth(i)) {\n                v.push(s.subslice(i, i + n));\n  \
    \              i += n;\n            }\n        }\n        i += 1;\n    }\n   \
    \ v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp84kz6a03.rs:23:39\n   |\n\
    23 |             if s.chars().all(|c| c == s.chars().nth(i)) {\n   |         \
    \                              ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0599]: no method named `subslice` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp84kz6a03.rs:24:26\n   |\n24 |                 v.push(s.subslice(i,\
    \ i + n));\n   |                          ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp84kz6a03.rs:24:42\n   |\n24 |\
    \                 v.push(s.subslice(i, i + n));\n   |                        \
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add\
    \ `isize` to `usize`\n  --> /tmp/tmp84kz6a03.rs:24:40\n   |\n24 |            \
    \     v.push(s.subslice(i, i + n));\n   |                                    \
    \    ^ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp84kz6a03.rs:25:22\n\
    \   |\n25 |                 i += n;\n   |                      ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmp84kz6a03.rs:25:19\n\
    \   |\n25 |                 i += n;\n   |                   ^^ no implementation\
    \ for `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    let mut n = n as usize;\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c| c.is_uppercase()\
    \ && c != ' ') {\n            result.push(s.subslice(i, i + n));\n           \
    \ i += n;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmppn0conab.rs:24:27\n   |\n24 |             result.push(s.subslice(i,\
    \ i + n));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c != ' ' && c != '\\t' && c != '\\n') {\n            if s.chars().all(|c| c\
    \ != ' ' && c != '\\t' && c != '\\n') {\n                if s.chars().all(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n  \
    \                  if s.chars().all(|c| c != 'a' && c != 'e' && c != 'i' && c\
    \ != 'o' && c != 'u' && c != 'y') {\n                        if s.chars().all(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n  \
    \                          if s.chars().all(|c| c != 'a' && c != 'e' && c != 'i'\
    \ && c != 'o' && c != 'u' && c != 'y') {\n                                if s.chars().all(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n  \
    \                                  if s.chars().all(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n                          \
    \              if s.chars().all(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o'\
    \ && c != 'u' && c != 'y') {\n                                            if s.chars().all(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n  \
    \                                              if s.chars().all(|c| c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n              \
    \                                      if s.chars().all(|c| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n                       \
    \                                 if s.chars().all(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n                          \
    \                                  if s.chars().all(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n                          \
    \                                      if s.chars().all(|c| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n                       \
    \                                             if s.chars().all(|c| c != 'a' &&\
    \ \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxoii6r4q.rs:48:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n20\
    \ |     while i < s.len() {\n   |                       - unclosed delimiter\n\
    21 |         if s.chars().any(|c| c != ' ' && c != '\\t' && c != '\\n') {\n  \
    \ |                                                                  - unclosed\
    \ delimiter\n22 |             if s.chars().all(|c| c != ' ' && c != '\\t' && c\
    \ != '\\n') {\n   |                                                          \
    \            - unclosed delimiter\n23 |                 if s.chars().all(|c| c\
    \ != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n   |\
    \                                                                            \
    \                                - unclosed delimiter\n24 |                  \
    \   if s.chars().all(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c !=\
    \ 'u' && c != 'y') {\n   |                                                   \
    \                                                             - unclosed delimiter\n\
    25 |                         if s.chars().all(|c| c != 'a' && c != 'e' && c !=\
    \ 'i' && c != 'o' && c != 'u' && c != 'y') {\n   |                           \
    \                                                                            \
    \             - unclosed delimiter\n26 |                             if s.chars().all(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n  \
    \ |                                                                          \
    \                                              - unclosed delimiter\n27 |    \
    \                             if s.chars().all(|c| c != 'a' && c != 'e' && c !=\
    \ 'i' && c != 'o' && c != 'u' && c != 'y') {\n   |                           \
    \                                                                            \
    \                     - unclosed delimiter\n28 |                             \
    \        if s.chars().all(|c| c != 'a' && c != 'e' && c != 'i' &&"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut s = String::from(s);\n    let mut n = n as usize;\n\
    \    while n != 0 {\n        if s.contains(&consonants[n % consonants.len()])\
    \ {\n            words.push(String::from(&s[s.len() - n ..]));\n        }\n  \
    \      n /= consonants.len();\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `consonants` in this scope\n  --> /tmp/tmpy_a91a4p.rs:22:24\n\
    \   |\n22 |         if s.contains(&consonants[n % consonants.len()]) {\n   | \
    \                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `consonants` in this scope\n  --> /tmp/tmpy_a91a4p.rs:22:39\n   |\n\
    22 |         if s.contains(&consonants[n % consonants.len()]) {\n   |        \
    \                               ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `consonants` in this scope\n  --> /tmp/tmpy_a91a4p.rs:25:14\n\
    \   |\n25 |         n /= consonants.len();\n   |              ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n;\n    while\
    \ n != 0 {\n        if s.contains(&consonants[n % consonants.len()]) {\n     \
    \       v.push(s.clone());\n        }\n        n /= consonants.len();\n    }\n\
    \    v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `consonants` in this scope\n  --> /tmp/tmpy7rzt1qg.rs:22:24\n\
    \   |\n22 |         if s.contains(&consonants[n % consonants.len()]) {\n   | \
    \                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `consonants` in this scope\n  --> /tmp/tmpy7rzt1qg.rs:22:39\n   |\n\
    22 |         if s.contains(&consonants[n % consonants.len()]) {\n   |        \
    \                               ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `consonants` in this scope\n  --> /tmp/tmpy7rzt1qg.rs:25:14\n\
    \   |\n25 |         n /= consonants.len();\n   |              ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_helper(s,\
    \ n, 0)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmp8p6hmq8g.rs:18:5\n   |\n18 |     select_words_helper(s, n, 0)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659805232
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            break;\n        }\n        let mut word\
    \ = String::from(&s[i .. j]);\n        let mut found = false;\n        for c in\
    \ &s[i .. j] {\n            if !c.is_ascii_lowercase() {\n                continue;\n\
    \            }\n            if found {\n                break;\n            }\n\
    \            if c == ' ' {\n                found = true;\n            }\n   \
    \         word += c;\n        }\n        if found {\n            words.push(word);\n\
    \        }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3fgres28.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: `&str`\
    \ is not an iterator\n   --> /tmp/tmp3fgres28.rs:30:18\n    |\n30  |         for\
    \ c in &s[i .. j] {\n    |                  ^^^^^^^^^^ `&str` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator`\
    \ is not implemented for `&str`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&str`\nnote: required by `into_iter`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut index = 0;\n    while index < s.len() {\n \
    \       let mut word = String::new();\n        let mut consonant = false;\n  \
    \      for c in s.chars() {\n            if c == ' ' {\n                consonant\
    \ = true;\n                continue;\n            }\n            if !consonant\
    \ {\n                word.push(c);\n            }\n            if n == index {\n\
    \                consonant = false;\n                break;\n            }\n \
    \       }\n        if consonant {\n            words.push(word);\n        }\n\
    \        index += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcu4amiua.rs:31:21\n   |\n\
    31 |             if n == index {\n   |                     ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n31 |             if n == index.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut spaces = vec![\" \"];\n    let mut punctuation\
    \ = vec![\".\", \",\", \";\", \"!\", \"?\"];\n    let mut numbers = vec![\"1\"\
    , \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n    let mut punctuation_count\
    \ = vec![0];\n    let mut vowel_count = vec![0];\n    let mut consonant_count\
    \ = vec![0];\n    let mut space_count = vec![0];\n    let mut number_count = vec![0];\n\
    \    let mut punctuation_count_copy = vec![0];\n    let mut vowel_count_copy =\
    \ vec![0];\n    let mut consonant_count_copy = vec![0];\n    let mut space_count_copy\
    \ = vec![0];\n    let mut number_count_copy = vec![0];\n    let mut punctuation_count_copy2\
    \ = vec![0];\n    let mut vowel_count_copy2 = vec![0];\n    let mut consonant_count_copy2\
    \ = vec![0];\n    let mut space_count_copy2 = vec![0];\n    let mut number_count_copy2\
    \ = vec![0];\n    let mut punctuation_count_copy3 = vec![0];\n    let mut vowel_count_copy3\
    \ = vec![0];\n    let mut consonant_count_copy3 = vec![0];\n    let mut space_count_copy3\
    \ = vec![0];\n    let mut number_count_copy3 = vec![0];\n    let mut punctuation_count_copy4\
    \ = vec![0];\n    let mut vowel_count_copy4 = vec![0];\n    let mut consonant_count_copy4\
    \ = vec![0];\n    let mut space_count_copy4 = vec![0];\n    let mut number_count_copy4\
    \ = vec![0];\n    let mut punctuation_count_copy5 = vec![0];\n    let mut vowel_count_copy5\
    \ = vec![0];\n    let mut consonant_count_copy5 = vec![0];\n    let mut space_count_copy5\
    \ = vec![0];\n    let mut number_count_copy5 = vec![0];\n    let mut punctuation_count_copy6\
    \ = vec![0];\n    let mut vowel_count_copy6 = vec![0];\n    let mut consonant_count_copy6\
    \ = vec![0];\n    let mut space_count_copy6 = vec![0];\n\n}\n\nfn main() {\n \
    \   let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpopwnqn_z.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j = j + 1;\n\
    \        }\n        if j == s.len() {\n            break;\n        }\n       \
    \ let mut word = String::from(&s[i .. j]);\n        if word.chars().count(|c|\
    \ c != ' ') >= n {\n            words.push_back(word);\n            i = j;\n \
    \       }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0dynfjou.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp0dynfjou.rs:29:25\n\
    \    |\n29  |         if word.chars().count(|c| c != ' ') >= n {\n    |      \
    \                   ^^^^^ ------------ supplied 1 argument\n    |            \
    \             |\n    |                         expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0dynfjou.rs:29:48\n\
    \   |\n29 |         if word.chars().count(|c| c != ' ') >= n {\n   |         \
    \                                       ^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |         if word.chars().count(|c| c != ' ') >=\
    \ n.try_into().unwrap() {\n   |                                              \
    \  ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `push_back` found for\
    \ struct `Vec<_>` in the current scope\n  --> /tmp/tmp0dynfjou.rs:30:19\n   |\n\
    30 |             words.push_back(word);\n   |                   ^^^^^^^^^ method\
    \ not found in `Vec<_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut found = false;\n        for c in s.chars() {\n            if index\
    \ == 0 {\n                if c.is_consonant() {\n                    found = true;\n\
    \                    break;\n                }\n            } else {\n       \
    \         if c.is_consonant() {\n                    found = true;\n         \
    \           break;\n                }\n            }\n            index += 1;\n\
    \        }\n        if found {\n            words.push(s.split_whitespace()[index].to_string());\n\
    \        }\n        index += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpbh4f6y7g.rs:24:22\n   |\n24 |                 if\
    \ c.is_consonant() {\n   |                      ^^^^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_consonant` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpbh4f6y7g.rs:29:22\n   |\n29 |          \
    \       if c.is_consonant() {\n   |                      ^^^^^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpbh4f6y7g.rs:37:24\n   |\n37 |             words.push(s.split_whitespace()[index].to_string());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = 0;\n        while i < s.len() && j < n {\n     \
    \       if s[i] == s[j] {\n                i += 1;\n                j += 1;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    if i == s.len() {\n            result.push(s.clone());\n        }\n     \
    \   s = &s[..i];\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkpm2o7d7.rs:24:16\n\
    \   |\n24 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpkpm2o7d7.rs:24:24\n   |\n24 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `isize`\n   |\n\
    \   = help: the trait `Index<isize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkpm2o7d7.rs:34:13\n   |\n34 |         s = &s[..i];\n\
    \   |             ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n34 |         s = (&s[..i]).to_string();\n\
    \   |             +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut word = String::from(\"\");\n        let mut found = false;\n     \
    \   for c in s.chars() {\n            if c == ' ' {\n                found = true;\n\
    \                break;\n            }\n            if found {\n             \
    \   word.push(c);\n                if word.len() == n {\n                    found\
    \ = false;\n                    break;\n                }\n            }\n   \
    \     }\n        if found {\n            words.push(word);\n        }\n      \
    \  index += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo8nndpi8.rs:30:34\n   |\n\
    30 |                 if word.len() == n {\n   |                              \
    \    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n30 |      \
    \           if word.len() == n.try_into().unwrap() {\n   |                   \
    \               ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut i = 0;\n        let mut j = s.len();\n        while i < j {\n\
    \            if s[i] == ' ' {\n                i += 1;\n                j -= 1;\n\
    \                continue;\n            }\n            if s[i] == ' ' && s[i +\
    \ 1] == ' ' {\n                i += 2;\n                j -= 2;\n            \
    \    continue;\n            }\n            if s[i] == ' ' && s[i + 1] != ' ' &&\
    \ s[i + 2] != ' ' {\n                i += 1;\n                j -= 1;\n      \
    \          continue;\n            }\n            if s[i] == ' ' && s[i + 1] !=\
    \ ' ' && s[i + 2] != ' ' && s[i + 3] != ' ' {\n                i += 2;\n     \
    \           j -= 2;\n                continue;\n            }\n            if\
    \ s[i] == ' ' && s[i + 1] != ' ' && s[i + 2] != ' ' && s[i + 3] != ' ' && s[i\
    \ + 4] != ' ' {\n                i += 3;\n                j -= 3;\n          \
    \      continue;\n            }\n            if s[i] == ' ' && s[i + 1] != ' '\
    \ && s[i + 2] != ' ' && s[i + 3] != ' ' && s[i + 4] != ' ' && s[i + 5] != ' '\
    \ {\n                i += 4;\n                j -= 4;\n                continue;\n\
    \            }\n            if s[i] == ' ' && s[i + 1] != ' ' && s[i + 2] != '\
    \ ' && s[i + 3] != ' ' && s[i + 4] != ' ' && s[i + 5] != ' ' && s[i + 6] != '\
    \ ' {\n                i += 5;\n                j -= 5;\n                continue;\n\
    \            }\n            if s[i] == ' ' && s[i + 1] != ' ' && s[i + 2] != '\
    \ ' && s[i + 3] != ' ' && s[i + 4] != ' ' && s[i + 5] != ' ' && s[i + 6] != '\
    \ ' && s[i + 7] != ' ' {\n                i += 6;\n                j -= 6;\n \
    \               continue;\n            }\n            if s[i] == ' ' && s[i +\
    \ 1] != ' ' && s[i + 2] != ' ' && s[i + 3] != ' ' && s[i + 4] != ' ' && s[i +\
    \ 5] != ' ' && s[i + 6] != ' ' && s[i + 7] != ' ' && s[i + 8] != ' ' {\n     \
    \           i += 7;\n                j -= 7;\n                continue;\n    \
    \        }\n            if s[i] == ' ' && s[i + 1] != ' ' && s[i + 2] != ' ' &&\
    \ s[i + 3] != ' ' && s[i + 4] != ' ' && s[i + 5] != ' ' && s[i + 6] != ' ' &&\
    \ s[i + 7] != ' ' && s[i + 8] != ' ' && s[i + 9] != ' ' {\n                i +=\
    \ 8;\n                j -= 8;\n                continue;\n            }\n\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpl2442_d5.rs:86:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n20\
    \ |     while s.len() > 0 {\n   |                       - unclosed delimiter\n\
    ...\n23 |         while i < j {\n   |                     - this delimiter might\
    \ not be properly closed...\n...\n75 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n86 | }\n   |   ^\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpl2442_d5.rs:24:16\n   |\n24 |  \
    \           if s[i] == ' ' {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpl2442_d5.rs:29:16\n   |\n29 |             if s[i] == ' ' && s[i\
    \ + 1] == ' ' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl2442_d5.rs:29:31\n\
    \   |\n29 |             if s[i] == ' ' && s[i + 1] == ' ' {\n   |            \
    \                   ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl2442_d5.rs:34:16\n\
    \   |\n34 |             if s[i] == ' ' && s[i + 1] != ' ' && s[i + 2] != ' ' {\n\
    \   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl2442_d5.rs:34:31\n\
    \   |\n34 |             if s[i] == ' ' && s[i + 1] != ' ' && s[i + 2] != ' ' {\n\
    \   |                               ^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed "
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut i = 0;\n        let mut j = s.len();\n        while i < j {\n          \
    \  if s[i] == ' ' {\n                i += 1;\n                j -= 1;\n      \
    \      } else {\n                i += 1;\n            }\n        }\n        if\
    \ i == n {\n            result.push(s.clone());\n        }\n        s = &s[i..];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpztyox_ni.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpztyox_ni.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpztyox_ni.rs:34:13\n   |\n34 |         s = &s[i..];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n34 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_helper(s,\
    \ n, 0)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmp8p6hmq8g.rs:18:5\n   |\n18 |     select_words_helper(s, n, 0)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659805232
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            result.push(s.subslice(i, i + n));\n\
    \            i += n;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp9qq2deuy.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp9qq2deuy.rs:22:27\n\
    \   |\n22 |             result.push(s.subslice(i, i + n));\n   |             \
    \              ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9qq2deuy.rs:22:43\n   |\n22 |             result.push(s.subslice(i,\
    \ i + n));\n   |                                           ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp9qq2deuy.rs:22:41\n\
    \   |\n22 |             result.push(s.subslice(i, i + n));\n   |             \
    \                            ^ no implementation for `usize + isize`\n   |\n \
    \  = help: the trait `Add<isize>` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9qq2deuy.rs:23:18\n   |\n23 |             i\
    \ += n;\n   |                  ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmp9qq2deuy.rs:23:15\n   |\n\
    23 |             i += n;\n   |               ^^ no implementation for `usize +=\
    \ isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented for\
    \ `usize`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n >\
    \ 0 {\n        let mut i = 0;\n        while i < s.len() {\n            if s[i]\
    \ == ' ' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i]\
    \ == 'u' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'y' || s[i] == 'u' || s[i] == 'a' || s[i] == 'e' || s[i]\
    \ == 'i' || s[i] == 'o' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 's' || s[i] == 'h' || s[i] == 'e' || s[i]\
    \ == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'w' {\n                i +=\
    \ 1;\n                continue;\n            }\n            if s[i] == 'd' ||\
    \ s[i] == 'o' || s[i] == 'm' || s[i] == 'a' || s[i] == 'l' || s[i] == 'l' || s[i]\
    \ == 'e' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'n' || s[i] == 'a' || s[i] == 'm' || s[i] == 'e' || s[i]\
    \ == 'r' || s[i] == 't' || s[i] == 'h' || s[i] == 's' {\n                i +=\
    \ 1;\n                continue;\n            }\n            if s[i] == 'c' ||\
    \ s[i] == 'h' || s[i] == 'a' || s[i] == 'l' || s[i] == 'l' || s[i] == 'o' || s[i]\
    \ == 'w' || s[i] == 's' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'b' || s[i] == 'e' || s[i] == 'l' || s[i]\
    \ == 'l' || s[i] == 'o' || s[i] == 'r' || s[i] == 'v' || s[i] == 'e' || s[i] ==\
    \ 'd' || s[i] == 'e' || s[i] == 'r' || s[i] == 's' {\n                i += 1;\n\
    \                continue;\n            }\n            if s[i] == 'f' || s[i]\
    \ == 'o' || s[i] == 'r' || s[i] == 'o' || s[i] == 'r' || s[i] == 'e' || s[i] ==\
    \ 'l' || s[i] == 'l' || s[i] == 'e' || s[i] == 'd' || s[i] == 'e' || s[i] == 'r'\
    \ || s[i] == 's' {\n                i += 1;\n                continue;\n     \
    \       }\n            if s[i] == 'g' || s[i] == 'u' || s[i] == 'l' || s[i] ==\
    \ 'l' || s[i] == 'o' || s[i] == 'r' || s[i] == 'v' || s[i] == 'e' || s[i] == 'd'\
    \ || s[i] == 'e' || s[i] == 'r' || s[i] == 's' {\n                i += 1;\n  \
    \              continue;\n            }\n            if s[i] == 'p' || s[i] ==\
    \ 'h' || s[i] == 'e' || s[i] == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'w'\
    \ || s[i] == 's' {\n                i += 1;\n                continue;\n     \
    \       }\n            if s[i]\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg0ljgnew.rs:80:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n21\
    \ |     while n > 0 {\n   |                 - unclosed delimiter\n22 |       \
    \  let mut i = 0;\n23 |         while i < s.len() {\n   |                    \
    \       - this delimiter might not be properly closed...\n...\n69 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n80 | }\n   |  \
    \ ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpg0ljgnew.rs:69:1\n   |\n\
    68 |             if s[i]\n   |             -- this `if` expression has a condition,\
    \ but no block\n69 | }\n   | ^ expected `{`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpg0ljgnew.rs:24:16\n   |\n24 |  \
    \           if s[i] == ' ' {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpg0ljgnew.rs:28:16\n   |\n28 |             if s[i] == 'a' || s[i]\
    \ == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpg0ljgnew.rs:28:31\n   |\n28 |            \
    \ if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n\
    \   |                               ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg0ljgnew.rs:28:46\n\
    \   |\n28 |             if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'u' {\n   |                                              ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String`"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            result.push(s.subslice(i, i + n));\n\
    \            i += n;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp9qq2deuy.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp9qq2deuy.rs:22:27\n\
    \   |\n22 |             result.push(s.subslice(i, i + n));\n   |             \
    \              ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9qq2deuy.rs:22:43\n   |\n22 |             result.push(s.subslice(i,\
    \ i + n));\n   |                                           ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp9qq2deuy.rs:22:41\n\
    \   |\n22 |             result.push(s.subslice(i, i + n));\n   |             \
    \                            ^ no implementation for `usize + isize`\n   |\n \
    \  = help: the trait `Add<isize>` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9qq2deuy.rs:23:18\n   |\n23 |             i\
    \ += n;\n   |                  ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmp9qq2deuy.rs:23:15\n   |\n\
    23 |             i += n;\n   |               ^^ no implementation for `usize +=\
    \ isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented for\
    \ `usize`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n                j -= 1;\n          \
    \  } else {\n                i += 1;\n            }\n        }\n        if i ==\
    \ n {\n            result.push(s.clone());\n        }\n        s = &s[i..];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4xjye9ej.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xjye9ej.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4xjye9ej.rs:34:13\n   |\n34 |         s = &s[i..];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n34 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            if\
    \ s.chars().any(|c| c != ' ' && c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u' && c != 'y') {\n                i += 1;\n            } else {\n   \
    \             j -= 1;\n            }\n        }\n        if i == n {\n       \
    \     result.push(s.clone());\n        }\n        s = &s[i..];\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpicgseic5.rs:30:17\n   |\n\
    30 |         if i == n {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |         if i == n.try_into().unwrap() {\n   |\
    \                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpicgseic5.rs:33:13\n   |\n33 |         s = &s[i..];\n   |           \
    \  ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion\
    \ method\n   |\n33 |         s = (&s[i..]).to_string();\n   |             +  \
    \     +++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n != 0 {\n\
    \        let mut i = 0;\n        while i < s.len() {\n            let c = s.chars().nth(i).unwrap();\n\
    \            if c.is_uppercase() {\n                i += 1;\n            } else\
    \ if c.is_lowercase() {\n                i += 1;\n            } else if c.is_whitespace()\
    \ {\n                i += 1;\n            } else {\n                i += 1;\n\
    \            }\n        }\n        if n == 0 {\n            break;\n        }\n\
    \        result.push(s.chars().nth(i).unwrap());\n        n -= 1;\n        s =\
    \ s.chars().skip(i).take(n - 1).collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzv6l_oy0.rs:40:36\n   |\n\
    40 |         s = s.chars().skip(i).take(n - 1).collect();\n   |              \
    \                      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n40 |         s = s.chars().skip(i).take((n - 1).try_into().unwrap()).collect();\n\
    \   |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzv6l_oy0.rs:42:5\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n42 |  \
    \   result\n   |     ^^^^^^ expected struct `String`, found `char`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == s[i] {\n            j += 1\n  \
    \      }\n        if j == i {\n            result.push(s.to_string());\n     \
    \       i += 1;\n        } else {\n            if j - i > n {\n              \
    \  result.push(s.to_string());\n                i += 1;\n            } else {\n\
    \                i += j - i;\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy46lcl37.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == s[i] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpy46lcl37.rs:22:38\n   |\n\
    22 |         while j < s.len() && s[j] == s[i] {\n   |                       \
    \               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy46lcl37.rs:29:24\n   |\n29 |             if j - i > n\
    \ {\n   |                        ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n29 |             if j - i > n.try_into().unwrap() {\n   |       \
    \                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j + 1;\n\
    \        }\n        if j - i == n {\n            words.push(s.to_string());\n\
    \            i = j;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7c2ortdr.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7c2ortdr.rs:25:21\n   |\n25 |         if j - i == n {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n25 |         if j - i == n.try_into().unwrap() {\n   |                \
    \     ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s = s;\n    let mut words: Vec<String> = Vec::new();\n    let mut vowels: Vec<&str>\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut consonants: Vec<&str>\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut vowels_set: HashSet<&str> = HashSet::new();\n    let mut consonants_set:\
    \ HashSet<&str> = HashSet::new();\n    let mut vowels_counter: usize = 0;\n  \
    \  let mut consonants_counter: usize = 0;\n    while vowels_counter < n && consonants_counter\
    \ < n {\n        if s.is_empty() {\n            break;\n        }\n        let\
    \ mut vowel = vowels.iter().next().unwrap();\n        let mut consonant = consonants.iter().next().unwrap();\n\
    \        if vowels_set.contains(&vowel) {\n            vowels_counter++;\n   \
    \     }\n        if consonants_set.contains(&consonant) {\n            consonants_counter++;\n\
    \        }\n        if vowels_counter == n && consonants_counter == n {\n    \
    \        words.push(s);\n        }\n        if vowels_counter == n {\n       \
    \     vowels_set.insert(vowel);\n        }\n        if consonants_counter == n\
    \ {\n            consonants_set.insert(consonant);\n        }\n        s = s.chars().skip(1).collect::<String>();\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpidzqr8md.rs:33:28\n\
    \   |\n33 |             vowels_counter++;\n   |                            ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpidzqr8md.rs:36:32\n\
    \   |\n36 |             consonants_counter++;\n   |                          \
    \      ^ expected expression\n\nerror[E0412]: cannot find type `HashSet` in this\
    \ scope\n  --> /tmp/tmpidzqr8md.rs:22:25\n   |\n22 |     let mut vowels_set: HashSet<&str>\
    \ = HashSet::new();\n   |                         ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpidzqr8md.rs:22:41\n   |\n22 |     let mut vowels_set: HashSet<&str>\
    \ = HashSet::new();\n   |                                         ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0412]: cannot find type `HashSet`\
    \ in this scope\n  --> /tmp/tmpidzqr8md.rs:23:29\n   |\n23 |     let mut consonants_set:\
    \ HashSet<&str> = HashSet::new();\n   |                             ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpidzqr8md.rs:23:45\n   |\n23 |  \
    \   let mut consonants_set: HashSet<&str> = HashSet::new();\n   |            \
    \                                 ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpidzqr8md.rs:26:28\n   |\n\
    26 |     while vowels_counter < n && consonants_counter < n {\n   |          \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    26 |     while vowels_counter < n.try_into().unwrap() && consonants_counter <\
    \ n {\n   |                            ~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j - i < n {\n            words.push(s.subslice(i, j));\n \
    \           i += j - i;\n        } else {\n            i += n;\n        }\n  \
    \  }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8y96chim.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8y96chim.rs:25:20\n   |\n25 |         if j - i < n {\n\
    \   |                    ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n25 |         if j - i < n.try_into().unwrap() {\n   |                 \
    \   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `subslice` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp8y96chim.rs:26:26\n   |\n\
    26 |             words.push(s.subslice(i, j));\n   |                         \
    \ ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8y96chim.rs:29:18\n   |\n29 |             i += n;\n   |            \
    \      ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign `isize`\
    \ to `usize`\n  --> /tmp/tmp8y96chim.rs:29:15\n   |\n29 |             i += n;\n\
    \   |               ^^ no implementation for `usize += isize`\n   |\n   = help:\
    \ the trait `AddAssign<isize>` is not implemented for `usize`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    let mut vowel_counters = vec![];\n    let mut consonant_counters =\
    \ vec![];\n    let mut vowel_counters_copy = vec![];\n    let mut consonant_counters_copy\
    \ = vec![];\n    let mut vowel_counters_copy2 = vec![];\n    let mut consonant_counters_copy2\
    \ = vec![];\n    let mut vowel_counters_copy3 = vec![];\n    let mut consonant_counters_copy3\
    \ = vec![];\n    let mut vowel_counters_copy4 = vec![];\n    let mut consonant_counters_copy4\
    \ = vec![];\n    let mut vowel_counters_copy5 = vec![];\n    let mut consonant_counters_copy5\
    \ = vec![];\n    let mut vowel_counters_copy6 = vec![];\n    let mut consonant_counters_copy6\
    \ = vec![];\n    let mut vowel_counters_copy7 = vec![];\n    let mut consonant_counters_copy7\
    \ = vec![];\n    let mut vowel_counters_copy8 = vec![];\n    let mut consonant_counters_copy8\
    \ = vec![];\n    let mut vowel_counters_copy9 = vec![];\n    let mut consonant_counters_copy9\
    \ = vec![];\n    let mut vowel_counters_copy10 = vec![];\n    let mut consonant_counters_copy10\
    \ = vec![];\n    let mut vowel_counters_copy11 = vec![];\n    let mut consonant_counters_copy11\
    \ = vec![];\n    let mut vowel_counters_copy12 = vec![];\n    let mut consonant_counters_copy12\
    \ = vec![];\n    let mut vowel_counters_copy13 = vec![];\n    let mut consonant_counters_copy13\
    \ = vec![];\n    let mut vowel_counters_copy14 = vec![];\n    let mut consonant_counters_copy14\
    \ = vec![];\n    let mut vowel_counters_copy15 = vec![];\n    let mut consonant_counter\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptv_b29dj.rs:54:30\n   |\n\
    54 |     let mut consonant_counter\n   |                              ^ help:\
    \ add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptv_b29dj.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut index = 0;\n    while index\
    \ < s.len() {\n        if s[index] == ' ' {\n            count += 1;\n       \
    \ }\n        if count == n {\n            words.push(s.split_whitespace()[index..]);\n\
    \            count = 0;\n        }\n        index += 1;\n    }\n    words\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8psrcuo8.rs:22:12\n\
    \   |\n22 |         if s[index] == ' ' {\n   |            ^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp8psrcuo8.rs:26:24\n   |\n26 |             words.push(s.split_whitespace()[index..]);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n                j -= 1;\n          \
    \  } else {\n                i += 1;\n            }\n        }\n        if i ==\
    \ n {\n            result.push(s.clone());\n        }\n        s = &s[i..];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4xjye9ej.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xjye9ej.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4xjye9ej.rs:34:13\n   |\n34 |         s = &s[i..];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n34 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n;\n\
    \    while n > 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n       \
    \     result.push(s);\n        }\n        n -= 1;\n        s = s.chars().filter(|c|\
    \ !c.is_consonant()).collect();\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpc4amvgj1.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmpc4amvgj1.rs:26:37\n  \
    \ |\n26 |         s = s.chars().filter(|c| !c.is_consonant()).collect();\n   |\
    \                                     ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            i += 1;\n            continue;\n   \
    \     }\n        let mut word = String::from(&s[i .. j]);\n        let mut count\
    \ = 0;\n        for c in word.chars() {\n            if c == ' ' {\n         \
    \       continue;\n            }\n            if c.is_consonant() {\n        \
    \        count += 1;\n            }\n        }\n        if count == n {\n    \
    \        words.push(word);\n        }\n        i = j;\n    }\n    words\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps6xx_k_u.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0599]: no method\
    \ named `is_consonant` found for type `char` in the current scope\n  --> /tmp/tmps6xx_k_u.rs:35:18\n\
    \   |\n35 |             if c.is_consonant() {\n   |                  ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        let mut j = i;\n        while j < s.len() && s.chars().any(|c|\
    \ c != s.chars().nth(j)) {\n            j = j + 1;\n        }\n        if j ==\
    \ i {\n            v.push(s.clone());\n            i += 1;\n        } else {\n\
    \            v.push(s.clone());\n            i = j;\n        }\n    }\n    v.sort_unstable();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7hdc0k2e.rs:23:53\n   |\n\
    23 |         while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0615]: attempted to take value of\
    \ method `dedup` on type `Vec<String>`\n   --> /tmp/tmp7hdc0k2e.rs:102:7\n   \
    \ |\n102 |     v.dedup\n    |       ^^^^^ method, not a field\n    |\nhelp: use\
    \ parentheses to call the method\n    |\n102 |     v.dedup()\n    |          \
    \  ++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0615.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j + 1;\n\
    \        }\n        if j == s.len() {\n            break;\n        }\n       \
    \ let mut k = j;\n        while k < s.len() && s[k] != ' ' {\n            k =\
    \ k + 1;\n        }\n        if k == s.len() {\n            break;\n        }\n\
    \        let mut c = s[k];\n        while k < s.len() && s[k] == c {\n       \
    \     k = k + 1;\n            c = s[k];\n        }\n        if k == s.len() {\n\
    \            break;\n        }\n        if n == 0 {\n            break;\n    \
    \    }\n        if k == j {\n            words.push_back(s.to_string());\n   \
    \     } else {\n            words.push_back(s.to_string().to_owned());\n     \
    \   }\n        i = j + 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp02ad309q.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp02ad309q.rs:29:30\n   |\n\
    29 |         while k < s.len() && s[k] != ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp02ad309q.rs:35:21\n   |\n35 |  \
    \       let mut c = s[k];\n   |                     ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp02ad309q.rs:36:30\n   |\n36 |         while k < s.len() && s[k]\
    \ == c {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp02ad309q.rs:38:17\n\
    \   |\n38 |             c = s[k];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmp02ad309q.rs:47:19\n   |\n47 |          \
    \   words.push_back(s.to_string());\n   |                   ^^^^^^^^^ method not\
    \ found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct\
    \ `Vec<_>` in the current scope\n  --> /tmp/tmp02ad309q.rs:49:19\n   |\n49 | \
    \            words.push_back(s.to_string().to_owned());\n   |                \
    \   ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 7 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s.chars().any(|c| c != s.chars().nth(j))\
    \ {\n            j = j + 1;\n        }\n        if j - i == n {\n            words.push(s.chars().nth(i).unwrap());\n\
    \            i = j + 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvpc9sj8x.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvpc9sj8x.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvpc9sj8x.rs:30:5\n   |\n17 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n30 |     words\n   |   \
    \  ^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<char>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n            words.push(s.split_whitespace()[i]);\n\
    \            i += 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmphaad219u.rs:21:32\n   |\n21 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmphaad219u.rs:22:24\n   |\n22 |         \
    \    words.push(s.split_whitespace()[i]);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowel_consonants = vec![];\n    let mut vowel_consonant_vowels =\
    \ vec![];\n    let mut vowel_consonant_vowels_vowels = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants =\
    \ vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels_consonants\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels_consonants_consonants\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels_consonants_consonants_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels_consonants_consonants_vowels_consonants\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels_consonants_consonants_vowels_consonants_consonants\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels_consonants_consonants_vowels_consonants_consonants_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels_consonants_consonants_vowels_consonants_consonants_vowels_consonants\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels_consonants_consonants_vowels_consonants_consonants_vowels_consonants_consonants\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels_consonants_consonants_vowels_consonants_con\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp6smjian.rs:35:115\n   |\n\
    35 |     let mut vowel_consonant_vowels_vowels_consonants_consonants_vowels_consonants_consonants_vowels_consonants_con\n\
    \   |                                                                        \
    \                                           ^ help: add `;` here\n36 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp6smjian.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            i += 1;\n            continue;\n   \
    \     }\n        let mut word = String::from(\"\");\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n     \
    \       i += 1;\n            continue;\n        }\n        let mut count = 0;\n\
    \        while j < s.len() {\n            if s[j] == s[i] {\n                count\
    \ += 1;\n                j += 1\n            } else {\n                break;\n\
    \            }\n        }\n        if count == n {\n            words.push(word);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpouiheeex.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpouiheeex.rs:30:30\n   |\n\
    30 |         while j < s.len() && s[j] == ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpouiheeex.rs:39:16\n   |\n39 |  \
    \           if s[j] == s[i] {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpouiheeex.rs:39:24\n   |\n39 |             if s[j] == s[i] {\n  \
    \ |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            result.push(s.to_string()[..i]);\n\
    \            i += n;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp0s7wcm7l.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmp0s7wcm7l.rs:22:25\n   |\n\
    22 |             result.push(s.to_string()[..i]);\n   |                      \
    \   ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmp0s7wcm7l.rs:18:22\n\
    \    |\n18  |     let mut result = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by `Vec::<T>::new`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmp0s7wcm7l.rs:18:22\n    |\n18  |  \
    \   let mut result = vec![];\n    |                      ^^^^^^ doesn't have a\
    \ size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec`\n    = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0s7wcm7l.rs:23:18\n \
    \  |\n23 |             i += n;\n   |                  ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmp0s7wcm7l.rs:23:15\n\
    \   |\n23 |             i += n;\n   |               ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0s7wcm7l.rs:27:5\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                 "
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         if n == 0 {\n                break;\n            }\n            i +=\
    \ 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp_q_nflkf.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n > 0 {\n        let mut index = s.find(' ').unwrap();\n \
    \       if index == s.len() {\n            result.push(s);\n            break;\n\
    \        }\n        let mut word = s.split_whitespace().nth(index).unwrap();\n\
    \        if word.chars().count(|c| c.is_consonant()) == n {\n            result.push(word);\n\
    \        }\n        n -= 1;\n        s = &s[(index + 1)..];\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmprt4edyxc.rs:28:25\n    |\n28  |         if word.chars().count(|c|\
    \ c.is_consonant()) == n {\n    |                         ^^^^^ --------------------\
    \ supplied 1 argument\n    |                         |\n    |                \
    \         expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprt4edyxc.rs:29:25\n   |\n29 |\
    \             result.push(word);\n   |                         ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                         |\n\
    \   |                         expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprt4edyxc.rs:32:13\n   |\n32 |         s = &s[(index\
    \ + 1)..];\n   |             ^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n32 |         s = (&s[(index\
    \ + 1)..]).to_string();\n   |             +                 +++++++++++++\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        while i < s.len() && s[i].is_ascii_letter() {\n            i\
    \ += 1;\n        }\n        if i == s.len() {\n            break;\n        }\n\
    \        let mut j = i;\n        while j < s.len() && s[j].is_ascii_letter() {\n\
    \            j += 1;\n        }\n        if j == s.len() {\n            break;\n\
    \        }\n        if s.len() == n {\n            result.push(s.split_whitespace().collect::<Vec<_>>());\n\
    \            break;\n        }\n        s = &s[j..];\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb24hjyz1.rs:22:30\n\
    \   |\n22 |         while i < s.len() && s[i].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb24hjyz1.rs:29:30\n\
    \   |\n29 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb24hjyz1.rs:35:23\n   |\n35 |         if s.len()\
    \ == n {\n   |                       ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n35 |         if s.len() == n.try_into().unwrap() {\n   |\
    \                       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb24hjyz1.rs:39:13\n   |\n39 |         s = &s[j..];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n39 |         s = (&s[j..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb24hjyz1.rs:41:5\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n41 |     result\n   |     ^^^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n       \
    \       found struct `Vec<Vec<&str>>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = 0;\n        while i < s.len() {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n                j = 0;\n           \
    \ } else {\n                i += 1;\n                j += 1;\n            }\n\
    \            if j == n {\n                result.push(s.clone());\n          \
    \      j = 0;\n            }\n        }\n        s = s.clone();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqb0fs3dt.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j = j + 1;\n\
    \        }\n        let mut k = j;\n        while k < s.len() && s[k] != ' ' {\n\
    \            k = k + 1;\n        }\n        if k == j {\n            words.push_back(s.to_string());\n\
    \            i = i + 1;\n        } else {\n            while i < j {\n       \
    \         words.push_back(s.to_string());\n                i = i + 1;\n      \
    \      }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpon8lmjos.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpon8lmjos.rs:26:30\n   |\n\
    26 |         while k < s.len() && s[k] != ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0599]: no method named\
    \ `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpon8lmjos.rs:30:19\n\
    \   |\n30 |             words.push_back(s.to_string());\n   |                \
    \   ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpon8lmjos.rs:34:23\n\
    \   |\n34 |                 words.push_back(s.to_string());\n   |            \
    \           ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut word = String::from(s);\n        let mut count = 0;\n       \
    \ while word.len() > 0 {\n            if word.chars().any(|c| c != ' ' && c !=\
    \ '-' && c != '_') {\n                count += 1;\n            }\n           \
    \ word = word.chars().next().unwrap();\n        }\n        if count == n {\n \
    \           result.push(word);\n        }\n        s = s.chars().next().unwrap();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_k1kiaz2.rs:27:20\n   |\n\
    27 |             word = word.chars().next().unwrap();\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                    |\n   |                    expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_k1kiaz2.rs:32:13\n\
    \   |\n32 |         s = s.chars().next().unwrap();\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |             |\n  \
    \ |             expected struct `String`, found `char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut word = String::from(s);\n        let mut count = 0;\n       \
    \ while word.len() > 0 {\n            if word.chars().any(|c| c.is_uppercase())\
    \ {\n                count += 1;\n            }\n            word = word.chars().filter(|c|\
    \ !c.is_uppercase()).collect();\n        }\n        if count == n {\n        \
    \    result.push(word);\n        }\n        s = s.chars().filter(|c| !c.is_uppercase()).collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n    --> /tmp/tmptdrfxxg_.rs:32:13\n\
    \     |\n19   |     let mut s = String::from(s);\n     |         ----- move occurs\
    \ because `s` has type `String`, which does not implement the `Copy` trait\n20\
    \   |     while s.len() > 0 {\n21   |         let mut word = String::from(s);\n\
    \     |                                     - value moved here\n...\n32   |  \
    \       s = s.chars().filter(|c| !c.is_uppercase()).collect();\n     |       \
    \      ^^^^^^^^^ value borrowed here after move\n     |\n     = note: borrow occurs\
    \ due to deref coercion to `str`\nnote: deref defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j + 1;\n\
    \        }\n        let mut k = j;\n        while k < s.len() && s[k] == ' ' {\n\
    \            k = k + 1;\n        }\n        if k == i {\n            words.push(s.to_string());\n\
    \            i = i + 1;\n        }\n        if j == i {\n            words.push(s.to_string());\n\
    \            i = i + 1;\n        }\n        if k > i {\n            words.push(s.to_string());\n\
    \            i = i + 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptr1my2id.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmptr1my2id.rs:26:30\n   |\n\
    26 |         while k < s.len() && s[k] == ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n            j += 1\n        }\n        if j - i == n {\n            words.push(s.to_string());\n\
    \            i += j - i;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpetk9e5mj.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpetk9e5mj.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s.chars().all(|c| c != s.chars().nth(j).unwrap())\
    \ {\n            j += 1\n        }\n        if j - i == n {\n            v.push(s.to_string());\n\
    \            i += j - i;\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_5cgfy4s.rs:25:21\n   |\n\
    25 |         if j - i == n {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    let mut consonants = vec![];\n\
    \    let mut vowels = vec![];\n    let mut vowel_index = 0;\n    let mut vowel_consonants\
    \ = vec![];\n    let mut vowel_consonant_index = 0;\n    let mut vowel_consonant_count\
    \ = 0;\n    let mut vowel_consonant_count_index = 0;\n    let mut vowel_consonant_count_index2\
    \ = 0;\n    let mut vowel_consonant_count_index3 = 0;\n    let mut vowel_consonant_count_index4\
    \ = 0;\n    let mut vowel_consonant_count_index5 = 0;\n    let mut vowel_consonant_count_index6\
    \ = 0;\n    let mut vowel_consonant_count_index7 = 0;\n    let mut vowel_consonant_count_index8\
    \ = 0;\n    let mut vowel_consonant_count_index9 = 0;\n    let mut vowel_consonant_count_index10\
    \ = 0;\n    let mut vowel_consonant_count_index11 = 0;\n    let mut vowel_consonant_count_index12\
    \ = 0;\n    let mut vowel_consonant_count_index13 = 0;\n    let mut vowel_consonant_count_index14\
    \ = 0;\n    let mut vowel_consonant_count_index15 = 0;\n    let mut vowel_consonant_count_index16\
    \ = 0;\n    let mut vowel_consonant_count_index17 = 0;\n    let mut vowel_consonant_count_index18\
    \ = 0;\n    let mut vowel_consonant_count_index19 = 0;\n    let mut vowel_consonant_count_index20\
    \ = 0;\n    let mut vowel_consonant_count_index21 = 0;\n    let mut vowel_consonant_count_index22\
    \ = 0;\n    let mut vowel_consonant_count_index23 = 0;\n    let mut vowel_consonant_count_index24\
    \ = 0;\n    let mut vowel_consonant_count_index25 = 0;\n    let mut vowel_consonant_count_index26\
    \ = 0;\n    let mut vowel_consonant_count_index27 = 0;\n    let mut vowel_consonant_count_index28\
    \ = 0;\n    let mut vowel_consonant_count_index29 = 0;\n    let mut vowel_consonant_count_index30\
    \ = 0;\n    let mut vowel_consonant_count_index31 = 0;\n    let mut vowel_consonant_count_index32\
    \ = 0;\n    let mut vowel_consonant_count_index33 = 0;\n    let mut vowel_consonant_count_index34\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp61z9464w.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j].is_ascii_letter() {\n            j\
    \ += 1\n        }\n        if j == i {\n            break;\n        }\n      \
    \  let mut word = String::from(&s[i .. j]);\n        if word.chars().count(|c|\
    \ !c.is_ascii_letter()) == n {\n            words.push(word);\n            i +=\
    \ j - i;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2v8045jr.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp2v8045jr.rs:29:25\n\
    \    |\n29  |         if word.chars().count(|c| !c.is_ascii_letter()) == n {\n\
    \    |                         ^^^^^ ------------------------ supplied 1 argument\n\
    \    |                         |\n    |                         expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2v8045jr.rs:29:60\n   |\n29 |         if word.chars().count(|c|\
    \ !c.is_ascii_letter()) == n {\n   |                                         \
    \                   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    29 |         if word.chars().count(|c| !c.is_ascii_letter()) == n.try_into().unwrap()\
    \ {\n   |                                                            ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n > 0 {\n        if s.chars().any(|c| c != ' ') {\n      \
    \      result.push(s.clone());\n        }\n        n -= 1;\n        s = s.chars().filter(|c|\
    \ c != ' ').collect();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa49b_nsf.rs:26:36\n\
    \   |\n26 |         s = s.chars().filter(|c| c != ' ').collect();\n   |      \
    \                              ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmplh81mt9v.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut punctuation = vec![];\n    let mut\
    \ letters = vec![];\n    let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n\
    \    let mut punctuation_count = s.chars().filter(|c| c == '.' || c == '!' ||\
    \ c == '?' || c == ';' || c == ':' || c == '-' || c == '_' || c == '/' || c ==\
    \ '\\\\' || c == '@' || c == '$' || c == '%' || c == '^' || c == '&' || c == '*'\
    \ || c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c\
    \ == '<' || c == '>' || c == '|' || c == ':' || c == '\"' || c == '~' || c ==\
    \ '`' || c == '?' || c == '-').count();\n    let mut letters_count = s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count();\n    let mut spaces_count\
    \ = s.chars().filter(|c| c == ' ').count();\n    let mut punctuation_count = s.chars().filter(|c|\
    \ c == '.' || c == '!' || c == '?' || c == ';' || c == ':' || c == '-' || c ==\
    \ '_' || c == '/' || c == '\\\\' || c == '@' || c == '$' || c == '%' || c == '^'\
    \ || c == '&' || c == '*' || c == '(' || c == ')' || c == '[' || c == ']' || c\
    \ == '{' || c == '}' || c == '<' || c == '>' || c == '|' || c == ':' || c == '\"\
    ' || c == '~' || c == '`' || c == '?' || c == '-').count();\n    let mut letters_count\
    \ = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z').count();\n\
    \    let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n    let mut\
    \ punctuation_count = s.chars().filter(|c| c == '.' || c == '!' || c == '?' ||\
    \ c == ';' || c == ':' || c == '-' || c == '_' || c == '/' || c == '\\\\' || c\
    \ == '@' || c == '$' || c == '%' || c\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpn4fg_dtb.rs:32:1\n   |\n32 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpn4fg_dtb.rs:31:49\n   |\n17 | fn select_words(s: String, n: isize) ->\
    \ Vec<String> {\n   |                                                     - closing\
    \ delimiter possibly meant for this\n...\n31 |     let mut punctuation_count =\
    \ s.chars().filter(|c| c == '.' || c == '!' || c == '?' || c == ';' || c == ':'\
    \ || c == '-' || c == '_' || ...\n   |                                       \
    \          ^ unclosed delimiter\n32 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn4fg_dtb.rs:24:51\n\
    \   |\n24 |     let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n\
    \   |                                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn4fg_dtb.rs:25:56\n\
    \   |\n25 |     let mut punctuation_count = s.chars().filter(|c| c == '.' || c\
    \ == '!' || c == '?' || c == ';' || c == ':' || c == '-' || c == '_' || ...\n\
    \   |                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn4fg_dtb.rs:25:68\n\
    \   |\n25 |     let mut punctuation_count = s.chars().filter(|c| c == '.' || c\
    \ == '!' || c == '?' || c == ';' || c == ':' || c == '-' || c == '_' || ...\n\
    \   |                                                                    ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpn4fg_dtb.rs:25:80\n   |\n25 |     let mut punctuation_count = s.chars().filter(|c|\
    \ c == '.' || c == '!' || c == '?' || c == ';' || c == ':' || c == "
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().any(|c| c == ' ') {\n            j +=\
    \ 1\n        }\n        if j == i {\n            break;\n        }\n        let\
    \ mut word = String::from(&s[i .. j]);\n        let mut count = 0;\n        for\
    \ c in word.chars() {\n            if c == ' ' {\n                continue;\n\
    \            }\n            if c == s.chars().nth(count) {\n                count\
    \ += 1;\n            } else {\n                break;\n            }\n       \
    \ }\n        if count == n {\n            result.push(word);\n        }\n    \
    \    i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqh9mtgdm.rs:36:21\n   |\n\
    36 |             if c == s.chars().nth(count) {\n   |                     ^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut i = 0;\n        let mut j = s.len();\n        while i < j {\n\
    \            if s[i] == ' ' {\n                i += 1;\n                j -= 1;\n\
    \            } else if s[i] == ' ' && j > 0 {\n                i += 1;\n     \
    \           j -= 1;\n            } else if s[i] == ' ' && i == j {\n         \
    \       i += 1;\n                j -= 1;\n            } else {\n             \
    \   i += 1;\n            }\n        }\n        if i == n {\n            v.push(s.clone());\n\
    \        }\n        s = s.chars().take(i).collect();\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwmnk2eab.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwmnk2eab.rs:27:23\n   |\n27 |             } else if s[i] == ' '\
    \ && j > 0 {\n   |                       ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwmnk2eab.rs:30:23\n\
    \   |\n30 |             } else if s[i] == ' ' && i == j {\n   |              \
    \         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwmnk2eab.rs:37:17\n   |\n37 |         if i == n {\n   |       \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n37 |      \
    \   if i == n.try_into().unwrap() {\n   |                 ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         words.push(s.split_whitespace()[i]);\n            i += 1;\n        }\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpb7bqdd_f.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpb7bqdd_f.rs:24:24\n   |\n24 |         \
    \    words.push(s.split_whitespace()[i]);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        let mut word = String::from(&s[i .. j]);\n        i += j - i;\n\
    \        if word.chars().count(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o'\
    \ && c != 'u') == n {\n            words.push(word);\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdk57c0ld.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpdk57c0ld.rs:27:25\n\
    \    |\n27  |         if word.chars().count(|c| c != 'a' && c != 'e' && c != 'i'\
    \ && c != 'o' && c != 'u') == n {\n    |                         ^^^^^ ------------------------------------------------------------\
    \ supplied 1 argument\n    |                         |\n    |                \
    \         expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdk57c0ld.rs:27:96\n   |\n27 |\
    \         if word.chars().count(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o'\
    \ && c != 'u') == n {\n   |                                                  \
    \                                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n27 |         if word.chars().count(|c| c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u') == n.try_into().unwrap() {\n \
    \  |                                                                         \
    \                       ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    let mut n = n as usize;\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c| c.is_consonant()\
    \ && c != ' ') {\n            result.push(s.subslice(i, i + n));\n           \
    \ i += n;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpe5x64n4c.rs:23:32\n   |\n23 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpe5x64n4c.rs:24:27\n\
    \   |\n24 |             result.push(s.subslice(i, i + n));\n   |             \
    \              ^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n\
    \        }\n        if j == i {\n            break;\n        }\n        let mut\
    \ word = String::from(&s[i .. j]);\n        let mut count = 0;\n        while\
    \ j < s.len() && s[j] == s[(j + count) % s.len()] {\n            count += 1;\n\
    \            j += 1\n        }\n        if count == n {\n            words.push(word);\n\
    \            i += j - i;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkp27dw39.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpkp27dw39.rs:30:30\n   |\n\
    30 |         while j < s.len() && s[j] == s[(j + count) % s.len()] {\n   |   \
    \                           ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkp27dw39.rs:30:38\n\
    \   |\n30 |         while j < s.len() && s[j] == s[(j + count) % s.len()] {\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkp27dw39.rs:34:21\n\
    \   |\n34 |         if count == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n34 |         if count == n.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut word = String::from(\"\");\n        let mut pos = 0;\n      \
    \  while pos < s.len() {\n            if s[pos] == ' ' {\n                pos\
    \ = pos + 1;\n                continue;\n            }\n            if s[pos]\
    \ == 'a' || s[pos] == 'e' || s[pos] == 'i' || s[pos] == 'o' || s[pos] == 'u' {\n\
    \                word = word.to_owned() + s[pos].to_owned();\n               \
    \ pos = pos + 1;\n                continue;\n            }\n            if s[pos]\
    \ == 'y' || s[pos] == 's' || s[pos] == 'h' || s[pos] == 'd' || s[pos] == 'r' ||\
    \ s[pos] == 'n' {\n                word = word.to_owned() + s[pos].to_owned();\n\
    \                pos = pos + 1;\n                continue;\n            }\n  \
    \          if s[pos] == 'c' || s[pos] == 'l' || s[pos] == 'm' || s[pos] == 'p'\
    \ || s[pos] == 't' {\n                word = word.to_owned() + s[pos].to_owned();\n\
    \                pos = pos + 1;\n                continue;\n            }\n  \
    \          if s[pos] == 'f' || s[pos] == 'v' || s[pos] == 's' || s[pos] == 'h'\
    \ || s[pos] == 'd' || s[pos] == 'r' || s[pos] == 'n' {\n                word =\
    \ word.to_owned() + s[pos].to_owned();\n                pos = pos + 1;\n     \
    \           continue;\n            }\n            if s[pos] == 'b' || s[pos] ==\
    \ 'o' || s[pos] == 'u' || s[pos] == 'l' || s[pos] == 'd' || s[pos] == 'r' || s[pos]\
    \ == 'n' {\n                word = word.to_owned() + s[pos].to_owned();\n    \
    \            pos = pos + 1;\n                continue;\n            }\n      \
    \      if s[pos] == 'g' || s[pos] == 'u' || s[pos] == 'l' || s[pos] == 'd' ||\
    \ s[pos] == 'r' || s[pos] == 'n' {\n                word = word.to_owned() + s[pos].to_owned();\n\
    \                pos = pos + 1;\n                continue;\n            }\n  \
    \          if s[pos] == 'p' || s[pos] == 'e' || s[pos] == 'd' || s[pos] == 'r'\
    \ || s[pos] == 'n' {\n                word = word.to_owned() + s[pos].to_owned();\n\
    \                pos = pos + 1;\n                continue;\n            }\n  \
    \          if s[pos] == 'm' || s[pos] == 'a' || s[pos] == 'l' || s[pos] == 'l'\
    \ || s[pos] == 'e' || s[pos] == 's' || s[pos] == 's' || s[pos] == 's' {\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0lr5l3ps.rs:75:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n20\
    \ |     while s.len() > 0 {\n   |                       - unclosed delimiter\n\
    ...\n23 |         while pos < s.len() {\n   |                             - unclosed\
    \ delimiter\n...\n63 |             if s[pos] == 'm' || s[pos] == 'a' || s[pos]\
    \ == 'l' || s[pos] == 'l' || s[pos] == 'e' || s[pos] == 's' || s[pos] == 's' ||\
    \ s[pos] == 's' {\n   |                                                      \
    \                                                                            \
    \                   - this delimiter might not be properly closed...\n64 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n75 | }\n\
    \   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmp0lr5l3ps.rs:24:16\n   |\n24 |             if s[pos] == ' ' {\n   | \
    \               ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0lr5l3ps.rs:28:16\n\
    \   |\n28 |             if s[pos] == 'a' || s[pos] == 'e' || s[pos] == 'i' ||\
    \ s[pos] == 'o' || s[pos] == 'u' {\n   |                ^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0lr5l3ps.rs:28:33\n   |\n28 |             if s[pos] == 'a' || s[pos]\
    \ == 'e' || s[pos] == 'i' || s[pos] == 'o' || s[pos] == 'u' {\n   |          \
    \                       ^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0lr5l3ps.rs:28:50\n\
    \   |\n28 |             if s[pos] == 'a' || s[pos] == 'e' || s[pos] == 'i' ||\
    \ s[pos] == 'o' || s[pos] == 'u' {\n   |                        "
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j = j + 1;\n\
    \        }\n        if j == s.len() {\n            break;\n        }\n       \
    \ let mut k = j;\n        while k < s.len() && s[k] != ' ' {\n            k =\
    \ k + 1;\n        }\n        if k == s.len() {\n            break;\n        }\n\
    \        if n == j - i + 1 {\n            words.push(s.split_whitespace()[i]);\n\
    \        }\n        i = k + 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5vtphaje.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp5vtphaje.rs:29:30\n   |\n\
    29 |         while k < s.len() && s[k] != ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5vtphaje.rs:35:17\n   |\n35 |         if n == j - i + 1 {\n   |\
    \                 ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n35 |         if n == (j - i + 1).try_into().unwrap() {\n   |          \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmp5vtphaje.rs:36:24\n   |\n36 | \
    \            words.push(s.split_whitespace()[i]);\n   |                      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s = s;\n    let mut words = vec![];\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        let mut j = i;\n        while j < s.len() && s[j] == ' ' {\n    \
    \        j = j + 1;\n        }\n        if j == i {\n            break;\n    \
    \    }\n        let mut word = String::from(&s[i .. j]);\n        let mut count\
    \ = 0;\n        while j < s.len() && s[j] == ' ' {\n            j = j + 1;\n \
    \       }\n        if j == i {\n            count = j - i;\n        }\n      \
    \  if count == n {\n            words.push(word);\n        }\n        i = j;\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8v7yzdfk.rs:23:30\n\
    \   |\n23 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp8v7yzdfk.rs:31:30\n   |\n\
    31 |         while j < s.len() && s[j] == ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8v7yzdfk.rs:37:21\n   |\n37 |         if count == n {\n   |   \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    37 |         if count == n.try_into().unwrap() {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowels_count = vec![];\n    let mut vowels_count_index = vec![];\n\
    \    let mut vowels_count_index2 = vec![];\n    let mut vowels_count_index3 =\
    \ vec![];\n    let mut vowels_count_index4 = vec![];\n    let mut vowels_count_index5\
    \ = vec![];\n    let mut vowels_count_index6 = vec![];\n    let mut vowels_count_index7\
    \ = vec![];\n    let mut vowels_count_index8 = vec![];\n    let mut vowels_count_index9\
    \ = vec![];\n    let mut vowels_count_index10 = vec![];\n    let mut vowels_count_index11\
    \ = vec![];\n    let mut vowels_count_index12 = vec![];\n    let mut vowels_count_index13\
    \ = vec![];\n    let mut vowels_count_index14 = vec![];\n    let mut vowels_count_index15\
    \ = vec![];\n    let mut vowels_count_index16 = vec![];\n    let mut vowels_count_index17\
    \ = vec![];\n    let mut vowels_count_index18 = vec![];\n    let mut vowels_count_index19\
    \ = vec![];\n    let mut vowels_count_index20 = vec![];\n    let mut vowels_count_index21\
    \ = vec![];\n    let mut vowels_count_index22 = vec![];\n    let mut vowels_count_index23\
    \ = vec![];\n    let mut vowels_count_index24 = vec![];\n    let mut vowels_count_index25\
    \ = vec![];\n    let mut vowels_count_index26 = vec![];\n    let mut vowels_count_index27\
    \ = vec![];\n    let mut vowels_count_index28 = vec![];\n    let mut vowels_count_index29\
    \ = vec![];\n    let mut vowels_count_index30 = vec![];\n    let mut vowels_count_index31\
    \ = vec![];\n    let mut vowels_count_index32 = vec![];\n    let mut vowels_count_index33\
    \ = vec![];\n    let mut vowels_count_index34 = vec![];\n    let mut vowels_count_index35\
    \ = vec![];\n    let mut vowels_count_index36 = vec![];\n    let mut vowels_count_index37\
    \ = vec![];\n    let mut vowels_count_\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpilf78qva.rs:59:26\n   |\n\
    59 |     let mut vowels_count_\n   |                          ^ help: add `;`\
    \ here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpilf78qva.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) ->\
    \ Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805232
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowel_consonants = vec![];\n    let mut vowel_consonant_vowels =\
    \ vec![];\n    let mut vowel_consonant_vowels_vowels = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels = vec![];\n\
    \    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels = vec![];\n  \
    \  let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels = vec![];\n\
    \    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowel\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk4ge9zqf.rs:38:118\n   |\n\
    38 |     let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowel\n\
    \   |                                                                        \
    \                                              ^ help: add `;` here\n39 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk4ge9zqf.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n                j = i;\n           \
    \ } else {\n                i += 1;\n            }\n        }\n        if n ==\
    \ 0 {\n            result.push(s.clone());\n        } else {\n            let\
    \ mut i = 0;\n            let mut j = s.len();\n            while i < j {\n  \
    \              if s[i] == ' ' {\n                    i += 1;\n               \
    \     j = i;\n                } else {\n                    i += 1;\n        \
    \        }\n            }\n            let mut i = 0;\n            let mut j =\
    \ s.len();\n            while i < j {\n                if s[i] == s[i + n] {\n\
    \                    i += 1;\n                } else {\n                    i\
    \ += 1;\n                }\n            }\n            if i == j {\n         \
    \       result.push(s.clone());\n            }\n        }\n        s = s.clone();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw6vyckze.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpw6vyckze.rs:37:20\n   |\n37 |                 if s[i] == ' ' {\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw6vyckze.rs:47:20\n\
    \   |\n47 |                 if s[i] == s[i + n] {\n   |                    ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw6vyckze.rs:47:34\n\
    \   |\n47 |                 if s[i] == s[i + n] {\n   |                      \
    \            ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize`\
    \ to `usize`\n  --> /tmp/tmpw6vyckze.rs:47:32\n   |\n47 |                 if s[i]\
    \ == s[i + n] {\n   |                                ^ no implementation for `usize\
    \ + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw6vyckze.rs:47:28\n\
    \   |\n47 |                 if s[i] == s[i + n] {\n   |                      \
    \      ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n > 0 {\n        let mut pos = 0;\n        while pos < s.len()\
    \ {\n            if s[pos] == ' ' {\n                pos = pos + 1;\n        \
    \        continue;\n            }\n            if s[pos] >= 'a' && s[pos] <= 'z'\
    \ {\n                pos = pos + 1;\n                continue;\n            }\n\
    \            if s[pos] >= 'A' && s[pos] <= 'Z' {\n                pos = pos +\
    \ 1;\n                continue;\n            }\n            if s[pos] >= '0' &&\
    \ s[pos] <= '9' {\n                pos = pos + 1;\n                continue;\n\
    \            }\n            if s[pos] == '_' {\n                pos = pos + 1;\n\
    \                continue;\n            }\n            if s[pos] == '-' {\n  \
    \              pos = pos + 1;\n                continue;\n            }\n    \
    \        if s[pos] == '.' {\n                pos = pos + 1;\n                continue;\n\
    \            }\n            if s[pos] == '_' {\n                pos = pos + 1;\n\
    \                continue;\n            }\n            if s[pos] == '/' {\n  \
    \              pos = pos + 1;\n                continue;\n            }\n    \
    \        if s[pos] == '\\\\' {\n                pos = pos + 1;\n             \
    \   continue;\n            }\n            if s[pos] == '@' {\n               \
    \ pos = pos + 1;\n                continue;\n            }\n            if s[pos]\
    \ == '!' {\n                pos = pos + 1;\n                continue;\n      \
    \      }\n            if s[pos] == '$' {\n                pos = pos + 1;\n   \
    \             continue;\n            }\n            if s[pos] == '%' {\n     \
    \           pos = pos + 1;\n                continue;\n            }\n       \
    \     if s[pos] == '^' {\n                pos = pos + 1;\n                continue;\n\
    \            }\n            if s[pos] == '&' {\n                pos = pos + 1;\n\
    \                continue;\n            }\n            if s[pos] == '*' {\n  \
    \              pos = pos + 1;\n                continue;\n            }\n    \
    \        if s[pos] == '+' {\n                pos = pos + 1;\n                continue;\n\
    \            }\n            if s[pos] == '|' {\n                pos = pos + 1;\n\
    \                continue;\n            }\n            if s[pos] == '>' {\n  \
    \              pos = pos + 1;\n                continue;\n            }\n    \
    \        if s[pos] == '<' {\n                pos = pos + 1;\n                continue;\n\
    \            }\n            if s[pos] == '>' {\n                pos = pos + 1;\n\
    \                continue;\n            }\n            if s[pos] == '<' {\n  \
    \              pos = pos + 1;\n                continue;\n            }\n    \
    \        if s[pos] == '>' {\n                pos = pos + 1;\n                continue;\n\
    \            }\n            if s[pos] == '>' {\n                pos = pos + \n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp43o6vlgr.rs:133:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    21  |     while n > 0 {\n    |                 - unclosed delimiter\n22  |   \
    \      let mut pos = 0;\n23  |         while pos < s.len() {\n    |          \
    \                   - unclosed delimiter\n...\n120 |             if s[pos] ==\
    \ '>' {\n    |                              - this delimiter might not be properly\
    \ closed...\n121 |                 pos = pos + \n122 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n133 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp43o6vlgr.rs:122:1\n    |\n122 | }\n  \
    \  | ^ expected expression\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp43o6vlgr.rs:24:16\n   |\n24 |             if s[pos]\
    \ == ' ' {\n   |                ^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp43o6vlgr.rs:28:16\n\
    \   |\n28 |             if s[pos] >= 'a' && s[pos] <= 'z' {\n   |            \
    \    ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp43o6vlgr.rs:28:33\n   |\n28 |  \
    \           if s[pos] >= 'a' && s[pos] <= 'z' {\n   |                        \
    \         ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp43o6vlgr.rs:32:16\n   |\n32 |  \
    \           if s[pos] >= 'A' && s[pos] <= 'Z' {\n   |                ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp43o6vlgr.rs:32:33\n   |\n32 "
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().any(|c| c.is_consonant() && count < n) {\n         \
    \   count += 1;\n            words.push(s.to_string());\n        }\n        i\
    \ += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpnep5xkg9.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant() && count < n) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut spaces = Vec::new();\n    let mut punctuation = Vec::new();\n\
    \    let mut letters = Vec::new();\n    let mut spaces_count = Vec::new();\n \
    \   let mut punctuation_count = Vec::new();\n    let mut letters_count = Vec::new();\n\
    \    let mut spaces_count_max = Vec::new();\n    let mut punctuation_count_max\
    \ = Vec::new();\n    let mut letters_count_max = Vec::new();\n    let mut spaces_count_min\
    \ = Vec::new();\n    let mut punctuation_count_min = Vec::new();\n    let mut\
    \ letters_count_min = Vec::new();\n    let mut spaces_count_max = Vec::new();\n\
    \    let mut punctuation_count_max = Vec::new();\n    let mut letters_count_max\
    \ = Vec::new();\n    let mut spaces_count_min = Vec::new();\n    let mut punctuation_count_min\
    \ = Vec::new();\n    let mut letters_count_min = Vec::new();\n    let mut spaces_count_max\
    \ = Vec::new();\n    let mut punctuation_count_max = Vec::new();\n    let mut\
    \ letters_count_max = Vec::new();\n    let mut spaces_count_min = Vec::new();\n\
    \    let mut punctuation_count_min = Vec::new();\n    let mut letters_count_min\
    \ = Vec::new();\n    let mut spaces_count_max = Vec::new();\n    let mut punctuation_count_max\
    \ = Vec::new();\n    let mut letters_count_max = Vec::new();\n    let mut spaces_count_min\
    \ = Vec::new();\n    let mut punctuation_count_min = Vec::new();\n    let mut\
    \ letters_count_min = Vec::new();\n    let mut spaces_count_max = Vec::new();\n\
    \    let mut punctuation_count_max = Vec::new();\n    let mut letters_count_max\
    \ = Vec::new();\n    let mut spaces_count_min = Vec::new();\n    let mut punctuation_count_min\
    \ = Vec::new();\n    let mut letters_count_min = Vec::new();\n    let mut spaces_count_max\
    \ = Vec::new();\n    let mut punctuation_count_max = Vec::new();\n    let mut\
    \ letters_count_max = Vec::new();\n    let mut spaces_count_min = Vec::new();\n\
    \    let mut punctuation_count_min = Vec::new\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppmtaosco.rs:61:45\n   |\n\
    61 |     let mut punctuation_count_min = Vec::new\n   |                      \
    \                       ^ help: add `;` here\n62 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppmtaosco.rs:17:41\n   |\n17 |\
    \ fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    let mut n = n as usize;\n\
    \    while n > 0 {\n        let mut i = 0;\n        while i < s.len() {\n    \
    \        if s.chars().any(|c| c != ' ' && c != 'a' && c != 'e' && c != 'i' &&\
    \ c != 'o' && c != 'u') {\n                i += 1;\n            } else {\n   \
    \             result.push(s.split_whitespace().nth(i));\n                i +=\
    \ 1;\n            }\n        }\n        n -= 1;\n        s = s.chars().filter(|c|\
    \ c != ' ' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4p65_af2.rs:32:36\n\
    \   |\n32 |         s = s.chars().filter(|c| c != ' ' && c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u').collect();\n   |                      \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp4p65_af2.rs:32:48\n   |\n32 |   \
    \      s = s.chars().filter(|c| c != ' ' && c != 'a' && c != 'e' && c != 'i' &&\
    \ c != 'o' && c != 'u').collect();\n   |                                     \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp4p65_af2.rs:32:60\n   |\n32 |         s =\
    \ s.chars().filter(|c| c != ' ' && c != 'a' && c != 'e' && c != 'i' && c != 'o'\
    \ && c != 'u').collect();\n   |                                              \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp4p65_af2.rs:32:72\n   |\n32 |   \
    \      s = s.chars().filter(|c| c != ' ' && c != 'a' && c != 'e' && c != 'i' &&\
    \ c != 'o' && c != 'u').collect();\n   |                                     \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4p65_af2.rs:32:84\n\
    \   |\n32 |         s = s.chars().filter(|c| c != ' ' && c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u').collect();\n   |                      \
    \                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4p65_af2.rs:32:96\n\
    \   |\n32 |         s = s.chars().filter(|c| "
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    for c in s.chars() {\n        if\
    \ c.is_consonant() {\n            count += 1;\n            if count == n {\n \
    \               words.push(s.to_string());\n                count = 0;\n     \
    \       }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpbgb8_e0h.rs:21:14\n   |\n21 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().any(|c| c != ' ' && c != '\\n' && c != '\\\
    t' && c != '\\r' && c != '\\b') {\n            if s.chars().all(|c| c != ' ' &&\
    \ c != '\\n' && c != '\\t' && c != '\\r' && c != '\\b') {\n                if\
    \ s.chars().all(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\
    \ {\n                    if s.chars().all(|c| c != 'A' && c != 'E' && c != 'I'\
    \ && c != 'O' && c != 'U') {\n                        if s.chars().all(|c| c !=\
    \ 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n                   \
    \         if s.chars().all(|c| c != 'A' && c != 'E' && c != 'I' && c != 'O' &&\
    \ c != 'U') {\n                                if s.chars().all(|c| c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n                          \
    \          if s.chars().all(|c| c != 'A' && c != 'E' && c != 'I' && c != 'O' &&\
    \ c != 'U') {\n                                        if s.chars().all(|c| c\
    \ != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n                \
    \                            if s.chars().all(|c| c != 'A' && c != 'E' && c !=\
    \ 'I' && c != 'O' && c != 'U') {\n                                           \
    \     if s.chars().all(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c !=\
    \ 'u') {\n                                                    if s.chars().all(|c|\
    \ c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n              \
    \                                          if s.chars().all(|c| c != 'a' && c\
    \ != 'e' && c != 'i' && c != 'o' && c != 'u') {\n                            \
    \                                v.push(s.subslice(i, i + n));\n             \
    \                                               i += n;\n                    \
    \                                    }\n                                     \
    \               }\n                                                }\n       \
    \                                     }\n                                    \
    \    }\n                                    }\n                              \
    \  }\n                            }\n                        }\n             \
    \       }\n                }\n            }\n        }\n        i += 1;\n    }\n\
    \    v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `b`\n  --> /tmp/tmpbnzingcs.rs:22:88\n\
    \   |\n22 |         if s.chars().any(|c| c != ' ' && c != '\\n' && c != '\\t'\
    \ && c != '\\r' && c != '\\b') {\n   |                                       \
    \                                                 ^ unknown character escape\n\
    \   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    \nerror: unknown character escape: `b`\n  --> /tmp/tmpbnzingcs.rs:23:92\n   |\n\
    23 |             if s.chars().all(|c| c != ' ' && c != '\\n' && c != '\\t' &&\
    \ c != '\\r' && c != '\\b') {\n   |                                          \
    \                                                  ^ unknown character escape\n\
    \   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    \nerror[E0599]: no method named `subslice` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpbnzingcs.rs:35:70\n   |\n35 | ...                   v.push(s.subslice(i,\
    \ i + n));\n   |                                ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbnzingcs.rs:35:86\n   |\n35 |\
    \ ...                   v.push(s.subslice(i, i + n));\n   |                  \
    \                              ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmpbnzingcs.rs:35:84\n   |\n35 | ...\
    \                   v.push(s.subslice(i, i + n));\n   |                      \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbnzingcs.rs:36:66\n   |\n36 | ...                   i +=\
    \ n;\n   |                            ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmpbnzingcs.rs:36:63\n   |\n\
    36 | ...                   i += n;\n   |                         ^^ no implementation\
    \ for `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n\nerror: aborting due to 7 pr"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut i = 0;\n        let mut j = s.len();\n        while i < j {\n\
    \            if s[i] == ' ' {\n                i += 1;\n                j = i;\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \     if i == j {\n            result.push(s.clone());\n            i += 1;\n\
    \        }\n        if i == n {\n            result.push(s.clone());\n       \
    \ }\n        s = &s[i..];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7uipevjm.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7uipevjm.rs:35:17\n\
    \   |\n35 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |         if i == n.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7uipevjm.rs:38:13\n   |\n38 |         s = &s[i..];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n38 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n != 0 {\n\
    \        let mut i = 0;\n        while i < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ' || c == '.' || c == '!' || c == '?' || c == '-' || c == '_' || c ==\
    \ '/' || c == '\\\\') {\n                i += 1;\n            } else {\n     \
    \           result.push(s.subslice(i, i + 1));\n                i += 1;\n    \
    \            break;\n            }\n        }\n        n -= 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpqwlymmgy.rs:27:31\n   |\n27 |                 result.push(s.subslice(i,\
    \ i + 1));\n   |                               ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().any(|c| c.is_consonant() && count < n) {\n         \
    \   count += 1;\n            words.push(s.subslice(i, i + 1));\n            i\
    \ += 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpiivicvuw.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant() && count < n) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpiivicvuw.rs:24:26\n\
    \   |\n24 |             words.push(s.subslice(i, i + 1));\n   |              \
    \            ^^^^^^^^ method not found in `String`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().any(|c| c.is_consonant() && c.is_lowercase() && count\
    \ < n) {\n            count += 1;\n            words.push(s.to_string());\n  \
    \      }\n        i += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpa2j2ts0v.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant() && c.is_lowercase() && count < n) {\n   |                 \
    \               ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    for c in s.chars() {\n        if\
    \ c.is_consonant() {\n            count += 1;\n            if count == n {\n \
    \               words.push(s.clone());\n                count = 0;\n         \
    \   }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpk_x5uju_.rs:21:14\n   |\n21 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut non_spaces = vec![];\n    let mut non_letters\
    \ = vec![];\n    let mut non_spaces_index = s.len();\n    let mut vowels_index\
    \ = s.len();\n    let mut spaces_index = s.len();\n    let mut non_letters_index\
    \ = s.len();\n    let mut non_spaces_index = 0;\n    let mut vowels_index = 0;\n\
    \    let mut spaces_index = 0;\n    let mut non_letters_index = 0;\n    let mut\
    \ non_spaces_index = 0;\n    let mut vowels_index = 0;\n    let mut spaces_index\
    \ = 0;\n    let mut non_letters_index = 0;\n    let mut non_spaces_index = 0;\n\
    \    let mut vowels_index = 0;\n    let mut spaces_index = 0;\n    let mut non_letters_index\
    \ = 0;\n    let mut non_spaces_index = 0;\n    let mut vowels_index = 0;\n   \
    \ let mut spaces_index = 0;\n    let mut non_letters_index = 0;\n    let mut non_spaces_index\
    \ = 0;\n    let mut vowels_index = 0;\n    let mut spaces_index = 0;\n    let\
    \ mut non_letters_index = 0;\n    let mut non_spaces_index = 0;\n    let mut vowels_index\
    \ = 0;\n    let mut spaces_index = 0;\n    let mut non_letters_index = 0;\n  \
    \  let mut non_spaces_index = 0;\n    let mut vowels_index = 0;\n    let mut spaces_index\
    \ = 0;\n    let mut non_letters_index = 0;\n    let mut non_spaces_index = 0;\n\
    \    let mut vowels_index = 0;\n    let mut spaces_index = 0;\n    let mut non_letters_index\
    \ = 0;\n    let mut non_spaces_index = 0;\n    let mut vowels_index = 0;\n   \
    \ let mut spaces_index = 0;\n    let mut non_letters_index = 0;\n    let mut non_spaces_index\
    \ = 0;\n    let mut vowels_index = 0;\n    let mut spaces_index = 0;\n    let\
    \ mut non_letters_index = 0;\n    let mut non_spaces_index = 0;\n    let mut vowels_index\
    \ = 0;\n    let mut spaces_index = 0;\n    let mut non_letters_index = 0;\n  \
    \  let mut non_spaces_index = 0;\n    let mut vowels_index = 0;\n    let mut spaces_index\
    \ = 0;\n    let mut non_letters_index = 0;\n    let mut non_space\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2ft1i80r.rs:76:22\n   |\n\
    76 |     let mut non_space\n   |                      ^ help: add `;` here\n77\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ft1i80r.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] != ' ' {\n            j += 1\n\
    \        }\n        if j == i {\n            result.push(s.to_string());\n   \
    \         i += 1;\n        } else {\n            let mut k = j;\n            while\
    \ k < s.len() && s[k] != ' ' {\n                k += 1\n            }\n      \
    \      if k == j {\n                result.push(s.to_string());\n            \
    \    i += 1;\n            } else {\n                while j < s.len() && s[k]\
    \ == ' ' {\n                    j += 1\n                }\n                let\
    \ mut k = j;\n                while k < s.len() && s[k] == ' ' {\n           \
    \         k += 1\n                }\n                if k == j {\n           \
    \         result.push(s.to_string());\n                    i += 1;\n         \
    \       } else {\n                    while j < s.len() && s[k] != ' ' && s[k]\
    \ != s[k + 1] {\n                        j += 1\n                    }\n     \
    \               let mut k = j;\n                    while k < s.len() && s[k]\
    \ != ' ' && s[k] != s[k + 1] {\n                        k += 1\n             \
    \       }\n                    if k == j {\n                        result.push(s.to_string());\n\
    \                        i += 1;\n                    } else {\n             \
    \           while j < s.len() && s[k] != ' ' && s[k] != s[k + 1] {\n         \
    \                   j += 1\n                        }\n                      \
    \  let mut k = j;\n                        while k < s.len() && s[k] != ' ' &&\
    \ s[k] != s[k + 1] {\n                            k += 1\n                   \
    \     }\n                        if k == j {\n                            result.push(s.to_string());\n\
    \                            i += 1;\n                        } else {\n     \
    \                       while j < s.len() && s[k] != ' ' && s[k] != s[k + 1] {\n\
    \                                j += 1\n                            }\n     \
    \                       let mut k = j;\n                            while k <\
    \ s.len() && s[k] != ' ' && s[k] != s[k + 1] {\n                             \
    \   k += 1\n                            }\n                            if k ==\
    \ j {\n                                result.push(s.to_string());\n         \
    \                       i += 1;\n                            } else {\n      \
    \                          while j < s.len() && s[k] != ' ' && s[k] != s[k + 1]\
    \ {\n                                    j += 1\n                            \
    \    }\n                                let mut k = j;\n                     \
    \           while k < s.len() && s[k] != ' ' && s[k] != s[k + 1] {\n         \
    \                           k += 1\n                                }\n      \
    \                          if k == j {\n                                    result.push(s.to_string());\n\
    \                                    i += 1;\n                               \
    \ } else {\n                                    while j < s.len() && s[k] != '\
    \ ' && s[k] != s[k + 1] {\n                                        j += 1\n  \
    \                                  }\n                                    let\
    \ mut k = j;\n                                    while k < s.len() && s[k] !=\
    \ ' ' && s[k] != s[k + 1] {\n                                        k += 1\n\
    \                                    }\n                                    if\
    \ k\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp56hijqqh.rs:111:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n28  |         } else {\n    |                - unclosed delimiter\n...\n\
    36  |             } else {\n    |                    - unclosed delimiter\n...\n\
    47  |                 } else {\n    |                        - unclosed delimiter\n\
    ...\n58  |                     } else {\n    |                            - unclosed\
    \ delimiter\n...\n69  |                         } else {\n    |              \
    \                  - unclosed delimiter\n...\n80  |                          \
    \   } else {\n    |                                    - unclosed delimiter\n\
    ...\n91  |                                 } else {\n    |                   \
    \                     - this delimiter might not be properly closed...\n...\n\
    100 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    111 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmp56hijqqh.rs:100:1\n\
    \    |\n99  |                                     if k\n    |                \
    \                     -- this `if` expression has a condition, but no block\n\
    100 | }\n    | ^ expected `{`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp56hijqqh.rs:22:30\n   |\n22 |         while j < s.len()\
    \ && s[j] != ' ' {\n   |                              ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp56hijqqh.rs:30:34\n   |\n30 |             while k < s.len() &&\
    \ s[k] != ' ' {\n   |                                  ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp56hijqqh.rs:37:38\n   |\n37 |               "
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut index = 0;\n    while index < s.len() {\n \
    \       let mut found = false;\n        for c in s.chars() {\n            if c.is_consonant()\
    \ {\n                if index == 0 {\n                    found = true;\n    \
    \                break;\n                }\n                index -= 1;\n    \
    \        } else {\n                index += 1;\n            }\n        }\n   \
    \     if found {\n            words.push(s.subslice(index, index + 1));\n    \
    \    }\n        index += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpcwkjv4kn.rs:23:18\n   |\n23 |             if c.is_consonant()\
    \ {\n   |                  ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `subslice` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpcwkjv4kn.rs:34:26\n   |\n34 |             words.push(s.subslice(index,\
    \ index + 1));\n   |                          ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         words.push(s.subslice(i, i + n));\n            i += n;\n        }\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpzv7em832.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpzv7em832.rs:24:26\n\
    \   |\n24 |             words.push(s.subslice(i, i + n));\n   |              \
    \            ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzv7em832.rs:24:42\n   |\n24 |             words.push(s.subslice(i,\
    \ i + n));\n   |                                          ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpzv7em832.rs:24:40\n\
    \   |\n24 |             words.push(s.subslice(i, i + n));\n   |              \
    \                          ^ no implementation for `usize + isize`\n   |\n   =\
    \ help: the trait `Add<isize>` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzv7em832.rs:25:18\n   |\n25 |             i\
    \ += n;\n   |                  ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmpzv7em832.rs:25:15\n   |\n\
    25 |             i += n;\n   |               ^^ no implementation for `usize +=\
    \ isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented for\
    \ `usize`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsx8l8wyc.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         words.push(s.to_string());\n            i += 1;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp_l476o8q.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            break;\n        }\n        let mut k\
    \ = i;\n        while k < j {\n            if s[k] == ' ' {\n                break;\n\
    \            }\n            k += 1\n        }\n        if k == j {\n         \
    \   break;\n        }\n        let mut s = String::from(&s[i .. k]);\n       \
    \ let mut count = 0;\n        while i < s.len() {\n            if s[i] == ' '\
    \ {\n                count += 1;\n            }\n            i += 1;\n       \
    \ }\n        if count == n {\n            result.push(s);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7_qdz211.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp7_qdz211.rs:30:16\n   |\n\
    30 |             if s[k] == ' ' {\n   |                ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7_qdz211.rs:41:16\n   |\n41 |             if s[i] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut word = String::from(s);\n        let mut count = 0;\n       \
    \ for c in word.chars() {\n            if c.is_consonant() {\n               \
    \ count += 1;\n            }\n        }\n        if count == n {\n           \
    \ result.push(word);\n        }\n        s = &s[..word.len()];\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmptoyuumk8.rs:24:18\n   |\n24 |             if c.is_consonant()\
    \ {\n   |                  ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptoyuumk8.rs:31:13\n   |\n31 |         s = &s[..word.len()];\n\
    \   |             ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n  \
    \ |\nhelp: try using a conversion method\n   |\n31 |         s = (&s[..word.len()]).to_string();\n\
    \   |             +                +++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    let mut vowel_counters = vec![];\n    let mut consonant_counters =\
    \ vec![];\n    let mut vowel_counters_copy = vowel_counters;\n    let mut consonant_counters_copy\
    \ = consonant_counters;\n    let mut vowel_counters_copy2 = vowel_counters;\n\
    \    let mut consonant_counters_copy2 = consonant_counters;\n    let mut vowel_counters_copy3\
    \ = vowel_counters;\n    let mut consonant_counters_copy3 = consonant_counters;\n\
    \    let mut vowel_counters_copy4 = vowel_counters;\n    let mut consonant_counters_copy4\
    \ = consonant_counters;\n    let mut vowel_counters_copy5 = vowel_counters;\n\
    \    let mut consonant_counters_copy5 = consonant_counters;\n    let mut vowel_counters_copy6\
    \ = vowel_counters;\n    let mut consonant_counters_copy6 = consonant_counters;\n\
    \    let mut vowel_counters_copy7 = vowel_counters;\n    let mut consonant_counters_copy7\
    \ = consonant_counters;\n    let mut vowel_counters_copy8 = vowel_counters;\n\
    \    let mut consonant_counters_copy8 = consonant_counters;\n    let mut vowel_counters_copy9\
    \ = vowel_counters;\n    let mut consonant_counters_copy9 = consonant_counters;\n\
    \    let mut vowel_counters_copy10 = vowel_counters;\n    let mut consonant_counters_copy10\
    \ = consonant_counters;\n    let mut vowel_counters_copy11 = vowel_counters;\n\
    \    let mut consonant_counters_copy11 = consonant_counters;\n    let mut vowel_counters_copy12\
    \ = vowel_counters;\n    let mut consonant_counters_copy12 = consonant_counters;\n\
    \    let mut vowel_counters_copy13 = vowel_counters;\n    let mut consonant_counters_copy13\
    \ = consonant_counters;\n    let mut vowel_counters_copy14 = vowel\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw1a6vkxb.rs:51:42\n   |\n\
    51 |     let mut vowel_counters_copy14 = vowel\n   |                         \
    \                 ^ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `vowel` in this scope\n  --> /tmp/tmpw1a6vkxb.rs:51:37\n \
    \  |\n51 |     let mut vowel_counters_copy14 = vowel\n   |                   \
    \                  ^^^^^ help: a local variable with a similar name exists: `vowels`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw1a6vkxb.rs:17:41\n   |\n17 |\
    \ fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            result.push(s.to_string());\n      \
    \      i += 1;\n        } else {\n            let mut k = i;\n            while\
    \ k < j {\n                if s[k] == ' ' {\n                    result.push(s.to_string());\n\
    \                    i += 1;\n                    break;\n                } else\
    \ {\n                    k += 1\n                }\n            }\n        }\n\
    \    }\n    if result.len() == 0 {\n        result\n    } else {\n        result\n\
    \            .iter()\n            .filter(|x| x.chars().count(|c| c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u') == n)\n            .collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpau_2_f4w.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpau_2_f4w.rs:31:20\n   |\n\
    31 |                 if s[k] == ' ' {\n   |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0061]: this function takes 0 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmpau_2_f4w.rs:46:35\n    |\n46  |             .filter(|x|\
    \ x.chars().count(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\
    \ == n)\n    |                                   ^^^^^ ------------------------------------------------------------\
    \ supplied 1 argument\n    |                                   |\n    |      \
    \                             expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpau_2_f4w.rs:46:106\n\
    \   |\n46 |             .filter(|x| x.chars().count(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u') == n)\n   |                              \
    \                                                                            ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n46 |           \
    \  .filter(|x| x.chars().count(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o'\
    \ && c != 'u') == n.try_into().unwrap())\n   |                               \
    \                                                                           ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmpau_2_f4w.rs:47:14\n   |\n47 |\
    \             .collect()\n   |              ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&St"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut vowels_count = vowels.len();\n    let\
    \ mut consonants_count = consonants.len();\n    let mut vowels_index = 0;\n  \
    \  let mut consonants_index = 0;\n    let mut vowels_found = false;\n    let mut\
    \ consonants_found = false;\n    let mut vowels_index2 = 0;\n    let mut consonants_index2\
    \ = 0;\n    let mut vowels_found2 = false;\n    let mut consonants_found2 = false;\n\
    \    let mut vowels_index3 = 0;\n    let mut consonants_index3 = 0;\n    let mut\
    \ vowels_found3 = false;\n    let mut consonants_found3 = false;\n    let mut\
    \ vowels_index4 = 0;\n    let mut consonants_index4 = 0;\n    let mut vowels_found4\
    \ = false;\n    let mut consonants_found4 = false;\n    let mut vowels_index5\
    \ = 0;\n    let mut consonants_index5 = 0;\n    let mut vowels_found5 = false;\n\
    \    let mut consonants_found5 = false;\n    let mut vowels_index6 = 0;\n    let\
    \ mut consonants_index6 = 0;\n    let mut vowels_found6 = false;\n    let mut\
    \ consonants_found6 = false;\n    let mut vowels_index7 = 0;\n    let mut consonants_index7\
    \ = 0;\n    let mut vowels_found7 = false;\n    let mut consonants_found7 = false;\n\
    \    let mut vowels_index8 = 0;\n    let mut consonants_index8 = 0;\n    let mut\
    \ vowels_found8 = false;\n    let mut consonants_found8 = false;\n    let mut\
    \ vowels_index9 = 0;\n    let mut consonants_index9 = 0;\n    let mut vowels_found9\
    \ = false;\n    let mut consonants_found9 = false;\n    let mut vowels_index10\
    \ = 0;\n    let mut consonants_index10 = 0;\n    let mut vowels_found10 = false;\n\
    \    let mut consonants_found10 = false;\n    let mut vowels_index11 = 0;\n  \
    \  let mut consonants_index11 = 0;\n    let mut vowels_found11\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbxr3m3ag.rs:65:27\n   |\n\
    65 |     let mut vowels_found11\n   |                           ^ help: add `;`\
    \ here\n66 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbxr3m3ag.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) ->\
    \ Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().all(|c| c.is_consonant() && c != ' ') {\n\
    \            v.push(s.subslice(i, i + n));\n            i += n;\n        }\n \
    \   }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmps4tks93i.rs:22:32\n   |\n22 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmps4tks93i.rs:23:22\n\
    \   |\n23 |             v.push(s.subslice(i, i + n));\n   |                  \
    \    ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps4tks93i.rs:23:38\n   |\n23 |             v.push(s.subslice(i,\
    \ i + n));\n   |                                      ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmps4tks93i.rs:23:36\n\
    \   |\n23 |             v.push(s.subslice(i, i + n));\n   |                  \
    \                  ^ no implementation for `usize + isize`\n   |\n   = help: the\
    \ trait `Add<isize>` is not implemented for `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps4tks93i.rs:24:18\n   |\n24 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmps4tks93i.rs:24:15\n   |\n24 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == s.len() {\n            break;\n        }\n        let\
    \ mut k = j;\n        while k < s.len() && s[k] != ' ' {\n            k += 1\n\
    \        }\n        if k == s.len() {\n            break;\n        }\n       \
    \ if n == j - i {\n            words.push(s.split_whitespace()[i]);\n        \
    \    i += k + 1;\n        } else {\n            i += k + 1;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrh19cnd.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpsrh19cnd.rs:29:30\n   |\n\
    29 |         while k < s.len() && s[k] != ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsrh19cnd.rs:35:17\n   |\n35 |         if n == j - i {\n   |   \
    \              ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    35 |         if n == (j - i).try_into().unwrap() {\n   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpsrh19cnd.rs:36:24\n   |\n36 |             words.push(s.split_whitespace()[i]);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        let mut j = i;\n        while j < s.len() && s.chars().all(|c|\
    \ c != s.chars().nth(j)) {\n            j += 1\n        }\n        if j == i {\n\
    \            v.push(s.to_string());\n            i += 1;\n        } else {\n \
    \           i += j - i;\n        }\n    }\n    v.sort_unstable();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjhq7lupu.rs:23:53\n   |\n\
    23 |         while j < s.len() && s.chars().all(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjhq7lupu.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        let mut j = i;\n        while j < s.len() && s.chars().all(|c|\
    \ c != s.chars().nth(j)) {\n            j += 1\n        }\n        if j == i {\n\
    \            v.push(s.clone());\n            i += 1;\n        } else {\n     \
    \       i += j - i;\n        }\n    }\n    v.sort_unstable();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n    v.dedup();\n\
    \    v.dedup();\n    v.dedup();\n    v.dedup();\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpim45v3un.rs:23:53\n   |\n\
    23 |         while j < s.len() && s.chars().all(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpim45v3un.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    let mut n = n as usize;\n\
    \    while n > 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n       \
    \     result.push(s.clone());\n            n -= 1;\n        }\n        s += \"\
    \ \";\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp5slenyek.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n > 0 {\n\
    \        let mut i = 0;\n        while i < s.len() {\n            let c = s.chars().nth(i).unwrap();\n\
    \            if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n \
    \               break;\n            }\n            i += 1;\n        }\n      \
    \  if i == s.len() {\n            break;\n        }\n        result.push(s.subslice(i,\
    \ i + n));\n        n -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp9kfuf2jg.rs:33:23\n   |\n33 |         result.push(s.subslice(i,\
    \ i + n));\n   |                       ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9kfuf2jg.rs:33:39\n   |\n33 |\
    \         result.push(s.subslice(i, i + n));\n   |                           \
    \            ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize`\
    \ to `usize`\n  --> /tmp/tmp9kfuf2jg.rs:33:37\n   |\n33 |         result.push(s.subslice(i,\
    \ i + n));\n   |                                     ^ no implementation for `usize\
    \ + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    for c in s.chars() {\n        if\
    \ c.is_consonant() {\n            count += 1;\n            if count == n {\n \
    \               words.push(c.to_string());\n                count = 0;\n     \
    \       }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpfgz85o4j.rs:21:14\n   |\n21 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j].is_ascii_letter() {\n            j\
    \ = j + 1;\n        }\n        if j == s.len() {\n            break;\n       \
    \ }\n        let mut k = j;\n        while k < s.len() && s[k].is_ascii_letter()\
    \ {\n            k = k + 1;\n        }\n        if k == s.len() {\n          \
    \  break;\n        }\n        let mut c = s.chars().nth(j).unwrap();\n       \
    \ if c == ' ' || c == ',' || c == '.' || c == '?' || c == '!' || c == '-' || c\
    \ == '/' || c == '\\\\' || c == '(' || c == ')' || c == '{' || c == '}' || c ==\
    \ '[' || c == ']' || c == '<' || c == '>' || c == '=' || c == '!' || c == '%'\
    \ || c == '&' || c == '*' || c == '+' || c == '-' || c == '^' || c == '|' || c\
    \ == '~' || c == '`' || c == '_' || c == '<' || c == '>' || c == '=' || c == '%'\
    \ || c == '&' || c == '*' || c == '+' || c == '-' || c == '^' || c == '|' || c\
    \ == '~' || c == '`' || c == '_' || c == '<' || c == '>' || c == '=' || c == '%'\
    \ || c == '&' || c == '*' || c == '+' || c == '-' || c == '^' || c == '|' || c\
    \ == '~' || c == '`' || c == '_' || c == '<' || c == '>' || c == '=' || c == '%'\
    \ || c == '&' || c == '*' || c == '+' || c == '-' || c == '^' || c == '|' || c\
    \ == '~' || c == '`' || c == '_' || c == '<' || c == '>' || c == '=' || c == '%'\
    \ || c == '&' || c == '*' || c == '+' || c == '-' || c == '^' || c == '|' || c\
    \ == '~' || c == '`' || c == '_' || c == '<' || c == '>' || c == '=' || c == '%'\
    \ || c == '&' || c == '*' || c == '+' || c == '-' || c == '^' || c == '|' || c\
    \ == '~' || c == '`' || c == '_' || c == '<' || c == '>' || c == '=' || c == '%'\
    \ || c == '&' || c == '*' || c == '+' || c == '-' || c == '^' || c\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp60bzw24n.rs:48:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n20\
    \ |     while i < s.len() {\n   |                       - this delimiter might\
    \ not be properly closed...\n...\n37 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n48 | }\n   |   ^\n\nerror: expected `{`, found\
    \ `}`\n  --> /tmp/tmp60bzw24n.rs:37:1\n   |\n36 |         if c == ' ' || c ==\
    \ ',' || c == '.' || c == '?' || c == '!' || c == '-' || c == '/' || c == '\\\\\
    ' || c == '(' || c == ')' || c == ...\n   |         -- this `if` expression has\
    \ a condition, but no block\n37 | }\n   | ^ expected `{`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp60bzw24n.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp60bzw24n.rs:29:30\n\
    \   |\n29 |         while k < s.len() && s[k].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp60bzw24n.rs:17:41\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |    ------------                   \
    \      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut vowels_count = vowels.len();\n    let\
    \ mut consonants_count = consonants.len();\n    let mut i = 0;\n    while i <\
    \ s.len() {\n        if s.chars().any(|c| consonants.contains(&c)) {\n       \
    \     consonants_count -= 1;\n        }\n        if s.chars().any(|c| vowels.contains(&c))\
    \ {\n            vowels_count -= 1;\n        }\n        if consonants_count ==\
    \ n && vowels_count == n {\n            result.push(s.to_string());\n        \
    \    i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl747q5hc.rs:25:50\n   |\n\
    25 |         if s.chars().any(|c| consonants.contains(&c)) {\n   |           \
    \                                       ^^ expected `&str`, found `char`\n   |\n\
    \   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl747q5hc.rs:28:46\n   |\n28 |\
    \         if s.chars().any(|c| vowels.contains(&c)) {\n   |                  \
    \                            ^^ expected `&str`, found `char`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl747q5hc.rs:31:32\n   |\n31 |         if consonants_count\
    \ == n && vowels_count == n {\n   |                                ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n31 |         if consonants_count\
    \ == n.try_into().unwrap() && vowels_count == n {\n   |                      \
    \          ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl747q5hc.rs:31:53\n\
    \   |\n31 |         if consonants_count == n && vowels_count == n {\n   |    \
    \                                                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n31 |         if consonants_count == n && vowels_count\
    \ == n.try_into().unwrap() {\n   |                                           \
    \          ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n                j -= 1;\n          \
    \  } else {\n                i += 1;\n            }\n        }\n        if i ==\
    \ n {\n            result.push(s.clone());\n        }\n        s = &s[i..];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4xjye9ej.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xjye9ej.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4xjye9ej.rs:34:13\n   |\n34 |         s = &s[i..];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n34 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().any(|c| c != ' ' && c != '\\t' && c != '\\\
    n' && c != '\\r') {\n            if s.chars().all(|c| c == ' ' || c == '\\t' ||\
    \ c == '\\n' || c == '\\r') {\n                v.push(s.subslice(i, i + n));\n\
    \                i += n;\n            } else {\n                i += 1;\n    \
    \        }\n        } else {\n            i += 1;\n        }\n    }\n    v\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpat_h4z3g.rs:24:26\n   |\n24 |                 v.push(s.subslice(i,\
    \ i + n));\n   |                          ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpat_h4z3g.rs:24:42\n   |\n24 |\
    \                 v.push(s.subslice(i, i + n));\n   |                        \
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add\
    \ `isize` to `usize`\n  --> /tmp/tmpat_h4z3g.rs:24:40\n   |\n24 |            \
    \     v.push(s.subslice(i, i + n));\n   |                                    \
    \    ^ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpat_h4z3g.rs:25:22\n\
    \   |\n25 |                 i += n;\n   |                      ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpat_h4z3g.rs:25:19\n\
    \   |\n25 |                 i += n;\n   |                   ^^ no implementation\
    \ for `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().any(|c| c != ' ' && c != '\\t' && c != '\\n') {\n  \
    \          count += 1;\n            if count == n {\n                words.push(s.to_string());\n\
    \                count = 0;\n            }\n        }\n        i += 1;\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\", \"Mary had a little lamb\"]`,\n right: `[\"\
    little\"]`', /tmp/tmpi27ipp4d.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    for c in s.chars() {\n        if\
    \ c.is_consonant() {\n            count += 1;\n            if count == n {\n \
    \               words.push(c.to_string());\n                count = 0;\n     \
    \       }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpfgz85o4j.rs:21:14\n   |\n21 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n            j += 1\n        }\n        if j - i == n {\n            words.push(s.chars().nth(i).unwrap());\n\
    \            i += n;\n        }\n        else {\n            i += j;\n       \
    \ }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n \
    \   assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp30ygrw1_.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp30ygrw1_.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp30ygrw1_.rs:27:18\n   |\n27 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmp30ygrw1_.rs:27:15\n   |\n27 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp30ygrw1_.rs:33:5\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n33 |  \
    \   words\n   |     ^^^^^ expected struct `String`, found `char`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<char>`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut s = String::from(s);\n    let mut n = n;\n    while\
    \ n != 0 {\n        let mut i = 0;\n        while i < s.len() {\n            if\
    \ s.chars().any(|c| c.is_uppercase() && c.is_consonant() && c != ' ') {\n    \
    \            i += 1;\n            } else {\n                break;\n         \
    \   }\n        }\n        if i == s.len() {\n            break;\n        }\n \
    \       words.push(s.split_whitespace()[i]);\n        n -= 1;\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpee2mvzkw.rs:24:56\n   |\n24 |             if s.chars().any(|c|\
    \ c.is_uppercase() && c.is_consonant() && c != ' ') {\n   |                  \
    \                                      ^^^^^^^^^^^^ method not found in `char`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpee2mvzkw.rs:33:20\n   |\n33 |         words.push(s.split_whitespace()[i]);\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowel_consonants = vec![];\n    let mut vowel_consonant_vowels =\
    \ vec![];\n    let mut vowel_consonant_vowels_vowels = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels = vec![];\n\
    \    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels = vec![];\n  \
    \  let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels = vec![];\n\
    \    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowel\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk4ge9zqf.rs:38:118\n   |\n\
    38 |     let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowel\n\
    \   |                                                                        \
    \                                              ^ help: add `;` here\n39 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk4ge9zqf.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut found = false;\n        let mut i = 0;\n        while i < n && !found\
    \ {\n            if s[index] == ' ' {\n                found = true;\n       \
    \     }\n            i += 1;\n        }\n        if found {\n            words.push(s.split_whitespace()[index..]);\n\
    \        }\n        index += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpenj_ak19.rs:24:16\n\
    \   |\n24 |             if s[index] == ' ' {\n   |                ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpenj_ak19.rs:30:24\n   |\n30 |         \
    \    words.push(s.split_whitespace()[index..]);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        while i < s.len() && s.chars().any(|c| c != ' ') {\n       \
    \     i += 1;\n        }\n        if i == s.len() {\n            result.push(s);\n\
    \            break;\n        }\n        let mut j = i;\n        while j < s.len()\
    \ && s.chars().any(|c| c != ' ') {\n            j += 1;\n        }\n        if\
    \ j == s.len() {\n            result.push(s.clone());\n            break;\n  \
    \      }\n        let mut k = j;\n        while k < s.len() && s.chars().any(|c|\
    \ c != ' ') {\n            k += 1;\n        }\n        if k == s.len() {\n   \
    \         result.push(s.clone());\n            break;\n        }\n        if s.chars().any(|c|\
    \ c != ' ') {\n            let mut i = j;\n            while i < s.len() && s.chars().any(|c|\
    \ c != ' ') {\n                i += 1;\n            }\n            if i == s.len()\
    \ {\n                result.push(s.clone());\n                break;\n       \
    \     }\n            let mut j = i;\n            while j < s.len() && s.chars().any(|c|\
    \ c != ' ') {\n                j += 1;\n            }\n            if j == s.len()\
    \ {\n                result.push(s.clone());\n                break;\n       \
    \     }\n            let mut k = j;\n            while k < s.len() && s.chars().any(|c|\
    \ c != ' ') {\n                k += 1;\n            }\n            if k == s.len()\
    \ {\n                result.push(s.clone());\n                break;\n       \
    \     }\n        }\n        s = &s[..k];\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppguceqdq.rs:71:13\n   |\n\
    71 |         s = &s[..k];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n71 |        \
    \ s = (&s[..k]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        let mut k = j;\n        while k < s.len() && s[k] == ' ' {\n\
    \            k += 1\n        }\n        if k == i {\n            words.push(s.to_string());\n\
    \            i += 1;\n            continue;\n        }\n        if s.chars().all(|c|\
    \ c != ' ' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n  \
    \          words.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if k > i {\n            let mut j = 0;\n            while\
    \ j < k {\n                if s[j] != ' ' {\n                    break;\n    \
    \            }\n                j += 1\n            }\n            if j == k {\n\
    \                words.push(s.to_string());\n                i += 1;\n       \
    \         continue;\n            }\n        }\n        if j > i {\n          \
    \  let mut k = 0;\n            while k < j {\n                if s[k] != ' ' {\n\
    \                    break;\n                }\n                k += 1\n     \
    \       }\n            if k == j {\n                words.push(s.to_string());\n\
    \                i += 1;\n                continue;\n            }\n        }\n\
    \        if j > i {\n            let mut k = 0;\n            while k < j {\n \
    \               if s[k] != ' ' {\n                    break;\n               \
    \ }\n                k += 1\n            }\n            if k == j {\n        \
    \        words.push(s.to_string());\n                i += 1;\n               \
    \ continue;\n            }\n        }\n        if j > i {\n            let mut\
    \ k = 0;\n            while k < j {\n                if s[k] != ' ' {\n      \
    \              break;\n                }\n                k += 1\n           \
    \ }\n            if k == j {\n                words.push(s.to_string());\n   \
    \             i += 1;\n                continue;\n            }\n        }\n \
    \       if j > i {\n            let mut k = 0;\n            while k < j {\n  \
    \              if s[k] != ' ' {\n                    break;\n                }\n\
    \                k += 1\n            }\n            if k == j {\n            \
    \    words.push(s.to_string());\n                i += 1;\n                continue;\n\
    \            }\n        }\n        if j > i {\n            let mut k = 0;\n  \
    \          while k < j {\n                if s[k] != ' ' {\n                 \
    \   break;\n                }\n                k += 1\n            }\n       \
    \     if k == j {\n                words.push(s.to_string());\n              \
    \  i += 1;\n                continue;\n            }\n        }\n        if j\
    \ > i {\n            let mut k = 0;\n            while k < j {\n             \
    \   if s[k] != ' ' {\n                    break;\n                }\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpwfhnyag0.rs:140:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n123 |         if j > i {\n    |                  - unclosed delimiter\n124\
    \ |             let mut k = 0;\n125 |             while k < j {\n    |       \
    \                  - this delimiter might not be properly closed...\n...\n129\
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n140\
    \ | }\n    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwfhnyag0.rs:22:30\n   |\n22 |         while j < s.len() && s[j]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpwfhnyag0.rs:26:30\n   |\n26 |         while k < s.len() && s[k]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpwfhnyag0.rs:42:20\n   |\n42 |                 if s[j] != ' ' {\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwfhnyag0.rs:56:20\n\
    \   |\n56 |                 if s[k] != ' ' {\n   |                    ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpwfhnyag0.rs:70:20\n   |\n70 |                 if s[k]\
    \ != ' ' {\n   |                    ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         words.push(s.to_string());\n            i += 1;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp_l476o8q.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        while i < s.len() && s[i] == ' ' {\n            i += 1;\n  \
    \      }\n        if i == s.len() {\n            break;\n        }\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1;\n\
    \        }\n        if j == s.len() {\n            break;\n        }\n       \
    \ if s.chars().nth(i).unwrap() == ' ' {\n            result.push(s.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j += 1;\n        }\n        if i == s.len()\
    \ || j == s.len() {\n            break;\n        }\n        if s.chars().nth(i).unwrap()\
    \ == 'a' || s.chars().nth(i).unwrap() == 'e' || s.chars().nth(i).unwrap() == 'i'\
    \ || s.chars().nth(i).unwrap() == 'o' || s.chars().nth(i).unwrap() == 'u' {\n\
    \            result.push(s.chars().nth(j).unwrap());\n            i += 1;\n  \
    \          j += 1;\n        }\n        if i == s.len() || j == s.len() {\n   \
    \         break;\n        }\n        if s.chars().nth(i).unwrap() == 'y' || s.chars().nth(i).unwrap()\
    \ == 'a' || s.chars().nth(i).unwrap() == 'e' || s.chars().nth(i).unwrap() == 'i'\
    \ || s.chars().nth(i).unwrap() == 'o' || s.chars().nth(i).unwrap() == 'u' {\n\
    \            result.push(s.chars().nth(j).unwrap());\n            i += 1;\n  \
    \          j += 1;\n        }\n        if i == s.len() || j == s.len() {\n   \
    \         break;\n        }\n        if s.chars().nth(i).unwrap() == 'o' || s.chars().nth(i).unwrap()\
    \ == 'a' || s.chars().nth(i).unwrap() == 'e' || s.chars().nth(i).unwrap() == 'i'\
    \ || s.chars().nth(i).unwrap() == 'u' {\n            result.push(s.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j += 1;\n        }\n        if i == s.len()\
    \ || j == s.len() {\n            break;\n        }\n        if s.chars().nth(i).unwrap()\
    \ == 'e' || s.chars().nth(i).unwrap() == 'a' || s.chars().nth(i).unwrap() == 'i'\
    \ || s.chars().nth(i).unwrap() == 'o' || s.chars().nth(i).unwrap() == 'u' {\n\
    \            result.push(s.chars().nth(j).unwrap());\n            i += 1;\n  \
    \          j += 1;\n        }\n        if i == s.len() || j == s.len() {\n   \
    \         break;\n        }\n        if s.chars().nth(i\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpgi84g0bp.rs:87:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n20\
    \ |     while s.len() > 0 {\n   |                       - this delimiter might\
    \ not be properly closed...\n...\n76 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n87 | }\n   |   ^\n\nerror: expected `{`, found\
    \ `}`\n  --> /tmp/tmpgi84g0bp.rs:76:1\n   |\n75 |         if s.chars().nth(i\n\
    \   |         -- this `if` expression has a condition, but no block\n76 | }\n\
    \   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpgi84g0bp.rs:75:25\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n...\n75 |         if s.chars().nth(i\n   |                       \
    \  ^ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgi84g0bp.rs:22:30\n\
    \   |\n22 |         while i < s.len() && s[i] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpgi84g0bp.rs:29:30\n   |\n\
    29 |         while j < s.len() && s[j] == ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgi84g0bp.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: "
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    let mut vowel_counters = vec![];\n    let mut consonant_counters =\
    \ vec![];\n    let mut vowel_counters_copy = vec![];\n    let mut consonant_counters_copy\
    \ = vec![];\n    let mut vowel_counters_copy_copy = vec![];\n    let mut consonant_counters_copy_copy\
    \ = vec![];\n    let mut vowel_counters_copy_copy_copy = vec![];\n    let mut\
    \ consonant_counters_copy_copy_copy = vec![];\n    let mut vowel_counters_copy_copy_copy_copy\
    \ = vec![];\n    let mut consonant_counters_copy_copy_copy_copy = vec![];\n  \
    \  let mut vowel_counters_copy_copy_copy_copy_copy = vec![];\n    let mut consonant_counters_copy_copy_copy_copy_copy_copy\
    \ = vec![];\n    let mut vowel_counters_copy_copy_copy_copy_copy_copy_copy = vec![];\n\
    \    let mut consonant_counters_copy_copy_copy_copy_copy_copy_copy_copy = vec![];\n\
    \    let mut vowel_counters_copy_copy_copy_copy_copy_copy_copy_copy_copy = vec![];\n\
    \    let mut consonant_counters_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = vec![];\n    let mut vowel_counters_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = vec![];\n    let mut consonant_counters_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = vec![];\n    let mut vowel_counters_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = vec![];\n    let mut consonant_counters_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = vec![];\n    let mut vowel_counters_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = vec![];\n    let mut consonant_counters_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy\
    \ = vec![];\n    let mut vowel_counters_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqdfwx9uy.rs:45:78\n   |\n\
    45 |     let mut vowel_counters_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_\n\
    \   |                                                                        \
    \      ^ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqdfwx9uy.rs:17:41\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |    ------------                   \
    \      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    for c in s.chars() {\n        if\
    \ c.is_whitespace() {\n            continue;\n        }\n        if c.is_ascii_letter()\
    \ {\n            count += 1;\n            if count == n {\n                words.push(String::from(&c.to_string()));\n\
    \            }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpntaar84n.rs:24:14\n   |\n24 |         if c.is_ascii_letter()\
    \ {\n   |              ^^^^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j + 1;\n\
    \        }\n        if j == s.len() {\n            break;\n        }\n       \
    \ let mut word = String::from(&s[i .. j]);\n        let mut count = 0;\n     \
    \   while j < s.len() && s[j] == ' ' {\n            j = j + 1;\n        }\n  \
    \      if j == s.len() {\n            count = j - i;\n            i = j;\n   \
    \     }\n        if count >= n {\n            words.push(word);\n        }\n \
    \       i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6e71t5rm.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp6e71t5rm.rs:30:30\n   |\n\
    30 |         while j < s.len() && s[j] == ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6e71t5rm.rs:37:21\n   |\n37 |         if count >= n {\n   |   \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    37 |         if count >= n.try_into().unwrap() {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut vowels = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut consonants = vec![\"b\", \"c\", \"d\"\
    , \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut spaces = vec![\"\
    \ \"];\n    let mut punctuation = vec![\".\", \"!\", \"?\"];\n    let mut letters\
    \ = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut numbers = vec![\"0\", \"1\"\
    , \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n    let mut punctuation_count\
    \ = vec![\".\", \"!\", \"?\"];\n    let mut letter_count = vec![\"a\", \"b\",\
    \ \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"];\n    let mut number_count = vec![\"0\", \"1\", \"2\", \"3\",\
    \ \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n    let mut space_count = vec![\"\
    \ \"];\n    let mut punctuation_count_count = vec![\".\", \"!\", \"?\"];\n   \
    \ let mut letter_count_count = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\",\
    \ \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut\
    \ number_count_count = vec![\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"\
    7\", \"8\", \"9\"];\n    let mut space_count_count = vec![\" \"];\n    let mut\
    \ punctuation_count_count_count = vec![\".\", \"!\", \"?\"];\n    let mut letter_count_count_count\
    \ = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut number_count_count_count =\
    \ vec![\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n\
    \    let mut space_count_count_count = vec![\" \"];\n    let mut punctuation_count_count_count_count\
    \ = vec![\".\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzrivcs55.rs:49:136\n\
    \   |\n49 |       assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n   | \
    \ ________________________________________________________________________________________________________________________________________^\n\
    50 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut word = String::from(\"\");\n        let mut count = 0;\n        while\
    \ count < n && index < s.len() {\n            if s[index] == ' ' {\n         \
    \       count++;\n            } else {\n                word += s[index];\n  \
    \              index += 1;\n            }\n        }\n        if word != \"\"\
    \ {\n            words.push(word);\n        }\n    }\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp32asr_9s.rs:25:23\n\
    \   |\n25 |                 count++;\n   |                       ^ expected expression\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp32asr_9s.rs:24:16\n\
    \   |\n24 |             if s[index] == ' ' {\n   |                ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp32asr_9s.rs:27:25\n   |\n27 |                 word\
    \ += s[index];\n   |                         ^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowel_counter = 0;\n    let mut vowel_counter2 = 0;\n    let mut\
    \ vowel_counter3 = 0;\n    let mut vowel_counter4 = 0;\n    let mut vowel_counter5\
    \ = 0;\n    let mut vowel_counter6 = 0;\n    let mut vowel_counter7 = 0;\n   \
    \ let mut vowel_counter8 = 0;\n    let mut vowel_counter9 = 0;\n    let mut vowel_counter10\
    \ = 0;\n    let mut vowel_counter11 = 0;\n    let mut vowel_counter12 = 0;\n \
    \   let mut vowel_counter13 = 0;\n    let mut vowel_counter14 = 0;\n    let mut\
    \ vowel_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let mut vowel_counter17\
    \ = 0;\n    let mut vowel_counter18 = 0;\n    let mut vowel_counter19 = 0;\n \
    \   let mut vowel_counter20 = 0;\n    let mut vowel_counter21 = 0;\n    let mut\
    \ vowel_counter22 = 0;\n    let mut vowel_counter23 = 0;\n    let mut vowel_counter24\
    \ = 0;\n    let mut vowel_counter25 = 0;\n    let mut vowel_counter26 = 0;\n \
    \   let mut vowel_counter27 = 0;\n    let mut vowel_counter28 = 0;\n    let mut\
    \ vowel_counter29 = 0;\n    let mut vowel_counter30 = 0;\n    let mut vowel_counter31\
    \ = 0;\n    let mut vowel_counter32 = 0;\n    let mut vowel_counter33 = 0;\n \
    \   let mut vowel_counter34 = 0;\n    let mut vowel_counter35 = 0;\n    let mut\
    \ vowel_counter36 = 0;\n    let mut vowel_counter37 = 0;\n    let mut vowel_counter38\
    \ = 0;\n    let mut vowel_counter39 = 0;\n    let mut vowel_counter40 = 0;\n \
    \   let mut vowel_counter41 = 0;\n    let mut vowel_counter42 = 0;\n    let mut\
    \ vowel_counter43 = 0;\n    let mut vowel_counter44 = 0;\n    let mut vowel_counter45\
    \ = 0;\n    let mut vowel_counter46 = 0;\n    let mut vowel_counter47 = 0;\n \
    \   let mut vowel_counter48 = 0;\n    let mut vowel_counter49 = 0;\n    let mut\
    \ vowel_counter50 = 0;\n    let mut vowel_counter51 = 0;\n    let mut vowel_counter52\
    \ = 0;\n    let mut vowel_counter53 = 0;\n    let mut vowel_counter54 = 0;\n \
    \   let mut \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpl13o8muc.rs:76:1\n\
    \   |\n76 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut i = 0;\n        let mut j = s.len();\n        while i < j {\n\
    \            if s[i] == ' ' {\n                i += 1;\n                j = i;\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \     if i == j {\n            result.push(s.clone());\n            i += 1;\n\
    \        }\n        if i == n {\n            result.push(s.clone());\n       \
    \ }\n        s = &s[i..];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7uipevjm.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7uipevjm.rs:35:17\n\
    \   |\n35 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |         if i == n.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7uipevjm.rs:38:13\n   |\n38 |         s = &s[i..];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n38 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut word = String::from(\"\");\n        let mut is_consonant = false;\n\
    \        for c in s.chars() {\n            if index == 0 {\n                is_consonant\
    \ = false;\n            }\n            if c == ' ' {\n                if is_consonant\
    \ {\n                    word.push_str(\" \");\n                }\n          \
    \  } else {\n                if is_consonant {\n                    word.push_str(c);\n\
    \                } else {\n                    if word.len() == n {\n        \
    \                words.push(word);\n                    }\n                  \
    \  is_consonant = true;\n                    word.push_str(c);\n             \
    \   }\n            }\n            index += 1;\n        }\n    }\n    words\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcyz57dhb.rs:33:35\n   |\n\
    33 |                     word.push_str(c);\n   |                             \
    \      ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcyz57dhb.rs:35:38\n   |\n35 |                     if word.len() == n\
    \ {\n   |                                      ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n35 |                     if word.len() == n.try_into().unwrap()\
    \ {\n   |                                      ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcyz57dhb.rs:39:35\n   |\n39 |              \
    \       word.push_str(c);\n   |                                   ^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            i += 1;\n            continue;\n   \
    \     }\n        let mut k = i;\n        while k < j {\n            if s[k] ==\
    \ ' ' {\n                k += 1;\n                continue;\n            }\n \
    \           if s[k] == 'a' || s[k] == 'e' || s[k] == 'i' || s[k] == 'o' || s[k]\
    \ == 'u' {\n                k += 1;\n                continue;\n            }\n\
    \            if s[k] == 'y' || s[k] == 's' || s[k] == 'd' || s[k] == 'r' || s[k]\
    \ == 'c' || s[k] == 'l' {\n                k += 1;\n                continue;\n\
    \            }\n            if s[k] == 'n' {\n                k += 1;\n      \
    \          continue;\n            }\n            if s[k] == 't' || s[k] == 'h'\
    \ || s[k] == 'w' || s[k] == 'f' || s[k] == 'v' || s[k] == 'b' || s[k] == 'k' {\n\
    \                k += 1;\n                continue;\n            }\n         \
    \   if s[k] == 'm' {\n                k += 1;\n                continue;\n   \
    \         }\n            if s[k] == 'p' {\n                k += 1;\n         \
    \       continue;\n            }\n            if s[k] == 'b' || s[k] == 'j' ||\
    \ s[k] == 'q' || s[k] == 'z' || s[k] == 'x' || s[k] == 'z' || s[k] == 'c' {\n\
    \                k += 1;\n                continue;\n            }\n         \
    \   if s[k] == 'q' || s[k] == 'j' || s[k] == 'z' || s[k] == 'x' || s[k] == 'z'\
    \ || s[k] == 'c' || s[k] == 'l' {\n                k += 1;\n                continue;\n\
    \            }\n            if s[k] == 'z' || s[k] == 'c' || s[k] == 'l' || s[k]\
    \ == 'p' || s[k] == 'q' || s[k] == 'j' || s[k] == 'z' || s[k] == 'x' {\n     \
    \           k += 1;\n                continue;\n            }\n            if\
    \ s[k] == 'q' || s[k] == 'j' || s[k] == 'z' || s[k] == 'x' || s[k] == 'z' || s[k]\
    \ == 'c' || s[k] == 'l' || s[k] == 'p' {\n                k += 1;\n          \
    \      continue;\n            }\n            if s[k] == 'j' || s[k] == 'z' ||\
    \ s[k] == 'x' || s[k] == 'z' || s[k] == 'c' || s[k] == 'l' || s[k] == 'p' || s[k]\
    \ == 'q' {\n                k += 1;\n                continue;\n            }\n\
    \            if s[k] == 'z' || s[k] == 'c' || s[k] == 'l' || s[k] == 'p' || s[k]\
    \ == 'q' || s[k] == 'j' || s[k] == 'z' || s[k] == 'x' || s[k] == 'z' || s[k] ==\
    \ 'c' || s[k] == 'l' || s[k] == 'p\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprsht87mu.rs:91:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n20\
    \ |     while i < s.len() {\n   |                       - unclosed delimiter\n\
    ...\n30 |         while k < j {\n   |                     - this delimiter might\
    \ not be properly closed...\n...\n80 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n91 | }\n   |   ^\n\nerror: expected `while`,\
    \ `for`, `loop` or `{` after a label\n  --> /tmp/tmprsht87mu.rs:80:1\n   |\n80\
    \ | }\n   | ^ expected `while`, `for`, `loop` or `{` after a label\n\nerror: expected\
    \ expression, found `}`\n  --> /tmp/tmprsht87mu.rs:80:1\n   |\n80 | }\n   | ^\
    \ expected expression\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmprsht87mu.rs:22:30\n   |\n22 |         while j < s.len()\
    \ && s[j] == ' ' {\n   |                              ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprsht87mu.rs:31:16\n   |\n31 |             if s[k] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmprsht87mu.rs:35:16\n\
    \   |\n35 |             if s[k] == 'a' || s[k] == 'e' || s[k] == 'i' || s[k] ==\
    \ 'o' || s[k] == 'u' {\n   |                ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprsht87mu.rs:35:31\n\
    \   |\n35 |             if s[k] == 'a' || s[k] == 'e' || s[k] == 'i' || s[k] ==\
    \ 'o' || s[k] == 'u' {\n   |                               ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` can"
  stdout: ''
  timestamp: 1659805235
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut word = String::from(\"\");\n        let mut pos = 0;\n      \
    \  while pos < s.len() {\n            let c = s[pos];\n            if c != 'a'\
    \ && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n                word.push(c);\n\
    \                pos += 1;\n            } else {\n                break;\n   \
    \         }\n        }\n        if word.len() == n {\n            words.push(word);\n\
    \        }\n        s = &s[pos..];\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa3cm9055.rs:24:21\n\
    \   |\n24 |             let c = s[pos];\n   |                     ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa3cm9055.rs:32:26\n\
    \   |\n32 |         if word.len() == n {\n   |                          ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n32 |         if word.len()\
    \ == n.try_into().unwrap() {\n   |                          ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa3cm9055.rs:35:13\n   |\n35 |\
    \         s = &s[pos..];\n   |             ^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n35 |        \
    \ s = (&s[pos..]).to_string();\n   |             +         +++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut punctuation = vec![];\n    let mut\
    \ numbers = vec![];\n    let mut letters = vec![];\n    let mut spaces_count =\
    \ s.chars().filter(|c| c == ' ').count();\n    let mut punctuation_count = s.chars().filter(|c|\
    \ c == '.' || c == '!' || c == '?' || c == ';' || c == '-' || c == '_' || c ==\
    \ '/' || c == '\\\\' || c == '@' || c == '$' || c == '%' || c == '^' || c == '&'\
    \ || c == '*' || c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c\
    \ == '}' || c == '<' || c == '>' || c == '|' || c == '\"' || c == '\\'' || c ==\
    \ '?' || c == ':' || c == ';' || c == '-' || c == '_' || c == '/' || c == '\\\\\
    ' || c == '@' || c == '$' || c == '%' || c == '^' || c == '&' || c == '*' || c\
    \ == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == '<'\
    \ || c == '>' || c == '|' || c == '\"' || c == '\\'' || c == '?' || c == ':' ||\
    \ c == ';' || c == '-' || c == '_' || c == '/' || c == '\\\\' || c == '@' || c\
    \ == '$' || c == '%' || c == '^' || c == '&' || c == '*' || c == '(' || c == ')'\
    \ || c == '[' || c == ']' || c == '{' || c == '}' || c == '<' || c == '>' || c\
    \ == '|' || c == '\"' || c == '\\'' || c == '?' || c == ':' || c == ';' || c ==\
    \ '-' || c == '_' || c == '/' || c == '\\\\' || c == '@' || c == '$' || c == '%'\
    \ || c == '^' || c == '&' || c == '*' || c == '(' || c == ')' || c == '[' || c\
    \ == ']' || c == '{' || c == '}' || c == '<' || c == '>' || c == '|' || c == '\"\
    ' || c == '\\'' || c == '?' || c == ':' || c == ';' || c == '-' || c == '_' ||\
    \ c == '/' || c == '\\\\' || c == '@' || c == '$' || c == '%' || c == '^' || \n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmp87rc6myi.rs:27:1\n\
    \   |\n27 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp87rc6myi.rs:26:49\n   |\n17 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                           \
    \          - closing delimiter possibly meant for this\n...\n26 |     let mut\
    \ punctuation_count = s.chars().filter(|c| c == '.' || c == '!' || c == '?' ||\
    \ c == ';' || c == '-' || c == '_' || c == '/' || ...\n   |                  \
    \                               ^ unclosed delimiter\n27 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0277]: can't compare `&char` with `char`\n  -->\
    \ /tmp/tmp87rc6myi.rs:25:51\n   |\n25 |     let mut spaces_count = s.chars().filter(|c|\
    \ c == ' ').count();\n   |                                                   ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().any(|c| c.is_consonant() && c.is_lowercase() && c.is_whitespace())\
    \ {\n            count += 1;\n            if count == n {\n                words.push(s.to_string());\n\
    \                count = 0;\n            }\n        }\n        i += 1;\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpkzarq9z8.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant() && c.is_lowercase() && c.is_whitespace()) {\n   |         \
    \                       ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_helper(s,\
    \ n, 0)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmp8p6hmq8g.rs:18:5\n   |\n18 |     select_words_helper(s, n, 0)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659805232
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n !=\
    \ 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n            result.push(s);\n\
    \        }\n        n -= 1;\n        s = s.chars().filter(|c| c.is_consonant()).collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp1uew6nl2.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmp1uew6nl2.rs:26:36\n  \
    \ |\n26 |         s = s.chars().filter(|c| c.is_consonant()).collect();\n   |\
    \                                    ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_uppercase() && c != 'A' && c != 'E' && c != 'I'\n            && c != 'O'\
    \ && c != 'U' && c != 'a' && c != 'e' && c != 'i'\n            && c != 'o' &&\
    \ c != 'u') {\n            result.push(s.subslice(i, i + n));\n            i +=\
    \ n;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp0yz62knq.rs:26:27\n   |\n26 |             result.push(s.subslice(i,\
    \ i + n));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut non_spaces = vec![];\n    let mut non_letters\
    \ = vec![];\n    let mut non_spaces_count = vec![];\n    let mut non_letters_count\
    \ = vec![];\n    let mut non_spaces_count_max = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_spaces_count_min = vec![];\n    let mut non_letters_count_min\
    \ = vec![];\n    let mut non_spaces_count_max_index = vec![];\n    let mut non_letters_count_max_index\
    \ = vec![];\n    let mut non_spaces_count_min_index = vec![];\n    let mut non_letters_count_min_index\
    \ = vec![];\n    let mut non_spaces_count_max_index = vec![];\n    let mut non_letters_count_max_index\
    \ = vec![];\n    let mut non_spaces_count_min_index = vec![];\n    let mut non_letters_count_min_index\
    \ = vec![];\n    let mut non_spaces_count_max_index = vec![];\n    let mut non_letters_count_max_index\
    \ = vec![];\n    let mut non_spaces_count_min_index = vec![];\n    let mut non_letters_count_min_index\
    \ = vec![];\n    let mut non_spaces_count_max_index = vec![];\n    let mut non_letters_count_max_index\
    \ = vec![];\n    let mut non_spaces_count_min_index = vec![];\n    let mut non_letters_count_min_index\
    \ = vec![];\n    let mut non_spaces_count_max_index = vec![];\n    let mut non_letters_count_max_index\
    \ = vec![];\n    let mut non_spaces_count_min_index = vec![];\n    let mut non_letters_count_min_index\
    \ = vec![];\n    let mut non_spaces_count_max_index = vec![];\n    let mut non_letters_count_max_index\
    \ = vec![];\n    let mut non_spaces_count_min_index = vec![];\n    let mut non_letters_count_min_index\
    \ = vec![];\n    let mut non_spaces_count_max_index = vec![];\n    let mut non_letters_count_max_index\
    \ = vec![];\n    let mut non_spaces_count_min_index = vec![];\n    let mut non_letters_count_min_index\
    \ = vec![];\n    let mut non_spaces_count_max_index = vec![];\n    let mut non_letters_count_max_\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsjy6glo6.rs:59:35\n   |\n\
    59 |     let mut non_letters_count_max_\n   |                                \
    \   ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsjy6glo6.rs:17:41\n   |\n17 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == s[i] {\n            j += 1\n  \
    \      }\n        if j == i {\n            v.push(s.to_string());\n          \
    \  i += 1;\n        } else {\n            if j - i > n {\n                v.push(s.to_string());\n\
    \                i += j - i;\n            } else {\n                i += j - i;\n\
    \            }\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa5kbjre1.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == s[i] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpa5kbjre1.rs:22:38\n   |\n\
    22 |         while j < s.len() && s[j] == s[i] {\n   |                       \
    \               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa5kbjre1.rs:29:24\n   |\n29 |             if j - i > n\
    \ {\n   |                        ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n29 |             if j - i > n.try_into().unwrap() {\n   |       \
    \                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            break;\n        }\n        let mut k\
    \ = j;\n        while k < s.len() && s[k] != ' ' {\n            k += 1\n     \
    \   }\n        if k == j {\n            break;\n        }\n        let mut c =\
    \ s.chars().nth(j).unwrap();\n        if c == ' ' {\n            i += 1;\n   \
    \         continue;\n        }\n        let mut found = false;\n        for word\
    \ in words {\n            if word.contains(&c) {\n                found = true;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      continue;\n        }\n        words.push(s.chars().nth(i).unwrap());\n\
    \        i += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw7estj5y.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpw7estj5y.rs:29:30\n   |\n\
    29 |         while k < s.len() && s[k] != ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805235
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    let mut n = n;\n    while n != 0 {\n\
    \        if s.is_empty() {\n            break;\n        }\n        let mut i =\
    \ 0;\n        while i < s.len() {\n            let c = s.chars().nth(i).unwrap();\n\
    \            if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c\
    \ != 'y' {\n                i += 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if i == s.len() {\n            result.push(s);\n\
    \            n -= 1;\n        }\n        s = &s[..i];\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbk7nhi45.rs:38:13\n   |\n\
    38 |         s = &s[..i];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n38 |        \
    \ s = (&s[..i]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805235
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n != 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n\
    \            result.push(s);\n        }\n        n -= 1;\n        s = s.chars().filter(|c|\
    \ !c.is_consonant()).collect();\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpg_9k55m8.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmpg_9k55m8.rs:26:37\n  \
    \ |\n26 |         s = s.chars().filter(|c| !c.is_consonant()).collect();\n   |\
    \                                     ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805235
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut punctuation = vec![];\n    let mut\
    \ letters = vec![];\n    let mut numbers = vec![];\n    let mut symbols = vec![];\n\
    \    let mut punctuation_count = vec![];\n    let mut vowel_count = vec![];\n\
    \    let mut space_count = vec![];\n    let mut letter_count = vec![];\n    let\
    \ mut number_count = vec![];\n    let mut symbol_count = vec![];\n    let mut\
    \ punctuation_count_max = vec![];\n    let mut vowel_count_max = vec![];\n   \
    \ let mut space_count_max = vec![];\n    let mut letter_count_max = vec![];\n\
    \    let mut number_count_max = vec![];\n    let mut symbol_count_max = vec![];\n\
    \    let mut punctuation_count_min = vec![];\n    let mut vowel_count_min = vec![];\n\
    \    let mut space_count_min = vec![];\n    let mut letter_count_min = vec![];\n\
    \    let mut number_count_min = vec![];\n    let mut symbol_count_min = vec![];\n\
    \    let mut punctuation_count_avg = vec![];\n    let mut vowel_count_avg = vec![];\n\
    \    let mut space_count_avg = vec![];\n    let mut letter_count_avg = vec![];\n\
    \    let mut number_count_avg = vec![];\n    let mut symbol_count_avg = vec![];\n\
    \    let mut punctuation_count_min = vec![];\n    let mut vowel_count_min = vec![];\n\
    \    let mut space_count_min = vec![];\n    let mut letter_count_min = vec![];\n\
    \    let mut number_count_min = vec![];\n    let mut symbol_count_min = vec![];\n\
    \    let mut punctuation_count_max = vec![];\n    let mut vowel_count_max = vec![];\n\
    \    let mut space_count_max = vec![];\n    let mut letter_count_max = vec![];\n\
    \    let mut number_count_max = vec![];\n    let mut symbol_count_max = vec![];\n\
    \    let mut punctuation_count_min = vec![];\n    let mut vowel_count_min = vec![];\n\
    \    let mut space_count_min = vec![];\n    let mut letter_count_min = vec![];\n\
    \    let mut number_count_min = vec![];\n    let mut symbol_count_min = vec![];\n\
    \    let mut punctu\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpawe6uyj6.rs:68:19\n   |\n\
    68 |     let mut punctu\n   |                   ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpawe6uyj6.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s.chars().all(|c| c != ' ') {\n       \
    \     j = j + 1;\n        }\n        if j == i {\n            break;\n       \
    \ }\n        let mut word = String::from(&s[i .. j]);\n        let mut count =\
    \ 0;\n        for c in word.chars() {\n            if c != ' ' {\n           \
    \     count = count + 1;\n            }\n        }\n        if count == n {\n\
    \            words.push(word);\n        }\n        i = j;\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp_6cxiflw.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659805235
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut letters = vec![];\n    let mut spaces_count\
    \ = vec![];\n    let mut vowels_count = vec![];\n    let mut consonants_count\
    \ = vec![];\n    let mut letters_count = vec![];\n    let mut spaces_count_max\
    \ = vec![];\n    let mut vowels_count_max = vec![];\n    let mut consonants_count_max\
    \ = vec![];\n    let mut letters_count_max = vec![];\n    let mut spaces_count_min\
    \ = vec![];\n    let mut vowels_count_min = vec![];\n    let mut consonants_count_min\
    \ = vec![];\n    let mut letters_count_min = vec![];\n    let mut spaces_count_max\
    \ = vec![];\n    let mut vowels_count_max = vec![];\n    let mut consonants_count_max\
    \ = vec![];\n    let mut letters_count_max = vec![];\n    let mut spaces_count_min\
    \ = vec![];\n    let mut vowels_count_min = vec![];\n    let mut consonants_count_min\
    \ = vec![];\n    let mut letters_count_min = vec![];\n    let mut spaces_count_max\
    \ = vec![];\n    let mut vowels_count_max = vec![];\n    let mut consonants_count_max\
    \ = vec![];\n    let mut letters_count_max = vec![];\n    let mut spaces_count_min\
    \ = vec![];\n    let mut vowels_count_min = vec![];\n    let mut consonants_count_min\
    \ = vec![];\n    let mut letters_count_min = vec![];\n    let mut spaces_count_max\
    \ = vec![];\n    let mut vowels_count_max = vec![];\n    let mut consonants_count_max\
    \ = vec![];\n    let mut letters_count_max = vec![];\n    let mut spaces_count_min\
    \ = vec![];\n    let mut vowels_count_min = vec![];\n    let mut consonants_count_min\
    \ = vec![];\n    let mut letters_count_min = vec![];\n    let mut spaces_count_max\
    \ = vec![];\n    let mut vowels_count_max = vec![];\n    let mut consonants_count_max\
    \ = vec![];\n    let mut letters_count_max = vec![];\n    let mut spaces_count_min\
    \ = vec![];\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzb4523mb.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805234
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j + 1;\n\
    \        }\n        if j == s.len() {\n            break;\n        }\n       \
    \ let mut k = j;\n        while k < s.len() && s[k] != ' ' {\n            k =\
    \ k + 1;\n        }\n        if k == s.len() {\n            break;\n        }\n\
    \        let mut word = String::from(&s[i .. k]);\n        if word.chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').count() == n {\n \
    \           words.push(word);\n        }\n        i = j;\n    }\n    words\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7szlqrzz.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp7szlqrzz.rs:29:30\n   |\n\
    29 |         while k < s.len() && s[k] != ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp7szlqrzz.rs:36:38\n   |\n36 |         if\
    \ word.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c !=\
    \ 'u').count() == n {\n   |                                      ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp7szlqrzz.rs:36:50\n\
    \   |\n36 |         if word.chars().filter(|c| c != 'a' && c != 'e' && c != 'i'\
    \ && c != 'o' && c != 'u').count() == n {\n   |                              \
    \                    ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp7szlqrzz.rs:36:62\n   |\n36\
    \ |         if word.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() == n {\n   |                                      \
    \                        ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp7szlqrzz.rs:36:74\n   |\n36\
    \ |         if word.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() == n {\n   |                                      \
    \                                    ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `Par"
  stdout: ''
  timestamp: 1659805235
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            let\
    \ mut c = s.chars().nth(i).unwrap();\n            if c.is_uppercase() {\n    \
    \            i += 1;\n                continue;\n            }\n            if\
    \ c.is_lowercase() {\n                i += 1;\n                continue;\n   \
    \         }\n            if c.is_whitespace() {\n                i += 1;\n   \
    \             continue;\n            }\n            if c.is_digit() {\n      \
    \          i += 1;\n                continue;\n            }\n            if c.is_punctuation()\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if c.is_symbol() {\n                i += 1;\n                continue;\n\
    \            }\n            if i == j {\n                break;\n            }\n\
    \            if c.is_consonant() {\n                i += 1;\n                continue;\n\
    \            }\n            if c.is_vowel() {\n                i += 1;\n     \
    \           continue;\n            }\n            if c.is_vowel_digraph() {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if c.is_vowel_graph() {\n                i += 1;\n                continue;\n\
    \            }\n            if c.is_vowel_tilde() {\n                i += 1;\n\
    \                continue;\n            }\n            if c.is_vowel_mark() {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if c.is_vowel_others() {\n                i += 1;\n                continue;\n\
    \            }\n            if c.is_vowel_others_digraph() {\n               \
    \ i += 1;\n                continue;\n            }\n            if c.is_vowel_others_graph()\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if c.is_vowel_others_tilde() {\n                i += 1;\n            \
    \    continue;\n            }\n            if c.is_vowel_others_mark() {\n   \
    \             i += 1;\n                continue;\n            }\n            if\
    \ c.is_vowel_others_others() {\n                i += 1;\n                continue;\n\
    \            }\n            if c.is_vowel_others_others_digraph() {\n        \
    \        i += 1;\n                continue;\n            }\n            if c.is_vowel_others_others_graph()\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if c.is_vowel_others_others_tilde() {\n                i += 1;\n     \
    \           continue;\n            }\n            if c.is_vowel_others_others_mark()\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if c.is_vowel_others_others_others() {\n                i += 1;\n    \
    \            continue;\n            }\n            if c.is_vowel_others_others_others_digraph()\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if c.is_vowel_others_others_others_graph() {\n                i += 1;\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6nblp33w.rs:137:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while s.len() > 0 {\n    |                       - unclosed delimiter\n\
    ...\n23  |         while i < j {\n    |                     - unclosed delimiter\n\
    ...\n124 |             if c.is_vowel_others_others_others_graph() {\n    |   \
    \                                                     - this delimiter might not\
    \ be properly closed...\n125 |                 i += 1;\n126 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n137 | }\n    |   ^\n\n\
    error[E0061]: this function takes 1 argument but 0 arguments were supplied\n \
    \  --> /tmp/tmp6nblp33w.rs:37:18\n    |\n37  |             if c.is_digit() {\n\
    \    |                  ^^^^^^^^- supplied 0 arguments\n    |                \
    \  |\n    |                  expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `is_punctuation` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp6nblp33w.rs:41:18\n   |\n41 |   \
    \          if c.is_punctuation() {\n   |                  ^^^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_symbol` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp6nblp33w.rs:45:18\n   |\n45 |   \
    \          if c.is_symbol() {\n   |                  ^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_consonant` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp6nblp33w.rs:52:18\n   |\n52 |          \
    \   if c.is_consonant() {\n   |                  ^^^^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_vowel` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp6nblp33w.rs:56:18\n   |\n56 |          \
    \   if c.is_vowel() {\n   |                  ^^^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `is_vowel_digraph` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp6nblp33w.rs:60:18\n   |\n60 |             if"
  stdout: ''
  timestamp: 1659805235
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    while s.len() >\
    \ 0 {\n        let mut i = 0;\n        let mut j = s.len();\n        while i <\
    \ j {\n            if s.chars().nth(i).unwrap().is_consonant() {\n           \
    \     i += 1;\n            } else {\n                j -= 1;\n            }\n\
    \        }\n        if i == n {\n            result.push(s.clone());\n       \
    \ }\n        s = &s[..i];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmplfa28err.rs:24:42\n   |\n24 |             if s.chars().nth(i).unwrap().is_consonant()\
    \ {\n   |                                          ^^^^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplfa28err.rs:30:17\n\
    \   |\n30 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n30 |         if i == n.try_into().unwrap()\
    \ {\n   |                 ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplfa28err.rs:33:13\n   |\n33 |         s = &s[..i];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n33 |         s = (&s[..i]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805235
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words(s,\
    \ n, vec![])\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmpuyvhgif2.rs:18:5\n   |\n18 |     select_words(s, n, vec![])\n \
    \  |     ^^^^^^^^^^^^ -  -  ------ supplied 3 arguments\n   |     |\n   |    \
    \ expected 2 arguments\n   |\nnote: function defined here\n  --> /tmp/tmpuyvhgif2.rs:17:4\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^\
    \ ---------  --------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    for c in s.chars() {\n        if\
    \ c.is_consonant() {\n            count += 1;\n            if count == n {\n \
    \               words.push(c.to_string());\n                count = 0;\n     \
    \       }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpfgz85o4j.rs:21:14\n   |\n21 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659805233
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == s[i] {\n            j += 1\n  \
    \      }\n        if j - i == n {\n            v.push(s.to_string());\n      \
    \      i += j - i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdb8cf8in.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == s[i] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpdb8cf8in.rs:22:38\n   |\n\
    22 |         while j < s.len() && s[j] == s[i] {\n   |                       \
    \               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdb8cf8in.rs:25:21\n   |\n25 |         if j - i == n {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n25 |         if j - i == n.try_into().unwrap() {\n   |                \
    \     ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805235
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    let mut vowel_counter2 = 0;\n    let mut consonant_counter2 = 0;\n\
    \    let mut vowel_counter3 = 0;\n    let mut consonant_counter3 = 0;\n    let\
    \ mut vowel_counter4 = 0;\n    let mut consonant_counter4 = 0;\n    let mut vowel_counter5\
    \ = 0;\n    let mut consonant_counter5 = 0;\n    let mut vowel_counter6 = 0;\n\
    \    let mut consonant_counter6 = 0;\n    let mut vowel_counter7 = 0;\n    let\
    \ mut consonant_counter7 = 0;\n    let mut vowel_counter8 = 0;\n    let mut consonant_counter8\
    \ = 0;\n    let mut vowel_counter9 = 0;\n    let mut consonant_counter9 = 0;\n\
    \    let mut vowel_counter10 = 0;\n    let mut consonant_counter10 = 0;\n    let\
    \ mut vowel_counter11 = 0;\n    let mut consonant_counter11 = 0;\n    let mut\
    \ vowel_counter12 = 0;\n    let mut consonant_counter12 = 0;\n    let mut vowel_counter13\
    \ = 0;\n    let mut consonant_counter13 = 0;\n    let mut vowel_counter14 = 0;\n\
    \    let mut consonant_counter14 = 0;\n    let mut vowel_counter15 = 0;\n    let\
    \ mut consonant_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let mut\
    \ consonant_counter16 = 0;\n    let mut vowel_counter17 = 0;\n    let mut consonant_counter17\
    \ = 0;\n    let mut vowel_counter18 = 0;\n    let mut consonant_counter18 = 0;\n\
    \    let mut vowel_counter19 = 0;\n    let mut consonant_counter19 = 0;\n    let\
    \ mut vowel_counter20 = 0;\n    let mut consonant_counter20 = 0;\n    let mut\
    \ vowel_counter21 = 0;\n    let mut consonant_counter21 = 0;\n    let mut vowel_counter22\
    \ = 0;\n    let mut consonant_counter22 = 0;\n    let mut vowel_counter23 = 0;\n\
    \    let mut consonant_counter23 = 0;\n    let mut vowel_counter24 = 0;\n    let\
    \ mut conson\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd15xoqpe.rs:68:19\n   |\n\
    68 |     let mut conson\n   |                   ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd15xoqpe.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
