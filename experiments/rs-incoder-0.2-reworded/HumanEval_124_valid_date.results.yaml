name: HumanEval_124_valid_date
language: rs
results:
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    if !date.is_empty()\
    \ {\n        let mut date_str = date.to_string();\n        let mut date_str =\
    \ date_str.trim_left_matches(\"-\");\n        let mut date_str = date_str.trim_right_matches(\"\
    -\");\n        let mut date_str = date_str.trim_left_matches(\"/\");\n       \
    \ let mut date_str = date_str.trim_right_matches(\"/\");\n        let mut date_str\
    \ = date_str.trim_left_matches(\".\");\n        let mut date_str = date_str.trim_right_matches(\"\
    .\");\n        let mut date_str = date_str.trim_left_matches(\"-\");\n       \
    \ let mut date_str = date_str.trim_right_matches(\"-\");\n        let mut date_str\
    \ = date_str.trim_left_matches(\"/\");\n        let mut date_str = date_str.trim_right_matches(\"\
    /\");\n        let mut date_str = date_str.trim_left_matches(\".\");\n       \
    \ let mut date_str = date_str.trim_right_matches(\".\");\n        let mut date_str\
    \ = date_str.trim_left_matches(\"-\");\n        let mut date_str = date_str.trim_right_matches(\"\
    -\");\n        let mut date_str = date_str.trim_left_matches(\"/\");\n       \
    \ let mut date_str = date_str.trim_right_matches(\"/\");\n        let mut date_str\
    \ = date_str.trim_left_matches(\".\");\n        let mut date_str = date_str.trim_right_matches(\"\
    .\");\n        let mut date_str = date_str.trim_left_matches(\"-\");\n       \
    \ let mut date_str = date_str.trim_right_matches(\"-\");\n        let mut date_str\
    \ = date_str.trim_left_matches(\"/\");\n        let mut date_str = date_str.trim_right_matches(\"\
    /\");\n        let mut date_str = date_str.trim_left_matches(\".\");\n       \
    \ let mut date_str = date_str.trim_right_matches(\".\");\n        let mut date_str\
    \ = date_str.trim_left_matches(\"-\");\n        let mut date_str = date_str.trim_right_matches(\"\
    -\");\n        let mut date_str = date_str.trim_left_matches(\"/\");\n       \
    \ let mut date_str = date_str.trim_right_matches(\"/\");\n        let mut date_str\
    \ = date_str.trim_left_matches(\".\");\n        let mut date_str = date_str.trim_right_matches(\"\
    .\");\n        let mut date_str = date_str.trim_left_matches(\"-\");\n       \
    \ let mut date_str = date_str.trim_right_matches(\"-\");\n        let mut date_str\
    \ = date_str.trim_left_matches(\"/\");\n        let mut date_str = date_str.trim_right_matches(\"\
    /\");\n        let mut date_str = date_str.trim_left_matches(\".\");\n       \
    \ let mut date_str = date_\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfp798973.rs:77:3\n\
    \   |\n18 | fn valid_date(date: String) -> bool {\n   |                      \
    \               - unclosed delimiter\n19 |     if !date.is_empty() {\n   |   \
    \                      - this delimiter might not be properly closed...\n...\n\
    57 | }\n   | - ...as it matches this but it has different indentation\n...\n77\
    \ | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpfp798973.rs:56:33\n\
    \   |\n56 |         let mut date_str = date_\n   |                           \
    \      ^ help: add `;` here\n57 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `date_` in this scope\n  --> /tmp/tmpfp798973.rs:56:28\n \
    \  |\n56 |         let mut date_str = date_\n   |                            ^^^^^\
    \ help: a local variable with a similar name exists: `date`\n\nwarning: use of\
    \ deprecated associated function `core::str::<impl str>::trim_left_matches`: superseded\
    \ by `trim_start_matches`\n  --> /tmp/tmpfp798973.rs:21:37\n   |\n21 |       \
    \  let mut date_str = date_str.trim_left_matches(\"-\");\n   |               \
    \                      ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_start_matches`\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right_matches`: superseded by `trim_end_matches`\n  --> /tmp/tmpfp798973.rs:22:37\n\
    \   |\n22 |         let mut date_str = date_str.trim_right_matches(\"-\");\n \
    \  |                                     ^^^^^^^^^^^^^^^^^^ help: replace the\
    \ use of the deprecated associated function: `trim_end_matches`\n\nwarning: use\
    \ of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmpfp798973.rs:23:37\n   |\n\
    23 |         let mut date_str = date_str.trim_left_matches(\"/\");\n   |     \
    \                                ^^^^^^^^^^^^^^^^^ help: replace the use of the\
    \ deprecated associated function: `trim_start_matches`\n\nwarning: use of deprecated\
    \ associated function `core::str::<impl str>::tr"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    !date.is_empty()\
    \ && valid_day(date.as_str()) && valid_month(date.as_str())\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `valid_day` in this scope\n  --> /tmp/tmp598thqs_.rs:19:25\n\
    \   |\n19 |     !date.is_empty() && valid_day(date.as_str()) && valid_month(date.as_str())\n\
    \   |                         ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `valid_month` in this scope\n  --> /tmp/tmp598thqs_.rs:19:53\n\
    \   |\n19 |     !date.is_empty() && valid_day(date.as_str()) && valid_month(date.as_str())\n\
    \   |                                                     ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches(\"-\");\n    date_str.trim_right_matches(\"\
    -\");\n    let mut date_parts = date_str.split_whitespace();\n    let mut month\
    \ = date_parts[0];\n    let mut day = date_parts[1];\n    let mut year = date_parts[2];\n\
    \    let mut date_parts = date_str.split_whitespace();\n    let mut year = date_parts[0];\n\
    \    let mut month = date_parts[1];\n    let mut day = date_parts[2];\n    let\
    \ mut days: u32;\n    let mut months: u32;\n    let mut years: u32;\n    let mut\
    \ days_parts: Vec<String>;\n    let mut months_parts: Vec<String>;\n    let mut\
    \ years_parts: Vec<String>;\n    let mut days_parts: Vec<String>;\n    let mut\
    \ months_parts: Vec<String>;\n    let mut years_parts: Vec<String>;\n    let mut\
    \ days_parts: Vec<String>;\n    let mut months_parts: Vec<String>;\n    let mut\
    \ years_parts: Vec<String>;\n    let mut days_parts: Vec<String>;\n    let mut\
    \ months_parts: Vec<String>;\n    let mut years_parts: Vec<String>;\n    let mut\
    \ days_parts: Vec<String>;\n    let mut months_parts: Vec<String>;\n    let mut\
    \ years_parts: Vec<String>;\n    let mut days_parts: Vec<String>;\n    let mut\
    \ months_parts: Vec<String>;\n    let mut years_parts: Vec<String>;\n    let mut\
    \ days_parts: Vec<String>;\n    let mut months_parts: Vec<String>;\n    let mut\
    \ years_parts: Vec<String>;\n    let mut days_parts: Vec<String>;\n    let mut\
    \ months_parts: Vec<String>;\n    let mut years_parts: Vec<String>;\n    let mut\
    \ days_parts: Vec<String>;\n    let mut months_parts: Vec<String>;\n    let mut\
    \ years_parts: Vec<String>;\n    let mut days_parts: Vec<String>;\n    let mut\
    \ months_parts: Vec<String>;\n    let mut years_parts: Vec<String>;\n    let mut\
    \ days_parts: Vec<String>;\n    let mut months_parts: Vec<String>;\n    let \n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfk2wrubw.rs:66:1\n  \
    \ |\n66 | }\n   | ^ expected pattern\n\nwarning: use of deprecated associated\
    \ function `core::str::<impl str>::trim_left_matches`: superseded by `trim_start_matches`\n\
    \  --> /tmp/tmpfk2wrubw.rs:20:14\n   |\n20 |     date_str.trim_left_matches(\"\
    -\");\n   |              ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_start_matches`\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right_matches`: superseded by `trim_end_matches`\n  --> /tmp/tmpfk2wrubw.rs:21:14\n\
    \   |\n21 |     date_str.trim_right_matches(\"-\");\n   |              ^^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_end_matches`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpfk2wrubw.rs:23:21\n   |\n23 |     let mut month = date_parts[0];\n \
    \  |                     ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmpfk2wrubw.rs:24:19\n   |\n24 | \
    \    let mut day = date_parts[1];\n   |                   ^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpfk2wrubw.rs:25:20\n\
    \   |\n25 |     let mut year = date_parts[2];\n   |                    ^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpfk2wrubw.rs:27:20\n   |\n27 |     let mut year = date_parts[0];\n  \
    \ |                    ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmpfk2wrubw.rs:28:21\n   |\n28 | \
    \    let mut month = date_parts[1];\n   |                     ^^^^^^^^^^^^^\n\n\
    error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpfk2wrubw.rs:29:19\n\
    \   |\n29 |     let mut day = date_parts[2];\n   |                   ^^^^^^^^^^^^^\n\
    \nerror: aborting due to 7 previous errors; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    if !date.is_empty()\
    \ {\n        let mut date_str = date.to_string();\n        let mut days: u32 =\
    \ 0;\n        let mut months: u32 = 0;\n        let mut year: u32 = 0;\n     \
    \   let mut date_parts: Vec<&str> = date_str.split_whitespace();\n        if date_parts.len()\
    \ != 3 {\n            return false;\n        }\n        for part in date_parts\
    \ {\n            let mut date_part: String = part;\n            if date_part.len()\
    \ != 2 {\n                return false;\n            }\n            let mut date_part_str\
    \ = date_part.to_string();\n            if date_part_str.len() != 2 {\n      \
    \          return false;\n            }\n            let mut date_part_str: String\
    \ = date_part_str.to_string();\n            if date_part_str.len() != 2 {\n  \
    \              return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string();\n            if date_part_str.len() != 2\
    \ {\n                return false;\n            }\n            let mut date_part_str:\
    \ String = date_part_str.to_string\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpb47bvo6i.rs:114:3\n\
    \    |\n18  | fn valid_date(date: String) -> bool {\n    |                   \
    \                  - unclosed delimiter\n19  |     if !date.is_empty() {\n   \
    \ |                         - unclosed delimiter\n...\n28  |         for part\
    \ in date_parts {\n    |                                - this delimiter might\
    \ not be properly closed...\n...\n94  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n114 | }\n    |   ^\n\nerror: expected `;`, found\
    \ `}`\n  --> /tmp/tmpb47bvo6i.rs:93:68\n   |\n93 |             let mut date_part_str:\
    \ String = date_part_str.to_string\n   |                                     \
    \                               ^ help: add `;` here\n94 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb47bvo6i.rs:24:41\n \
    \  |\n24 |         let mut date_parts: Vec<&str> = date_str.split_whitespace();\n\
    \   |                             ---------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `SplitWhitespace`\n   |                         \
    \    |\n   |                             expected due to this\n   |\n   = note:\
    \ expected struct `Vec<&str>`\n              found struct `SplitWhitespace<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb47bvo6i.rs:29:41\n   |\n29 |\
    \             let mut date_part: String = part;\n   |                        \
    \        ------   ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                |        |\n   |                        \
    \        |        expected struct `String`, found `&str`\n   |               \
    \                 expected due to this\n\nerror[E0615]: attempted to take value\
    \ of method `to_string` on type `String`\n  --> /tmp/tmpb47bvo6i.rs:93:59\n  \
    \ |\n93 |             let mut date_part_str: String = date_part_str.to_string\n\
    \   |                                                           ^^^^^^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n93 |    \
    \         let mut date_part_str: String = date_part_str.to_string()\n   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches(\"-\");\n    date_str.trim_right_matches(\"\
    -\");\n    let mut date_str = date_str.to_string();\n    date_str.trim_left_matches(\"\
    /\");\n    date_str.trim_right_matches(\"/\");\n    let mut date_str = date_str.to_string();\n\
    \    date_str.trim_left_matches(\".\");\n    date_str.trim_right_matches(\".\"\
    );\n    let mut date_str = date_str.to_string();\n    date_str.trim_left_matches(\"\
    -\");\n    date_str.trim_right_matches(\"-\");\n    let mut date_str = date_str.to_string();\n\
    \    date_str.trim_left_matches(\".\");\n    date_str.trim_right_matches(\".\"\
    );\n    let mut date_str = date_str.to_string();\n    date_str.trim_left_matches(\"\
    .\");\n    date_str.trim_right_matches(\".\");\n    let mut date_str = date_str.to_string();\n\
    \    date_str.trim_left_matches(\"-\");\n    date_str.trim_right_matches(\"-\"\
    );\n    let mut date_str = date_str.to_string();\n    date_str.trim_left_matches(\"\
    .\");\n    date_str.trim_right_matches(\".\");\n    let mut date_str = date_str.to_string();\n\
    \    date_str.trim_left_matches(\".\");\n    date_str.trim_right_matches(\".\"\
    );\n    let mut date_str = date_str.to_string();\n    date_str.trim_left_matches(\"\
    -\");\n    date_str.trim_right_matches(\"-\");\n    let mut date_str = date_str.to_string();\n\
    \    date_str.trim_left_matches(\".\");\n    date_str.trim_right_matches(\".\"\
    );\n    let mut date_str = date_str.to_string();\n    date_str.trim_left_matches(\"\
    .\");\n    date_str.trim_right_matches(\".\");\n    let mut date_str = date_str.to_string();\n\
    \    date_str.trim_left_matches(\"-\");\n    date_str.trim_right_matches(\"-\"\
    );\n    let mut date_str = date_str.to_string();\n    date_str.trim_left_matches(\"\
    .\");\n    date_str.trim_right_matches(\".\");\n    let mut date_str = date_str.to_string();\n\
    \    date_str.trim_left_matches(\".\");\n    date_str.trim_right_matches(\".\"\
    );\n    let mut date_str = date_str.to_string();\n    date_str.trim_left_matches(\"\
    -\");\n    date_str.trim_right_matches(\"-\");\n    let mut date_str = date_str.to_string();\n\
    \    date_str.trim_left_matches(\".\");\n    date_str.trim_right_matches(\".\"\
    );\n    let mut \n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmps884ljs6.rs:71:1\n\
    \   |\n71 | }\n   | ^ expected identifier\n\nwarning: use of deprecated associated\
    \ function `core::str::<impl str>::trim_left_matches`: superseded by `trim_start_matches`\n\
    \  --> /tmp/tmps884ljs6.rs:20:14\n   |\n20 |     date_str.trim_left_matches(\"\
    -\");\n   |              ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_start_matches`\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right_matches`: superseded by `trim_end_matches`\n  --> /tmp/tmps884ljs6.rs:21:14\n\
    \   |\n21 |     date_str.trim_right_matches(\"-\");\n   |              ^^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_end_matches`\n\
    \nwarning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmps884ljs6.rs:23:14\n   |\n\
    23 |     date_str.trim_left_matches(\"/\");\n   |              ^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_start_matches`\n\
    \nwarning: use of deprecated associated function `core::str::<impl str>::trim_right_matches`:\
    \ superseded by `trim_end_matches`\n  --> /tmp/tmps884ljs6.rs:24:14\n   |\n24\
    \ |     date_str.trim_right_matches(\"/\");\n   |              ^^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_end_matches`\n\
    \nwarning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmps884ljs6.rs:26:14\n   |\n\
    26 |     date_str.trim_left_matches(\".\");\n   |              ^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_start_matches`\n\
    \nwarning: use of deprecated associated function `core::str::<impl str>::trim_right_matches`:\
    \ superseded by `trim_end_matches`\n  --> /tmp/tmps884ljs6.rs:27:14\n   |\n27\
    \ |     date_str.trim_right_matches(\".\");\n   |              ^^^^^^^^^^^^^^^^^^\
    \ help: replace the use of th"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    date.len()\
    \ > 0 && valid_day(date.len(), &date[..date.len() - 2]) && valid_month(date.len(),\
    \ &date[..date.len() - 2]) && valid_year(date.len(), &date[..date.len() - 2])\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `valid_day` in this scope\n  --> /tmp/tmpv3j7_5u4.rs:19:23\n\
    \   |\n19 |     date.len() > 0 && valid_day(date.len(), &date[..date.len() - 2])\
    \ && valid_month(date.len(), &date[..date.len() - 2]) && valid_year(da...\n  \
    \ |                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `valid_month` in this scope\n  --> /tmp/tmpv3j7_5u4.rs:19:73\n\
    \   |\n19 |     date.len() > 0 && valid_day(date.len(), &date[..date.len() - 2])\
    \ && valid_month(date.len(), &date[..date.len() - 2]) && valid_year(da...\n  \
    \ |                                                                         ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `valid_year` in\
    \ this scope\n  --> /tmp/tmpv3j7_5u4.rs:19:125\n   |\n19 | ...lid_month(date.len(),\
    \ &date[..date.len() - 2]) && valid_year(date.len(), &date[..date.len() - 2])\n\
    \   |                                                      ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches(\"-\");\n    date_str.trim_right_matches(\"\
    -\");\n    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut date_str = date_str.to_owned();\n    let mut date_str = date_str.to_owned();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmps4gj3p7s.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nwarning: use of deprecated associated\
    \ function `core::str::<impl str>::trim_left_matches`: superseded by `trim_start_matches`\n\
    \  --> /tmp/tmps4gj3p7s.rs:20:14\n   |\n20 |     date_str.trim_left_matches(\"\
    -\");\n   |              ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_start_matches`\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right_matches`: superseded by `trim_end_matches`\n  --> /tmp/tmps4gj3p7s.rs:21:14\n\
    \   |\n21 |     date_str.trim_right_matches(\"-\");\n   |              ^^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_end_matches`\n\
    \nerror: aborting due to previous error; 2 warnings emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    if !date.is_empty()\
    \ {\n        let mut date_str = date.to_string();\n        date_str.trim_left_matches(\"\
    -\");\n        date_str.trim_right_matches(\"-\");\n        let mut date_parts\
    \ = date_str.split_whitespace();\n        let mut days: u32 = 0;\n        let\
    \ mut months: u32 = 0;\n        let mut year: u32 = 0;\n        if date_parts[0].len()\
    \ > 0 {\n            days = date_parts[0].parse().unwrap();\n        }\n     \
    \   if date_parts[1].len() > 0 {\n            months = date_parts[1].parse().unwrap();\n\
    \        }\n        if date_parts[2].len() > 0 {\n            year = date_parts[2].parse().unwrap();\n\
    \        }\n        if days > 31 || months > 12 || year > 9999 {\n           \
    \ return false;\n        }\n        if months == 1 || months == 3 || months ==\
    \ 5 || months == 7 || months == 8 || months == 10 || months == 12 {\n        \
    \    if days == 31 || days == 30 || days == 29 {\n                return true;\n\
    \            }\n        }\n        if months == 4 || months == 6 || months ==\
    \ 9 || months == 11 {\n            if days == 31 && days == 30 || days == 29 {\n\
    \                return true;\n            }\n        }\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmp9zzbr1yu.rs:21:18\n   |\n\
    21 |         date_str.trim_left_matches(\"-\");\n   |                  ^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_start_matches`\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated\
    \ associated function `core::str::<impl str>::trim_right_matches`: superseded\
    \ by `trim_end_matches`\n  --> /tmp/tmp9zzbr1yu.rs:22:18\n   |\n22 |         date_str.trim_right_matches(\"\
    -\");\n   |                  ^^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_end_matches`\n\nerror[E0608]: cannot index into a\
    \ value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp9zzbr1yu.rs:27:12\n   |\n\
    27 |         if date_parts[0].len() > 0 {\n   |            ^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp9zzbr1yu.rs:28:20\n\
    \   |\n28 |             days = date_parts[0].parse().unwrap();\n   |         \
    \           ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp9zzbr1yu.rs:30:12\n   |\n30 |         if date_parts[1].len() >\
    \ 0 {\n   |            ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmp9zzbr1yu.rs:31:22\n   |\n31 | \
    \            months = date_parts[1].parse().unwrap();\n   |                  \
    \    ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp9zzbr1yu.rs:33:12\n   |\n33 |         if date_parts[2].len() >\
    \ 0 {\n   |            ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmp9zzbr1yu.rs:34:20\n   |\n34 | \
    \            year = date_parts[2].parse().unwrap();\n   |                    ^^^^^^^^^^^^^\n\
    \nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    !date.is_empty()\
    \ &&\n    (date.len() != 0 &&\n    (date.len() <= 10 &&\n    (date.len() >= 1\
    \ &&\n    (date.len() <= 31 &&\n    (date.len() >= 1 &&\n    (date.len() <= 30\
    \ &&\n    (date.len() >= 1 &&\n    (date.len() <= 29 &&\n    (date.len() >= 1\
    \ &&\n    (date.len() <= 12 &&\n    (date.len() >= 1 &&\n    (date.len() <= 31))))))))))\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpbrend_qw.rs:21:5\n\
    \   |\n18 | fn valid_date(date: String) -> bool {\n   |                      \
    \               - closing delimiter possibly meant for this\n...\n21 |     (date.len()\
    \ <= 10 &&\n   |     ^ unclosed delimiter\n...\n32 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches('-');\n    date_str.trim_right_matches('-');\n\
    \    let mut date_parts = date_str.split_whitespace();\n    let mut days_valid\
    \ = true;\n    let mut months_valid = true;\n    let mut years_valid = true;\n\
    \    let mut days_parts: Vec<String> = date_parts.split_whitespace();\n    let\
    \ mut months_parts: Vec<String> = date_parts.split_whitespace();\n    let mut\
    \ years_parts: Vec<String> = date_parts.split_whitespace();\n    let mut days_parts_len\
    \ = days_parts.len();\n    let mut months_parts_len = months_parts.len();\n  \
    \  let mut years_parts_len = years_parts.len();\n    let mut days_parts_len =\
    \ days_parts.len();\n    let mut months_parts_len = months_parts.len();\n    let\
    \ mut years_parts_len = years_parts.len();\n    let mut days_parts_len = days_parts.len();\n\
    \    let mut months_parts_len = months_parts.len();\n    let mut years_parts_len\
    \ = years_parts.len();\n    let mut days_parts_len = days_parts.len();\n    let\
    \ mut months_parts_len = months_parts.len();\n    let mut years_parts_len = years_parts.len();\n\
    \    let mut days_parts_len = days_parts.len();\n    let mut months_parts_len\
    \ = months_parts.len();\n    let mut years_parts_len = years_parts.len();\n  \
    \  let mut days_parts_len = days_parts.len();\n    let mut months_parts_len =\
    \ months_parts.len();\n    let mut years_parts_len = years_parts.len();\n    let\
    \ mut days_parts_len = days_parts.len();\n    let mut months_parts_len = months_parts.len();\n\
    \    let mut years_parts_len = years_parts.len();\n    let mut days_parts_len\
    \ = days_parts.len();\n    let mut months_parts_len = months_parts.len();\n  \
    \  let mut years_parts_len = years_parts.len();\n    let mut days_parts_len =\
    \ days_parts.len();\n    let mut months_parts_len = months_parts.len();\n    let\
    \ mut years_parts_len = years_parts.len();\n    let mut days_parts_len = days_parts.len();\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqsvuy4mu.rs:57:11\n   |\n\
    57 |     let mu\n   |           ^ help: add `;` here\n58 | }\n   | - unexpected\
    \ token\n\nwarning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmpqsvuy4mu.rs:20:14\n   |\n\
    20 |     date_str.trim_left_matches('-');\n   |              ^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_start_matches`\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated\
    \ associated function `core::str::<impl str>::trim_right_matches`: superseded\
    \ by `trim_end_matches`\n  --> /tmp/tmpqsvuy4mu.rs:21:14\n   |\n21 |     date_str.trim_right_matches('-');\n\
    \   |              ^^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_end_matches`\n\nerror[E0599]: no method named `split_whitespace`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpqsvuy4mu.rs:26:50\n\
    \   |\n26 |     let mut days_parts: Vec<String> = date_parts.split_whitespace();\n\
    \   |                                                  ^^^^^^^^^^^^^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `split_whitespace`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpqsvuy4mu.rs:27:52\n\
    \   |\n27 |     let mut months_parts: Vec<String> = date_parts.split_whitespace();\n\
    \   |                                                    ^^^^^^^^^^^^^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `split_whitespace`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpqsvuy4mu.rs:28:51\n\
    \   |\n28 |     let mut years_parts: Vec<String> = date_parts.split_whitespace();\n\
    \   |                                                   ^^^^^^^^^^^^^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqsvuy4mu.rs:18:32\n   |\n18 | fn valid_date(date: String) -> bool {\n\
    \   |    ----------                  ^^^^ expected `bool`, found `()`\n   |  \
    \  |\n   |    imp"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches('-');\n    date_str.trim_right_matches('-');\n\
    \    let mut date_parts = date_str.split_whitespace();\n    let month = date_parts[0];\n\
    \    let day = date_parts[1];\n    let year = date_parts[2];\n    let mut date_parts\
    \ = date_str.split_whitespace();\n    let month = date_parts[0];\n    let day\
    \ = date_parts[1];\n    let year = date_parts[2];\n    let mut date_parts = date_str.split_whitespace();\n\
    \    let month = date_parts[0];\n    let day = date_parts[1];\n    let year =\
    \ date_parts[2];\n    if month.len() < 1 || month.len() > 12 {\n        return\
    \ false;\n    }\n    if day.len() < 1 || day.len() > 31 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if month.len() < 1 || month.len() > 12 {\n        return false;\n\
    \    }\n    if \n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmp_t1_737s.rs:104:1\n\
    \    |\n104 | }\n    | ^ expected expression\n\nwarning: use of deprecated associated\
    \ function `core::str::<impl str>::trim_left_matches`: superseded by `trim_start_matches`\n\
    \  --> /tmp/tmp_t1_737s.rs:20:14\n   |\n20 |     date_str.trim_left_matches('-');\n\
    \   |              ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated associated\
    \ function: `trim_start_matches`\n   |\n   = note: `#[warn(deprecated)]` on by\
    \ default\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right_matches`: superseded by `trim_end_matches`\n  --> /tmp/tmp_t1_737s.rs:21:14\n\
    \   |\n21 |     date_str.trim_right_matches('-');\n   |              ^^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_end_matches`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp_t1_737s.rs:23:17\n   |\n23 |     let month = date_parts[0];\n   | \
    \                ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmp_t1_737s.rs:24:15\n   |\n24 |     let day\
    \ = date_parts[1];\n   |               ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp_t1_737s.rs:25:16\n\
    \   |\n25 |     let year = date_parts[2];\n   |                ^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp_t1_737s.rs:27:17\n   |\n27 |     let month = date_parts[0];\n   | \
    \                ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmp_t1_737s.rs:28:15\n   |\n28 |     let day\
    \ = date_parts[1];\n   |               ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp_t1_737s.rs:29:16\n\
    \   |\n29 |     let year = date_parts[2];\n   |                ^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp_t1_737s.rs:31:17\n   |\n31 |     let month = date_parts[0];\n   | \
    \                ^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date = date.to_string();\n    date.trim_end();\n    let mut date_split = date.split_at(3);\n\
    \    let mut month = date_split[0];\n    let mut day = date_split[1];\n    let\
    \ mut year = date_split[2];\n    let mut date_split2 = month.split_at(2);\n  \
    \  let mut month_str = date_split2[0];\n    let mut month_int = month_str.parse().unwrap();\n\
    \    let mut month_int2 = month_int.checked_mul(12);\n    let mut month_int3 =\
    \ month_int2.checked_add(1);\n    let mut month_int4 = month_int3.checked_add(1);\n\
    \    let mut month_int5 = month_int4.checked_add(1);\n    let mut month_int6 =\
    \ month_int5.checked_add(1);\n    let mut month_int7 = month_int6.checked_add(1);\n\
    \    let mut month_int8 = month_int7.checked_add(1);\n    let mut month_int9 =\
    \ month_int8.checked_add(1);\n    let mut month_int10 = month_int9.checked_add(1);\n\
    \    let mut month_int11 = month_int10.checked_add(1);\n    let mut month_int12\
    \ = month_int11.checked_add(1);\n    let mut month_int13 = month_int12.checked_add(1);\n\
    \    let mut month_int14 = month_int13.checked_add(1);\n    let mut month_int15\
    \ = month_int14.checked_add(1);\n    let mut month_int16 = month_int15.checked_add(1);\n\
    \    let mut month_int17 = month_int16.checked_add(1);\n    let mut month_int18\
    \ = month_int17.checked_add(1);\n    let mut month_int19 = month_int18.checked_add(1);\n\
    \    let mut month_int20 = month_int19.checked_add(1);\n    let mut month_int21\
    \ = month_int20.checked_add(1);\n    let mut month_int22 = month_int21.checked_add(1);\n\
    \    let mut month_int23 = month_int22.checked_add(1);\n    let mut month_int24\
    \ = month_int23.checked_add(1);\n    let mut month_int25 = month_int24.checked_add(1);\n\
    \    let mut month_int26 = month_int25.checked_add(1);\n    let mut month_int27\
    \ = month_int26.checked_add(1);\n    let mut month_int28 = month_int27.checked_add(1);\n\
    \    let mut month_int29 = month_int28.checked_add(1);\n    let mut month_int30\
    \ = month_int29.checked_add(1);\n    let mut month_int31 = \n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp0e43ejc7.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected expression\n\nerror[E0608]: cannot index into a\
    \ value of type `(&str, &str)`\n  --> /tmp/tmp0e43ejc7.rs:22:21\n   |\n22 |  \
    \   let mut month = date_split[0];\n   |                     ^^^^^^^^^^^^^ help:\
    \ to access tuple elements, use: `date_split.0`\n\nerror[E0608]: cannot index\
    \ into a value of type `(&str, &str)`\n  --> /tmp/tmp0e43ejc7.rs:23:19\n   |\n\
    23 |     let mut day = date_split[1];\n   |                   ^^^^^^^^^^^^^ help:\
    \ to access tuple elements, use: `date_split.1`\n\nerror[E0608]: cannot index\
    \ into a value of type `(&str, &str)`\n  --> /tmp/tmp0e43ejc7.rs:24:20\n   |\n\
    24 |     let mut year = date_split[2];\n   |                    ^^^^^^^^^^^^^\
    \ help: to access tuple elements, use: `date_split.2`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date = date.to_string();\n    date.trim_left_matches('-');\n    date.trim_right_matches('-');\n\
    \    date.trim_left_matches('/');\n    date.trim_right_matches('-');\n    date.trim_left_matches('\
    \ ');\n    date.trim_right_matches(' ');\n    let mut days: u32 = 0;\n    let\
    \ mut months: u32 = 0;\n    let mut year: u32 = 0;\n    let mut days_month: u32\
    \ = 0;\n    let mut days_year: u32 = 0;\n    let mut days_month_year: u32 = 0;\n\
    \    let mut days_year_month: u32 = 0;\n    let mut days_year_month_day: u32 =\
    \ 0;\n    let mut days_year_month_day_hour: u32 = 0;\n    let mut days_year_month_day_minute:\
    \ u32 = 0;\n    let mut days_year_month_day_second: u32 = 0;\n    let mut days_year_month_day_millisecond:\
    \ u32 = 0;\n    let mut days_year_month_day_microsecond: u32 = 0;\n    let mut\
    \ days_year_month_day_nanosecond: u32 = 0;\n    let mut days_year_month_day_day_of_week:\
    \ u32 = 0;\n    let mut days_year_month_day_day_of_year: u32 = 0;\n    let mut\
    \ days_year_month_day_day_of_week_day: u32 = 0;\n    let mut days_year_month_day_day_of_week_day_of_year:\
    \ u32 = 0;\n    let mut days_year_month_day_day_of_week_day_of_year_day: u32 =\
    \ 0;\n    let mut days_year_month_day_day_of_week_day_of_year_day_of_year: u32\
    \ = 0;\n    let mut days_year_month_day_day_of_week_day_of_year_day_of_year_day:\
    \ u32 = 0;\n    let mut days_year_month_day_day_of_week_day_of_year_day_of_year_day_of_year:\
    \ u32 = 0;\n    let mut days_year_month_day_day_of_week_day_of_year_day_of_year_day_of_year_day:\
    \ u32 = 0;\n    let mut days_year_month_day_day_of_week_day_of_year_day_of_year_day_of_year_day_of_year:\
    \ u32 = 0;\n    let mut days_year_month_day_day_of_week_day_of_year_day_of_year_day_of_year_day_of_year:\
    \ u32 = 0;\n    let mut days_year_month_day_day_of_week_day_of_year_day_of_year_day_of_year_day_of_year_day:\
    \ u32 = 0;\n    let mut days_year_month_day_day_of_week_day_of_year_day_of_year_day_of_year_day_of_year_day_of_year:\
    \ u32 = 0;\n    let \n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmptf12vroz.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nwarning: use of deprecated associated\
    \ function `core::str::<impl str>::trim_left_matches`: superseded by `trim_start_matches`\n\
    \  --> /tmp/tmptf12vroz.rs:20:10\n   |\n20 |     date.trim_left_matches('-');\n\
    \   |          ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated associated\
    \ function: `trim_start_matches`\n   |\n   = note: `#[warn(deprecated)]` on by\
    \ default\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right_matches`: superseded by `trim_end_matches`\n  --> /tmp/tmptf12vroz.rs:21:10\n\
    \   |\n21 |     date.trim_right_matches('-');\n   |          ^^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_end_matches`\n\
    \nwarning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmptf12vroz.rs:22:10\n   |\n\
    22 |     date.trim_left_matches('/');\n   |          ^^^^^^^^^^^^^^^^^ help: replace\
    \ the use of the deprecated associated function: `trim_start_matches`\n\nwarning:\
    \ use of deprecated associated function `core::str::<impl str>::trim_right_matches`:\
    \ superseded by `trim_end_matches`\n  --> /tmp/tmptf12vroz.rs:23:10\n   |\n23\
    \ |     date.trim_right_matches('-');\n   |          ^^^^^^^^^^^^^^^^^^ help:\
    \ replace the use of the deprecated associated function: `trim_end_matches`\n\n\
    warning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmptf12vroz.rs:24:10\n   |\n\
    24 |     date.trim_left_matches(' ');\n   |          ^^^^^^^^^^^^^^^^^ help: replace\
    \ the use of the deprecated associated function: `trim_start_matches`\n\nwarning:\
    \ use of deprecated associated function `core::str::<impl str>::trim_right_matches`:\
    \ superseded by `trim_end_matches`\n  --> /tmp/tmptf12vroz.rs:25:10\n   |\n25\
    \ |     date.trim_right_matches(' ');\n   |          ^^^^^^^^^^^^^^^^^^ help:\
    \ replace the use of the deprecated associated function: `trim_end_matches`\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches(\"-\");\n    date_str.trim_right_matches(\"\
    -\");\n    let mut date_parts = date_str.split_whitespace();\n    let mut date_parts\
    \ = date_parts.split_at(3);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n    let mut date_parts = date_parts.split_at(2);\n\
    \    let mut date_parts = date_parts.split_at(2);\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmp_r3dk_2u.rs:20:14\n   |\n\
    20 |     date_str.trim_left_matches(\"-\");\n   |              ^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_start_matches`\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated\
    \ associated function `core::str::<impl str>::trim_right_matches`: superseded\
    \ by `trim_end_matches`\n  --> /tmp/tmp_r3dk_2u.rs:21:14\n   |\n21 |     date_str.trim_right_matches(\"\
    -\");\n   |              ^^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_end_matches`\n\nerror[E0599]: no method named `split_at`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmp_r3dk_2u.rs:23:37\n\
    \   |\n23 |     let mut date_parts = date_parts.split_at(3);\n   |           \
    \                          ^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_r3dk_2u.rs:18:32\n   |\n18 |\
    \ fn valid_date(date: String) -> bool {\n   |    ----------                  ^^^^\
    \ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches(\"-\");\n    date_str.trim_right_matches(\"\
    -\");\n    let mut date_parts = date_str.split_whitespace();\n    let mut days_parts:\
    \ Vec<String> = date_parts.split_whitespace();\n    let mut months_parts: Vec<String>\
    \ = date_parts.split_whitespace();\n    let mut years_parts: Vec<String> = date_parts.split_whitespace();\n\
    \    days_parts.sort_unstable();\n    months_parts.sort_unstable();\n    years_parts.sort_unstable();\n\
    \    let mut days: usize = 0;\n    let mut months: usize = 0;\n    let mut years:\
    \ usize = 0;\n    for part in days_parts {\n        days += part.parse::<usize>().unwrap();\n\
    \    }\n    for part in months_parts {\n        months += part.parse::<usize>().unwrap();\n\
    \    }\n    for part in years_parts {\n        years += part.parse::<usize>().unwrap();\n\
    \    }\n    if days > 31 || months > 12 || years > 30 {\n        return false;\n\
    \    }\n    if days == 31 && (months == 1 || months == 3 || months == 5 || months\
    \ == 7 || months == 8 || months == 10 || months == 12 || months == 4 || months\
    \ == 6 || months == 9 || months == 11) {\n        return false;\n    }\n    if\
    \ days == 30 && (months == 4 || months == 6 || months == 9 || months == 11) {\n\
    \        return false;\n    }\n    if days == 29 && (months == 2) {\n        return\
    \ false;\n    }\n    if days == 31 && (months == 1 || months == 3 || months ==\
    \ 5 || months == 7 || months == 8 || months == 10 || months == 12 || months ==\
    \ 4 || months == 6 || months == 9 || months == 11) {\n        return false;\n\
    \    }\n    if days == 30 && (months == 4 || months == 6 || months == 9 || months\
    \ == 11) {\n        return false;\n    }\n    if days == 29 && (months == 2) {\n\
    \        return false;\n    }\n    if days == 31 && (months == 1 || months ==\
    \ 3 || months == 5 || months == 7 || months == 8 || months == 10 || months ==\
    \ 12 || months == 4 || months == 6 || months == 9 || months == 11) {\n       \
    \ return false;\n    }\n    if days == 30 && (months == 4 || months == 6 || months\
    \ == 9 || months == 11) {\n        return false;\n    }\n    if days == 29 &&\
    \ (months == 2) {\n        return false;\n    }\n    if day\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpl34e832r.rs:72:1\n   |\n\
    71 |     if day\n   |     -- this `if` expression has a condition, but no block\n\
    72 | }\n   | ^ expected `{`\n\nwarning: use of deprecated associated function\
    \ `core::str::<impl str>::trim_left_matches`: superseded by `trim_start_matches`\n\
    \  --> /tmp/tmpl34e832r.rs:20:14\n   |\n20 |     date_str.trim_left_matches(\"\
    -\");\n   |              ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_start_matches`\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right_matches`: superseded by `trim_end_matches`\n  --> /tmp/tmpl34e832r.rs:21:14\n\
    \   |\n21 |     date_str.trim_right_matches(\"-\");\n   |              ^^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_end_matches`\n\
    \nerror[E0599]: no method named `split_whitespace` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpl34e832r.rs:23:50\n   |\n23 |     let mut\
    \ days_parts: Vec<String> = date_parts.split_whitespace();\n   |             \
    \                                     ^^^^^^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `split_whitespace` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpl34e832r.rs:24:52\n   |\n24 |     let mut\
    \ months_parts: Vec<String> = date_parts.split_whitespace();\n   |           \
    \                                         ^^^^^^^^^^^^^^^^ method not found in\
    \ `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `split_whitespace` found\
    \ for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpl34e832r.rs:25:51\n\
    \   |\n25 |     let mut years_parts: Vec<String> = date_parts.split_whitespace();\n\
    \   |                                                   ^^^^^^^^^^^^^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to 4 previous errors;\
    \ 2 warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches('-');\n    date_str.trim_right_matches('-');\n\
    \    let mut date_parts = date_str.split_whitespace();\n    let mut days: u32\
    \ = 0;\n    let mut months: u32 = 0;\n    let mut year: u32 = 0;\n    let mut\
    \ date_parts_len = date_parts.len();\n    let mut date_parts_len2 = date_parts_len;\n\
    \    let mut date_parts_len3 = date_parts_len;\n    let mut date_parts_len4 =\
    \ date_parts_len;\n    let mut date_parts_len5 = date_parts_len;\n    let mut\
    \ date_parts_len6 = date_parts_len;\n    let mut date_parts_len7 = date_parts_len;\n\
    \    let mut date_parts_len8 = date_parts_len;\n    let mut date_parts_len9 =\
    \ date_parts_len;\n    let mut date_parts_len10 = date_parts_len;\n    let mut\
    \ date_parts_len11 = date_parts_len;\n    let mut date_parts_len12 = date_parts_len;\n\
    \    let mut date_parts_len13 = date_parts_len;\n    let mut date_parts_len14\
    \ = date_parts_len;\n    let mut date_parts_len15 = date_parts_len;\n    let mut\
    \ date_parts_len16 = date_parts_len;\n    let mut date_parts_len17 = date_parts_len;\n\
    \    let mut date_parts_len18 = date_parts_len;\n    let mut date_parts_len19\
    \ = date_parts_len;\n    let mut date_parts_len20 = date_parts_len;\n    let mut\
    \ date_parts_len21 = date_parts_len;\n    let mut date_parts_len22 = date_parts_len;\n\
    \    let mut date_parts_len23 = date_parts_len;\n    let mut date_parts_len24\
    \ = date_parts_len;\n    let mut date_parts_len25 = date_parts_len;\n    let mut\
    \ date_parts_len26 = date_parts_len;\n    let mut date_parts_len27 = date_parts_len;\n\
    \    let mut date_parts_len28 = date_parts_len;\n    let mut date_parts_len29\
    \ = date_parts_len;\n    let mut date_parts_len30 = date_parts_len;\n    let mut\
    \ date_parts_len31 = date_parts_len;\n    let mut date_parts_len32 = date_parts_len;\n\
    \    let mut date_parts_len33 = date_parts_len;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmpbgmey4hc.rs:20:14\n   |\n\
    20 |     date_str.trim_left_matches('-');\n   |              ^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_start_matches`\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated\
    \ associated function `core::str::<impl str>::trim_right_matches`: superseded\
    \ by `trim_end_matches`\n  --> /tmp/tmpbgmey4hc.rs:21:14\n   |\n21 |     date_str.trim_right_matches('-');\n\
    \   |              ^^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_end_matches`\n\nerror[E0599]: no method named `len`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpbgmey4hc.rs:26:41\n\
    \   |\n26 |     let mut date_parts_len = date_parts.len();\n   |             \
    \                            ^^^ method not found in `SplitWhitespace<'_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbgmey4hc.rs:18:32\n   |\n18 | fn\
    \ valid_date(date: String) -> bool {\n   |    ----------                  ^^^^\
    \ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches(\"-\");\n    date_str.trim_right_matches(\"\
    -\");\n    date_str.trim_left_matches(\"/\");\n    date_str.trim_right_matches(\"\
    /\");\n    date_str.trim_left_matches(\".\");\n    date_str.trim_right_matches(\"\
    .\");\n    let mut date_str2 = date_str.to_string();\n    date_str2.trim_left_matches(\"\
    -\");\n    date_str2.trim_right_matches(\"-\");\n    date_str2.trim_left_matches(\"\
    /\");\n    date_str2.trim_right_matches(\"/\");\n    date_str2.trim_left_matches(\"\
    .\");\n    date_str2.trim_right_matches(\".\");\n    let mut date_str3 = date_str2.to_string();\n\
    \    date_str3.trim_left_matches(\"-\");\n    date_str3.trim_right_matches(\"\
    -\");\n    date_str3.trim_left_matches(\"/\");\n    date_str3.trim_right_matches(\"\
    /\");\n    date_str3.trim_left_matches(\".\");\n    date_str3.trim_right_matches(\"\
    .\");\n    let mut date_str4 = date_str3.to_string();\n    date_str4.trim_left_matches(\"\
    -\");\n    date_str4.trim_right_matches(\"-\");\n    date_str4.trim_left_matches(\"\
    /\");\n    date_str4.trim_right_matches(\"/\");\n    date_str4.trim_left_matches(\"\
    .\");\n    date_str4.trim_right_matches(\".\");\n    let mut date_str5 = date_str4.to_string();\n\
    \    date_str5.trim_left_matches(\"-\");\n    date_str5.trim_right_matches(\"\
    -\");\n    date_str5.trim_left_matches(\"/\");\n    date_str5.trim_right_matches(\"\
    /\");\n    date_str5.trim_left_matches(\".\");\n    date_str5.trim_right_matches(\"\
    .\");\n    let mut date_str6 = date_str5.to_string();\n    date_str6.trim_left_matches(\"\
    -\");\n    date_str6.trim_right_matches(\"-\");\n    date_str6.trim_left_matches(\"\
    /\");\n    date_str6.trim_right_matches(\"/\");\n    date_str6.trim_left_matches(\"\
    .\");\n    date_str6.trim_right_matches(\".\");\n    let mut date_str7 = date_str6.to_string();\n\
    \    date_str7.trim_left_matches(\"-\");\n    date_str7.trim_right_matches(\"\
    -\");\n    date_str7.trim_left_matches(\"/\");\n    date_str7.trim_right_matches(\"\
    /\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp920q_p40.rs:85:47\n\
    \   |\n85 |       assert_eq!(candidate(String::from(\"04-2003\")), false);\n \
    \  |  _______________________________________________^\n86 | | }\n   | |__^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    !date.is_empty()\
    \ &&\n    date.len() == 10 &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !date.contains(\"\
    /\") &&\n    !date.contains(\".\") &&\n    !date.contains(\"-\") &&\n    !\n}\n\
    \nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp168sli1v.rs:77:1\n\
    \   |\n77 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches('-');\n    date_str.trim_right_matches('-');\n\
    \    let mut date_parts = date_str.split_whitespace();\n    let mut days: u32\
    \ = 0;\n    let mut months: u32 = 0;\n    let mut years: u32 = 0;\n    let mut\
    \ date_parts_len = date_parts.len();\n    let mut date_parts_len_max = date_parts_len;\n\
    \    let mut date_parts_len_min = date_parts_len;\n    let mut date_parts_len_min_max\
    \ = date_parts_len;\n    let mut date_parts_len_min_max_max = date_parts_len;\n\
    \    let mut date_parts_len_min_max_max_max = date_parts_len;\n    let mut date_parts_len_min_max_max_max_max\
    \ = date_parts_len;\n    let mut date_parts_len_min_max_max_max_max_max = date_parts_len;\n\
    \    let mut date_parts_len_min_max_max_max_max_max_max = date_parts_len;\n  \
    \  let mut date_parts_len_min_max_max_max_max_max_max_max = date_parts_len;\n\
    \    let mut date_parts_len_min_max_max_max_max_max_max_max_max = date_parts_len;\n\
    \    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max = date_parts_len;\n\
    \    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max = date_parts_len;\n\
    \    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max = date_parts_len;\n\
    \    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max_max =\
    \ date_parts_len;\n    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = date_parts_len;\n    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = date_parts_len;\n    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = date_parts_len;\n    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = date_parts_len;\n    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = date_parts_len;\n    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = date_parts_len;\n    let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max_\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0wqkgo25.rs:47:72\n   |\n\
    47 |     let mut date_parts_len_min_max_max_max_max_max_max_max_max_max_max_\n\
    \   |                                                                        ^\
    \ help: add `;` here\n48 | }\n   | - unexpected token\n\nwarning: use of deprecated\
    \ associated function `core::str::<impl str>::trim_left_matches`: superseded by\
    \ `trim_start_matches`\n  --> /tmp/tmp0wqkgo25.rs:20:14\n   |\n20 |     date_str.trim_left_matches('-');\n\
    \   |              ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated associated\
    \ function: `trim_start_matches`\n   |\n   = note: `#[warn(deprecated)]` on by\
    \ default\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right_matches`: superseded by `trim_end_matches`\n  --> /tmp/tmp0wqkgo25.rs:21:14\n\
    \   |\n21 |     date_str.trim_right_matches('-');\n   |              ^^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_end_matches`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmp0wqkgo25.rs:26:41\n   |\n26 |     let mut date_parts_len\
    \ = date_parts.len();\n   |                                         ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0wqkgo25.rs:18:32\n   |\n18 | fn valid_date(date: String) -> bool {\n\
    \   |    ----------                  ^^^^ expected `bool`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have to write a function which validates a given date string and\n\
    /// returns true if the date is valid otherwise false.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    /// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"\
    15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n///\
    \ false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"\
    06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut\
    \ date_str = date.to_string();\n    date_str.trim_left_matches(\"-\");\n    date_str.trim_right_matches(\"\
    -\");\n    let mut date_parts = date_str.split_whitespace();\n    let mut month\
    \ = date_parts[0].parse().unwrap();\n    let mut day = date_parts[1].parse().unwrap();\n\
    \    let mut year = date_parts[2].parse().unwrap();\n    if month < 1 || month\
    \ > 12 {\n        return false;\n    }\n    if day < 1 || day > 31 {\n       \
    \ return false;\n    }\n    if month == 2 && day > 29 {\n        return false;\n\
    \    }\n    if month == 4 && day > 30 {\n        return false;\n    }\n    if\
    \ month == 6 && day > 31 {\n        return false;\n    }\n    if month == 9 &&\
    \ day > 31 {\n        return false;\n    }\n    if month == 11 && day > 30 {\n\
    \        return false;\n    }\n    if month == 1 && day > 31 {\n        return\
    \ false;\n    }\n    if month == 3 && day > 31 {\n        return false;\n    }\n\
    \    if month == 5 && day > 31 {\n        return false;\n    }\n    if month ==\
    \ 7 && day > 31 {\n        return false;\n    }\n    if month == 8 && day > 31\
    \ {\n        return false;\n    }\n    if month == 10 && day > 31 {\n        return\
    \ false;\n    }\n    if month == 12 && day > 31 {\n        return false;\n   \
    \ }\n    if month == 1 && day > 30 {\n        return false;\n    }\n    if month\
    \ == 3 && day > 30 {\n        return false;\n    }\n    if month == 5 && day >\
    \ 30 {\n        return false;\n    }\n    if month == 7 && day > 30 {\n      \
    \  return false;\n    }\n    if month == 8 && day > 30 {\n        return false;\n\
    \    }\n    if month == 10 && day > 30 {\n        return false;\n    }\n    if\
    \ month == 12 && day > 30 {\n        return false;\n    }\n    if month == 1 &&\
    \ day > 29 {\n        return false;\n    }\n    if month == 3 && day > 29 {\n\
    \        return false;\n    }\n    if month == 5 && day > 29 {\n        return\
    \ false;\n    }\n    if month == 7 && day > 29 {\n        return false;\n    }\n\
    \    if month == 8 && day > 29 {\n        return false;\n    }\n    if month ==\
    \ 10 && day > 29 {\n        return false;\n    }\n    if month == 12 && day >\
    \ 29 {\n        return false;\n    }\n    if month == 1 && day > 28 {\n      \
    \  return false;\n    }\n    if month == 3 && day > 28 {\n        return false;\n\
    \    }\n    if month == 5 && day > 28 {\n        return false;\n    }\n    if\
    \ month == 7 && day > 28 {\n        return false;\n    }\n    if month == 8 &&\
    \ day > 28 {\n        return false;\n    }\n    if month == 10 && day > 28\n}\n\
    \nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpldjts3qb.rs:126:1\n    |\n\
    125 |     if month == 10 && day > 28\n    |     -- this `if` expression has a\
    \ condition, but no block\n126 | }\n    | ^ expected `{`\n\nwarning: use of deprecated\
    \ associated function `core::str::<impl str>::trim_left_matches`: superseded by\
    \ `trim_start_matches`\n  --> /tmp/tmpldjts3qb.rs:20:14\n   |\n20 |     date_str.trim_left_matches(\"\
    -\");\n   |              ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated\
    \ associated function: `trim_start_matches`\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right_matches`: superseded by `trim_end_matches`\n  --> /tmp/tmpldjts3qb.rs:21:14\n\
    \   |\n21 |     date_str.trim_right_matches(\"-\");\n   |              ^^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_end_matches`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpldjts3qb.rs:23:21\n   |\n23 |     let mut month = date_parts[0].parse().unwrap();\n\
    \   |                     ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmpldjts3qb.rs:24:19\n   |\n24 | \
    \    let mut day = date_parts[1].parse().unwrap();\n   |                   ^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpldjts3qb.rs:25:20\n   |\n25 |     let mut year = date_parts[2].parse().unwrap();\n\
    \   |                    ^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors;\
    \ 2 warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  exit_code: 1
  status: SyntaxError
