language: rs
name: HumanEval_111_histogram
results:
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp9ybu0r5a.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letter_count = 1;\n \
    \   let mut letter = String::from(\"\");\n    while letters_count > 0 {\n    \
    \    histogram.insert(letter, letter_count);\n        letters_count -= 1;\n  \
    \      letter = letters[letters_count];\n        letter_count += 1;\n    }\n \
    \   histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpawb5vlv2.rs:26:18\n   |\n\
    22 |     let mut letter = String::from(\"\");\n   |                      ----------------\
    \ expected due to this value\n...\n26 |         letter = letters[letters_count];\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                  |\n   |                  expected struct\
    \ `String`, found `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_max = 0;\n    let mut letters_count_count_min = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_min = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixk5hfo_.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      histogram.entry(c.to_string()).or_insert(0) += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpuhffy72a.rs:20:9\n   |\n20 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpuhffy72a.rs:20:53\n\
    \   |\n20 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    while letters_count_index < letters_count {\n        let letter = &letters[letters_count_index];\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n        letters_count_index += 1;\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw92i1lhz.rs:28:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    let mut letter = String::from(\"\"\
    );\n    let mut count = 1;\n    let mut i = 0;\n    while i < letters.len() {\n\
    \        if let Some(letter) = letters.next() {\n            histogram.insert(letter,\
    \ count);\n            counts.entry(letter).and_modify(|c| *c += 1);\n       \
    \     i += 1;\n        } else {\n            histogram.insert(letter, count);\n\
    \            counts.entry(letter).and_modify(|c| *c += 1);\n            i += 1;\n\
    \            letter = String::from(\"\");\n            count = 1;\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpd6bdcxra.rs:25:39\n   |\n25 |         if let Some(letter)\
    \ = letters.next() {\n   |                                       ^^^^ method not\
    \ found in `Vec<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut counts = letters.iter().cloned().map(|c|\
    \ histogram.entry(c).or_insert(0));\n    loop {\n        let mut max_count = counts.iter().max().unwrap();\n\
    \        let mut max_letter = String::new();\n        for (key, value) in histogram\
    \ {\n            if value == max_count {\n                max_letter = key;\n\
    \            }\n        }\n        if max_count == 0 {\n            break;\n \
    \       }\n        for (key, value) in histogram {\n            if value == max_count\
    \ {\n                counts.remove(&key);\n            }\n        }\n        histogram.insert(max_letter,\
    \ 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpkh1r5270.rs:22:36\n   |\n22 |         let mut max_count\
    \ = counts.iter().max().unwrap();\n   |                                    ^^^^\
    \ private field, not a method\n\nerror[E0599]: no method named `remove` found\
    \ for struct `Map` in the current scope\n  --> /tmp/tmpkh1r5270.rs:34:24\n   |\n\
    34 |                 counts.remove(&key);\n   |                        ^^^^^^\
    \ method not found in `Map<Cloned<std::slice::Iter<'_, String>>, [closure@/tmp/tmpkh1r5270.rs:20:50:\
    \ 20:85]>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_max = 0;\n    let mut letters_count_count_min = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_max = 0;\n    let mut\
    \ letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_max = 0;\n    let mut\
    \ letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzu6gdmq7.rs:58:27\n   |\n\
    58 |     let mut letters_count_\n   |                           ^ help: add `;`\
    \ here\n59 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzu6gdmq7.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut counts = HashMap::new();\n\
    \    for letter in test.chars().filter_map(|c| c.is_alphabetic()) {\n        letters.entry(letter).or_insert(0)\
    \ += 1;\n        counts.entry(letter).or_insert(0) += 1;\n    }\n    letters\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdmpgl_kn.rs:20:47\n   |\n\
    20 |     for letter in test.chars().filter_map(|c| c.is_alphabetic()) {\n   |\
    \                                               ^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n       \
    \       found type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n\
    20 |     for letter in test.chars().filter_map(|c| Some(c.is_alphabetic())) {\n\
    \   |                                               +++++                 +\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ {integer}`\n  --> /tmp/tmpdmpgl_kn.rs:21:9\n   |\n21 |         letters.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `letters.entry(letter).or_insert(0)`\n\
    \   |\n21 |         *letters.entry(letter).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdmpgl_kn.rs:21:44\n\
    \   |\n21 |         letters.entry(letter).or_insert(0) += 1;\n   |         ----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmpdmpgl_kn.rs:22:9\n   |\n22 |         counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ---------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `counts.entry(letter).or_insert(0)`\n\
    \   |\n22 |         *counts.entry(letter).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdmpgl_kn.rs:22:43\n\
    \   |\n22 |         counts.entry(letter).or_insert(0) += 1;\n   |         ---------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have deta"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut count = 1;\n    for word in\
    \ words {\n        let mut letter = String::new();\n        for letter in word.chars()\
    \ {\n            histogram.entry(letter).or_insert(count).cloned() as isize\n\
    \        }\n        letters = letters + letter;\n        count += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&mut {integer}` is not an iterator\n  --> /tmp/tmp8s3sjvpz.rs:25:54\n\
    \   |\n25 |             histogram.entry(letter).or_insert(count).cloned() as isize\n\
    \   |                                                      ^^^^^^ `&mut {integer}`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `{integer}: Iterator`\n           which is required by `&mut {integer}:\
    \ Iterator`\n           `&mut {integer}: Iterator`\n           which is required\
    \ by `&mut &mut {integer}: Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8s3sjvpz.rs:27:29\n   |\n27 |         letters = letters + letter;\n\
    \   |                             ^^^^^^\n   |                             |\n\
    \   |                             expected `&str`, found struct `String`\n   |\
    \                             help: consider borrowing here: `&letter`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8s3sjvpz.rs:30:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n30 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letter_count = 1;\n    let mut letter = String::from(\"\");\n   \
    \ while let Some(letter) = letters_iter.next() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(letter_count).1 += 1;\n  \
    \      } else {\n            histogram.insert(letter, letter_count);\n       \
    \ }\n        letter_count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `1` on type `&mut {integer}`\n  --> /tmp/tmptexqpql1.rs:25:62\n\
    \   |\n25 |             histogram.entry(&letter).or_insert(letter_count).1 +=\
    \ 1;\n   |                                                              ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptexqpql1.rs:27:30\n   |\n27 |  \
    \           histogram.insert(letter, letter_count);\n   |                    \
    \          ^^^^^^ expected `&String`, found struct `String`\n   |\n   = note:\
    \ expected reference `&&String`\n              found reference `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptexqpql1.rs:31:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n31 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&&String`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&&String,\
    \ {integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_count_iter = 0;\n    let mut letters_count_iter2 = 0;\n \
    \   let mut letters_count_iter3 = 0;\n    let mut letters_count_iter4 = 0;\n \
    \   let mut letters_count_iter5 = 0;\n    let mut letters_count_iter6 = 0;\n \
    \   let mut letters_count_iter7 = 0;\n    let mut letters_count_iter8 = 0;\n \
    \   let mut letters_count_iter9 = 0;\n    let mut letters_count_iter10 = 0;\n\
    \    let mut letters_count_iter11 = 0;\n    let mut letters_count_iter12 = 0;\n\
    \    let mut letters_count_iter13 = 0;\n    let mut letters_count_iter14 = 0;\n\
    \    let mut letters_count_iter15 = 0;\n    let mut letters_count_iter16 = 0;\n\
    \    let mut letters_count_iter17 = 0;\n    let mut letters_count_iter18 = 0;\n\
    \    let mut letters_count_iter19 = 0;\n    let mut letters_count_iter20 = 0;\n\
    \    let mut letters_count_iter21 = 0;\n    let mut letters_count_iter22 = 0;\n\
    \    let mut letters_count_iter23 = 0;\n    let mut letters_count_iter24 = 0;\n\
    \    let mut letters_count_iter25 = 0;\n    let mut letters_count_iter26 = 0;\n\
    \    let mut letters_count_iter27 = 0;\n    let mut letters_count_iter28 = 0;\n\
    \    let mut letters_count_iter29 = 0;\n    let mut letters_count_iter30 = 0;\n\
    \    let mut letters_count_iter31 = 0;\n    let mut letters_count_iter32 = 0;\n\
    \    let mut letters_count_iter33 = 0;\n    let mut letters_count_iter34 = 0;\n\
    \    let mut letters_count_iter35 = 0;\n    let mut letters_count_iter36 = 0;\n\
    \    let mut letters_count_iter37 = 0;\n    let mut letters_count_iter38 = 0;\n\
    \    let mut letters_count_iter39 = 0;\n    let mut letters_count_iter40 = 0;\n\
    \    let mut letters_count_iter41 = 0;\n    let mut letters_count_iter42 = 0;\n\
    \    let mut letters_count_iter43 = 0;\n    let mut letters_count_iter44 = 0;\n\
    \    let mut letters_count_iter45 = 0;\n    let mut letters_count_iter46 = 0;\n\
    \    let mut letters_count_iter47\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcd4n_0fq.rs:68:33\n   |\n\
    68 |     let mut letters_count_iter47\n   |                                 ^\
    \ help: add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0599]: no method\
    \ named `count` found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpcd4n_0fq.rs:21:37\n\
    \   |\n21 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcd4n_0fq.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n\n    while let Some(letter) = letters.pop()\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n        letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpuaq4109n.rs:23:9\n   |\n23 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpuaq4109n.rs:23:46\n\
    \   |\n23 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmpuaq4109n.rs:24:9\n   |\n24 |         letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpuaq4109n.rs:24:50\n\
    \   |\n24 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuaq4109n.rs:27:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n27 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    let mut letter = String::from(\"\");\n    while let\
    \ Some(letter) = letters.next() {\n        histogram.entry(letter).or_insert(count).cloned().unwrap();\n\
    \        count += 1;\n        if count == histogram.len() {\n            histogram.insert(letter,\
    \ count);\n            count = 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp73xm_401.rs:22:38\n   |\n22 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0599]: `&mut {integer}` is not an iterator\n\
    \  --> /tmp/tmp73xm_401.rs:23:50\n   |\n23 |         histogram.entry(letter).or_insert(count).cloned().unwrap();\n\
    \   |                                                  ^^^^^^ `&mut {integer}`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `{integer}: Iterator`\n           which is required by `&mut {integer}:\
    \ Iterator`\n           `&mut {integer}: Iterator`\n           which is required\
    \ by `&mut &mut {integer}: Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp73xm_401.rs:30:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n30 |     histogram\n \
    \  |     ^^^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<_, usize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter_iter = letters.iter();\n\
    \    let mut letter_count = letters.len();\n    while let Some(letter) = letter_iter.next()\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n        letter_count\
    \ -= 1;\n        if letter_count == 0 {\n            letter_iter = letters_iter.next();\n\
    \            letter_count = letters.len();\n        }\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprkrz14b1.rs:24:9\n   |\n24 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprkrz14b1.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprkrz14b1.rs:27:27\n   |\n21 |     let mut letter_iter\
    \ = letters.iter();\n   |                           -------------- expected due\
    \ to this value\n...\n27 |             letter_iter = letters_iter.next();\n  \
    \ |                           ^^^^^^^^^^^^^^^^^^^ expected struct `std::slice::Iter`,\
    \ found enum `Option`\n   |\n   = note: expected struct `std::slice::Iter<'_,\
    \ char>`\n                found enum `Option<&char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprkrz14b1.rs:31:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n31 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0067, E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0067`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string());\n\
    \        histogram.insert(letters.collect::<Vec<_>>().into_iter().max().unwrap().cloned(),\
    \ 0);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp31b3vtex.rs:22:81\n\
    \    |\n22  |           histogram.insert(letters.collect::<Vec<_>>().into_iter().max().unwrap().cloned(),\
    \ 0);\n    |                                                                 \
    \                  ^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_letter = String::new();\n    let mut letters_count_max_letter_count\
    \ = 0;\n\n    for letter in letters {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.get_mut(&letter).unwrap() += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n\n        if histogram.get(&letter).unwrap()\
    \ > letters_count_max {\n            letters_count_max = histogram.get(&letter).unwrap();\n\
    \            letters_count_max_letter = letter;\n            letters_count_max_letter_count\
    \ = histogram.get(&letter).unwrap();\n        }\n    }\n\n    histogram.insert(letters_count_max_letter,\
    \ letters_count_max_letter_count);\n\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut _`\n  --> /tmp/tmprtnjkomt.rs:27:13\n   |\n27 |             histogram.get_mut(&letter).unwrap()\
    \ += 1;\n   |             -----------------------------------^^^^^\n   |     \
    \        |\n   |             cannot use `+=` on type `&mut _`\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmprtnjkomt.rs:27:49\n   |\n\
    27 |             histogram.get_mut(&letter).unwrap() += 1;\n   |             -----------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprtnjkomt.rs:32:46\n   |\n32 |  \
    \       if histogram.get(&letter).unwrap() > letters_count_max {\n   |       \
    \                                       ^^^^^^^^^^^^^^^^^\n   |              \
    \                                |\n   |                                     \
    \         expected reference, found integer\n   |                            \
    \                  help: consider borrowing here: `&letters_count_max`\n   |\n\
    \   = note: expected reference `&_`\n                   found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprtnjkomt.rs:33:33\n   |\n21 |\
    \     let mut letters_count_max = 0;\n   |                                 - expected\
    \ due to this value\n...\n33 |             letters_count_max = histogram.get(&letter).unwrap();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&{integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n33 |             letters_count_max = *histogram.get(&letter).unwrap();\n\
    \   |                                 +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprtnjkomt.rs:34:40\n   |\n22 |     let mut letters_count_max_letter =\
    \ String::new();\n   |                                        ------------- expected\
    \ due to this value\n...\n34 |             letters_count_max_letter = letter;\n\
    \   |                                        ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                        |\n   |\
    \     "
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphd7prwwh.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<char>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = vec![];\n    while let Some(letter) = letters.pop() {\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).and_modify(|count|\
    \ {\n                count += 1;\n            });\n        } else {\n        \
    \    histogram.insert(letter, 1);\n        }\n    }\n    histogram.into_iter().map(|(_,\
    \ count)| {\n        (String::from(&letters[0..count..count..]), count)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `]`, `{`, or an operator, found\
    \ `..`\n  --> /tmp/tmplut5tjzw.rs:31:40\n   |\n31 |         (String::from(&letters[0..count..count..]),\
    \ count)\n   |                                        ^^ expected one of 7 possible\
    \ tokens\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to\
    \ type `&mut _`\n  --> /tmp/tmplut5tjzw.rs:24:17\n   |\n24 |                 count\
    \ += 1;\n   |                 -----^^^^^\n   |                 |\n   |       \
    \          cannot use `+=` on type `&mut _`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplut5tjzw.rs:27:30\n   |\n27 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&char`, found `char`\n \
    \  |                              help: consider borrowing here: `&letter`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpiorqg518.rs:21:13\n   |\n21 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n21 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpiorqg518.rs:21:51\n\
    \   |\n21 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiorqg518.rs:23:30\n   |\n23 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&String`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpiorqg518.rs:26:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n26 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, {integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut counts = HashMap::new();\n\
    \    for letter in test.chars().filter_map(|c| c.is_alphabetic()) {\n        let\
    \ count = letters.entry(letter).or_insert(0);\n        *count += 1;\n    }\n \
    \   for letter in letters.iter() {\n        let count = counts.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    letters\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprc6x94yr.rs:20:47\n   |\n\
    20 |     for letter in test.chars().filter_map(|c| c.is_alphabetic()) {\n   |\
    \                                               ^^^^^^^^^^^^^^^^^\n   |      \
    \                                         |\n   |                            \
    \                   expected enum `Option`, found `bool`\n   |               \
    \                                help: try using a variant of the expected enum:\
    \ `Some(c.is_alphabetic())`\n   |\n   = note: expected enum `Option<_>`\n    \
    \          found type `bool`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    let mut current_letter = String::from(\"\
    \");\n    let mut current_count = -1;\n    let mut current_letters = HashMap::new();\n\
    \n    while let Some(letter) = letters.next() {\n        let count = counts.entry(letter).or_insert(0);\n\
    \        *count += 1;\n        if *count > current_count {\n            current_letter\
    \ = letter;\n            current_count = *count;\n        }\n    }\n\n    for\
    \ letter in letters {\n        if let Some(count) = counts.entry(letter).or_insert(0)\
    \ {\n            *count -= 1;\n            if *count == 0 {\n                let\
    \ mut current_letters = histogram.entry(current_letter).or_insert(HashMap::new());\n\
    \                *current_letters.entry(letter).or_insert(0) += 1;\n         \
    \   }\n        }\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpc80dgtqh.rs:25:38\n   |\n25 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc80dgtqh.rs:35:43\n\
    \   |\n35 |         if let Some(count) = counts.entry(letter).or_insert(0) {\n\
    \   |                                           ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                           |\n \
    \  |                                           expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc80dgtqh.rs:35:16\n\
    \   |\n35 |         if let Some(count) = counts.entry(letter).or_insert(0) {\n\
    \   |                ^^^^^^^^^^^   --------------------------------- this expression\
    \ has type `&mut {integer}`\n   |                |\n   |                expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpc80dgtqh.rs:44:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n44 |     histogram\n \
    \  |     ^^^^^^^^^ expected `isize`, found struct `HashMap`\n   |\n   = note:\
    \ expected struct `HashMap<_, isize>`\n              found struct `HashMap<_,\
    \ HashMap<char, {integer}>>`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        histogram.insert(letters.iter().max().unwrap().to_string(), letters.iter().count());\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr09p2dxc.rs:24:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n24 |     histogram\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n      \
    \        found struct `HashMap<_, usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp9ybu0r5a.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwb32h02_.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_whitespace());\n  \
    \  let mut letters_iter = letters_iter.flat_map(|c| {\n        if let Some(count)\
    \ = histogram.get(c) {\n            *count += 1;\n            Some(c.to_string())\n\
    \        } else {\n            histogram.insert(c, 1);\n            Some(c.to_string())\n\
    \        }\n    });\n    letters_iter.for_each(|c| {\n        histogram.insert(c,\
    \ histogram.get(c).unwrap() + 1);\n    });\n    histogram\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_whitespace` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpp9sevw0n.rs:21:56\n   |\n21 |     let mut\
    \ letters_iter = letters_iter.filter(|&c| !c.is_whitespace());\n   |         \
    \                                               ^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `split_whitespace`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp9sevw0n.rs:32:26\n   |\n32 |         histogram.insert(c,\
    \ histogram.get(c).unwrap() + 1);\n   |                          ^\n   |     \
    \                     |\n   |                          expected `&String`, found\
    \ struct `String`\n   |                          help: consider borrowing here:\
    \ `&c`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp9sevw0n.rs:32:43\n  \
    \ |\n32 |         histogram.insert(c, histogram.get(c).unwrap() + 1);\n   |  \
    \                                         ^\n   |                            \
    \               |\n   |                                           expected reference,\
    \ found struct `String`\n   |                                           help:\
    \ consider borrowing here: `&c`\n   |\n   = note: expected reference `&_`\n  \
    \               found struct `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpp9sevw0n.rs:34:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n34 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&String`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&String,\
    \ {integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split_whitespace();\n\
    \    for letter in letters {\n        histogram.entry(letter).or_insert(0) +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmplpdat3ky.rs:21:9\n   |\n21 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n21 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmplpdat3ky.rs:21:46\n\
    \   |\n21 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplpdat3ky.rs:23:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n23 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    loop {\n        if letters_count > 0 {\n            histogram.insert(letters_repeated.clone(),\
    \ letters_count);\n            letters_count -= 1;\n            letters_repeated\
    \ = letters_repeated.clone();\n        } else {\n            break;\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp62q6hsff.rs:31:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n31 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<char>, usize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_index\
    \ = 0;\n    let mut letters_repeated_count_index2 = 0;\n    let mut letters_repeated_count_index3\
    \ = 0;\n    let mut letters_repeated_count_index4 = 0;\n    let mut letters_repeated_count_index5\
    \ = 0;\n    let mut letters_repeated_count_index6 = 0;\n    let mut letters_repeated_count_index7\
    \ = 0;\n    let mut letters_repeated_count_index8 = 0;\n    let mut letters_repeated_count_index9\
    \ = 0;\n    let mut letters_repeated_count_index10 = 0;\n    let mut letters_repeated_count_index11\
    \ = 0;\n    let mut letters_repeated_count_index12 = 0;\n    let mut letters_repeated_count_index13\
    \ = 0;\n    let mut letters_repeated_count_index14 = 0;\n    let mut letters_repeated_count_index15\
    \ = 0;\n    let mut letters_repeated_count_index16 = 0;\n    let mut letters_repeated_count_index17\
    \ = 0;\n    let mut letters_repeated_count_index18 = 0;\n    let mut letters_repeated_count_index19\
    \ = 0;\n    let mut letters_repeated_count_index20 = 0;\n    let mut letters_repeated_count_index21\
    \ = 0;\n    let mut letters_repeated_count_index22 = 0;\n    let mut letters_repeated_count_index23\
    \ = 0;\n    let mut letters_repeated_count_index24 = 0;\n    let mut letters_repeated_count_index25\
    \ = 0;\n    let mut letters_repeated_count_index26 = 0;\n    let mut letters_repeated_count_index27\
    \ = 0;\n    let mut letters_repeated_count_index28 = 0;\n    let mut letters_repeated_count_index29\
    \ = 0;\n    let mut letters_repeated_count_index30 = 0;\n    let mut letters_repeated_count_index31\
    \ = 0;\n    let mut letters_repeated_count_index32 = 0;\n    let mut letters_repeated_count_index33\
    \ = 0;\n    let mut letters_repeated_count_index34 = 0;\n    let mut letters_repeated_count_index35\
    \ = 0;\n    let mut letters_repeated_count_index36 = 0;\n    let mut letters_repeated_count_index37\
    \ = 0;\n    let mut letters_repeated_count_index38 = 0;\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_8ji0g6e.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut counts = letters.iter().cloned().map(|c|\
    \ histogram.entry(c).or_insert(0));\n    loop {\n        let mut max_count = counts.iter().max().unwrap();\n\
    \        let mut max_letter = counts.iter().filter(|&(_, count)| count == max_count).max().unwrap();\n\
    \        if counts.iter().any(|&(_, count)| count == max_count) {\n          \
    \  break;\n        }\n        for &(letter, count) in &histogram[&max_letter]\
    \ {\n            counts.remove(&letter);\n            counts.insert(letter, count\
    \ + 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpesxjnmmq.rs:22:36\n   |\n22 |         let mut max_count\
    \ = counts.iter().max().unwrap();\n   |                                    ^^^^\
    \ private field, not a method\n\nerror[E0599]: no method named `iter` found for\
    \ struct `Map` in the current scope\n  --> /tmp/tmpesxjnmmq.rs:23:37\n   |\n23\
    \ |         let mut max_letter = counts.iter().filter(|&(_, count)| count == max_count).max().unwrap();\n\
    \   |                                     ^^^^ private field, not a method\n\n\
    error[E0599]: no method named `iter` found for struct `Map` in the current scope\n\
    \  --> /tmp/tmpesxjnmmq.rs:24:19\n   |\n24 |         if counts.iter().any(|&(_,\
    \ count)| count == max_count) {\n   |                   ^^^^ private field, not\
    \ a method\n\nerror[E0277]: `&{integer}` is not an iterator\n   --> /tmp/tmpesxjnmmq.rs:27:33\n\
    \    |\n27  |         for &(letter, count) in &histogram[&max_letter] {\n    |\
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^ `&{integer}` is not\
    \ an iterator\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `&{integer}`\n    = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&{integer}`\nnote: required by `into_iter`\n\nerror[E0599]:\
    \ no method named `remove` found for struct `Map` in the current scope\n  -->\
    \ /tmp/tmpesxjnmmq.rs:28:20\n   |\n28 |             counts.remove(&letter);\n\
    \   |                    ^^^^^^ method not found in `Map<Cloned<std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmpesxjnmmq.rs:20:50: 20:85]>`\n\nerror[E0599]: no method\
    \ named `insert` found for struct `Map` in the current scope\n  --> /tmp/tmpesxjnmmq.rs:29:20\n\
    \   |\n29 |             counts.insert(letter, count + 1);\n   |              \
    \      ^^^^^^ method not found in `Map<Cloned<std::slice::Iter<'_, String>>, [closure@/tmp/tmpesxjnmmq.rs:20:50:\
    \ 20:85]>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9c8hsdq7.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9c8hsdq7.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    while let Some(letter) = letters.pop()\
    \ {\n        if let Some(count) = counts.remove(&letter) {\n            histogram.insert(letter,\
    \ count + 1);\n        } else {\n            counts.insert(letter, 1);\n     \
    \   }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp76_fpoel.rs:28:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, _>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        letters.entry(letter).or_insert(0) += 1;\n    }\n\
    \    letters\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpwcajrmbx.rs:20:9\n   |\n20 |         letters.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `letters.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *letters.entry(letter).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpwcajrmbx.rs:20:44\n\
    \   |\n20 |         letters.entry(letter).or_insert(0) += 1;\n   |         ----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().filter_map(|c|\
    \ c.is_alphabetic()) {\n        histogram.entry(letter).or_insert(0) += 1;\n \
    \   }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpas1kppcy.rs:19:47\n   |\n\
    19 |     for letter in test.chars().filter_map(|c| c.is_alphabetic()) {\n   |\
    \                                               ^^^^^^^^^^^^^^^^^\n   |      \
    \                                         |\n   |                            \
    \                   expected enum `Option`, found `bool`\n   |               \
    \                                help: try using a variant of the expected enum:\
    \ `Some(c.is_alphabetic())`\n   |\n   = note: expected enum `Option<_>`\n    \
    \          found type `bool`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpas1kppcy.rs:20:9\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpas1kppcy.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpftvsu5vn.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = words.collect::<Vec<String>>();\n    let mut letters_count\
    \ = letters.iter().cloned().map(|letter| histogram.entry(letter).or_insert(0));\n\
    \    letters_count = letters_count.fold(0, |mut acc, letter| {\n        match\
    \ acc.get(&letter) {\n            Some(count) => acc + count,\n            None\
    \ => acc + 1,\n        }\n    });\n    histogram.insert(String::from(\"\"), letters_count);\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmptgt1g0se.rs:20:29\n   |\n20 |  \
    \   let mut letters = words.collect::<Vec<String>>();\n   |                  \
    \           ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \   |\n   = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptgt1g0se.rs:22:40\n   |\n21 |\
    \     let mut letters_count = letters.iter().cloned().map(|letter| histogram.entry(letter).or_insert(0));\n\
    \   |                                                         ---------------------------------------------\
    \ the expected closure\n22 |     letters_count = letters_count.fold(0, |mut acc,\
    \ letter| {\n   |                                        ^ expected struct `Map`,\
    \ found integer\n   |\n   = note: expected struct `Map<Cloned<std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmptgt1g0se.rs:21:57: 21:102]>`\n                found\
    \ type `{integer}`\n\nerror[E0599]: no method named `get` found for struct `Map`\
    \ in the current scope\n  --> /tmp/tmptgt1g0se.rs:23:19\n   |\n23 |         match\
    \ acc.get(&letter) {\n   |                   ^^^ method not found in `Map<Cloned<std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmptgt1g0se.rs:21:57: 21:102]>`\n\nerror[E0369]: cannot\
    \ add `_` to `Map<Cloned<std::slice::Iter<'_, String>>, [closure@/tmp/tmptgt1g0se.rs:21:57:\
    \ 21:102]>`\n  --> /tmp/tmptgt1g0se.rs:24:32\n   |\n24 |             Some(count)\
    \ => acc + count,\n   |                            --- ^ ----- _\n   |       \
    \                     |\n   |                            Map<Cloned<std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmptgt1g0se.rs:21:57: 21:102]>\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Map<Cloned<std::slice::Iter<'_, String>>, [closure@/tmp/tmptgt1g0se.rs:21:57:\
    \ 21:102]>`\n  --> /tmp/tmptgt1g0se.rs:25:25\n   |\n25 |             None => acc\
    \ + 1,\n   |                     --- ^ - {integer}\n   |                     |\n\
    \   |                     Map<Cloned<std::slice::Iter<'_, "
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n\
    \    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_max = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8mpjly3v.rs:55:51\n   |\n\
    55 |     let mut letters_count_count_count_count_count_\n   |                \
    \                                   ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8mpjly3v.rs:17:31\n \
    \  |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n  \
    \  }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpylloj1na.rs:23:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n23 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        if let Some(count) = histogram.get(&letter) {\n  \
    \          histogram.insert(letter, count + 1);\n        } else {\n          \
    \  histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2, \"a\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp_ml1haue.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    let mut letter = String::new();\n \
    \   let mut count = 0;\n    while let Some(letter) = letters.pop() {\n       \
    \ if let Some(count) = counts.remove(&letter) {\n            histogram.insert(letter,\
    \ count + 1);\n        } else {\n            histogram.insert(letter, 1);\n  \
    \      }\n    }\n    histogram.into_iter().collect()\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `HashMap<String, isize>` cannot be built\
    \ from an iterator over elements of type `(char, {integer})`\n  --> /tmp/tmpqb4tiqp0.rs:30:27\n\
    \   |\n30 |     histogram.into_iter().collect()\n   |                        \
    \   ^^^^^^^ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=(char,\
    \ {integer})>`\n   |\n   = help: the trait `FromIterator<(char, {integer})>` is\
    \ not implemented for `HashMap<String, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_index = 0;\n    let mut letters_count_max_letter\
    \ = String::new();\n    for letter in letters {\n        if letters_count > letters_count_max\
    \ {\n            letters_count_max = letters_count;\n            letters_count_max_index\
    \ = letters_count_max_index;\n            letters_count_max_letter = letter;\n\
    \        }\n        histogram.insert(letter, letters_count);\n        letters_count\
    \ -= 1;\n    }\n    histogram.insert(letters_count_max_letter, letters_count_max);\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp283lxbmd.rs:28:40\n   |\n\
    28 |             letters_count_max_letter = letter;\n   |                    \
    \                    ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                        |\n   |                         \
    \               expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp283lxbmd.rs:33:22\n   |\n33 |     histogram.insert(letters_count_max_letter,\
    \ letters_count_max);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp283lxbmd.rs:34:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n34 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, usize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9c8hsdq7.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9c8hsdq7.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_index2 = 0;\n    let mut letters_count_index3\
    \ = 0;\n    let mut letters_count_index4 = 0;\n    let mut letters_count_index5\
    \ = 0;\n    let mut letters_count_index6 = 0;\n    let mut letters_count_index7\
    \ = 0;\n    let mut letters_count_index8 = 0;\n    let mut letters_count_index9\
    \ = 0;\n    let mut letters_count_index10 = 0;\n    let mut letters_count_index11\
    \ = 0;\n    let mut letters_count_index12 = 0;\n    let mut letters_count_index13\
    \ = 0;\n    let mut letters_count_index14 = 0;\n    let mut letters_count_index15\
    \ = 0;\n    let mut letters_count_index16 = 0;\n    let mut letters_count_index17\
    \ = 0;\n    let mut letters_count_index18 = 0;\n    let mut letters_count_index19\
    \ = 0;\n    let mut letters_count_index20 = 0;\n    let mut letters_count_index21\
    \ = 0;\n    let mut letters_count_index22 = 0;\n    let mut letters_count_index23\
    \ = 0;\n    let mut letters_count_index24 = 0;\n    let mut letters_count_index25\
    \ = 0;\n    let mut letters_count_index26 = 0;\n    let mut letters_count_index27\
    \ = 0;\n    let mut letters_count_index28 = 0;\n    let mut letters_count_index29\
    \ = 0;\n    let mut letters_count_index30 = 0;\n    let mut letters_count_index31\
    \ = 0;\n    let mut letters_count_index32 = 0;\n    let mut letters_count_index33\
    \ = 0;\n    let mut letters_count_index34 = 0;\n    let mut letters_count_index35\
    \ = 0;\n    let mut letters_count_index36 = 0;\n    let mut letters_count_index37\
    \ = 0;\n    let mut letters_count_index38 = 0;\n    let mut letters_count_index39\
    \ = 0;\n    let mut letters_count_index40 = 0;\n    let mut letters_count_index41\
    \ = 0;\n    let mut letters_count_index42 = 0;\n    let mut letters_count_index43\
    \ = 0;\n    let mut letters_count_index44 = 0;\n    let mut letters_count_index45\
    \ = 0;\n    let mut letters_count_index46 = 0;\n    let mut letters_count_index47\
    \ = 0;\n    let mut letters_count_index48 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsww80vo7.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let \n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfrltj5mq.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror[E0599]: the method `count` exists\
    \ for struct `Vec<char>`, but its trait bounds were not satisfied\n   --> /tmp/tmpfrltj5mq.rs:21:37\n\
    \    |\n21  |       let mut letters_count = letters.count();\n    |          \
    \                             ^^^^^ method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Vec<char>: Iterator`\n            which is required\
    \ by `&mut Vec<char>: Iterator`\n            `[char]: Iterator`\n            which\
    \ is required by `&mut [char]: Iterator`\n\nerror[E0599]: the method `count` exists\
    \ for struct `Vec<char>`, but its trait bounds were not satisfied\n   --> /tmp/tmpfrltj5mq.rs:23:37\n\
    \    |\n23  |       let mut letters_count = letters.count();\n    |          \
    \                             ^^^^^ method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Vec<char>: Iterator`\n            which is required\
    \ by `&mut Vec<char>: Iterator`\n            `[char]: Iterator`\n            which\
    \ is required by `&mut [char]: Iterator`\n\nerror[E0599]: the method `count` exists\
    \ for struct `Vec<char>`, but its trait bounds were not satisfied\n   --> /tmp/tmpfrltj5mq.rs:25:37\n\
    \    |\n25  |       let mut letters_count = letters.count();\n    |          \
    \                             ^^^^^ method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Vec<char>: Iterator`\n            which is required\
    \ by `&mut Vec<char>: Iterator`\n            `[char]: Iterator`\n            which\
    \ is required by `&mut [char]: Iterator`\n\nerror[E0599]: the method `count` exists\
    \ for struct `Vec<char>`, but its trait bounds were not satisfied\n   --> /tmp/tmpfrltj5mq.rs:27:37\n\
    \    |\n27  |       let mut letters_count = letters.count();\n    |          \
    \                             ^^^^^ meth"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        if let Ok(count) = histogram.entry(word).or_insert(0)\
    \ {\n            *count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnnwtpzli.rs:21:16\n   |\n\
    21 |         if let Ok(count) = histogram.entry(word).or_insert(0) {\n   |   \
    \             ^^^^^^^^^   ---------------------------------- this expression has\
    \ type `&mut {integer}`\n   |                |\n   |                expected integer,\
    \ found enum `Result`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Result<_, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnnwtpzli.rs:25:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&str, {integer}>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string());\n\
    \        histogram.insert(letters.collect::<String>(), histogram.get(&letters).unwrap()\
    \ + 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: Borrow<Map<Chars<'_>, [closure@/tmp/tmpb1h8r_1b.rs:21:44:\
    \ 21:61]>>` is not satisfied\n  --> /tmp/tmpb1h8r_1b.rs:22:69\n   |\n22 |    \
    \     histogram.insert(letters.collect::<String>(), histogram.get(&letters).unwrap()\
    \ + 1);\n   |                                                                \
    \     ^^^^^^^^ the trait `Borrow<Map<Chars<'_>, [closure@/tmp/tmpb1h8r_1b.rs:21:44:\
    \ 21:61]>>` is not implemented for `String`\n   |\n   = help: the following implementations\
    \ were found:\n             <String as Borrow<str>>\n\nerror[E0277]: the trait\
    \ bound `Map<Chars<'_>, [closure@/tmp/tmpb1h8r_1b.rs:21:44: 21:61]>: Hash` is\
    \ not satisfied\n  --> /tmp/tmpb1h8r_1b.rs:22:69\n   |\n22 |         histogram.insert(letters.collect::<String>(),\
    \ histogram.get(&letters).unwrap() + 1);\n   |                               \
    \                                      ^^^^^^^^ the trait `Hash` is not implemented\
    \ for `Map<Chars<'_>, [closure@/tmp/tmpb1h8r_1b.rs:21:44: 21:61]>`\n\nerror[E0277]:\
    \ the trait bound `Map<Chars<'_>, [closure@/tmp/tmpb1h8r_1b.rs:21:44: 21:61]>:\
    \ Eq` is not satisfied\n  --> /tmp/tmpb1h8r_1b.rs:22:69\n   |\n22 |         histogram.insert(letters.collect::<String>(),\
    \ histogram.get(&letters).unwrap() + 1);\n   |                               \
    \                                      ^^^^^^^^ the trait `Eq` is not implemented\
    \ for `Map<Chars<'_>, [closure@/tmp/tmpb1h8r_1b.rs:21:44: 21:61]>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_index = 0;\n    let mut letters_count_max_letter\
    \ = String::new();\n    let mut letters_count_max_letter_count = 0;\n\n    for\
    \ letter in letters {\n        let count = letters_count.iter().filter(|&count|\
    \ count == letter).count();\n        if count > letters_count_max {\n        \
    \    letters_count_max = count;\n            letters_count_max_index = letters.iter().position(|&letter|\
    \ letter == letter).unwrap();\n            letters_count_max_letter = letter;\n\
    \            letters_count_max_letter_count = count;\n        }\n        histogram.insert(letter,\
    \ count);\n        letters_count -= count;\n    }\n\n    if letters_count_max\
    \ == 0 {\n        return HashMap::new();\n    }\n\n    histogram.insert(letters_count_max_letter,\
    \ letters_count_max_letter_count);\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpx4nyk4zi.rs:27:35\n   |\n27 |         let count = letters_count.iter().filter(|&count|\
    \ count == letter).count();\n   |                                   ^^^^ method\
    \ not found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx4nyk4zi.rs:31:40\n\
    \   |\n31 |             letters_count_max_letter = letter;\n   |             \
    \                           ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                        |\n   |                         \
    \               expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx4nyk4zi.rs:42:22\n   |\n42 |     histogram.insert(letters_count_max_letter,\
    \ letters_count_max_letter_count);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpx4nyk4zi.rs:43:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n43 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, usize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letter_counts = letters.into_iter().fold(0,\
    \ |mut acc, c| {\n        match histogram.entry(c) {\n            Occupied(mut\
    \ e) => {\n                e.value += 1;\n                acc\n            }\n\
    \            Vacant(mut e) => {\n                e.insert(1);\n              \
    \  acc\n            }\n        }\n    });\n    histogram.into_iter().fold(HashMap::new(),\
    \ |mut acc, e| {\n        acc.entry(e.key()).or_insert(e.value()).cloned()\n \
    \   })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0531]: cannot find tuple struct or tuple variant `Occupied` in this\
    \ scope\n  --> /tmp/tmp569eaae9.rs:22:13\n   |\n22 |             Occupied(mut\
    \ e) => {\n   |             ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::collections::btree_map::Entry::Occupied;\n\
    \   |\n1  | use std::collections::hash_map::Entry::Occupied;\n   |\n1  | use std::collections::hash_map::RawEntryMut::Occupied;\n\
    \   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Vacant` in this\
    \ scope\n  --> /tmp/tmp569eaae9.rs:26:13\n   |\n26 |             Vacant(mut e)\
    \ => {\n   |             ^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::collections::btree_map::Entry::Vacant;\n\
    \   |\n1  | use std::collections::hash_map::Entry::Vacant;\n   |\n1  | use std::collections::hash_map::RawEntryMut::Vacant;\n\
    \   |\n\nerror[E0599]: no method named `key` found for tuple `(String, _)` in\
    \ the current scope\n  --> /tmp/tmp569eaae9.rs:33:21\n   |\n33 |         acc.entry(e.key()).or_insert(e.value()).cloned()\n\
    \   |                     ^^^ method not found in `(String, _)`\n\nerror[E0599]:\
    \ no method named `value` found for tuple `(String, _)` in the current scope\n\
    \  --> /tmp/tmp569eaae9.rs:33:40\n   |\n33 |         acc.entry(e.key()).or_insert(e.value()).cloned()\n\
    \   |                                        ^^^^^ method not found in `(String,\
    \ _)`\n\nerror[E0599]: the method `cloned` exists for mutable reference `&mut\
    \ isize`, but its trait bounds were not satisfied\n  --> /tmp/tmp569eaae9.rs:33:49\n\
    \   |\n33 |         acc.entry(e.key()).or_insert(e.value()).cloned()\n   |   \
    \                                              ^^^^^^ method cannot be called\
    \ on `&mut isize` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `isize: Iterator`\n           which\
    \ is required by `&mut isize: Iterator`\n           `&mut isize: Iterator`\n \
    \          which is required by `&mut &mut isize: Iterator`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors hav"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut counts = letters.iter().cloned().map(|c|\
    \ histogram.entry(c).or_insert(0));\n    loop {\n        let mut max_count = counts.iter().max().unwrap();\n\
    \        let mut max_letter = counts.iter().filter(|&(_, count)| count == max_count).max().unwrap();\n\
    \        let mut max_letter_count = counts.iter().filter(|&(_, count)| count ==\
    \ max_count).count().unwrap();\n        if max_letter_count > 1 {\n          \
    \  counts.retain(|&(_, count)| count == max_count);\n            histogram.insert(max_letter,\
    \ max_letter_count);\n        }\n        if counts.is_empty() {\n            break;\n\
    \        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmp1r6f41cs.rs:22:36\n   |\n22 |         let mut max_count\
    \ = counts.iter().max().unwrap();\n   |                                    ^^^^\
    \ private field, not a method\n\nerror[E0599]: no method named `iter` found for\
    \ struct `Map` in the current scope\n  --> /tmp/tmp1r6f41cs.rs:23:37\n   |\n23\
    \ |         let mut max_letter = counts.iter().filter(|&(_, count)| count == max_count).max().unwrap();\n\
    \   |                                     ^^^^ private field, not a method\n\n\
    error[E0599]: no method named `iter` found for struct `Map` in the current scope\n\
    \  --> /tmp/tmp1r6f41cs.rs:24:43\n   |\n24 |         let mut max_letter_count\
    \ = counts.iter().filter(|&(_, count)| count == max_count).count().unwrap();\n\
    \   |                                           ^^^^ private field, not a method\n\
    \nerror[E0599]: no method named `retain` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmp1r6f41cs.rs:26:20\n   |\n26 |             counts.retain(|&(_,\
    \ count)| count == max_count);\n   |                    ^^^^^^ method not found\
    \ in `Map<Cloned<std::slice::Iter<'_, String>>, [closure@/tmp/tmp1r6f41cs.rs:20:50:\
    \ 20:85]>`\n\nerror[E0658]: use of unstable library feature 'exact_size_is_empty'\n\
    \  --> /tmp/tmp1r6f41cs.rs:29:19\n   |\n29 |         if counts.is_empty() {\n\
    \   |                   ^^^^^^^^\n   |\n   = note: see issue #35428 <https://github.com/rust-lang/rust/issues/35428>\
    \ for more information\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0658.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_max = 0;\n    let mut letters_count_count_min = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_min = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixk5hfo_.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    let mut letter = String::new();\n \
    \   let mut count = 0;\n    while let Some(letter) = letters.next() {\n      \
    \  histogram.entry(letter).or_insert(0) += 1;\n        counts[letter] += 1;\n\
    \        if counts[letter] > count {\n            count = counts[letter];\n  \
    \          letter = String::new();\n        }\n        letter.push(letter);\n\
    \    }\n    histogram.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp1wtivhi0.rs:23:38\n   |\n23 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut {integer}`\n  --> /tmp/tmp1wtivhi0.rs:24:9\n   |\n\
    24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp1wtivhi0.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1wtivhi0.rs:28:22\n   |\n28 |             letter\
    \ = String::new();\n   |                      ^^^^^^^^^^^^^\n   |            \
    \          |\n   |                      expected reference, found struct `String`\n\
    \   |                      help: consider borrowing here: `&String::new()`\n \
    \  |\n   = note: expected reference `&_`\n                 found struct `String`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    while let Some(letter) = letters.pop()\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpjzgm_5dg.rs:22:13\n   |\n22 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n22 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpjzgm_5dg.rs:22:51\n\
    \   |\n22 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjzgm_5dg.rs:24:30\n   |\n24 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&String`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjzgm_5dg.rs:27:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n27 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, {integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        histogram.insert(letters.clone(), histogram.get(&letters).clone() + 1);\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `Option<&_>`\n  --> /tmp/tmpbphkfyxu.rs:22:75\n\
    \   |\n22 |         histogram.insert(letters.clone(), histogram.get(&letters).clone()\
    \ + 1);\n   |                                           -------------------------------\
    \ ^ - {integer}\n   |                                           |\n   |      \
    \                                     Option<&_>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbphkfyxu.rs:24:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n24 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<Vec<String>,\
    \ _>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = 1;\n        for letter in letters {\n            histogram.entry(letter).or_insert(count).cloned()\
    \ += 1;\n            count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for mutable reference `&mut {integer}`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpi87u4our.rs:24:54\n \
    \  |\n24 |             histogram.entry(letter).or_insert(count).cloned() += 1;\n\
    \   |                                                      ^^^^^^ method cannot\
    \ be called on `&mut {integer}` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `{integer}: Iterator`\n\
    \           which is required by `&mut {integer}: Iterator`\n           `&mut\
    \ {integer}: Iterator`\n           which is required by `&mut &mut {integer}:\
    \ Iterator`\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpi87u4our.rs:24:63\n\
    \   |\n24 |             histogram.entry(letter).or_insert(count).cloned() += 1;\n\
    \   |             ------------------------------------------------- ^^\n   | \
    \            |\n   |             cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi87u4our.rs:28:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n28 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9c8hsdq7.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9c8hsdq7.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split_whitespace();\n\
    \    while let Some(letter) = letters.pop() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmphyakppxv.rs:20:38\n   |\n20 |     while\
    \ let Some(letter) = letters.pop() {\n   |                                   \
    \   ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmphyakppxv.rs:22:13\n\
    \   |\n22 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         -------------------------------------^^^^^\n   |             |\n   |\
    \             cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n22 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmphyakppxv.rs:22:51\n\
    \   |\n22 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphyakppxv.rs:24:30\n   |\n24 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              cyclic type of infinite size\n   |\
    \                              help: consider borrowing here: `&letter`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphyakppxv.rs:27:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n27 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&_,\
    \ {integer}>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0067, E0308, E0368, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_count = letters.count();\n    let mut letters_count_iter:\
    \ Option<isize> = None;\n    let mut letters_count_iter_count = 0;\n    let mut\
    \ letters_count_iter_max = 0;\n    let mut letters_count_iter_max_letter: Option<String>\
    \ = None;\n    let mut letters_count_iter_max_letter_count = 0;\n    let mut letters_count_iter_max_letter_counts:\
    \ Vec<isize> = vec![];\n    let mut letters_count_iter_max_letter_counts_iter:\
    \ Option<Vec<isize>> = None;\n    let mut letters_count_iter_max_letter_counts_iter_count\
    \ = 0;\n    let mut letters_count_iter_max_letter_counts_iter_max = 0;\n    let\
    \ mut letters_count_iter_max_letter_counts_iter_max_letter: Option<String> = None;\n\
    \    let mut letters_count_iter_max_letter_counts_iter_max_letter_count = 0;\n\
    \    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts: Vec<isize>\
    \ = vec![];\n    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter:\
    \ Option<Vec<isize>> = None;\n    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter_count\
    \ = 0;\n    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter_max\
    \ = 0;\n    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter_max_letter:\
    \ Option<String> = None;\n    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter_max_letter_count\
    \ = 0;\n    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter_max_letter_counts:\
    \ Vec<isize> = vec![];\n    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter_max_letter_counts_iter:\
    \ Option<Vec<isize>> = None;\n    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter_max_letter_counts_iter_count\
    \ = 0;\n    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter_max_letter_counts_iter_max\
    \ = 0;\n    let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter_max_letter_counts_\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpauryfqbg.rs:43:96\n   |\n\
    43 |     let mut letters_count_iter_max_letter_counts_iter_max_letter_counts_iter_max_letter_counts_\n\
    \   |                                                                        \
    \                        ^ help: add `;` here\n44 | }\n   | - unexpected token\n\
    \nerror[E0599]: the method `count` exists for struct `Vec<String>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpauryfqbg.rs:21:37\n    |\n21  |  \
    \     let mut letters_count = letters.count();\n    |                        \
    \               ^^^^^ method cannot be called on `Vec<String>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<String>: Iterator`\n            which is required by `&mut Vec<String>:\
    \ Iterator`\n            `[String]: Iterator`\n            which is required by\
    \ `&mut [String]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpauryfqbg.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letter_count = 1;\n \
    \   let mut letter = String::from(\"\");\n    while letters_count > 0 {\n    \
    \    histogram.insert(letter, letter_count);\n        letters_count -= 1;\n  \
    \      letter = letters[letters_count];\n        letter_count += 1;\n    }\n \
    \   histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpawb5vlv2.rs:26:18\n   |\n\
    22 |     let mut letter = String::from(\"\");\n   |                      ----------------\
    \ expected due to this value\n...\n26 |         letter = letters[letters_count];\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                  |\n   |                  expected struct\
    \ `String`, found `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = Vec::new();\n    let mut letter = String::new();\n    let\
    \ mut count = usize::MAX;\n    while let Some(letter) = letters.pop() {\n    \
    \    let count = histogram.entry(letter).or_insert(0);\n        *count += 1;\n\
    \        if *count > count {\n            count = *count;\n            letter\
    \ = String::from(letter);\n        }\n    }\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\"\
    \"), 0);\n    histogram.insert(String::from(\"\"), 0);\n    histogram.insert(String::from(\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp489qlpga.rs:67:34\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                                                 - closing delimiter possibly\
    \ meant for this\n...\n67 |     histogram.insert(String::from(\n   |         \
    \                         ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0277]: can't compare `{integer}` with `&mut {integer}`\n\
    \  --> /tmp/tmp489qlpga.rs:26:19\n   |\n26 |         if *count > count {\n   |\
    \                   ^ no implementation for `{integer} < &mut {integer}` and `{integer}\
    \ > &mut {integer}`\n   |\n   = help: the trait `PartialOrd<&mut {integer}>` is\
    \ not implemented for `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp489qlpga.rs:27:21\n\
    \   |\n27 |             count = *count;\n   |                     ^^^^^^ expected\
    \ `&mut {integer}`, found integer\n   |\nhelp: consider dereferencing here to\
    \ assign to the mutable borrowed piece of memory\n   |\n27 |             *count\
    \ = *count;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp489qlpga.rs:28:22\n\
    \   |\n28 |             letter = String::from(letter);\n   |                 \
    \     ^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp489qlpga.rs:31:22\n   |\n31 |     histogram.insert(String::from(\"\
    \"), 0);\n   |                      ^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp489qlpga.rs:32:22\n\
    \   |\n32 |     histogram.insert(String::from(\"\"), 0);\n   |               \
    \       ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp489qlpga.rs:33:22\n   |\n33 |     histogram.insert(String::from(\"\
    \"), 0);\n   |                      ^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp489qlpga.rs:34:22\n\
    \   |\n34 |     histogram.insert(String::from(\"\"), 0);\n   |               \
    \       ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_index\
    \ = 0;\n    let mut letters_repeated_count_index2 = 0;\n    let mut letters_repeated_count_index3\
    \ = 0;\n    let mut letters_repeated_count_index4 = 0;\n    let mut letters_repeated_count_index5\
    \ = 0;\n    let mut letters_repeated_count_index6 = 0;\n    let mut letters_repeated_count_index7\
    \ = 0;\n    let mut letters_repeated_count_index8 = 0;\n    let mut letters_repeated_count_index9\
    \ = 0;\n    let mut letters_repeated_count_index10 = 0;\n    let mut letters_repeated_count_index11\
    \ = 0;\n    let mut letters_repeated_count_index12 = 0;\n    let mut letters_repeated_count_index13\
    \ = 0;\n    let mut letters_repeated_count_index14 = 0;\n    let mut letters_repeated_count_index15\
    \ = 0;\n    let mut letters_repeated_count_index16 = 0;\n    let mut letters_repeated_count_index17\
    \ = 0;\n    let mut letters_repeated_count_index18 = 0;\n    let mut letters_repeated_count_index19\
    \ = 0;\n    let mut letters_repeated_count_index20 = 0;\n    let mut letters_repeated_count_index21\
    \ = 0;\n    let mut letters_repeated_count_index22 = 0;\n    let mut letters_repeated_count_index23\
    \ = 0;\n    let mut letters_repeated_count_index24 = 0;\n    let mut letters_repeated_count_index25\
    \ = 0;\n    let mut letters_repeated_count_index26 = 0;\n    let mut letters_repeated_count_index27\
    \ = 0;\n    let mut letters_repeated_count_index28 = 0;\n    let mut letters_repeated_count_index29\
    \ = 0;\n    let mut letters_repeated_count_index30 = 0;\n    let mut letters_repeated_count_index31\
    \ = 0;\n    let mut letters_repeated_count_index32 = 0;\n    let mut letters_repeated_count_index33\
    \ = 0;\n    let mut letters_repeated_count_index34 = 0;\n    let mut letters_repeated_count_index35\
    \ = 0;\n    let mut letters_repeated_count_index36 = 0;\n    let mut letters_repeated_count_index37\
    \ = 0;\n    let mut letters_repeated_count_index38 = 0;\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_8ji0g6e.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut counts = letters.iter().cloned().map(|c|\
    \ histogram.entry(c).or_insert(0));\n    counts.fold(histogram, |mut acc, &count|\
    \ {\n        acc.entry(count.to_string()).and_modify(|count| count += 1);\n  \
    \      acc\n    });\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpung4sesv.rs:21:38\n   |\n\
    21 |     counts.fold(histogram, |mut acc, &count| {\n   |                    \
    \                  ^------\n   |                                      ||\n   |\
    \                                      |expected due to this\n   |           \
    \                           types differ in mutability\n   |                 \
    \                     help: did you mean `count`: `&&mut {integer}`\n   |\n  \
    \ = note: expected mutable reference `&mut {integer}`\n                      found\
    \ reference `&_`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut {integer}`\n  --> /tmp/tmpung4sesv.rs:22:57\n   |\n22 |      \
    \   acc.entry(count.to_string()).and_modify(|count| count += 1);\n   |       \
    \                                                  -----^^^^^\n   |          \
    \                                               |\n   |                      \
    \                                   cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `count`\n  \
    \ |\n22 |         acc.entry(count.to_string()).and_modify(|count| *count += 1);\n\
    \   |                                                         +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9c8hsdq7.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9c8hsdq7.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp9ybu0r5a.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters_iter.into_iter();\n\
    \    let mut letters_iter = letters_iter.map(|&c| c.to_string());\n    let mut\
    \ letters_iter = letters_iter.map(|&c| c.chars().collect::<Vec<_>>());\n    let\
    \ mut letters_iter = letters_iter.map(|&c| c.iter().cloned());\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.clone());\n    let mut letters_iter = letters_iter.map(|&c|\
    \ c.to_string());\n    let mut letters_iter = letters_iter.map(|&c| c.chars().collect::<Vec<_>>());\n\
    \    let mut letters_iter = letters_iter.map(|&c| c.iter().cloned());\n    let\
    \ mut letters_iter = letters_iter.map(|&c| c.clone());\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.to_string());\n    let mut letters_iter = letters_iter.map(|&c|\
    \ c.chars().collect::<Vec<_>>());\n    let mut letters_iter = letters_iter.map(|&c|\
    \ c.iter().cloned());\n    let mut letters_iter = letters_iter.map(|&c| c.clone());\n\
    \    let mut letters_iter = letters_iter.map(|&c| c.to_string());\n    let mut\
    \ letters_iter = letters_iter.map(|&c| c.chars().collect::<Vec<_>>());\n    let\
    \ mut letters_iter = letters_iter.map(|&c| c.iter().cloned());\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.clone());\n    let mut letters_iter = letters_iter.map(|&c|\
    \ c.to_string());\n    let mut letters_iter = letters_iter.map(|&c| c.chars().collect::<Vec<_>>());\n\
    \    let mut letters_iter = letters_iter.map(|&c| c.iter().cloned());\n    let\
    \ mut letters_iter = letters_iter.map(|&c| c.clone());\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.to_string());\n    let mut letters_iter = letters_iter.map(|&c|\
    \ c.chars().collect::<Vec<_>>());\n    let mut letters_iter = letter\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptt5mtkg2.rs:44:34\n   |\n\
    44 |     let mut letters_iter = letter\n   |                                 \
    \ ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `letter` in this scope\n  --> /tmp/tmptt5mtkg2.rs:44:28\n   |\n44\
    \ |     let mut letters_iter = letter\n   |                            ^^^^^^\
    \ help: a local variable with a similar name exists: `letters`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptt5mtkg2.rs:23:46\n   |\n23 |     let mut letters_iter\
    \ = letters_iter.map(|&c| c.chars().collect::<Vec<_>>());\n   |              \
    \                                ^--\n   |                                   \
    \           ||\n   |                                              |expected due\
    \ to this\n   |                                              expected struct `String`,\
    \ found reference\n   |                                              help: did\
    \ you mean `c`: `&String`\n   |\n   = note: expected struct `String`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptt5mtkg2.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters_iter.into_iter();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_iter = letters_iter.peekable();\n\
    \    let mut letters_iter = letters_iter.peekable();\n    let mut letters_iter\
    \ = letters_iter.peekable();\n    let mut letters_\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbn6meih1.rs:57:21\n   |\n\
    57 |     let mut letters_\n   |                     ^ help: add `;` here\n58 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbn6meih1.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = vec![];\n    while let Some(letter) = letters.pop() {\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).and_modify(|count|\
    \ {\n                *count += 1;\n            });\n        } else {\n       \
    \     histogram.insert(letter, 1);\n        }\n    }\n    histogram.into_iter().map(|(_,\
    \ count)| {\n        (String::from(&*letters[..count..]), count)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `]`, `{`, or an operator, found\
    \ `..`\n  --> /tmp/tmpg6y28cmy.rs:31:40\n   |\n31 |         (String::from(&*letters[..count..]),\
    \ count)\n   |                                        ^^ expected one of 7 possible\
    \ tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg6y28cmy.rs:27:30\n\
    \   |\n27 |             histogram.insert(letter, 1);\n   |                   \
    \           ^^^^^^\n   |                              |\n   |                \
    \              expected `&char`, found `char`\n   |                          \
    \    help: consider borrowing here: `&letter`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter_iter = letters.iter();\n\
    \    let mut letter_count = letters.len();\n    let mut letter_count_iter = letter_count.iter();\n\
    \    let mut letter_count_iter_next = letter_count_iter.next();\n    while let\
    \ Some(letter) = letter_iter {\n        if histogram.contains_key(&letter) {\n\
    \            histogram.entry(letter).or_insert(0) += 1;\n        } else {\n  \
    \          histogram.insert(letter, 1);\n        }\n        letter_iter = letter_iter.next();\n\
    \        letter_count_iter = letter_count_iter.next();\n        letter_count_iter_next\
    \ = letter_count_iter.next();\n    }\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp2zqx4wpm.rs:23:46\n   |\n23 |     let mut letter_count_iter\
    \ = letter_count.iter();\n   |                                              ^^^^\
    \ method not found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2zqx4wpm.rs:25:15\n\
    \   |\n25 |     while let Some(letter) = letter_iter {\n   |               ^^^^^^^^^^^^\
    \   ----------- this expression has type `std::slice::Iter<'_, char>`\n   |  \
    \             |\n   |               expected struct `std::slice::Iter`, found\
    \ enum `Option`\n   |\n   = note: expected struct `std::slice::Iter<'_, char>`\n\
    \                found enum `Option<_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmp2zqx4wpm.rs:27:13\n\
    \   |\n27 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------^^^^^\n   |             |\n   | \
    \            cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n27 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp2zqx4wpm.rs:27:50\n\
    \   |\n27 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2zqx4wpm.rs:31:23\n   |\n31 |         letter_iter = letter_iter.next();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^ expected struct `std::slice::Iter`,\
    \ found enum `Option`\n   |\n   = note: expected struct `std::slice::Iter<'_,\
    \ char>`\n                found enum `Option<&char>`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0067, E0308, E0368,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = letters.iter().filter(|&c| !c.is_whitespace()).count();\n\
    \        if let Some(count) = count {\n            histogram.insert(word.to_string(),\
    \ count);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp3rdhl9n0.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_count = letters.len();\n\
    \    let mut letter_count = 1;\n    let mut letter = String::from(\"\");\n   \
    \ while letters_count > 0 {\n        histogram.insert(letter, letter_count);\n\
    \        letters_count -= 1;\n        letter = letters[letters_count];\n     \
    \   letter_count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpr4gm2gsb.rs:19:9\n\
    \   |\n19 |     let mut letters = test.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \   |         ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0507]: cannot\
    \ move out of index of `Vec<String>`\n  --> /tmp/tmpr4gm2gsb.rs:26:18\n   |\n\
    26 |         letter = letters[letters_count];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = words.collect::<Vec<String>>();\n    let mut letter_counts\
    \ = HashMap::new();\n    for letter in letters {\n        letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    for letter in letter_counts {\n        histogram.entry(letter).or_insert(letter_counts[letter]);\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpplwryrxb.rs:20:29\n   |\n20 |  \
    \   let mut letters = words.collect::<Vec<String>>();\n   |                  \
    \           ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \   |\n   = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ {integer}`\n  --> /tmp/tmpplwryrxb.rs:23:9\n   |\n23 |         letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n23 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpplwryrxb.rs:23:50\n\
    \   |\n23 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpplwryrxb.rs:26:57\n\
    \   |\n26 |         histogram.entry(letter).or_insert(letter_counts[letter]);\n\
    \   |                                                         ^^^^^^\n   |   \
    \                                                      |\n   |               \
    \                                          expected reference, found tuple\n \
    \  |                                                         help: consider borrowing\
    \ here: `&letter`\n   |\n   = note: expected reference `&_`\n                \
    \  found tuple `(String, {integer})`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpplwryrxb.rs:28:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n28 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, "
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters_iter.into_iter();\n\
    \    let mut letters_iter = letters_iter.map(|c| c.to_ascii_lowercase());\n  \
    \  let mut letters_iter = letters_iter.collect::<Vec<_>>();\n    let mut letters_iter\
    \ = letters_iter.into_iter();\n    let mut letters_iter = letters_iter.map(|c|\
    \ c.to_ascii_lowercase());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|c| c.to_ascii_lowercase());\n    let mut letters_iter =\
    \ letters_iter.collect::<Vec<_>>();\n    let mut letters_iter = letters_iter.into_iter();\n\
    \    let mut letters_iter = letters_iter.map(|c| c.to_ascii_lowercase());\n  \
    \  let mut letters_iter = letters_iter.collect::<Vec<_>>();\n    let mut letters_iter\
    \ = letters_iter.into_iter();\n    let mut letters_iter = letters_iter.map(|c|\
    \ c.to_ascii_lowercase());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|c| c.to_ascii_lowercase());\n    let mut letters_iter =\
    \ letters_iter.collect::<Vec<_>>();\n    let mut letters_iter = letters_iter.into_iter();\n\
    \    let mut letters_iter = letters_iter.map(|c| c.to_ascii_lowercase());\n  \
    \  let mut letters_iter = letters_iter.collect::<Vec<_>>();\n    let mut letters_iter\
    \ = letters_iter.into_iter();\n    let mut letters_iter = letters_iter.map(|c|\
    \ c.to_ascii_lowercase());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|c| c.to_ascii_lowercase());\n    let mut letters_iter =\
    \ letters_iter.collect::<Vec<_>>();\n    let mut letters_iter = letters_iter.into_iter();\n\
    \    let mut letters_iter = letters_iter.map(\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmptlkilinm.rs:49:44\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                                                 - closing delimiter possibly\
    \ meant for this\n...\n49 |     let mut letters_iter = letters_iter.map(\n   |\
    \                                            ^ unclosed delimiter\n50 | }\n  \
    \ | ^ mismatched closing delimiter\n\nerror: expected one of `.`, `;`, `?`, `else`,\
    \ or an operator, found `}`\n  --> /tmp/tmptlkilinm.rs:50:1\n   |\n50 | }\n  \
    \ | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        letters.sort_by_key(|&x| x.to_ascii_lowercase());\n        let mut count\
    \ = 1;\n        for letter in letters {\n            histogram.entry(letter).or_insert(count).cloned()\
    \ += 1;\n            count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for mutable reference `&mut {integer}`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp9z_lcsyh.rs:25:54\n \
    \  |\n25 |             histogram.entry(letter).or_insert(count).cloned() += 1;\n\
    \   |                                                      ^^^^^^ method cannot\
    \ be called on `&mut {integer}` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `{integer}: Iterator`\n\
    \           which is required by `&mut {integer}: Iterator`\n           `&mut\
    \ {integer}: Iterator`\n           which is required by `&mut &mut {integer}:\
    \ Iterator`\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9z_lcsyh.rs:25:63\n\
    \   |\n25 |             histogram.entry(letter).or_insert(count).cloned() += 1;\n\
    \   |             ------------------------------------------------- ^^\n   | \
    \            |\n   |             cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9z_lcsyh.rs:29:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n29 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    while letters_count_index < letters_count\
    \ {\n        let letter = &letters[letters_count_index];\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n        if *count\
    \ > letters_count_max {\n            letters_count_max = *count;\n        }\n\
    \        letters_count_index += 1;\n    }\n    histogram\n}\n\nfn main() {\n \
    \   let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgllhn4ev.rs:32:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n32 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwb32h02_.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letter = letters_iter.next().unwrap();\n    let mut letter_count\
    \ = 0;\n    while let Some(letter) = letters_iter.next() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.get_mut(&letter).unwrap() += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n        letter_count +=\
    \ 1;\n    }\n    while letter_count < histogram.len() {\n        histogram.remove(&letter);\n\
    \        letter_count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `count` exists for struct `Vec<char>`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmpizu978k3.rs:21:37\n    |\n21\
    \  |       let mut letters_count = letters.count();\n    |                   \
    \                    ^^^^^ method cannot be called on `Vec<char>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<char>: Iterator`\n            which is required by `&mut Vec<char>:\
    \ Iterator`\n            `[char]: Iterator`\n            which is required by\
    \ `&mut [char]: Iterator`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut _`\n  --> /tmp/tmpizu978k3.rs:26:13\n   |\n26 |   \
    \          histogram.get_mut(&letter).unwrap() += 1;\n   |             -----------------------------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&mut _`\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpizu978k3.rs:26:49\n   |\n\
    26 |             histogram.get_mut(&letter).unwrap() += 1;\n   |             -----------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpizu978k3.rs:36:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n36 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368, E0599.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_occurrence\
    \ = letters.iter().cloned().fold(0, |acc, x| acc + x);\n    while letters_count\
    \ > 0 {\n        let letter = letters.remove(0);\n        let count = letters_occurrence;\n\
    \        histogram.insert(letter, count);\n        letters_occurrence -= count;\n\
    \        letters_count -= 1;\n    }\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `char` to `{integer}`\n  --> /tmp/tmplfv2a5fm.rs:21:79\n\
    \   |\n21 |     let mut letters_occurrence = letters.iter().cloned().fold(0, |acc,\
    \ x| acc + x);\n   |                                                         \
    \                      ^ no implementation for `{integer} + char`\n   |\n   =\
    \ help: the trait `Add<char>` is not implemented for `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplfv2a5fm.rs:29:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n29 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().next().unwrap();\n\
    \        histogram.insert(letter, histogram.entry(letter).or_insert(0));\n   \
    \ }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyhhw4rtw.rs:22:34\n   |\n\
    22 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpyhhw4rtw.rs:24:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n24 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = Vec::new();\n    let mut letter = String::from(\"\");\n\
    \    let mut count = 0;\n\n    while let Some(letter) = letters.pop() {\n    \
    \    histogram.entry(letter).or_insert(0) += 1;\n        counts.push(histogram.entry(letter).or_insert(0));\n\
    \    }\n\n    while let Some(letter) = letters.pop() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(letter).or_insert(0) += counts.pop();\n     \
    \   } else {\n            histogram.insert(letter, 1);\n        }\n    }\n\n \
    \   histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmplk7maxuo.rs:25:9\n   |\n25 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n25 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmplk7maxuo.rs:25:46\n\
    \   |\n25 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmplk7maxuo.rs:31:13\n   |\n31 |             histogram.entry(letter).or_insert(0)\
    \ += counts.pop();\n   |             ------------------------------------^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmplk7maxuo.rs:31:50\n\
    \   |\n31 |             histogram.entry(letter).or_insert(0) += counts.pop();\n\
    \   |             ------------------------------------ ^^\n   |             |\n\
    \   |             cannot assign to this expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplk7maxuo.rs:37:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n37 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut counts = letters.into_iter().fold(0,\
    \ |mut acc, c| {\n        match histogram.entry(c) {\n            Occupied::Vacant(v)\
    \ => {\n                v.insert(0);\n                acc + 1\n            }\n\
    \            Occupied::Occupied(mut o) => {\n                o.value += 1;\n \
    \               acc\n            }\n        }\n    });\n    histogram.insert(String::from(\"\
    \"), counts);\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Occupied`\n  -->\
    \ /tmp/tmpta0ao_mi.rs:22:13\n   |\n22 |             Occupied::Vacant(v) => {\n\
    \   |             ^^^^^^^^ use of undeclared type `Occupied`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Occupied`\n  --> /tmp/tmpta0ao_mi.rs:26:13\n\
    \   |\n26 |             Occupied::Occupied(mut o) => {\n   |             ^^^^^^^^\
    \ use of undeclared type `Occupied`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters_iter.map(|&letter|\
    \ {\n        let mut letter_count = histogram.entry(letter).or_insert(0);\n  \
    \      *letter_count += 1;\n        letter\n    });\n    letters_iter.for_each(|letter|\
    \ {\n        let mut letter_count = histogram.entry(letter).or_insert(0);\n  \
    \      *letter_count += 1;\n    });\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5811txt8.rs:30:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters_iter.into_iter();\n\
    \    let mut letters_iter = letters_iter.map(|&letter| {\n        let mut letter\
    \ = String::from(letter);\n        let mut occurrences = 0;\n        histogram.entry(letter).or_insert(occurrences);\n\
    \        occurrences\n    });\n    histogram.into_iter()\n}\n\nfn main() {\n \
    \   let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0cy68qom.rs:28:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram.into_iter()\n   |     ^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found struct `std::collections::hash_map::IntoIter`\n\
    \   |\n   = note: expected struct `HashMap<String, isize>`\n              found\
    \ struct `std::collections::hash_map::IntoIter<String, {integer}>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    let mut letters_count_index2 = 0;\n\
    \    let mut letters_count_max2 = 0;\n    let mut letters_count_index3 = 0;\n\
    \    let mut letters_count_max3 = 0;\n    let mut letters_count_index4 = 0;\n\
    \    let mut letters_count_max4 = 0;\n    let mut letters_count_index5 = 0;\n\
    \    let mut letters_count_max5 = 0;\n    let mut letters_count_index6 = 0;\n\
    \    let mut letters_count_max6 = 0;\n    let mut letters_count_index7 = 0;\n\
    \    let mut letters_count_max7 = 0;\n    let mut letters_count_index8 = 0;\n\
    \    let mut letters_count_max8 = 0;\n    let mut letters_count_index9 = 0;\n\
    \    let mut letters_count_max9 = 0;\n    let mut letters_count_index10 = 0;\n\
    \    let mut letters_count_max10 = 0;\n    let mut letters_count_index11 = 0;\n\
    \    let mut letters_count_max11 = 0;\n    let mut letters_count_index12 = 0;\n\
    \    let mut letters_count_max12 = 0;\n    let mut letters_count_index13 = 0;\n\
    \    let mut letters_count_max13 = 0;\n    let mut letters_count_index14 = 0;\n\
    \    let mut letters_count_max14 = 0;\n    let mut letters_count_index15 = 0;\n\
    \    let mut letters_count_max15 = 0;\n    let mut letters_count_index16 = 0;\n\
    \    let mut letters_count_max16 = 0;\n    let mut letters_count_index17 = 0;\n\
    \    let mut letters_count_max17 = 0;\n    let mut letters_count_index18 = 0;\n\
    \    let mut letters_count_max18 = 0;\n    let mut letters_count_index19 = 0;\n\
    \    let mut letters_count_max19 = 0;\n    let mut letters_count_index20 = 0;\n\
    \    let mut letters_count_max20 = 0;\n    let mut letters_count_index21 = 0;\n\
    \    let mut letters_count_max21 = 0;\n    let mut letters_count_index22 = 0;\n\
    \    let mut letters_count_max22 = 0;\n    let mut letters_count_index23 = 0;\n\
    \    let mut letters_count_max23 = 0;\n    let mut letters_count_index24 = 0;\n\
    \    let mut letters_count_max24 = 0;\n    let mut letter\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7d5wu9ig.rs:69:19\n   |\n\
    69 |     let mut letter\n   |                   ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7d5wu9ig.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = String::from(word);\n        if\
    \ histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpphtt4kc1.rs:23:13\n   |\n23 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpphtt4kc1.rs:23:51\n\
    \   |\n23 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpphtt4kc1.rs:25:30\n   |\n25 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&String`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpphtt4kc1.rs:28:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, {integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9c8hsdq7.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9c8hsdq7.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n        histogram.insert(letters.clone(),\
    \ histogram.get(&letters).clone() + 1);\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpey50b2aq.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0369]: cannot add `{integer}` to\
    \ `Option<&_>`\n  --> /tmp/tmpey50b2aq.rs:22:75\n   |\n22 |         histogram.insert(letters.clone(),\
    \ histogram.get(&letters).clone() + 1);\n   |                                \
    \           ------------------------------- ^ - {integer}\n   |              \
    \                             |\n   |                                        \
    \   Option<&_>\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0369, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut letters_count = HashMap::new();\n\
    \    for letter in test.chars() {\n        let count = letters_count.entry(letter).or_insert(0);\n\
    \        *count += 1;\n        letters.entry(letter).or_insert(0);\n        letters[letter]\
    \ += 1;\n    }\n    letters\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3uviutob.rs:24:17\n   |\n\
    24 |         letters[letter] += 1;\n   |                 ^^^^^^\n   |        \
    \         |\n   |                 expected `&char`, found `char`\n   |       \
    \          help: consider borrowing here: `&letter`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3uviutob.rs:26:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n26 |     letters\n\
    \   |     ^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_index\
    \ = 0;\n    let mut letters_repeated_count_index2 = 0;\n    let mut letters_repeated_count_index3\
    \ = 0;\n    let mut letters_repeated_count_index4 = 0;\n    let mut letters_repeated_count_index5\
    \ = 0;\n    let mut letters_repeated_count_index6 = 0;\n    let mut letters_repeated_count_index7\
    \ = 0;\n    let mut letters_repeated_count_index8 = 0;\n    let mut letters_repeated_count_index9\
    \ = 0;\n    let mut letters_repeated_count_index10 = 0;\n    let mut letters_repeated_count_index11\
    \ = 0;\n    let mut letters_repeated_count_index12 = 0;\n    let mut letters_repeated_count_index13\
    \ = 0;\n    let mut letters_repeated_count_index14 = 0;\n    let mut letters_repeated_count_index15\
    \ = 0;\n    let mut letters_repeated_count_index16 = 0;\n    let mut letters_repeated_count_index17\
    \ = 0;\n    let mut letters_repeated_count_index18 = 0;\n    let mut letters_repeated_count_index19\
    \ = 0;\n    let mut letters_repeated_count_index20 = 0;\n    let mut letters_repeated_count_index21\
    \ = 0;\n    let mut letters_repeated_count_index22 = 0;\n    let mut letters_repeated_count_index23\
    \ = 0;\n    let mut letters_repeated_count_index24 = 0;\n    let mut letters_repeated_count_index25\
    \ = 0;\n    let mut letters_repeated_count_index26 = 0;\n    let mut letters_repeated_count_index27\
    \ = 0;\n    let mut letters_repeated_count_index28 = 0;\n    let mut letters_repeated_count_index29\
    \ = 0;\n    let mut letters_repeated_count_index30 = 0;\n    let mut letters_repeated_count_index31\
    \ = 0;\n    let mut letters_repeated_count_index32 = 0;\n    let mut letters_repeated_count_index33\
    \ = 0;\n    let mut letters_repeated_count_index34 = 0;\n    let mut letters_repeated_count_index35\
    \ = 0;\n    let mut letters_repeated_count_index36 = 0;\n    let mut letters_repeated_count_index37\
    \ = 0;\n    let mut letters_repeated_count_index38 = 0;\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_8ji0g6e.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_count = letters.count();\n    while let Some(letter) = letters_iter.next()\
    \ {\n        let count = letters_count.remove(&letter);\n        histogram.insert(letter,\
    \ count);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `count` exists for struct `Vec<String>`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmp4i3fe0pc.rs:21:37\n    |\n21\
    \  |       let mut letters_count = letters.count();\n    |                   \
    \                    ^^^^^ method cannot be called on `Vec<String>` due to unsatisfied\
    \ trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<String>: Iterator`\n            which is required by `&mut Vec<String>:\
    \ Iterator`\n            `[String]: Iterator`\n            which is required by\
    \ `&mut [String]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4i3fe0pc.rs:26:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n26 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, _>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    while letters_count_index != letters_count\
    \ {\n        let letter = &letters[letters_count_index];\n        let count =\
    \ histogram.entry(letter).or_insert(0);\n        *count += 1;\n        if *count\
    \ > letters_count_max {\n            letters_count_max = *count;\n        }\n\
    \        letters_count_index += 1;\n    }\n    histogram\n}\n\nfn main() {\n \
    \   let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0wyzgqxu.rs:32:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n32 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter = String::from(\"\
    \");\n    let mut count = 0;\n    while let Some(letter) = letters_iter.next()\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n        if histogram.contains_key(&letter)\
    \ {\n            count += 1;\n        }\n    }\n    histogram.insert(String::from(\"\
    \"), count);\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpi4y2dgrr.rs:24:9\n   |\n24 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpi4y2dgrr.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi4y2dgrr.rs:29:22\n   |\n29 |     histogram.insert(String::from(\"\
    \"), count);\n   |                      ^^^^^^^^^^^^^^^^ expected `&char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi4y2dgrr.rs:30:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&char, {integer}>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    let mut letter = String::new();\n \
    \   let mut letter_count = 0;\n    let mut letter_index = -1;\n    let mut letters_size\
    \ = letters.len();\n    while letter_index < letters_size {\n        letter =\
    \ letters[letter_index].to_string();\n        if let Some(count) = counts.entry(letter).or_insert(0)\
    \ {\n            *count += 1;\n        } else {\n            counts.insert(letter,\
    \ 1);\n        }\n        letter_index += 1;\n    }\n    histogram.insert(String::from(\"\
    \"), 0);\n    for (letter, count) in counts {\n        histogram.entry(letter).or_insert(0)\
    \ += count;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpxznwwf47.rs:23:28\n\
    \   |\n23 |     let mut letter_index = -1;\n   |                            ^^\
    \ the trait `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxznwwf47.rs:27:16\n   |\n27 |         if let Some(count) = counts.entry(letter).or_insert(0)\
    \ {\n   |                ^^^^^^^^^^^   --------------------------------- this\
    \ expression has type `&mut {integer}`\n   |                |\n   |          \
    \      expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpxznwwf47.rs:36:9\n\
    \   |\n36 |         histogram.entry(letter).or_insert(0) += count;\n   |     \
    \    ------------------------------------^^^^^^^^^\n   |         |\n   |     \
    \    cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used on\
    \ `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n  \
    \ |\n36 |         *histogram.entry(letter).or_insert(0) += count;\n   |      \
    \   +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpxznwwf47.rs:36:46\n\
    \   |\n36 |         histogram.entry(letter).or_insert(0) += count;\n   |     \
    \    ------------------------------------ ^^\n   |         |\n   |         cannot\
    \ assign to this expression\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0067, E0277, E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = Vec::new();\n    let mut letter = String::from(\"\");\n\
    \    let mut count = 1;\n    let mut i = 0;\n    while i < letters.len() {\n \
    \       letter = letters[i];\n        if histogram.contains_key(&letter) {\n \
    \           histogram.entry(&letter).or_insert(count).cloned() as isize\n    \
    \    } else {\n            histogram.insert(letter, count);\n            counts.push((letter,\
    \ count));\n            count = 1;\n        }\n        i += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_m4m4ds4.rs:25:18\n   |\n\
    25 |         letter = letters[i];\n   |                  ^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                  |\n   |   \
    \               expected struct `String`, found `char`\n\nerror[E0599]: the method\
    \ `cloned` exists for mutable reference `&mut {integer}`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp_m4m4ds4.rs:27:55\n   |\n27 |            \
    \ histogram.entry(&letter).or_insert(count).cloned() as isize\n   |          \
    \                                             ^^^^^^ method cannot be called on\
    \ `&mut {integer}` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `{integer}: Iterator`\n       \
    \    which is required by `&mut {integer}: Iterator`\n           `&mut {integer}:\
    \ Iterator`\n           which is required by `&mut &mut {integer}: Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_m4m4ds4.rs:29:30\n   |\n29 |\
    \             histogram.insert(letter, count);\n   |                         \
    \     ^^^^^^\n   |                              |\n   |                      \
    \        expected `&String`, found struct `String`\n   |                     \
    \         help: consider borrowing here: `&letter`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_m4m4ds4.rs:35:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n35 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&String`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&String,\
    \ {integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        letters.sort_by_key(|c| c.to_ascii_lowercase());\n        for letter\
    \ in letters {\n            histogram.entry(letter).or_insert(0) += 1;\n     \
    \   }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5_azdyz8.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmp5_azdyz8.rs:24:13\n\
    \   |\n24 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------^^^^^\n   |             |\n   | \
    \            cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp5_azdyz8.rs:24:50\n\
    \   |\n24 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n    let mut letter = String::new();\n\
    \    let mut letter_count = isize::MIN;\n\n    for _ in 0..letters.len() {\n \
    \       letter = String::from(letters.pop());\n        letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n        if letter_counts.entry(letter).or_insert(0) >= letter_count {\n\
    \            histogram.insert(letter, letter_count);\n            letter_count\
    \ = isize::MIN;\n        } else {\n            letter_count += 1;\n        }\n\
    \    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<Option<char>>` is not satisfied\n\
    \   --> /tmp/tmpmlq3eeow.rs:25:18\n    |\n25  |         letter = String::from(letters.pop());\n\
    \    |                  ^^^^^^^^^^^^ the trait `From<Option<char>>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpmlq3eeow.rs:26:9\n\
    \   |\n26 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ----------------------------------------^^^^^\n   |         |\n   |     \
    \    cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used on\
    \ `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n26 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmlq3eeow.rs:26:50\n\
    \   |\n26 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmlq3eeow.rs:27:56\n\
    \   |\n27 |         if letter_counts.entry(letter).or_insert(0) >= letter_count\
    \ {\n   |                                                        ^^^^^^^^^^^^\n\
    \   |                                                        |\n   |         \
    \                                               expected `&mut _`, found `isize`\n\
    \   |                                                        help: consider mutably\
    \ borrowing here: `&mut letter_count`\n   |\n   = note: expected mutable reference\
    \ `&mut _`\n                           found type `isize`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0277,\
    \ E0308, E0368.\nFor more information about an error, try `r"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters.iter();\n\
    \    let \n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpbgiizom5.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        for letter in letters {\n            histogram.entry(letter).or_insert(0)\
    \ += 1;\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9m4_d_fh.rs:23:13\n   |\n23 |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |             ------------------------------------^^^^^\n   |    \
    \         |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9m4_d_fh.rs:23:50\n\
    \   |\n23 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n\n    while letters_count\
    \ > 0 {\n        let mut letter = letters.remove(0);\n        let mut count =\
    \ letters_repeated_count.remove(0);\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).and_modify(|x| *x += count);\n     \
    \   } else {\n            histogram.insert(letter, count);\n        }\n      \
    \  letters_count -= 1;\n        letters_repeated_count -= 1;\n    }\n\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8x9p4fbn.rs:30:30\n   |\n\
    30 |             histogram.insert(letter, count);\n   |                      \
    \        ^^^^^^\n   |                              |\n   |                   \
    \           expected `&char`, found `char`\n   |                             \
    \ help: consider borrowing here: `&letter`\n\nerror[E0277]: cannot add-assign\
    \ `char` to `char`\n  --> /tmp/tmp8x9p4fbn.rs:28:56\n   |\n28 |             histogram.entry(&letter).and_modify(|x|\
    \ *x += count);\n   |                                                        ^^\
    \ no implementation for `char += char`\n   |\n   = help: the trait `AddAssign`\
    \ is not implemented for `char`\n\nerror[E0368]: binary assignment operation `-=`\
    \ cannot be applied to type `Vec<char>`\n  --> /tmp/tmp8x9p4fbn.rs:33:9\n   |\n\
    33 |         letters_repeated_count -= 1;\n   |         ----------------------^^^^^\n\
    \   |         |\n   |         cannot use `-=` on type `Vec<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8x9p4fbn.rs:36:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n36 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ char>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0368.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut letters_count = HashMap::new();\n\
    \    let mut letters_count_max = HashMap::new();\n    let mut letters_count_max_key\
    \ = String::from(\"\");\n    let mut letters_count_max_value = isize::MAX;\n \
    \   let mut letters_count_max_key_value = isize::MAX;\n    let mut letters_count_max_key_value_count\
    \ = isize::MAX;\n    let mut letters_count_max_key_value_count_max = isize::MAX;\n\
    \    let mut letters_count_max_key_value_count_max_key = String::from(\"\");\n\
    \    let mut letters_count_max_key_value_count_max_value = isize::MAX;\n    let\
    \ mut letters_count_max_key_value_count_max_key_value = isize::MAX;\n    let mut\
    \ letters_count_max_key_value_count_max_key_value_count = isize::MAX;\n    let\
    \ mut letters_count_max_key_value_count_max_key_value_count_max = isize::MAX;\n\
    \    let mut letters_count_max_key_value_count_max_key_value_count_max_key = String::from(\"\
    \");\n    let mut letters_count_max_key_value_count_max_key_value_count_max_value\
    \ = isize::MAX;\n    let mut letters_count_max_key_value_count_max_key_value_count_max_key_value\
    \ = isize::MAX;\n    let mut letters_count_max_key_value_count_max_key_value_count_max_key_value_count\
    \ = isize::MAX;\n    let mut letters_count_max_key_value_count_max_key_value_count_max_key_value_count_max\
    \ = isize::MAX;\n    let mut letters_count_max_key_value_count_max_key_value_count_max_key_value_count_max_key\
    \ = String::from(\"\");\n    let mut letters_count_max_key_value_count_max_key_value_count_max_key_value_count_max_value\
    \ = isize::MAX;\n    let mut letters_count_max_key_value_count_max_key_value_count_max_key_value_count_max_key_value\
    \ = isize::MAX;\n    let mut letters_count_max_key_value_count_max_key_value_count_max_key_value_count_max_key_value_count\
    \ = isize::MAX;\n    let mut letters_count_max_key_value_count_max_key_value_count_max_key_value_count_max_key_value_count_max\
    \ = isize::MAX;\n    let mut letters_count_max_key_value_count_max_key_value_count_max_key_value_count_max_key_value_count_max_key\
    \ = String::from(\"\");\n    let mut letters_count_max_key_value_count_max_key_value_count_max_key_value_count_max_key_value_count_max_value\
    \ = isize::\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpi2d20qlm.rs:43:1\n\
    \   |\n43 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        if histogram.contains_key(&word)\
    \ {\n            histogram.entry(word).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(word, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpb5jmcnli.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpb5jmcnli.rs:22:13\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ----------------------------------^^^^^\n   |             |\n   |     \
    \        cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `histogram.entry(word).or_insert(0)`\n \
    \  |\n22 |             *histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpb5jmcnli.rs:22:48\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_index = 0;\n    let mut letters_count_max_letter\
    \ = String::new();\n\n    for letter in letters {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n\n        if histogram.get(&letter)\
    \ > letters_count_max {\n            letters_count_max = histogram.get(&letter);\n\
    \            letters_count_max_index = histogram.iter().position(|&(_, count)|\
    \ count == letters_count_max).unwrap();\n            letters_count_max_letter\
    \ = letter;\n        }\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmps9clguem.rs:27:13\n   |\n27 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n27 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmps9clguem.rs:27:51\n\
    \   |\n27 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps9clguem.rs:29:30\n   |\n29 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&char`, found `char`\n \
    \  |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmps9clguem.rs:32:37\n   |\n32 |  \
    \       if histogram.get(&letter) > letters_count_max {\n   |                \
    \                     ^^^^^^^^^^^^^^^^^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<&{integer}>`\n              found type\
    \ `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9clguem.rs:33:33\n\
    \   |\n33 |             letters_count_max = histogram.get(&letter);\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum\
    \ `Option`\n   |\n   = note: expected type `{integer}`\n              found enum\
    \ `Option<&{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9clguem.rs:34:66\n\
    \   |\n34 |             letters_count_max_index = histogram.iter().position(|&(_,\
    \ count)| count == letters_count_max).unwrap();\n   |                        \
    \                                          ^^^^^^^^^^-\n   |                 "
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9c8hsdq7.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9c8hsdq7.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    while letters_count_index < letters_count {\n        let letter = &letters[letters_count_index];\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n        letters_count_index += 1;\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw92i1lhz.rs:28:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_index2 = letters.clone();\n\
    \    let mut letters_repeated_count_index3 = letters.clone();\n    let mut letters_repeated_count_index4\
    \ = letters.clone();\n    let mut letters_repeated_count_index5 = letters.clone();\n\
    \    let mut letters_repeated_count_index6 = letters.clone();\n    let mut letters_repeated_count_index7\
    \ = letters.clone();\n    let mut letters_repeated_count_index8 = letters.clone();\n\
    \    let mut letters_repeated_count_index9 = letters.clone();\n    let mut letters_repeated_count_index10\
    \ = letters.clone();\n    let mut letters_repeated_count_index11 = letters.clone();\n\
    \    let mut letters_repeated_count_index12 = letters.clone();\n    let mut letters_repeated_count_index13\
    \ = letters.clone();\n    let mut letters_repeated_count_index14 = letters.clone();\n\
    \    let mut letters_repeated_count_index15 = letters.clone();\n    let mut letters_repeated_count_index16\
    \ = letters.clone();\n    let mut letters_repeated_count_index17 = letters.clone();\n\
    \    let mut letters_repeated_count_index18 = letters.clone();\n    let mut letters_repeated_count_index19\
    \ = letters.clone();\n    let mut letters_repeated_count_index20 = letters.clone();\n\
    \    let mut letters_repeated_count_index21 = letters.clone();\n    let mut letters_repeated_count_index22\
    \ = letters.clone();\n    let mut letters_repeated_count_index23 = letters.clone();\n\
    \    let mut letters_repeated_count_index24 = letters.clone();\n    let mut letters_repeated_count_index25\
    \ = letters.clone();\n    let mut letters_repeated_count_index26 = letters.clone();\n\
    \    let mut letters_repeated_count_index27 = letters.clone();\n    let mut letters_repeated_count_index28\
    \ = letters.clone();\n    let mut letters_repeated_count_index29 = letters.clone();\n\
    \    let mut letters_repeated_count_index30 = letters.clone();\n    let mut letters_repeated_count_index31\
    \ = letters.\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpph0j5kve.rs:54:1\n   |\n54\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpph0j5kve.rs:53:54\n\
    \   |\n53 |     let mut letters_repeated_count_index31 = letters.\n   |      \
    \                                                ^ help: add `;` here\n54 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpph0j5kve.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n\
    \    let mut letters_count_count = 0;\n    let mut letters_count_count_max = 0;\n\
    \    let mut letters_count_count_min = 0;\n    let mut letters_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count = 0;\n    let mut letters_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count = 0;\n \
    \   let mut letters_count_count_count_count_count_count_max = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count =\
    \ 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_min = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_sum = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_count = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_count\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpydt0enc1.rs:58:63\n   |\n\
    58 |     let mut letters_count_count_count_count_count_count_count_\n   |    \
    \                                                           ^ help: add `;` here\n\
    59 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpydt0enc1.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp9ybu0r5a.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let count = histogram.entry(word).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpn4t8lssh.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letter_count = 1;\n \
    \   let mut letter = String::from(\"\");\n    while let Some(letter) = letters.pop()\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n        letters_count\
    \ -= 1;\n        if letters_count == 0 {\n            histogram.insert(letter,\
    \ letter_count);\n            letter_count = 1;\n        }\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp5sdad2jb.rs:24:9\n   |\n24 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp5sdad2jb.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5sdad2jb.rs:31:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n31 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().filter_map(|c|\
    \ c.is_alphabetic()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqvk0z_g2.rs:19:47\n   |\n\
    19 |     for letter in test.chars().filter_map(|c| c.is_alphabetic()) {\n   |\
    \                                               ^^^^^^^^^^^^^^^^^\n   |      \
    \                                         |\n   |                            \
    \                   expected enum `Option`, found `bool`\n   |               \
    \                                help: try using a variant of the expected enum:\
    \ `Some(c.is_alphabetic())`\n   |\n   = note: expected enum `Option<_>`\n    \
    \          found type `bool`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split_whitespace();\n\
    \    for letter in letters {\n        if histogram.contains_key(&letter) {\n \
    \           histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n  \
    \          histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp95q0ea6p.rs:22:13\n   |\n22 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n22 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp95q0ea6p.rs:22:51\n\
    \   |\n22 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp95q0ea6p.rs:24:30\n   |\n24 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^ expected `&str`, found `str`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp95q0ea6p.rs:27:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n27 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&&str, {integer}>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_index = 0;\n    let mut letters_count_max_letter\
    \ = String::new();\n    for letter in letters {\n        if letters_count_max\
    \ < letters_count {\n            letters_count_max = letters_count;\n        \
    \    letters_count_max_index = letters.iter().position(|&letter| letter == letter).unwrap();\n\
    \            letters_count_max_letter = letter;\n        }\n        histogram.insert(letter,\
    \ letters_count);\n        letters_count -= 1;\n    }\n    histogram.insert(letters_count_max_letter,\
    \ letters_count_max);\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3jmafz2w.rs:28:40\n   |\n\
    28 |             letters_count_max_letter = letter;\n   |                    \
    \                    ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                        |\n   |                         \
    \               expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3jmafz2w.rs:33:22\n   |\n33 |     histogram.insert(letters_count_max_letter,\
    \ letters_count_max);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3jmafz2w.rs:34:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n34 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, usize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_count_iter = letters_count.iter();\n    let mut letters_count_iter2\
    \ = letters_count_iter.clone();\n    let mut letters_count_iter3 = letters_count_iter2.clone();\n\
    \    let mut letters_count_iter4 = letters_count_iter3.clone();\n    let mut letters_count_iter5\
    \ = letters_count_iter4.clone();\n    let mut letters_count_iter6 = letters_count_iter5.clone();\n\
    \    let mut letters_count_iter7 = letters_count_iter6.clone();\n    let mut letters_count_iter8\
    \ = letters_count_iter7.clone();\n    let mut letters_count_iter9 = letters_count_iter8.clone();\n\
    \    let mut letters_count_iter10 = letters_count_iter9.clone();\n    let mut\
    \ letters_count_iter11 = letters_count_iter10.clone();\n    let mut letters_count_iter12\
    \ = letters_count_iter11.clone();\n    let mut letters_count_iter13 = letters_count_iter12.clone();\n\
    \    let mut letters_count_iter14 = letters_count_iter13.clone();\n    let mut\
    \ letters_count_iter15 = letters_count_iter14.clone();\n    let mut letters_count_iter16\
    \ = letters_count_iter15.clone();\n    let mut letters_count_iter17 = letters_count_iter16.clone();\n\
    \    let mut letters_count_iter18 = letters_count_iter17.clone();\n    let mut\
    \ letters_count_iter19 = letters_count_iter18.clone();\n    let mut letters_count_iter20\
    \ = letters_count_iter19.clone();\n    let mut letters_count_iter21 = letters_count_iter20.clone();\n\
    \    let mut letters_count_iter22 = letters_count_iter21.clone();\n    let mut\
    \ letters_count_iter23 = letters_count_iter22.clone();\n    let mut letters_count_iter24\
    \ = letters_count_iter23.clone();\n    let mut letters_count_iter25 = letters_count_iter24.clone();\n\
    \    let mut letters_count_iter26 = letters_count_iter25.clone();\n    let mut\
    \ letters_count_iter27 = letters_count_iter26.clone();\n    let mut letters_count_iter28\
    \ = letters_count_iter27.clone();\n    let mut letters_count_iter29 = letters_count_iter28.clone();\n\
    \    let mut letters_count_iter30 = letters_count_iter29.\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpwrbp1ssq.rs:52:1\n   |\n52\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpwrbp1ssq.rs:51:57\n\
    \   |\n51 |     let mut letters_count_iter30 = letters_count_iter29.\n   |   \
    \                                                      ^ help: add `;` here\n\
    52 | }\n   | - unexpected token\n\nerror[E0599]: the method `count` exists for\
    \ struct `Vec<char>`, but its trait bounds were not satisfied\n   --> /tmp/tmpwrbp1ssq.rs:21:37\n\
    \    |\n21  |       let mut letters_count = letters.count();\n    |          \
    \                             ^^^^^ method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Vec<char>: Iterator`\n            which is required\
    \ by `&mut Vec<char>: Iterator`\n            `[char]: Iterator`\n            which\
    \ is required by `&mut [char]: Iterator`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpwrbp1ssq.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split_whitespace();\n\
    \    for letter in letters {\n        histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcoi1k5jw.rs:21:34\n   |\n\
    21 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpcoi1k5jw.rs:23:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n23 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = vec![];\n    while let Some(letter) = letters.pop() {\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n        counts.push(count);\n    }\n    histogram.into_iter().map(|(_, count)|\
    \ {\n        (String::from(&*letters[..count.0]), *count)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `{integer}` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpc6fzmji3.rs:27:41\n   |\n27 |         (String::from(&*letters[..count.0]),\
    \ *count)\n   |                                         ^\n\nerror[E0614]: type\
    \ `[char]` cannot be dereferenced\n  --> /tmp/tmpc6fzmji3.rs:27:24\n   |\n27 |\
    \         (String::from(&*letters[..count.0]), *count)\n   |                 \
    \       ^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmpc6fzmji3.rs:27:46\n   |\n27 |         (String::from(&*letters[..count.0]),\
    \ *count)\n   |                                              ^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0610, E0614.\nFor more information about an error, try `rustc --explain E0610`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    let mut letter = String::from(\"\");\n    while let\
    \ Some(letter) = letters.pop() {\n        if histogram.contains_key(&letter) {\n\
    \            histogram.entry(&letter).or_insert(count).unwrap();\n        } else\
    \ {\n            histogram.insert(letter, count);\n        }\n        count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for mutable reference `&mut\
    \ {integer}` in the current scope\n  --> /tmp/tmpkwfntjsk.rs:24:55\n   |\n24 |\
    \             histogram.entry(&letter).or_insert(count).unwrap();\n   |      \
    \                                                 ^^^^^^ method not found in `&mut\
    \ {integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkwfntjsk.rs:26:30\n\
    \   |\n26 |             histogram.insert(letter, count);\n   |               \
    \               ^^^^^^\n   |                              |\n   |            \
    \                  expected `&char`, found `char`\n   |                      \
    \        help: consider borrowing here: `&letter`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkwfntjsk.rs:30:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n30 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n\
    \    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_max = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8mpjly3v.rs:55:51\n   |\n\
    55 |     let mut letters_count_count_count_count_count_\n   |                \
    \                                   ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8mpjly3v.rs:17:31\n \
    \  |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split_whitespace();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter = String::from(\"\
    \");\n    let mut count = 0;\n    while let Some(letter) = letters_iter.next()\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).and_modify(|count|\
    \ {\n                *count += 1;\n            });\n        } else {\n       \
    \     histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp2j_0x3d8.rs:20:36\n   |\n20 |     let mut\
    \ letters_iter = letters.iter();\n   |                                    ^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2j_0x3d8.rs:29:30\n   |\n29 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              cyclic type of infinite size\n   |\
    \                              help: consider borrowing here: `&letter`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2j_0x3d8.rs:32:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n32 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&_,\
    \ {integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    let mut letters_count_max_index\
    \ = 0;\n    let mut letters_count_min = 0;\n    let mut letters_count_min_index\
    \ = 0;\n    let mut letters_count_sum = 0;\n    let mut letters_count_sum_index\
    \ = 0;\n    let mut letters_count_product = 1;\n    let mut letters_count_product_index\
    \ = 0;\n    let mut letters_count_product2 = 0;\n    let mut letters_count_product2_index\
    \ = 0;\n    let mut letters_count_product3 = 0;\n    let mut letters_count_product3_index\
    \ = 0;\n    let mut letters_count_product4 = 0;\n    let mut letters_count_product4_index\
    \ = 0;\n    let mut letters_count_product5 = 0;\n    let mut letters_count_product5_index\
    \ = 0;\n    let mut letters_count_product6 = 0;\n    let mut letters_count_product6_index\
    \ = 0;\n    let mut letters_count_product7 = 0;\n    let mut letters_count_product7_index\
    \ = 0;\n    let mut letters_count_product8 = 0;\n    let mut letters_count_product8_index\
    \ = 0;\n    let mut letters_count_product9 = 0;\n    let mut letters_count_product9_index\
    \ = 0;\n    let mut letters_count_product10 = 0;\n    let mut letters_count_product10_index\
    \ = 0;\n    let mut letters_count_product11 = 0;\n    let mut letters_count_product11_index\
    \ = 0;\n    let mut letters_count_product12 = 0;\n    let mut letters_count_product12_index\
    \ = 0;\n    let mut letters_count_product13 = 0;\n    let mut letters_count_product13_index\
    \ = 0;\n    let mut letters_count_product14 = 0;\n    let mut letters_count_product14_index\
    \ = 0;\n    let mut letters_count_product15 = 0;\n    let mut letters_count_product15_index\
    \ = 0;\n    let mut letters_count_product16 = 0;\n    let mut letters_count_product16_index\
    \ = 0;\n    let mut letters_count_product17 = 0;\n    let mut letters_count_product17_index\
    \ = 0;\n    let mut letters_count_product18 = 0;\n    let mut letters_count_product18_index\
    \ = 0;\n    let mut letters_count_product19 = 0;\n    let mut letters_count_product19_index\
    \ = 0;\n    let mut letters_count_product20 = 0;\n    let mut letters_\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm_trsbtx.rs:67:21\n   |\n\
    67 |     let mut letters_\n   |                     ^ help: add `;` here\n68 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm_trsbtx.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n  \
    \  }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpylloj1na.rs:23:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n23 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n    let mut letters_set = HashSet::new();\n\
    \    let mut letters_count = HashMap::new();\n    let mut letters_count_max =\
    \ 0;\n    let mut letters_count_max2 = 0;\n    let mut letters_count_max3 = 0;\n\
    \    let mut letters_count_max4 = 0;\n    let mut letters_count_max5 = 0;\n  \
    \  let mut letters_count_max6 = 0;\n    let mut letters_count_max7 = 0;\n    let\
    \ mut letters_count_max8 = 0;\n    let mut letters_count_max9 = 0;\n    let mut\
    \ letters_count_max10 = 0;\n    let mut letters_count_max11 = 0;\n    let mut\
    \ letters_count_max12 = 0;\n    let mut letters_count_max13 = 0;\n    let mut\
    \ letters_count_max14 = 0;\n    let mut letters_count_max15 = 0;\n    let mut\
    \ letters_count_max16 = 0;\n    let mut letters_count_max17 = 0;\n    let mut\
    \ letters_count_max18 = 0;\n    let mut letters_count_max19 = 0;\n    let mut\
    \ letters_count_max20 = 0;\n    let mut letters_count_max21 = 0;\n    let mut\
    \ letters_count_max22 = 0;\n    let mut letters_count_max23 = 0;\n    let mut\
    \ letters_count_max24 = 0;\n    let mut letters_count_max25 = 0;\n    let mut\
    \ letters_count_max26 = 0;\n    let mut letters_count_max27 = 0;\n    let mut\
    \ letters_count_max28 = 0;\n    let mut letters_count_max29 = 0;\n    let mut\
    \ letters_count_max30 = 0;\n    let mut letters_count_max31 = 0;\n    let mut\
    \ letters_count_max32 = 0;\n    let mut letters_count_max33 = 0;\n    let mut\
    \ letters_count_max34 = 0;\n    let mut letters_count_max35 = 0;\n    let mut\
    \ letters_count_max36 = 0;\n    let mut letters_count_max37 = 0;\n    let mut\
    \ letters_count_max38 = 0;\n    let mut letters_count_max39 = 0;\n    let mut\
    \ letters_count_max40 = 0;\n    let mut letters_count_max41 = 0;\n    let mut\
    \ letters_count_max42 = 0;\n    let mut letters_count_max43 = 0;\n    let mut\
    \ letters_count_max44 = 0;\n    let mut letters_count_max45 = 0;\n    let mut\
    \ letter\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0bksc3bg.rs:68:19\n   |\n\
    68 |     let mut letter\n   |                   ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmp0bksc3bg.rs:21:27\n   |\n21 |     let mut letters_set\
    \ = HashSet::new();\n   |                           ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0bksc3bg.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = letters_count.clone();\n    let mut letters_count_min = letters_count.clone();\n\
    \    let mut letters_count_sum = letters_count.clone();\n    let mut letters_count_product\
    \ = letters_count.clone();\n    let mut letters_count_quotient = letters_count.clone();\n\
    \n    while letters_count_sum != 0 {\n        letters_count_sum -= 1;\n      \
    \  letters_count_product *= letters_count_sum;\n        letters_count_quotient\
    \ /= letters_count_sum;\n    }\n\n    letters.sort_unstable_by_key(|&x| x.to_ascii_lowercase());\n\
    \n    for &letter in letters {\n        let letter = letter.to_ascii_lowercase();\n\
    \        let count = letters_count_product;\n        let count_max = letters_count_max;\n\
    \        let count_min = letters_count_min;\n        let count_sum = letters_count_sum;\n\
    \        let count_product = letters_count_product;\n        let count_quotient\
    \ = letters_count_quotient;\n\n        if count == count_max {\n            histogram.insert(letter,\
    \ count);\n        }\n\n        if count == count_min {\n            histogram.insert(letter,\
    \ count);\n        }\n\n        if count > count_sum {\n            histogram.insert(letter,\
    \ count);\n        }\n\n        if count < count_sum {\n            histogram.insert(letter,\
    \ count);\n        }\n\n        if count > count_quotient {\n            histogram.insert(letter,\
    \ count);\n        }\n\n        if count < count_quotient {\n            histogram.insert(letter,\
    \ count);\n        }\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps3sj_p1m.rs:35:9\n   |\n\
    35 |     for &letter in letters {\n   |         ^^^^^^^    ------- this expression\
    \ has type `char`\n   |         |\n   |         expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmps3sj_p1m.rs:69:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n69 |     histogram\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<String, isize>`\n \
    \             found struct `HashMap<_, usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_letter = String::new();\n    let mut letters_count_max_letter_count\
    \ = 0;\n\n    while let Some(letter) = letters.iter().next() {\n        if let\
    \ Some(count) = letters_count.remove(&letter) {\n            histogram.insert(String::from(letter),\
    \ count);\n            if count > letters_count_max {\n                letters_count_max\
    \ = count;\n                letters_count_max_letter = letter;\n             \
    \   letters_count_max_letter_count = count;\n            }\n        }\n    }\n\
    \n    if letters_count_max > 0 {\n        histogram.insert(\n            String::from(letters_count_max_letter),\n\
    \            letters_count_max_letter_count,\n        );\n    }\n\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp5gxzcbvb.rs:26:44\n   |\n26 |         if let Some(count)\
    \ = letters_count.remove(&letter) {\n   |                                    \
    \        ^^^^^^ method not found in `usize`\n\nerror[E0277]: the trait bound `String:\
    \ From<&char>` is not satisfied\n   --> /tmp/tmp5gxzcbvb.rs:27:30\n    |\n27 \
    \ |             histogram.insert(String::from(letter), count);\n    |        \
    \                      ^^^^^^^^^^^^ the trait `From<&char>` is not implemented\
    \ for `String`\n    |\n    = help: the following implementations were found:\n\
    \              <String as From<&String>>\n              <String as From<&mut str>>\n\
    \              <String as From<&str>>\n              <String as From<Box<str>>>\n\
    \            and 2 others\nnote: required by `from`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5gxzcbvb.rs:30:44\n   |\n30 |                 letters_count_max_letter\
    \ = letter;\n   |                                            ^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \                |\n   |                                            expected struct\
    \ `String`, found `&char`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n    let mut letter = String::from(\"\
    \");\n    let mut letter_count = isize::from(0);\n    let mut letter_index = isize::from(0);\n\
    \    while let Some(letter) = letters.next() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n        letter_counts.entry(letter).or_insert(0) += 1;\n        if letter_counts.entry(letter).or_insert(0)\
    \ > letter_count {\n            letter = String::from(\"\");\n            letter_count\
    \ = isize::from(0);\n            letter_index = isize::from(0);\n        }\n \
    \       letter_count += 1;\n        letter_index += 1;\n        letter = String::from(&letters[letter_index..]);\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp4dd20ac9.rs:24:38\n   |\n24 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut {integer}`\n  --> /tmp/tmp4dd20ac9.rs:25:9\n   |\n\
    25 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n25 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp4dd20ac9.rs:25:46\n\
    \   |\n25 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmp4dd20ac9.rs:26:9\n   |\n26 |         letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n26 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp4dd20ac9.rs:26:50\n\
    \   |\n26 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4dd20ac9.rs:27:55\n\
    \   |\n27 |         if letter_counts.entry(letter).or_insert(0) > letter_count\
    \ {\n   |                                                       ^^^^^^^^^^^^\n\
    \   |                                                       |\n  "
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = letters_count.clone();\n    let mut letters_count_min = letters_count.clone();\n\
    \    let mut letters_count_sum = letters_count.clone();\n    let mut letters_count_product\
    \ = letters_count.clone();\n    let mut letters_count_quotient = letters_count.clone();\n\
    \n    while letters_count_sum < letters_count_max {\n        letters_count_sum\
    \ += letters_count_product;\n        letters_count_product *= letters_count_quotient;\n\
    \        letters_count_quotient = letters_count_sum / letters_count_max;\n   \
    \ }\n\n    letters.sort_unstable_by_key(|&x| x.to_ascii_lowercase());\n    for\
    \ letter in letters {\n        let count = letters_count_product;\n        histogram.insert(letter,\
    \ count);\n        letters_count_product /= letters_count_max;\n        letters_count_max\
    \ /= letters_count_max;\n        letters_count_min = (letters_count_min * letters_count_max)\
    \ / letters_count_sum;\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxtbldge9.rs:42:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n42 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, usize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = letters.iter().cloned().count();\n        histogram.insert(word.to_string(),\
    \ count);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgx9zv93f.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n      \
    \        found struct `HashMap<_, usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      histogram.entry(c.to_string()).or_insert(0) += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpuhffy72a.rs:20:9\n   |\n20 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpuhffy72a.rs:20:53\n\
    \   |\n20 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter = String::from(\"\
    \");\n    let mut count = 0;\n    while let Some(letter) = letters_iter.next()\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmppj4rpf5o.rs:25:13\n   |\n25 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n25 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmppj4rpf5o.rs:25:51\n\
    \   |\n25 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppj4rpf5o.rs:27:30\n   |\n27 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^ expected `&char`, found `char`\n\
    \   |\n   = note: expected reference `&&char`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppj4rpf5o.rs:30:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&&char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&&char, {integer}>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    let mut letter = String::from(\"\");\n    while let\
    \ Some(letter) = letters.pop() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n        if histogram.contains_key(&letter) {\n            count += 1;\n\
    \        }\n    }\n    histogram.insert(String::from(\"\"), count);\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpizx6237h.rs:23:9\n   |\n23 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpizx6237h.rs:23:46\n\
    \   |\n23 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpizx6237h.rs:28:22\n   |\n28 |     histogram.insert(String::from(\"\
    \"), count);\n   |                      ^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpizx6237h.rs:29:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n29 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = letters_count.clone();\n    let mut letters_count_min = letters_count.clone();\n\
    \n    while letters_count != 0 {\n        let mut letter = letters.iter().cloned().next().unwrap();\n\
    \        let mut count = letters_count.clone();\n        while count != 0 {\n\
    \            if letters_count_max < count {\n                letters_count_max\
    \ = count;\n                letter = letters.iter().cloned().next().unwrap();\n\
    \            }\n            count -= 1;\n        }\n        histogram.insert(letter,\
    \ letters_count_max);\n        letters_count_min.swap(letters_count_max);\n  \
    \      letters_count_max.swap(0);\n        letters_count.swap(0);\n    }\n   \
    \ histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp9irlddl9.rs:35:27\n   |\n35 |         letters_count_min.swap(letters_count_max);\n\
    \   |                           ^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `swap` found for type `usize` in the current scope\n  --> /tmp/tmp9irlddl9.rs:36:27\n\
    \   |\n36 |         letters_count_max.swap(0);\n   |                         \
    \  ^^^^ method not found in `usize`\n\nerror[E0599]: no method named `swap` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmp9irlddl9.rs:37:23\n   |\n\
    37 |         letters_count.swap(0);\n   |                       ^^^^ method not\
    \ found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9irlddl9.rs:39:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n39 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, usize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_repeated\
    \ = letters.iter().cloned().filter(|&x| histogram.contains_key(&x)).count();\n\
    \    while letters_count > 0 {\n        let mut letter = letters.iter().cloned().filter(|&x|\
    \ histogram.contains_key(&x)).count();\n        if letter > letters_count {\n\
    \            letters_count = letter;\n        }\n        histogram.insert(letters.iter().cloned().filter(|&x|\
    \ histogram.contains_key(&x)).collect::<Vec<_>>().to_owned()[0], letters_count);\n\
    \        letters_count -= letter;\n        letters_repeated -= letter;\n     \
    \   letters = letters.iter().cloned().filter(|&x| !histogram.contains_key(&x)).collect::<Vec<_>>();\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsim647k3.rs:32:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n32 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, usize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      if histogram.contains_key(&c.to_string()) {\n            histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(c.to_string(), 1);\n \
    \       }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp12r4idcd.rs:21:13\n   |\n21 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             -------------------------------------------^^^^^\n \
    \  |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n21 |             *histogram.entry(c.to_string()).or_insert(0) += 1;\n \
    \  |             +\n\nerror[E0067]: invalid left-hand side of assignment\n  -->\
    \ /tmp/tmp12r4idcd.rs:21:57\n   |\n21 |             histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |             ------------------------------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_occurrences\
    \ = letters.iter().cloned().fold(0, |acc, &x| acc + 1);\n    let mut letters_occurrences_max\
    \ = letters_occurrences.clone();\n    let mut letters_occurrences_max_index =\
    \ letters.iter().cloned().enumerate().find(|&(_, x)| x == letters_occurrences.clone()).unwrap();\n\
    \    while letters_occurrences_max_index != letters.len() {\n        let mut letters_occurrences_max_value\
    \ = letters_occurrences.clone();\n        let mut letters_occurrences_max_index\
    \ = letters.iter().cloned().enumerate().find(|&(_, x)| x == letters_occurrences_max_value.clone()).unwrap();\n\
    \        while letters_occurrences_max_index != letters.len() {\n            let\
    \ mut letters_occurrences_max_value = letters_occurrences.clone();\n         \
    \   let mut letters_occurrences_max_index = letters.iter().cloned().enumerate().find(|&(_,\
    \ x)| x == letters_occurrences_max_value.clone()).unwrap();\n            while\
    \ letters_occurrences_max_index != letters.len() {\n                let mut letters_occurrences_max_value\
    \ = letters_occurrences.clone();\n                let mut letters_occurrences_max_index\
    \ = letters.iter().cloned().enumerate().find(|&(_, x)| x == letters_occurrences_max_value.clone()).unwrap();\n\
    \                while letters_occurrences_max_index != letters.len() {\n    \
    \                let mut letters_occurrences_max_value = letters_occurrences.clone();\n\
    \                    let mut letters_occurrences_max_index = letters.iter().cloned().enumerate().find(|&(_,\
    \ x)| x == letters_occurrences_max_value.clone()).unwrap();\n                \
    \    while letters_occurrences_max_index != letters.len() {\n                \
    \        let mut letters_occurrences_max_value = letters_occurrences.clone();\n\
    \                        let mut letters_occurrences_max_index = letters.iter().cloned().enumerate().find(|&(_,\
    \ x)| x == letters_occurrences_max_value.clone()).unwrap();\n                \
    \        while letters_occurrences_max_index != letters.len() {\n            \
    \                let mut letters_occurrences_max_value = letters_occurrences.clone();\n\
    \                            let mut letters_occurrences_max_index = letters.iter().cloned().enumerate().find(|&(_,\
    \ x)| x == letters_occurrences_max_\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmphqj0gz8x.rs:54:3\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                                                 - unclosed delimiter\n...\n\
    24 |     while letters_occurrences_max_index != letters.len() {\n   |        \
    \                                                  - unclosed delimiter\n...\n\
    27 |         while letters_occurrences_max_index != letters.len() {\n   |    \
    \                                                          - unclosed delimiter\n\
    ...\n30 |             while letters_occurrences_max_index != letters.len() {\n\
    \   |                                                                  - unclosed\
    \ delimiter\n...\n33 |                 while letters_occurrences_max_index !=\
    \ letters.len() {\n   |                                                      \
    \                - unclosed delimiter\n...\n36 |                     while letters_occurrences_max_index\
    \ != letters.len() {\n   |                                                   \
    \                       - unclosed delimiter\n...\n39 |                      \
    \   while letters_occurrences_max_index != letters.len() {\n   |             \
    \                                                                 - this delimiter\
    \ might not be properly closed...\n...\n42 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n54 | }\n   |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmphqj0gz8x.rs:41:109\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                                  \
    \                    - closing delimiter possibly meant for this\n...\n41 |  \
    \                           let mut letters_occurrences_max_index = letters.iter().cloned().enumerate().find(|&(_,\
    \ x)| x == letters_occur...\n   |                                            \
    \                                                                 ^ unclosed delimiter\n\
    42 | }\n   | ^ mismatched closing delimiter\n\nerror: expected one of `.`, `;`,\
    \ `?`, `else`, or an operator, found `}`\n  --> /tmp/tmphqj0gz8x.rs:42:1\n   |\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut counts = letters.iter().cloned().map(|c|\
    \ histogram.entry(c).or_insert(0));\n    counts.sort_by_key(|&(_, count)| count.cmp(&counts.last()));\n\
    \    histogram.into_iter().map(|(_, count)| {\n        let mut letter = String::from(\"\
    \");\n        let mut count = count.clone();\n        histogram.entry(letter).and_modify(|count|\
    \ {\n            count += count;\n        });\n        (letter, count)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpwyh6kv6v.rs:21:12\n   |\n21 |     counts.sort_by_key(|&(_,\
    \ count)| count.cmp(&counts.last()));\n   |            ^^^^^^^^^^^ method not\
    \ found in `Map<Cloned<std::slice::Iter<'_, String>>, [closure@/tmp/tmpwyh6kv6v.rs:20:50:\
    \ 20:85]>`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut {integer}`\n  --> /tmp/tmpwyh6kv6v.rs:26:13\n   |\n26 |      \
    \       count += count;\n   |             -----^^^^^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `&mut {integer}`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0368, E0599.\n\
    For more information about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = Vec::new();\n    let mut letter = String::new();\n    let\
    \ mut count = 1;\n    let mut i = 0;\n    while i < letters.len() {\n        letter\
    \ = letters[i].to_string();\n        if histogram.contains_key(&letter) {\n  \
    \          histogram.entry(&letter).and_modify(|x| *x += 1);\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n        counts.push(count);\n\
    \        i += 1;\n        count += 1;\n    }\n    histogram\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdpfedp9r.rs:29:30\n   |\n\
    29 |             histogram.insert(letter, 1);\n   |                          \
    \    ^^^^^^\n   |                              |\n   |                       \
    \       expected `&String`, found struct `String`\n   |                      \
    \        help: consider borrowing here: `&letter`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdpfedp9r.rs:35:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n35 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&String`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&String,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0)).collect::<Vec<_>>();\n\
    \    let mut letters_count = letters_count.iter().cloned().map(|c| c + 1).collect::<Vec<_>>();\n\
    \    while let Some(count) = letters_count.iter().max().cloned() {\n        for\
    \ &(letter, count) in histogram.iter() {\n            if count == count {\n  \
    \              histogram.remove(&letter);\n            }\n        }\n    }\n \
    \   histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `&mut {integer}: Clone` is not satisfied\n\
    \  --> /tmp/tmp0f0d241j.rs:21:50\n   |\n21 |     let mut letters_count = letters_count.iter().cloned().map(|c|\
    \ c + 1).collect::<Vec<_>>();\n   |                                          \
    \        ^^^^^^ the trait `Clone` is not implemented for `&mut {integer}`\n  \
    \ |\n   = help: the following implementations were found:\n             <! as\
    \ Clone>\n             <&T as Clone>\n             <*const T as Clone>\n     \
    \        <*mut T as Clone>\n           and 1076 others\n\nerror[E0599]: the method\
    \ `map` exists for struct `Cloned<std::slice::Iter<'_, &mut {integer}>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmp0f0d241j.rs:21:59\n   |\n\
    21 |       let mut letters_count = letters_count.iter().cloned().map(|c| c + 1).collect::<Vec<_>>();\n\
    \   |                                                             ^^^ method cannot\
    \ be called on `Cloned<std::slice::Iter<'_, &mut {integer}>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `Cloned<std::slice::Iter<'_, &mut {integer}>>: Iterator`\n       \
    \    which is required by `&mut Cloned<std::slice::Iter<'_, &mut {integer}>>:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0f0d241j.rs:23:13\n\
    \   |\n23 |         for &(letter, count) in histogram.iter() {\n   |         \
    \    ^^^^^^^^^^^^^^^^    ---------------- this expression has type `(&char, &{integer})`\n\
    \   |             |\n   |             expected tuple, found reference\n   |\n\
    \   = note:  expected tuple `(&char, &{integer})`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0f0d241j.rs:29:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n29 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to 4 pre"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = letters_count;\n    let mut letters_count_sum\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = letters_count_max;\n    let mut letters_count_count_sum = 0;\n    let mut\
    \ letters_count_count_count_max = 0;\n    let mut letters_count_count_count_min\
    \ = letters_count_count_max;\n    let mut letters_count_count_count_sum = 0;\n\
    \    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_max;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = letters_count_count_count_max;\n\
    \    let mut letters_count_count_count_count_min = letters_count_count_count_count_max;\n\
    \    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_max\
    \ = letters_count_count_count_count_max;\n    let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_count_count_max;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = letters_count_count_count_count_max;\n\
    \    let mut letters_count_count_count_count_min = letters_count_count_count_count_max;\n\
    \    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_max\
    \ = letters_count_count_count_count_max;\n    let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_count_max;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = letters_count_count_count_count_max;\n\
    \    let mut letters_count_count_count_count_min = letters_count_count_count_count_max;\n\
    \    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_max\
    \ = letters_count_count_count_count_max;\n    let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_count_max;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = letters_count_count_count_count_max;\n\
    \    let mut letters_count_count_count_count_min = letters_\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxis6jyqh.rs:52:59\n   |\n\
    52 |     let mut letters_count_count_count_count_min = letters_\n   |        \
    \                                                   ^ help: add `;` here\n53 |\
    \ }\n   | - unexpected token\n\nerror[E0425]: cannot find value `letters_count_count_count_count_count_max`\
    \ in this scope\n  --> /tmp/tmpxis6jyqh.rs:37:51\n   |\n37 |     let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_count_count_max;\n   |                         \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `letters_count_count_count_count_max`\n\
    \nerror[E0425]: cannot find value `letters_` in this scope\n  --> /tmp/tmpxis6jyqh.rs:52:51\n\
    \   |\n52 |     let mut letters_count_count_count_count_min = letters_\n   | \
    \                                                  ^^^^^^^^ help: a local variable\
    \ with a similar name exists: `letters`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxis6jyqh.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().filter_map(|c|\
    \ c.is_alphabetic()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqvk0z_g2.rs:19:47\n   |\n\
    19 |     for letter in test.chars().filter_map(|c| c.is_alphabetic()) {\n   |\
    \                                               ^^^^^^^^^^^^^^^^^\n   |      \
    \                                         |\n   |                            \
    \                   expected enum `Option`, found `bool`\n   |               \
    \                                help: try using a variant of the expected enum:\
    \ `Some(c.is_alphabetic())`\n   |\n   = note: expected enum `Option<_>`\n    \
    \          found type `bool`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_max_index = 0;\n    let mut letters_count_max_letter\
    \ = String::new();\n    let mut letters_count_max_letter_count = 0;\n    let mut\
    \ letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_index = -1;\n\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplo7a62sq.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_index = 0;\n    let mut letters_count_min\
    \ = 0;\n    let mut letters_count_min_index = 0;\n    let mut letters_count_sum\
    \ = 0;\n    let mut letters_count_sum_index = 0;\n    let mut letters_count_product\
    \ = 1;\n    let mut letters_count_product_index = 0;\n    let mut letters_count_quotient\
    \ = 1;\n    let mut letters_count_quotient_index = 0;\n    let mut letters_count_quotient_product\
    \ = 1;\n    let mut letters_count_quotient_product_index = 0;\n    let mut letters_count_quotient_quotient\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_product\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_quotient\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_quotient_product\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_quotient_quotient\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_quotient_quotient_product\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_quotient_quotient_quotient\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_quotient_quotient_quotient\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_quotient_quotient_quotient_product\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_quotient_quotient_quotient_quotient\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_quotient_quotient_quotient_quotient_product\
    \ = 1;\n    let mut letters_count_quotient_quotient_index = 0;\n    let mut letters_count_quotient_quotient_quotient_quotient_quotient_quotient_quotient\
    \ = 1;\n    let \n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpe6yd5bw9.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_max_index = 0;\n    let mut letters_count_min = 0;\n\
    \    let mut letters_count_min_index = 0;\n\n    while letters_count > 0 {\n \
    \       let mut letter = letters.remove(0);\n        let mut count = histogram.entry(letter).or_insert(0);\n\
    \        count += 1;\n        if count > letters_count_max {\n            letters_count_max\
    \ = count;\n            letters_count_max_index = letter;\n        }\n       \
    \ if count < letters_count_min {\n            letters_count_min = count;\n   \
    \         letters_count_min_index = letter;\n        }\n        letters_count\
    \ -= 1;\n    }\n\n    histogram.entry(letters_count_max_index).or_insert(letters_count_max)\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp0unbcbtu.rs:29:9\n   |\n29 |         count +=\
    \ 1;\n   |         -----^^^^^\n   |         |\n   |         cannot use `+=` on\
    \ type `&mut {integer}`\n   |\nhelp: `+=` can be used on `{integer}`, you can\
    \ dereference `count`\n   |\n29 |         *count += 1;\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0unbcbtu.rs:30:20\n   |\n30 |         if count\
    \ > letters_count_max {\n   |                    ^^^^^^^^^^^^^^^^^\n   |     \
    \               |\n   |                    expected `&mut _`, found integer\n\
    \   |                    help: consider mutably borrowing here: `&mut letters_count_max`\n\
    \   |\n   = note: expected mutable reference `&mut _`\n                      \
    \     found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0unbcbtu.rs:31:33\n\
    \   |\n31 |             letters_count_max = count;\n   |                     \
    \            ^^^^^ expected integer, found `&mut {integer}`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n31 |             letters_count_max = *count;\n\
    \   |                                 +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0unbcbtu.rs:32:39\n   |\n32 |             letters_count_max_index =\
    \ letter;\n   |                                       ^^^^^^ expected integer,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0unbcbtu.rs:34:20\n\
    \   |\n34 |         if count < letters_count_min {\n   |                    ^^^^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&mut _`, found integer\n\
    \   |                    help: consider mutably borrowing here: `&mut letters_count_min`\n\
    \   |\n   = note: expected mutable reference `&mut _`\n                      \
    \     found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0unbcbtu.rs:35:33\n\
    \   |\n35 |             letters_count_min = count;\n   |                     \
    \            ^^^^^ expected integer, found `&mut {integer}`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n35 |             letters_count_min = *count;\n\
    \   |  "
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = 1;\n        for letter in letters {\n            histogram.entry(letter).or_insert(count).cloned()\
    \ += 1;\n            count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for mutable reference `&mut {integer}`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpi87u4our.rs:24:54\n \
    \  |\n24 |             histogram.entry(letter).or_insert(count).cloned() += 1;\n\
    \   |                                                      ^^^^^^ method cannot\
    \ be called on `&mut {integer}` due to unsatisfied trait bounds\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `{integer}: Iterator`\n\
    \           which is required by `&mut {integer}: Iterator`\n           `&mut\
    \ {integer}: Iterator`\n           which is required by `&mut &mut {integer}:\
    \ Iterator`\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpi87u4our.rs:24:63\n\
    \   |\n24 |             histogram.entry(letter).or_insert(count).cloned() += 1;\n\
    \   |             ------------------------------------------------- ^^\n   | \
    \            |\n   |             cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi87u4our.rs:28:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n28 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_letter = String::new();\n    let mut letters_count_max_letter_count\
    \ = 0;\n\n    while let Some(letter) = letters.iter().next() {\n        if letters_count_max\
    \ < letters_count {\n            letters_count_max = letters_count;\n        \
    \    letters_count_max_letter = letter;\n            letters_count_max_letter_count\
    \ = letters_count_max;\n        }\n\n        histogram.entry(letter).or_insert(0);\n\
    \        histogram.entry(letter).unwrap() += 1;\n        letters_count -= 1;\n\
    \    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwpg8ctyj.rs:28:40\n   |\n\
    28 |             letters_count_max_letter = letter;\n   |                    \
    \                    ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                        |\n   |                         \
    \               expected struct `String`, found `&char`\n\nerror[E0599]: no method\
    \ named `unwrap` found for enum `std::collections::hash_map::Entry` in the current\
    \ scope\n  --> /tmp/tmpwpg8ctyj.rs:33:33\n   |\n33 |         histogram.entry(letter).unwrap()\
    \ += 1;\n   |                                 ^^^^^^ method not found in `std::collections::hash_map::Entry<'_,\
    \ &char, {integer}>`\n\nerror[E0067]: invalid left-hand side of assignment\n \
    \ --> /tmp/tmpwpg8ctyj.rs:33:42\n   |\n33 |         histogram.entry(letter).unwrap()\
    \ += 1;\n   |         -------------------------------- ^^\n   |         |\n  \
    \ |         cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwpg8ctyj.rs:37:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n37 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0067, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = Vec::new();\n    let mut letter = String::new();\n    let\
    \ mut letter_count = 0;\n    let mut letter_index = 0;\n    while letter_index\
    \ < letters.len() {\n        letter = letters[letter_index].to_string();\n   \
    \     if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \        counts.push(histogram.get(&letter).unwrap());\n        letter_index +=\
    \ 1;\n    }\n    histogram.into_iter().map(|(_, count)| {\n        (String::from(\"\
    \"), count)\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpuvgjfvsm.rs:27:13\n   |\n27 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n27 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpuvgjfvsm.rs:27:51\n\
    \   |\n27 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuvgjfvsm.rs:29:30\n   |\n29 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&String`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&letter`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        if histogram.contains_key(&word)\
    \ {\n            histogram.entry(word).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(word, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpb5jmcnli.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpb5jmcnli.rs:22:13\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ----------------------------------^^^^^\n   |             |\n   |     \
    \        cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `histogram.entry(word).or_insert(0)`\n \
    \  |\n22 |             *histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpb5jmcnli.rs:22:48\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let mut occurrences = histogram.entry(letters.clone()).or_insert(0);\n\
    \        *occurrences += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3rtr4oda.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split_whitespace();\n\
    \    for letter in letters {\n        if histogram.contains_key(letter) {\n  \
    \          histogram.entry(letter).and_modify(|count| count += 1);\n        }\
    \ else {\n            histogram.insert(letter, 1);\n        }\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut _`\n  --> /tmp/tmp989xrpcl.rs:22:56\n   |\n22 |             histogram.entry(letter).and_modify(|count|\
    \ count += 1);\n   |                                                        -----^^^^^\n\
    \   |                                                        |\n   |         \
    \                                               cannot use `+=` on type `&mut\
    \ _`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp989xrpcl.rs:27:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n27 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&str, {integer}>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n  \
    \  }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpylloj1na.rs:23:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n23 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n\n    while let Some(letter) = letters.iter().next()\
    \ {\n        if let Some(count) = letter_counts.entry(letter).or_insert(0) {\n\
    \            *count += 1;\n        }\n    }\n\n    for entry in letter_counts.iter()\
    \ {\n        if let Some(count) = entry.value {\n            histogram.insert(entry.key.to_string(),\
    \ count);\n        }\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0twd5pg_.rs:23:16\n   |\n\
    23 |         if let Some(count) = letter_counts.entry(letter).or_insert(0) {\n\
    \   |                ^^^^^^^^^^^   ---------------------------------------- this\
    \ expression has type `&mut {integer}`\n   |                |\n   |          \
    \      expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<_>`\n\nerror[E0609]: no field `value` on type\
    \ `(&&char, &{integer})`\n  --> /tmp/tmp0twd5pg_.rs:29:36\n   |\n29 |        \
    \ if let Some(count) = entry.value {\n   |                                   \
    \ ^^^^^\n\nerror[E0609]: no field `key` on type `(&&char, &{integer})`\n  -->\
    \ /tmp/tmp0twd5pg_.rs:30:36\n   |\n30 |             histogram.insert(entry.key.to_string(),\
    \ count);\n   |                                    ^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp9ybu0r5a.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp9ybu0r5a.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = Vec::new();\n    let mut letter = String::new();\n    let\
    \ mut count = 0;\n    while let Some(letter) = letters.next() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n        counts.push((letter, histogram.entry(letter).or_insert(0)));\n\
    \    }\n    histogram.sort_by(|a, b| b.1.cmp(&a.1));\n    histogram.into_iter().map(|(_,\
    \ count)| count).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp0vxpbnvr.rs:23:38\n   |\n23 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut {integer}`\n  --> /tmp/tmp0vxpbnvr.rs:24:9\n   |\n\
    24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp0vxpbnvr.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `HashMap` in the current scope\n\
    \  --> /tmp/tmp0vxpbnvr.rs:27:15\n   |\n27 |     histogram.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \   |               ^^^^^^^ method not found in `HashMap<_, {integer}>`\n\nerror[E0277]:\
    \ a value of type `HashMap<String, isize>` cannot be built from an iterator over\
    \ elements of type `{integer}`\n  --> /tmp/tmp0vxpbnvr.rs:28:51\n   |\n28 |  \
    \   histogram.into_iter().map(|(_, count)| count).collect()\n   |            \
    \                                       ^^^^^^^ value of type `HashMap<String,\
    \ isize>` cannot be built from `std::iter::Iterator<Item={integer}>`\n   |\n \
    \  = help: the trait `FromIterator<{integer}>` is not implemented for `HashMap<String,\
    \ isize>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0067, E0277, E0368, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    let mut current_letter = String::new();\n\
    \    let mut current_count = 1;\n    while let Some(letter) = letters.pop() {\n\
    \        if let Some(count) = counts.remove(&letter) {\n            counts.insert(letter,\
    \ count + current_count);\n        } else {\n            counts.insert(letter,\
    \ current_count);\n        }\n        current_letter = letter;\n        current_count\
    \ += 1;\n    }\n    histogram.insert(current_letter, current_count);\n    histogram.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpol1d_8fy.rs:29:26\n   |\n\
    29 |         current_letter = letter;\n   |                          ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split_whitespace();\n\
    \    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsn005hkw.rs:24:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n24 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&str, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n    let mut letters_with_repetition\
    \ = Vec::new();\n\n    // Count how many times each letter appears\n    while\
    \ let Some(letter) = letters.pop() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n        letter_counts.entry(letter).or_insert(0) += 1;\n    }\n\n   \
    \ // Keep track of letters with more than one occurrence\n    while let Some(letter)\
    \ = letters.pop() {\n        if histogram.get(letter).is_some() > 1 {\n      \
    \      letters_with_repetition.push(letter);\n        }\n    }\n\n    // Return\
    \ all letters with more than one occurrence\n    if letters_with_repetition.is_empty()\
    \ {\n        histogram.clone()\n    } else {\n        let mut letters_with_repetition_map\
    \ = HashMap::new();\n        for letter in letters_with_repetition {\n       \
    \     letters_with_repetition_map.entry(letter).or_insert(0) += 1;\n        }\n\
    \        histogram.merge(letters_with_repetition_map)\n    }\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp829vnzrn.rs:25:9\n   |\n25 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n25 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp829vnzrn.rs:25:46\n\
    \   |\n25 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmp829vnzrn.rs:26:9\n   |\n26 |         letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n26 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp829vnzrn.rs:26:50\n\
    \   |\n26 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp829vnzrn.rs:31:26\n\
    \   |\n31 |         if histogram.get(letter).is_some() > 1 {\n   |           \
    \               ^^^^^^\n   |                          |\n   |                \
    \          expected `&char`, found `char`\n   |                          help:\
    \ consider borrowing here: `&letter`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp829vnzrn.rs:31:46\n   |\n31 |         if histogram.get(letter).is_some()\
    \ > 1 {\n   |                                              ^ expected `bool`,\
    \ found integer\n\ner"
  stdout: ''
  timestamp: 1659748965
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    let mut letter = String::new();\n    for _ in 0..letters.len()\
    \ {\n        histogram.insert(letter, count);\n        count += 1;\n        letter\
    \ = String::new();\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"\": 7}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpcce9dvln.rs:32:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut letters_count = HashMap::new();\n\
    \    for letter in test.chars().map(|c| c.to_string()) {\n        letters.entry(letter).or_insert(0)\
    \ += 1;\n        letters_count.entry(letter).or_insert(0) += 1;\n    }\n    letters.into_iter().max_by_key(|&(_,\
    \ count)| count).map(|(_, count)| letters.entry(count).or_insert(0)).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpcna3gbnt.rs:21:9\n   |\n21 |         letters.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `letters.entry(letter).or_insert(0)`\n\
    \   |\n21 |         *letters.entry(letter).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcna3gbnt.rs:21:44\n\
    \   |\n21 |         letters.entry(letter).or_insert(0) += 1;\n   |         ----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmpcna3gbnt.rs:22:9\n   |\n22 |         letters_count.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letters_count.entry(letter).or_insert(0)`\n\
    \   |\n22 |         *letters_count.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcna3gbnt.rs:22:50\n\
    \   |\n22 |         letters_count.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcna3gbnt.rs:24:88\n\
    \   |\n24 |     letters.into_iter().max_by_key(|&(_, count)| count).map(|(_, count)|\
    \ letters.entry(count).or_insert(0)).collect()\n   |                         \
    \                                                               ^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \                                                            |\n   |         \
    \                                                                            \
    \   expected struct "
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut counts = letters.iter().cloned().map(|c|\
    \ histogram.entry(c).or_insert(0));\n    counts.fold(histogram, |mut acc, c| {\n\
    \        acc.entry(c.clone()).and_modify(|e| *e += 1);\n        acc\n    });\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8q6dbwrx.rs:22:19\n   |\n\
    22 |         acc.entry(c.clone()).and_modify(|e| *e += 1);\n   |             \
    \      ^^^^^^^^^\n   |                   |\n   |                   expected struct\
    \ `String`, found integer\n   |                   help: try using a conversion\
    \ method: `c.to_string()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwb32h02_.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = letters_count.clone();\n    let mut letters_count_min = letters_count.clone();\n\
    \    let mut letters_count_sum = 0;\n    let mut letters_count_count_max = 0;\n\
    \    let mut letters_count_count_min = 0;\n    let mut letters_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_max = 0;\n    let mut letters_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_max = 0;\n    let mut\
    \ letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_min = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_sum = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_sum = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_count_sum = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp8kmrylq8.rs:56:1\n\
    \   |\n56 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters_iter.enumerate().filter_map(|(i,\
    \ c)| {\n        if *c != ' ' {\n            Some((c, i))\n        } else {\n\
    \            None\n        }\n    });\n    let mut letters_iter = letters_iter.map(|(_,\
    \ c)| c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.enumerate().filter_map(|(i, c)| {\n        if *c != ' ' {\n \
    \           Some((c, i))\n        } else {\n            None\n        }\n    });\n\
    \    let mut letters_iter = letters_iter.map(|(_, c)| c.to_string());\n    let\
    \ mut letters_iter = letters_iter.collect::<Vec<_>>();\n    let mut letters_iter\
    \ = letters_iter.into_iter();\n    let mut letters_iter = letters_iter.enumerate().filter_map(|(i,\
    \ c)| {\n        if *c != ' ' {\n            Some((c, i))\n        } else {\n\
    \            None\n        }\n    });\n    let mut letters_iter = letters_iter.map(|(_,\
    \ c)| c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.enumerate().filter_map(|(i, c)| {\n        if *c != ' ' {\n \
    \           Some((c, i))\n        } else {\n            None\n        }\n    });\n\
    \    let mut letters_iter = letters_iter.map(|(_, c)| c.to_string());\n    let\
    \ mut letters_iter = letters_iter.collect::<Vec<_>>();\n    let mut letters_iter\
    \ = letters_iter.into_iter();\n    let mut letters_iter = letters_iter.enumerate().filter_map(|(i,\
    \ c)| {\n        if *c != ' ' {\n            Some((c, i))\n        } else {\n\
    \            None\n        }\n    });\n    let mut letters_iter = letters_iter.map(|(_,\
    \ c)| c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.enumerate().filter_map(|(i, c)| {\n\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7i0d3x43.rs:85:3\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                                                 - unclosed delimiter\n...\n\
    71 |     let mut letters_iter = letters_iter.enumerate().filter_map(|(i, c)| {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n85 | }\n   |   ^\n\nerror: expected one of `)`, `,`, `.`, `?`,\
    \ or an operator, found keyword `fn`\n  --> /tmp/tmp7i0d3x43.rs:75:1\n   |\n73\
    \ | }\n   |  - expected one of `)`, `,`, `.`, `?`, or an operator\n74 | \n75 |\
    \ fn main() {\n   | ^^ unexpected token\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        histogram.insert(letters.iter().max().unwrap().to_string(), letters.iter().count());\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr09p2dxc.rs:24:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n24 |     histogram\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n      \
    \        found struct `HashMap<_, usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    let mut letters_count_index2 = 0;\n\
    \    let mut letters_count_max2 = 0;\n    while letters_count_index != letters_count\
    \ {\n        let letter = &letters[letters_count_index];\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n        letters_count_index\
    \ += 1;\n        if letters_count_index == letters_count {\n            letters_count_index\
    \ = 0;\n        }\n    }\n    while letters_count_index2 != letters_count {\n\
    \        let letter = &letters[letters_count_index2];\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n        letters_count_index2\
    \ += 1;\n        if letters_count_index2 == letters_count {\n            letters_count_index2\
    \ = 0;\n        }\n    }\n    while letters_count_index != letters_count {\n \
    \       let letter = &letters[letters_count_index];\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n        letters_count_index\
    \ += 1;\n        if letters_count_index == letters_count {\n            letters_count_index\
    \ = 0;\n        }\n    }\n    while letters_count_index2 != letters_count {\n\
    \        let letter = &letters[letters_count_index2];\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n        letters_count_index2\
    \ += 1;\n        if letters_count_index2 == letters_count {\n            letters_count_index2\
    \ = 0;\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp6bkm4zqb.rs:28:13\n   |\n28 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n28 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp6bkm4zqb.rs:28:51\n\
    \   |\n28 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6bkm4zqb.rs:30:30\n   |\n30 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^ expected `&char`, found `char`\n\
    \   |\n   = note: expected reference `&&char`\n              found reference `&char`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ {integer}`\n  --> /tmp/tmp6bkm4zqb.rs:40:13\n   |\n40 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n40 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp6bkm4zqb.rs:40:51\n\
    \   |\n40 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6bkm4zqb.rs:42:30\n   |\n42 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^ expected `&char`, found `char`\n\
    \   |\n  "
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = vec![];\n    while let Some(letter) = letters.pop() {\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n        counts.push(count);\n    }\n    histogram.into_iter().map(|(_, count)|\
    \ {\n        (String::from(&*letters[..count.0]), *count)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `{integer}` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpc6fzmji3.rs:27:41\n   |\n27 |         (String::from(&*letters[..count.0]),\
    \ *count)\n   |                                         ^\n\nerror[E0614]: type\
    \ `[char]` cannot be dereferenced\n  --> /tmp/tmpc6fzmji3.rs:27:24\n   |\n27 |\
    \         (String::from(&*letters[..count.0]), *count)\n   |                 \
    \       ^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmpc6fzmji3.rs:27:46\n   |\n27 |         (String::from(&*letters[..count.0]),\
    \ *count)\n   |                                              ^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0610, E0614.\nFor more information about an error, try `rustc --explain E0610`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        if let Some(count) = histogram.get(&letter) {\n  \
    \          histogram.insert(letter, count + 1);\n        } else {\n          \
    \  histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2, \"a\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp_ml1haue.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters_iter.map(|c|\
    \ c.to_ascii_lowercase());\n    let mut letters_iter = letters_iter.filter(|&c|\
    \ !c.is_whitespace());\n    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_lowercase());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_uppercase());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_digit());\n \
    \   let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_punctuation());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \    let mut letters_iter = letter\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7uj2q67z.rs:42:34\n   |\n\
    42 |     let mut letters_iter = letter\n   |                                 \
    \ ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `letter` in this scope\n  --> /tmp/tmp7uj2q67z.rs:42:28\n   |\n42\
    \ |     let mut letters_iter = letter\n   |                            ^^^^^^\
    \ help: a local variable with a similar name exists: `letters`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmp7uj2q67z.rs:27:56\n   |\n27 |     let mut letters_iter = letters_iter.filter(|&c|\
    \ !c.is_ascii_letter());\n   |                                               \
    \         ^^^^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `is_ascii_ascii_letter` found for type `char` in the current scope\n \
    \ --> /tmp/tmp7uj2q67z.rs:28:56\n   |\n28 |     let mut letters_iter = letters_iter.filter(|&c|\
    \ !c.is_ascii_ascii_letter());\n   |                                         \
    \               ^^^^^^^^^^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `is_ascii_ascii_ascii_letter` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp7uj2q67z.rs:29:56\n   |\n29 |     let mut letters_iter\
    \ = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n   |        \
    \                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_ascii_ascii_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp7uj2q67z.rs:30:56\n\
    \   |\n30 |     let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_ascii_ascii_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp7uj2q67z.rs:31:56\n\
    \   |\n31 |     let mut letters_iter = letters_iter.filter(|&c| !c.is_ascii_ascii_ascii_letter());\n\
    \   |                                            "
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.split_whitespace();\n\
    \    for letter in letters {\n        histogram.entry(letter).or_insert(0) +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmplpdat3ky.rs:21:9\n   |\n21 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n21 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmplpdat3ky.rs:21:46\n\
    \   |\n21 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplpdat3ky.rs:23:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n23 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    while letters_count\
    \ > 0 {\n        let letter = letters.remove(0);\n        histogram.insert(letter,\
    \ histogram.get(&letter).unwrap_or(0));\n        letters_count -= 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4n0rss3z.rs:23:67\n   |\n\
    23 |         histogram.insert(letter, histogram.get(&letter).unwrap_or(0));\n\
    \   |                                                                   ^\n  \
    \ |                                                                   |\n   |\
    \                                                                   expected reference,\
    \ found integer\n   |                                                        \
    \           help: consider borrowing here: `&0`\n   |\n   = note: expected reference\
    \ `&_`\n                   found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4n0rss3z.rs:23:34\n   |\n23 |         histogram.insert(letter,\
    \ histogram.get(&letter).unwrap_or(0));\n   |                                \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                  |\n   |                               \
    \   cyclic type of infinite size\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4n0rss3z.rs:26:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n26 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, _>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_count_iter = 0;\n    let mut letters_count_max = 0;\n   \
    \ let mut letters_count_max_index = 0;\n    let mut letters_count_max_letter =\
    \ String::new();\n    let mut letters_count_max_letter_count = 0;\n    let mut\
    \ letters_count_max_letter_count2 = 0;\n    let mut letters_count_max_letter_count3\
    \ = 0;\n    let mut letters_count_max_letter_count4 = 0;\n    let mut letters_count_max_letter_count5\
    \ = 0;\n    let mut letters_count_max_letter_count6 = 0;\n    let mut letters_count_max_letter_count7\
    \ = 0;\n    let mut letters_count_max_letter_count8 = 0;\n    let mut letters_count_max_letter_count9\
    \ = 0;\n    let mut letters_count_max_letter_count10 = 0;\n    let mut letters_count_max_letter_count11\
    \ = 0;\n    let mut letters_count_max_letter_count12 = 0;\n    let mut letters_count_max_letter_count13\
    \ = 0;\n    let mut letters_count_max_letter_count14 = 0;\n    let mut letters_count_max_letter_count15\
    \ = 0;\n    let mut letters_count_max_letter_count16 = 0;\n    let mut letters_count_max_letter_count17\
    \ = 0;\n    let mut letters_count_max_letter_count18 = 0;\n    let mut letters_count_max_letter_count19\
    \ = 0;\n    let mut letters_count_max_letter_count20 = 0;\n    let mut letters_count_max_letter_count21\
    \ = 0;\n    let mut letters_count_max_letter_count22 = 0;\n    let mut letters_count_max_letter_count23\
    \ = 0;\n    let mut letters_count_max_letter_count24 = 0;\n    let mut letters_count_max_letter_count25\
    \ = 0;\n    let mut letters_count_max_letter_count26 = 0;\n    let mut letters_count_max_letter_count27\
    \ = 0;\n    let mut letters_count_max_letter_count28 = 0;\n    let mut letters_count_max_letter_count29\
    \ = 0;\n    let mut letters_count_max_letter_count30 = 0;\n    let mut letters_count_max_letter_count31\
    \ = 0;\n    let mut letters_count_max_letter_count32 = 0;\n    let mut letters_count_max_letter_count33\
    \ = 0;\n    let mut letters_count_max_letter_count34 = 0;\n    let mut letters_count_max_letter_count35\
    \ = 0;\n    let mut letters_count_max_\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8kixpm6j.rs:61:31\n   |\n\
    61 |     let mut letters_count_max_\n   |                               ^ help:\
    \ add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0599]: the method `count`\
    \ exists for struct `Vec<char>`, but its trait bounds were not satisfied\n   -->\
    \ /tmp/tmp8kixpm6j.rs:21:37\n    |\n21  |       let mut letters_count = letters.count();\n\
    \    |                                       ^^^^^ method cannot be called on\
    \ `Vec<char>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<char>: Iterator`\n      \
    \      which is required by `&mut Vec<char>: Iterator`\n            `[char]: Iterator`\n\
    \            which is required by `&mut [char]: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8kixpm6j.rs:17:31\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letter_count = 1;\n \
    \   let mut letter = String::from(\"\");\n    while letters_count > 0 {\n    \
    \    histogram.insert(letter, letter_count);\n        letters_count -= 1;\n  \
    \      letter = String::from(letters[letters_count]);\n        letter_count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\" \": 7, \"\": 1, \"b\": 6, \"a\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`',\
    \ /tmp/tmp28f1e8wv.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    let mut current_letter = String::new();\n\
    \    let mut current_count = -1;\n    while let Some(letter) = letters.next()\
    \ {\n        let count = counts.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n        if *count > current_count {\n            current_letter = letter;\n\
    \            current_count = *count;\n        }\n    }\n    histogram.insert(current_letter,\
    \ current_count);\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp1pevs_u2.rs:23:38\n   |\n23 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut letters_count = HashMap::new();\n\
    \    let mut letters_count_max = HashMap::new();\n    let mut letters_count_max_key\
    \ = String::from(\"\");\n    let mut letters_count_max_value = isize::MAX;\n \
    \   let mut letters_count_max_key_len = isize::MAX;\n    let mut letters_count_max_value_len\
    \ = isize::MAX;\n    let mut letters_count_max_key_len2 = isize::MAX;\n    let\
    \ mut letters_count_max_value_len2 = isize::MAX;\n    let mut letters_count_max_key_len3\
    \ = isize::MAX;\n    let mut letters_count_max_value_len3 = isize::MAX;\n    let\
    \ mut letters_count_max_key_len4 = isize::MAX;\n    let mut letters_count_max_value_len4\
    \ = isize::MAX;\n    let mut letters_count_max_key_len5 = isize::MAX;\n    let\
    \ mut letters_count_max_value_len5 = isize::MAX;\n    let mut letters_count_max_key_len6\
    \ = isize::MAX;\n    let mut letters_count_max_value_len6 = isize::MAX;\n    let\
    \ mut letters_count_max_key_len7 = isize::MAX;\n    let mut letters_count_max_value_len7\
    \ = isize::MAX;\n    let mut letters_count_max_key_len8 = isize::MAX;\n    let\
    \ mut letters_count_max_value_len8 = isize::MAX;\n    let mut letters_count_max_key_len9\
    \ = isize::MAX;\n    let mut letters_count_max_value_len9 = isize::MAX;\n    let\
    \ mut letters_count_max_key_len10 = isize::MAX;\n    let mut letters_count_max_value_len10\
    \ = isize::MAX;\n    let mut letters_count_max_key_len11 = isize::MAX;\n    let\
    \ mut letters_count_max_value_len11 = isize::MAX;\n    let mut letters_count_max_key_len12\
    \ = isize::MAX;\n    let mut letters_count_max_value_len12 = isize::MAX;\n   \
    \ let mut letters_count_max_key_len13 = isize::MAX;\n    let mut letters_count_max_value_len13\
    \ = isize::MAX;\n    let mut letters_count_max_key_len14 = isize::MAX;\n    let\
    \ mut letters_count_max_value_len14 = isize::MAX;\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3c5xzj_a.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9c8hsdq7.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9c8hsdq7.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    let mut letter = String::from(\"\");\n    while let\
    \ Some(letter) = letters.next() {\n        histogram.entry(letter).or_default()\
    \ += 1;\n        if histogram.contains_key(letter) {\n            count += 1;\n\
    \        }\n        letter = String::from(\"\");\n    }\n    histogram.insert(String::from(\"\
    \"), count);\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmptrv1rj14.rs:22:38\n   |\n22 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut _`\n  --> /tmp/tmptrv1rj14.rs:23:9\n   |\n23 |    \
    \     histogram.entry(letter).or_default() += 1;\n   |         ------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut _`\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmptrv1rj14.rs:23:46\n   |\n\
    23 |         histogram.entry(letter).or_default() += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptrv1rj14.rs:27:18\n   |\n27 |         letter\
    \ = String::from(\"\");\n   |                  ^^^^^^^^^^^^^^^^\n   |        \
    \          |\n   |                  expected reference, found struct `String`\n\
    \   |                  help: consider borrowing here: `&String::from(\"\")`\n\
    \   |\n   = note: expected reference `&_`\n                 found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptrv1rj14.rs:29:22\n   |\n29 |\
    \     histogram.insert(String::from(\"\"), count);\n   |                     \
    \ ^^^^^^^^^^^^^^^^\n   |                      |\n   |                      expected\
    \ reference, found struct `String`\n   |                      help: consider borrowing\
    \ here: `&String::from(\"\")`\n   |\n   = note: expected reference `&_`\n    \
    \             found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptrv1rj14.rs:30:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found reference\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&_, {integer}>`\n\nerr"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = vec![];\n    while let Some(letter) = letters.pop() {\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n        counts.push(count);\n    }\n    histogram.into_iter().map(|(_, count)|\
    \ {\n        let mut letter = String::from(\"\");\n        let mut count = counts.iter().filter(|&count|\
    \ count == count).next();\n        if let Some(count) = count {\n            letter\
    \ = String::from(count.to_string());\n        }\n        (letter, count)\n   \
    \ }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `HashMap<String, isize>` cannot be built\
    \ from an iterator over elements of type `(String, Option<&&mut {integer}>)`\n\
    \  --> /tmp/tmp4oneb1s3.rs:33:8\n   |\n33 |     }).collect()\n   |        ^^^^^^^\
    \ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=(String,\
    \ Option<&&mut {integer}>)>`\n   |\n   = help: the trait `FromIterator<(String,\
    \ Option<&&mut {integer}>)>` is not implemented for `HashMap<String, isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter = String::from(\"\
    \");\n    let mut count = 1;\n    while let Some(letter) = letters_iter.next()\
    \ {\n        histogram.entry(letter).or_insert(0) += count;\n        count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmptivgpynx.rs:24:9\n   |\n24 |         histogram.entry(letter).or_insert(0)\
    \ += count;\n   |         ------------------------------------^^^^^^^^^\n   |\
    \         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += count;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmptivgpynx.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += count;\n   |     \
    \    ------------------------------------ ^^\n   |         |\n   |         cannot\
    \ assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptivgpynx.rs:27:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n27 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&char, {integer}>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_min = letters.clone();\n\
    \    let mut letters_repeated_count_max_index = letters.clone();\n    let mut\
    \ letters_repeated_count_min_index = letters.clone();\n    let mut letters_repeated_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value = letters.clone();\n\
    \    let mut letters_repeated_count_max_value_count = letters.clone();\n    let\
    \ mut letters_repeated_count_min_value_count = letters.clone();\n    let mut letters_repeated_count_max_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm71prqt1.rs:49:36\n   |\n\
    49 |     let mut letters_repeated_count_\n   |                               \
    \     ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm71prqt1.rs:17:31\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    while let Some(letter) = letters.pop()\
    \ {\n        let count = histogram.entry(letter).or_insert(0);\n        *count\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\" \": 3, \"a\": 2, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpr7ezuvu7.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    let mut current_letter = String::from(\"\
    \");\n    let mut current_count = -1;\n    let mut current_letters = Vec::new();\n\
    \n    while let Some(letter) = letters.pop() {\n        if let Some(count) = counts.remove(&letter)\
    \ {\n            counts.insert(letter, count + 1);\n        } else {\n       \
    \     counts.insert(letter, 1);\n        }\n    }\n\n    for letter in counts.keys()\
    \ {\n        let count = counts.get(letter).unwrap();\n        if count > current_count\
    \ {\n            current_count = count;\n            current_letter = letter;\n\
    \            current_letters.push(letter);\n        }\n    }\n\n    histogram.insert(current_letter,\
    \ current_count);\n    histogram.insert(String::from(\"\"), 1);\n\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ozvi7y8.rs:35:20\n   |\n\
    35 |         if count > current_count {\n   |                    ^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected reference, found\
    \ integer\n   |                    help: consider borrowing here: `&current_count`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6ozvi7y8.rs:36:29\n   |\n36 |\
    \             current_count = count;\n   |                             ^^^^^ expected\
    \ integer, found `&{integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n36 |             current_count = *count;\n   |                        \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6ozvi7y8.rs:37:30\n \
    \  |\n37 |             current_letter = letter;\n   |                        \
    \      ^^^^^^- help: try using a conversion method: `.to_string()`\n   |     \
    \                         |\n   |                              expected struct\
    \ `String`, found `&char`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        if histogram.contains_key(&word)\
    \ {\n            histogram.entry(word).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(word, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpb5jmcnli.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpb5jmcnli.rs:22:13\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ----------------------------------^^^^^\n   |             |\n   |     \
    \        cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `histogram.entry(word).or_insert(0)`\n \
    \  |\n22 |             *histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpb5jmcnli.rs:22:48\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748964
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        if let Some(count) = histogram.get(&letter) {\n  \
    \          *count += 1;\n        } else {\n            histogram.insert(letter,\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*count`, which is behind a `&` reference\n\
    \  --> /tmp/tmppgwtuftg.rs:21:13\n   |\n20 |         if let Some(count) = histogram.get(&letter)\
    \ {\n   |                     ----- help: consider changing this to be a mutable\
    \ reference: `&mut isize`\n21 |             *count += 1;\n   |             ^^^^^^^^^^^\
    \ `count` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1659748965
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = Vec::new();\n    while let Some(letter) = letters.iter().next()\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    for entry in histogram.iter() {\n        if let Some(count) = entry.value\
    \ {\n            counts.push((entry.key.clone(), count));\n        }\n    }\n\
    \    counts.sort_by(|a, b| b.1.cmp(&a.1));\n    histogram.into_iter().map(|entry|\
    \ entry.key).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n   \
    \ assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpy_78o9gl.rs:23:13\n   |\n23 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpy_78o9gl.rs:23:51\n\
    \   |\n23 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy_78o9gl.rs:25:30\n   |\n25 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^ expected `&char`, found `char`\n\
    \   |\n   = note: expected reference `&&char`\n              found reference `&char`\n\
    \nerror[E0609]: no field `value` on type `(&&&char, &{integer})`\n  --> /tmp/tmpy_78o9gl.rs:29:36\n\
    \   |\n29 |         if let Some(count) = entry.value {\n   |                 \
    \                   ^^^^^\n\nerror[E0609]: no field `key` on type `(&&&char, &{integer})`\n\
    \  --> /tmp/tmpy_78o9gl.rs:30:32\n   |\n30 |             counts.push((entry.key.clone(),\
    \ count));\n   |                                ^^^\n\nerror[E0609]: no field\
    \ `1` on type `&_`\n  --> /tmp/tmpy_78o9gl.rs:33:29\n   |\n33 |     counts.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                             ^\n\nerror[E0609]: no field\
    \ `key` on type `(&&char, {integer})`\n  --> /tmp/tmpy_78o9gl.rs:34:45\n   |\n\
    34 |     histogram.into_iter().map(|entry| entry.key).collect()\n   |        \
    \                                     ^^^\n\nerror: aborting due to 7 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0308, E0368, E0609.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n    let mut current_letter = String::new();\n\
    \    let mut current_count = 1;\n    let mut current_letters = HashMap::new();\n\
    \    let mut current_letters_count = HashMap::new();\n\n    while let Some(letter)\
    \ = letters.pop() {\n        if let Some(count) = letter_counts.get(&letter) {\n\
    \            letter_counts.entry(letter).and_modify(|count| *count += 1);\n  \
    \      } else {\n            letter_counts.entry(letter).and_modify(|count| *count\
    \ += 1);\n        }\n    }\n\n    for letter in letter_counts {\n        if let\
    \ Some(count) = letter_counts.get(&letter) {\n            if let Some(current_letter)\
    \ = current_letters.get(&letter) {\n                if let Some(current_count)\
    \ = current_letters_count.get(&current_letter) {\n                    if *count\
    \ > current_count {\n                        current_letters.entry(letter).and_modify(|count|\
    \ *count += 1);\n                        current_letters_count.entry(current_letter).and_modify(|count|\
    \ *count += 1);\n                    }\n                } else {\n           \
    \         current_letters.entry(letter).and_modify(|count| *count += 1);\n   \
    \                 current_letters_count.entry(letter).and_modify(|count| *count\
    \ += 1);\n                }\n            } else {\n                current_letters.entry(letter).and_modify(|count|\
    \ *count += 1);\n                current_letters_count.entry(letter).and_modify(|count|\
    \ *count += 1);\n            }\n        }\n    }\n\n    for letter in current_letters\
    \ {\n        if let Some(count) = current_letters_count.get(&letter) {\n     \
    \       histogram.entry(letter).and_modify(|count| *count += 1);\n        }\n\
    \    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzjnw1eya.rs:35:48\n   |\n\
    35 |         if let Some(count) = letter_counts.get(&letter) {\n   |         \
    \                                       ^^^^^^^ expected `char`, found tuple\n\
    \   |\n   = note: expected reference `&char`\n              found reference `&(char,\
    \ _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzjnw1eya.rs:44:49\n   |\n\
    44 |                     current_letters_count.entry(letter).and_modify(|count|\
    \ *count += 1);\n   |                                                 ^^^^^^\n\
    \   |                                                 |\n   |                \
    \                                 expected reference, found tuple\n   |      \
    \                                           help: consider borrowing here: `&letter`\n\
    \   |\n   = note: expected reference `&_`\n                  found tuple `(char,\
    \ _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzjnw1eya.rs:48:45\n   |\n\
    48 |                 current_letters_count.entry(letter).and_modify(|count| *count\
    \ += 1);\n   |                                             ^^^^^^\n   |      \
    \                                       |\n   |                              \
    \               expected reference, found tuple\n   |                        \
    \                     help: consider borrowing here: `&letter`\n   |\n   = note:\
    \ expected reference `&_`\n                  found tuple `(char, _)`\n\nerror[E0277]:\
    \ the trait bound `&_: Borrow<((char, _), _)>` is not satisfied\n  --> /tmp/tmpzjnw1eya.rs:54:52\n\
    \   |\n54 |         if let Some(count) = current_letters_count.get(&letter) {\n\
    \   |                                                    ^^^ the trait `Borrow<((char,\
    \ _), _)>` is not implemented for `&_`\n   |\n   = help: the following implementations\
    \ were found:\n             <&T as Borrow<T>>\n             <&mut T as Borrow<T>>\n\
    \             <Arc<T> as Borrow<T>>\n             <Box<T, A> as Borrow<T>>\n \
    \          and 9 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzjnw1eya.rs:59:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                  "
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0)).collect::<Vec<_>>();\n\
    \    letters_count.sort_by_key(|&(_, count)| count.cmp(&letters_count[letters_count.len()\
    \ - 1]));\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpns2bub8c.rs:21:33\n   |\n\
    21 |     letters_count.sort_by_key(|&(_, count)| count.cmp(&letters_count[letters_count.len()\
    \ - 1]));\n   |                                 ^^^^^^^^^-\n   |             \
    \                    |        |\n   |                                 |      \
    \  expected due to this\n   |                                 expected integer,\
    \ found tuple\n   |\n   = note: expected type `{integer}`\n             found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpns2bub8c.rs:22:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n22 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpftvsu5vn.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n\n    while letters_count\
    \ > 0 {\n        let mut letter = letters.remove(0);\n        histogram.insert(letter,\
    \ histogram.get(&letter).unwrap_or(0) + 1);\n        letters_count -= 1;\n   \
    \     letters_repeated_count -= 1;\n        if letters_repeated_count == 0 {\n\
    \            letters_repeated = letters.clone();\n            letters_repeated_count\
    \ = letters.clone();\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbxlcbc99.rs:26:67\n   |\n\
    26 |         histogram.insert(letter, histogram.get(&letter).unwrap_or(0) + 1);\n\
    \   |                                                                   ^\n  \
    \ |                                                                   |\n   |\
    \                                                                   expected reference,\
    \ found integer\n   |                                                        \
    \           help: consider borrowing here: `&0`\n   |\n   = note: expected reference\
    \ `&_`\n                   found type `{integer}`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `Vec<char>`\n  --> /tmp/tmpbxlcbc99.rs:28:9\n\
    \   |\n28 |         letters_repeated_count -= 1;\n   |         ----------------------^^^^^\n\
    \   |         |\n   |         cannot use `-=` on type `Vec<char>`\n\nerror[E0277]:\
    \ can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmpbxlcbc99.rs:29:35\n\
    \   |\n29 |         if letters_repeated_count == 0 {\n   |                   \
    \                ^^ no implementation for `Vec<char> == {integer}`\n   |\n   =\
    \ help: the trait `PartialEq<{integer}>` is not implemented for `Vec<char>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbxlcbc99.rs:34:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n34 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, _>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp9ybu0r5a.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    let mut letter = String::from(\"\");\n    while let\
    \ Some(letter) = letters.next() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(count).cloned() += 1;\n  \
    \      } else {\n            histogram.insert(letter, count);\n            count\
    \ += 1;\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp6mxbq7ia.rs:22:38\n   |\n22 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0599]: the method `cloned` exists for mutable\
    \ reference `&mut {integer}`, but its trait bounds were not satisfied\n  --> /tmp/tmp6mxbq7ia.rs:24:55\n\
    \   |\n24 |             histogram.entry(&letter).or_insert(count).cloned() +=\
    \ 1;\n   |                                                       ^^^^^^ method\
    \ cannot be called on `&mut {integer}` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `{integer}:\
    \ Iterator`\n           which is required by `&mut {integer}: Iterator`\n    \
    \       `&mut {integer}: Iterator`\n           which is required by `&mut &mut\
    \ {integer}: Iterator`\n\nerror[E0067]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmp6mxbq7ia.rs:24:64\n   |\n24 |             histogram.entry(&letter).or_insert(count).cloned()\
    \ += 1;\n   |             -------------------------------------------------- ^^\n\
    \   |             |\n   |             cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6mxbq7ia.rs:26:30\n   |\n26 |             histogram.insert(letter,\
    \ count);\n   |                              ^^^^^^\n   |                    \
    \          |\n   |                              cyclic type of infinite size\n\
    \   |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6mxbq7ia.rs:30:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found reference\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&_, {integer}>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0067,"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().next().unwrap();\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp55m_amu_.rs:22:9\n   |\n22 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n22 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp55m_amu_.rs:22:46\n\
    \   |\n22 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp55m_amu_.rs:24:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n24 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpf5sh6098.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letter = String::from(\"\");\n    let mut count = 0;\n    while let\
    \ Some(letter) = letters_iter.next() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n        if histogram.contains_key(letter) {\n            count += 1;\n\
    \        }\n    }\n    histogram.insert(String::from(\"\"), count);\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp0b19h7va.rs:24:9\n   |\n24 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp0b19h7va.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0b19h7va.rs:29:22\n   |\n29 |     histogram.insert(String::from(\"\
    \"), count);\n   |                      ^^^^^^^^^^^^^^^^\n   |               \
    \       |\n   |                      expected `&String`, found struct `String`\n\
    \   |                      help: consider borrowing here: `&String::from(\"\"\
    )`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0b19h7va.rs:30:5\n   |\n17\
    \ | fn histogram(test: String) -> HashMap<String, isize> {\n   |             \
    \                  ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, {integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    let mut letters_count_max_index\
    \ = 0;\n    let mut letters_count_min = 0;\n    let mut letters_count_min_index\
    \ = 0;\n    let mut letters_count_sum = 0;\n    let mut letters_count_sum_index\
    \ = 0;\n    let mut letters_count_avg = 0;\n    let mut letters_count_avg_index\
    \ = 0;\n    let mut letters_count_median = 0;\n    let mut letters_count_median_index\
    \ = 0;\n    let mut letters_count_mode = 0;\n    let mut letters_count_mode_index\
    \ = 0;\n    let mut letters_count_stddev = 0;\n    let mut letters_count_stddev_index\
    \ = 0;\n    let mut letters_count_sum_squares = 0;\n    let mut letters_count_sum_squares_index\
    \ = 0;\n    let mut letters_count_count_unique = 0;\n    let mut letters_count_count_unique_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio = 0;\n    let mut letters_count_count_unique_ratio_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio2 = 0;\n    let mut letters_count_count_unique_ratio2_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio3 = 0;\n    let mut letters_count_count_unique_ratio3_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio4 = 0;\n    let mut letters_count_count_unique_ratio4_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio5 = 0;\n    let mut letters_count_count_unique_ratio5_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio6 = 0;\n    let mut letters_count_count_unique_ratio6_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio7 = 0;\n    let mut letters_count_count_unique_ratio7_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio8 = 0;\n    let mut letters_count_count_unique_ratio8_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio9 = 0;\n    let mut letters_count_count_unique_ratio9_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio10 = 0;\n    let mut letters_count_count_unique_ratio10_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio11 = 0;\n    let mut letters_count_count_unique_ratio11_index\
    \ = 0;\n    let mut letters_count_count_unique_ratio12 = 0;\n    let mut letters_count_count_unique\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0bfb4xvl.rs:63:39\n   |\n\
    63 |     let mut letters_count_count_unique\n   |                            \
    \           ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0bfb4xvl.rs:17:31\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0));\n\
    \    let mut letters_count_iter = letters_count.iter();\n    loop {\n        let\
    \ mut letter = letters_count_iter.next().unwrap();\n        if letters_count_iter.peek().is_none()\
    \ {\n            break;\n        }\n        let mut letters_count = letters_count_iter.next().unwrap();\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmp88pfs8ah.rs:21:48\n   |\n21 |     let mut letters_count_iter\
    \ = letters_count.iter();\n   |                                              \
    \  ^^^^ private field, not a method\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmp88pfs8ah.rs:28:9\n\
    \   |\n28 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n28 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp88pfs8ah.rs:28:46\n\
    \   |\n28 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp88pfs8ah.rs:30:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n30 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp9ybu0r5a.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_min = letters.clone();\n\
    \    let mut letters_repeated_count_max_index = letters.clone();\n    let mut\
    \ letters_repeated_count_min_index = letters.clone();\n\n    while letters_count\
    \ > 0 {\n        let mut letter = letters.clone();\n        let mut letters_count\
    \ = letters.len();\n        while letters_count > 0 {\n            histogram.insert(letter.pop(),\
    \ histogram.get(&letter).unwrap() + 1);\n            letters_count -= 1;\n   \
    \     }\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp85wfk6nb.rs:32:58\n   |\n\
    32 |             histogram.insert(letter.pop(), histogram.get(&letter).unwrap()\
    \ + 1);\n   |                                                          ^^^^^^^\
    \ expected enum `Option`, found struct `Vec`\n   |\n   = note: expected reference\
    \ `&Option<char>`\n              found reference `&Vec<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp85wfk6nb.rs:37:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n37 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   =\
    \ note: expected struct `HashMap<String, isize>`\n              found struct `HashMap<Option<char>,\
    \ _>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = letters.into_iter().map(|c| histogram.entry(c).or_insert(0));\n\
    \    letter_counts.sort_by_key(|&(_, count)| count.cmp(&1));\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpc2w3jyx2.rs:21:19\n   |\n21 |     letter_counts.sort_by_key(|&(_,\
    \ count)| count.cmp(&1));\n   |                   ^^^^^^^^^^^ method not found\
    \ in `Map<std::vec::IntoIter<char>, [closure@/tmp/tmpc2w3jyx2.rs:20:53: 20:88]>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc2w3jyx2.rs:22:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n22 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_letter = String::new();\n    let mut letters_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_count_max = 0;\n    let mut letters_count_max_letter_count_max_letter\
    \ = String::new();\n    let mut letters_count_max_letter_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max = 0;\n\
    \    let mut letters_count_max_letter_count_max_letter_count_max_letter = String::new();\n\
    \    let mut letters_count_max_letter_count_max_letter_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter\
    \ = String::new();\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter\
    \ = String::new();\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter\
    \ = String::new();\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max_letter_count_max\
    \ = 0;\n    let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpicmixvvj.rs:43:89\n   |\n\
    43 |     let mut letters_count_max_letter_count_max_letter_count_max_letter_count_max_letter_\n\
    \   |                                                                        \
    \                 ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpicmixvvj.rs:17:31\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        letters.sort_by_key(|&x| x.to_ascii_lowercase());\n        let mut letter\
    \ = letters.iter().cloned().collect::<String>();\n        histogram.insert(letter,\
    \ histogram.entry(letter).or_insert(0));\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpsvqbs_u1.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsvqbs_u1.rs:24:34\n   |\n24 |         histogram.insert(letter, histogram.entry(letter).or_insert(0));\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n24 |         histogram.insert(letter, *histogram.entry(letter).or_insert(0));\n\
    \   |                                  +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9c8hsdq7.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9c8hsdq7.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_min = letters.clone();\n\
    \    let mut letters_repeated_count_max_index = letters.clone();\n    let mut\
    \ letters_repeated_count_min_index = letters.clone();\n    let mut letters_repeated_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value = letters.clone();\n\
    \    let mut letters_repeated_count_max_value_count = letters.clone();\n    let\
    \ mut letters_repeated_count_min_value_count = letters.clone();\n    let mut letters_repeated_count_max_value_count_min\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_max =\
    \ letters.clone();\n    let mut letters_repeated_count_max_value_count_max_index\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_max_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_max_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_min\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_max_value_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_index\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_max_value_count_max_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_max_value_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_max_value_count_max_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_min\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_max_value_count_max_value_count_max\
    \ = letters.\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmphmgt9yd9.rs:49:1\n   |\n49\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmphmgt9yd9.rs:48:98\n\
    \   |\n48 |     let mut letters_repeated_count_min_value_count_max_value_count_max_value_count_max\
    \ = letters.\n   |                                                           \
    \                                       ^ help: add `;` here\n49 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphmgt9yd9.rs:17:31\n \
    \  |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748966
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp9c8hsdq7.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9c8hsdq7.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748963
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    while let Some(letter) = letters.pop()\
    \ {\n        let count = histogram.entry(letter).or_insert(0);\n        *count\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\" \": 3, \"a\": 2, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpr7ezuvu7.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748966
