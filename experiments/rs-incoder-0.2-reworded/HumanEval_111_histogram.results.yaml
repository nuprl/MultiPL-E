name: HumanEval_111_histogram
language: rs
results:
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp9ybu0r5a.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letter_count = 1;\n \
    \   let mut letter = String::from(\"\");\n    while letters_count > 0 {\n    \
    \    histogram.insert(letter, letter_count);\n        letters_count -= 1;\n  \
    \      letter = letters[letters_count];\n        letter_count += 1;\n    }\n \
    \   histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpawb5vlv2.rs:26:18\n   |\n\
    22 |     let mut letter = String::from(\"\");\n   |                      ----------------\
    \ expected due to this value\n...\n26 |         letter = letters[letters_count];\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                  |\n   |                  expected struct\
    \ `String`, found `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_max = 0;\n    let mut letters_count_count_min = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_min = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixk5hfo_.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      histogram.entry(c.to_string()).or_insert(0) += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpuhffy72a.rs:20:9\n   |\n20 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpuhffy72a.rs:20:53\n\
    \   |\n20 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    while letters_count_index < letters_count {\n        let letter = &letters[letters_count_index];\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n        letters_count_index += 1;\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw92i1lhz.rs:28:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = HashMap::new();\n    let mut letter = String::from(\"\"\
    );\n    let mut count = 1;\n    let mut i = 0;\n    while i < letters.len() {\n\
    \        if let Some(letter) = letters.next() {\n            histogram.insert(letter,\
    \ count);\n            counts.entry(letter).and_modify(|c| *c += 1);\n       \
    \     i += 1;\n        } else {\n            histogram.insert(letter, count);\n\
    \            counts.entry(letter).and_modify(|c| *c += 1);\n            i += 1;\n\
    \            letter = String::from(\"\");\n            count = 1;\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpd6bdcxra.rs:25:39\n   |\n25 |         if let Some(letter)\
    \ = letters.next() {\n   |                                       ^^^^ method not\
    \ found in `Vec<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut counts = letters.iter().cloned().map(|c|\
    \ histogram.entry(c).or_insert(0));\n    loop {\n        let mut max_count = counts.iter().max().unwrap();\n\
    \        let mut max_letter = String::new();\n        for (key, value) in histogram\
    \ {\n            if value == max_count {\n                max_letter = key;\n\
    \            }\n        }\n        if max_count == 0 {\n            break;\n \
    \       }\n        for (key, value) in histogram {\n            if value == max_count\
    \ {\n                counts.remove(&key);\n            }\n        }\n        histogram.insert(max_letter,\
    \ 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpkh1r5270.rs:22:36\n   |\n22 |         let mut max_count\
    \ = counts.iter().max().unwrap();\n   |                                    ^^^^\
    \ private field, not a method\n\nerror[E0599]: no method named `remove` found\
    \ for struct `Map` in the current scope\n  --> /tmp/tmpkh1r5270.rs:34:24\n   |\n\
    34 |                 counts.remove(&key);\n   |                        ^^^^^^\
    \ method not found in `Map<Cloned<std::slice::Iter<'_, String>>, [closure@/tmp/tmpkh1r5270.rs:20:50:\
    \ 20:85]>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_max = 0;\n    let mut letters_count_count_min = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_max = 0;\n    let mut\
    \ letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_max = 0;\n    let mut\
    \ letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzu6gdmq7.rs:58:27\n   |\n\
    58 |     let mut letters_count_\n   |                           ^ help: add `;`\
    \ here\n59 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzu6gdmq7.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut letters = HashMap::new();\n    let mut counts = HashMap::new();\n\
    \    for letter in test.chars().filter_map(|c| c.is_alphabetic()) {\n        letters.entry(letter).or_insert(0)\
    \ += 1;\n        counts.entry(letter).or_insert(0) += 1;\n    }\n    letters\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdmpgl_kn.rs:20:47\n   |\n\
    20 |     for letter in test.chars().filter_map(|c| c.is_alphabetic()) {\n   |\
    \                                               ^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n       \
    \       found type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n\
    20 |     for letter in test.chars().filter_map(|c| Some(c.is_alphabetic())) {\n\
    \   |                                               +++++                 +\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ {integer}`\n  --> /tmp/tmpdmpgl_kn.rs:21:9\n   |\n21 |         letters.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `letters.entry(letter).or_insert(0)`\n\
    \   |\n21 |         *letters.entry(letter).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdmpgl_kn.rs:21:44\n\
    \   |\n21 |         letters.entry(letter).or_insert(0) += 1;\n   |         ----------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmpdmpgl_kn.rs:22:9\n   |\n22 |         counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ---------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `counts.entry(letter).or_insert(0)`\n\
    \   |\n22 |         *counts.entry(letter).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpdmpgl_kn.rs:22:43\n\
    \   |\n22 |         counts.entry(letter).or_insert(0) += 1;\n   |         ---------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have deta"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut count = 1;\n    for word in\
    \ words {\n        let mut letter = String::new();\n        for letter in word.chars()\
    \ {\n            histogram.entry(letter).or_insert(count).cloned() as isize\n\
    \        }\n        letters = letters + letter;\n        count += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `&mut {integer}` is not an iterator\n  --> /tmp/tmp8s3sjvpz.rs:25:54\n\
    \   |\n25 |             histogram.entry(letter).or_insert(count).cloned() as isize\n\
    \   |                                                      ^^^^^^ `&mut {integer}`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `{integer}: Iterator`\n           which is required by `&mut {integer}:\
    \ Iterator`\n           `&mut {integer}: Iterator`\n           which is required\
    \ by `&mut &mut {integer}: Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8s3sjvpz.rs:27:29\n   |\n27 |         letters = letters + letter;\n\
    \   |                             ^^^^^^\n   |                             |\n\
    \   |                             expected `&str`, found struct `String`\n   |\
    \                             help: consider borrowing here: `&letter`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8s3sjvpz.rs:30:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n30 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letter_count = 1;\n    let mut letter = String::from(\"\");\n   \
    \ while let Some(letter) = letters_iter.next() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(letter_count).1 += 1;\n  \
    \      } else {\n            histogram.insert(letter, letter_count);\n       \
    \ }\n        letter_count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `1` on type `&mut {integer}`\n  --> /tmp/tmptexqpql1.rs:25:62\n\
    \   |\n25 |             histogram.entry(&letter).or_insert(letter_count).1 +=\
    \ 1;\n   |                                                              ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptexqpql1.rs:27:30\n   |\n27 |  \
    \           histogram.insert(letter, letter_count);\n   |                    \
    \          ^^^^^^ expected `&String`, found struct `String`\n   |\n   = note:\
    \ expected reference `&&String`\n              found reference `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptexqpql1.rs:31:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n31 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&&String`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&&String,\
    \ {integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_count_iter = 0;\n    let mut letters_count_iter2 = 0;\n \
    \   let mut letters_count_iter3 = 0;\n    let mut letters_count_iter4 = 0;\n \
    \   let mut letters_count_iter5 = 0;\n    let mut letters_count_iter6 = 0;\n \
    \   let mut letters_count_iter7 = 0;\n    let mut letters_count_iter8 = 0;\n \
    \   let mut letters_count_iter9 = 0;\n    let mut letters_count_iter10 = 0;\n\
    \    let mut letters_count_iter11 = 0;\n    let mut letters_count_iter12 = 0;\n\
    \    let mut letters_count_iter13 = 0;\n    let mut letters_count_iter14 = 0;\n\
    \    let mut letters_count_iter15 = 0;\n    let mut letters_count_iter16 = 0;\n\
    \    let mut letters_count_iter17 = 0;\n    let mut letters_count_iter18 = 0;\n\
    \    let mut letters_count_iter19 = 0;\n    let mut letters_count_iter20 = 0;\n\
    \    let mut letters_count_iter21 = 0;\n    let mut letters_count_iter22 = 0;\n\
    \    let mut letters_count_iter23 = 0;\n    let mut letters_count_iter24 = 0;\n\
    \    let mut letters_count_iter25 = 0;\n    let mut letters_count_iter26 = 0;\n\
    \    let mut letters_count_iter27 = 0;\n    let mut letters_count_iter28 = 0;\n\
    \    let mut letters_count_iter29 = 0;\n    let mut letters_count_iter30 = 0;\n\
    \    let mut letters_count_iter31 = 0;\n    let mut letters_count_iter32 = 0;\n\
    \    let mut letters_count_iter33 = 0;\n    let mut letters_count_iter34 = 0;\n\
    \    let mut letters_count_iter35 = 0;\n    let mut letters_count_iter36 = 0;\n\
    \    let mut letters_count_iter37 = 0;\n    let mut letters_count_iter38 = 0;\n\
    \    let mut letters_count_iter39 = 0;\n    let mut letters_count_iter40 = 0;\n\
    \    let mut letters_count_iter41 = 0;\n    let mut letters_count_iter42 = 0;\n\
    \    let mut letters_count_iter43 = 0;\n    let mut letters_count_iter44 = 0;\n\
    \    let mut letters_count_iter45 = 0;\n    let mut letters_count_iter46 = 0;\n\
    \    let mut letters_count_iter47\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcd4n_0fq.rs:68:33\n   |\n\
    68 |     let mut letters_count_iter47\n   |                                 ^\
    \ help: add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0599]: no method\
    \ named `count` found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpcd4n_0fq.rs:21:37\n\
    \   |\n21 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcd4n_0fq.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n\n    while let Some(letter) = letters.pop()\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n        letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpuaq4109n.rs:23:9\n   |\n23 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpuaq4109n.rs:23:46\n\
    \   |\n23 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmpuaq4109n.rs:24:9\n   |\n24 |         letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpuaq4109n.rs:24:50\n\
    \   |\n24 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuaq4109n.rs:27:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n27 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    let mut letter = String::from(\"\");\n    while let\
    \ Some(letter) = letters.next() {\n        histogram.entry(letter).or_insert(count).cloned().unwrap();\n\
    \        count += 1;\n        if count == histogram.len() {\n            histogram.insert(letter,\
    \ count);\n            count = 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp73xm_401.rs:22:38\n   |\n22 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0599]: `&mut {integer}` is not an iterator\n\
    \  --> /tmp/tmp73xm_401.rs:23:50\n   |\n23 |         histogram.entry(letter).or_insert(count).cloned().unwrap();\n\
    \   |                                                  ^^^^^^ `&mut {integer}`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `{integer}: Iterator`\n           which is required by `&mut {integer}:\
    \ Iterator`\n           `&mut {integer}: Iterator`\n           which is required\
    \ by `&mut &mut {integer}: Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp73xm_401.rs:30:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n30 |     histogram\n \
    \  |     ^^^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<_, usize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter_iter = letters.iter();\n\
    \    let mut letter_count = letters.len();\n    while let Some(letter) = letter_iter.next()\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n        letter_count\
    \ -= 1;\n        if letter_count == 0 {\n            letter_iter = letters_iter.next();\n\
    \            letter_count = letters.len();\n        }\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmprkrz14b1.rs:24:9\n   |\n24 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprkrz14b1.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprkrz14b1.rs:27:27\n   |\n21 |     let mut letter_iter\
    \ = letters.iter();\n   |                           -------------- expected due\
    \ to this value\n...\n27 |             letter_iter = letters_iter.next();\n  \
    \ |                           ^^^^^^^^^^^^^^^^^^^ expected struct `std::slice::Iter`,\
    \ found enum `Option`\n   |\n   = note: expected struct `std::slice::Iter<'_,\
    \ char>`\n                found enum `Option<&char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprkrz14b1.rs:31:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n31 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0067, E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string());\n\
    \        histogram.insert(letters.collect::<Vec<_>>().into_iter().max().unwrap().cloned(),\
    \ 0);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp31b3vtex.rs:22:81\n\
    \    |\n22  |           histogram.insert(letters.collect::<Vec<_>>().into_iter().max().unwrap().cloned(),\
    \ 0);\n    |                                                                 \
    \                  ^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_letter = String::new();\n    let mut letters_count_max_letter_count\
    \ = 0;\n\n    for letter in letters {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.get_mut(&letter).unwrap() += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n\n        if histogram.get(&letter).unwrap()\
    \ > letters_count_max {\n            letters_count_max = histogram.get(&letter).unwrap();\n\
    \            letters_count_max_letter = letter;\n            letters_count_max_letter_count\
    \ = histogram.get(&letter).unwrap();\n        }\n    }\n\n    histogram.insert(letters_count_max_letter,\
    \ letters_count_max_letter_count);\n\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut _`\n  --> /tmp/tmprtnjkomt.rs:27:13\n   |\n27 |             histogram.get_mut(&letter).unwrap()\
    \ += 1;\n   |             -----------------------------------^^^^^\n   |     \
    \        |\n   |             cannot use `+=` on type `&mut _`\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmprtnjkomt.rs:27:49\n   |\n\
    27 |             histogram.get_mut(&letter).unwrap() += 1;\n   |             -----------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprtnjkomt.rs:32:46\n   |\n32 |  \
    \       if histogram.get(&letter).unwrap() > letters_count_max {\n   |       \
    \                                       ^^^^^^^^^^^^^^^^^\n   |              \
    \                                |\n   |                                     \
    \         expected reference, found integer\n   |                            \
    \                  help: consider borrowing here: `&letters_count_max`\n   |\n\
    \   = note: expected reference `&_`\n                   found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprtnjkomt.rs:33:33\n   |\n21 |\
    \     let mut letters_count_max = 0;\n   |                                 - expected\
    \ due to this value\n...\n33 |             letters_count_max = histogram.get(&letter).unwrap();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&{integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n33 |             letters_count_max = *histogram.get(&letter).unwrap();\n\
    \   |                                 +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprtnjkomt.rs:34:40\n   |\n22 |     let mut letters_count_max_letter =\
    \ String::new();\n   |                                        ------------- expected\
    \ due to this value\n...\n34 |             letters_count_max_letter = letter;\n\
    \   |                                        ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                        |\n   |\
    \     "
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphd7prwwh.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<char>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = vec![];\n    while let Some(letter) = letters.pop() {\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).and_modify(|count|\
    \ {\n                count += 1;\n            });\n        } else {\n        \
    \    histogram.insert(letter, 1);\n        }\n    }\n    histogram.into_iter().map(|(_,\
    \ count)| {\n        (String::from(&letters[0..count..count..]), count)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `]`, `{`, or an operator, found\
    \ `..`\n  --> /tmp/tmplut5tjzw.rs:31:40\n   |\n31 |         (String::from(&letters[0..count..count..]),\
    \ count)\n   |                                        ^^ expected one of 7 possible\
    \ tokens\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to\
    \ type `&mut _`\n  --> /tmp/tmplut5tjzw.rs:24:17\n   |\n24 |                 count\
    \ += 1;\n   |                 -----^^^^^\n   |                 |\n   |       \
    \          cannot use `+=` on type `&mut _`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplut5tjzw.rs:27:30\n   |\n27 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&char`, found `char`\n \
    \  |                              help: consider borrowing here: `&letter`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpiorqg518.rs:21:13\n   |\n21 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n21 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpiorqg518.rs:21:51\n\
    \   |\n21 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiorqg518.rs:23:30\n   |\n23 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&String`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpiorqg518.rs:26:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n26 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, {integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
