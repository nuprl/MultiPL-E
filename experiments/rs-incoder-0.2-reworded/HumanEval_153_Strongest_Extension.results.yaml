name: HumanEval_153_Strongest_Extension
language: rs
results:
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut class_name =\
    \ class_name.clone();\n        let mut c = class_name.chars().count();\n     \
    \   let mut s = extension.chars().count();\n        let mut c = c - s;\n     \
    \   if c > strength {\n            strength = c;\n            extension = extension.clone();\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpv71gc69m.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(&letter) {\n      \
    \          extension_map.insert(letter, strength + 1);\n            } else {\n\
    \                extension_map.insert(letter, 1);\n            }\n        }\n\
    \        if let Some(strength) = extension_map.get(&'.') {\n            extension_strength\
    \ = strength;\n        }\n        extensions_map.insert(extension, extension_strength);\n\
    \    }\n    let mut extensions_strength = -1;\n    for extension in extensions_map.keys()\
    \ {\n        if let Some(strength) = extensions_map.get(&extension) {\n      \
    \      extensions_strength = strength;\n        }\n    }\n    if extensions_strength\
    \ == -1 {\n        return class_name;\n    }\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(&letter) {\n      \
    \          extension_map.insert(letter, strength + 1);\n            } else {\n\
    \                extension_map.insert(letter, 1);\n            }\n        }\n\
    \        if let Some(strength) = extension_map.get(&'.') {\n            extension_strength\
    \ = strength;\n        }\n        extensions_map.insert(extension, extension_strength);\n\
    \    }\n    let mut extensions_strength = -1;\n    for extension in extensions_map.keys()\
    \ {\n        if let Some(strength) = extensions_map.get(&extension) {\n      \
    \      extensions_strength = strength;\n        }\n    }\n    if extensions_strength\
    \ == -1 {\n        return class_name;\n    }\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(&letter) {\n      \
    \          extension_map.insert(letter, strength + 1);\n            } else {\n\
    \                extension_map.insert(letter, 1);\n            }\n        }\n\
    \        if let Some(strength) = extension_map.get(&'.') {\n            extension_strength\
    \ = strength;\n        }\n        extensions_map.insert(extension, extension_strength);\n\
    \    }\n    let mut extensions_strength = -1;\n    for extension in extensions_map.keys()\
    \ {\n        if let Some(strength) = extensions_\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpd4i1c6q9.rs:100:3\n\
    \    |\n17  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                                         \
    \                      - unclosed delimiter\n...\n85  |     for extension in extensions_map.keys()\
    \ {\n    |                                            - this delimiter might not\
    \ be properly closed...\n86  |         if let Some(strength) = extensions_\n87\
    \  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    100 | }\n    |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpd4i1c6q9.rs:87:1\n\
    \   |\n86 |         if let Some(strength) = extensions_\n   |         -- this\
    \ `if` expression has a condition, but no block\n87 | }\n   | ^ expected `{`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpd4i1c6q9.rs:18:30\n\
    \   |\n18 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpd4i1c6q9.rs:20:33\n\
    \   |\n20 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpd4i1c6q9.rs:43:30\n\
    \   |\n43 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpd4i1c6q9.rs:45:33\n\
    \   |\n45 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ fail"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    class_name.concat(\".\"\
    ).concat(extension).concat(\".\").concat(format!(\"{}\", strength));\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpzp6s1vtu.rs:28:31\n   |\n28 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpzp6s1vtu.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n \
    \  |\n   = help: the following other types implement trait `Neg`:\n          \
    \   &f32\n             &f64\n             &i128\n             &i16\n         \
    \    &i32\n             &i64\n             &i8\n             &isize\n        \
    \   and 8 others\n\nerror[E0599]: no method named `concat` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpzp6s1vtu.rs:30:16\n   |\n30 |     class_name.concat(\"\
    .\").concat(extension).concat(\".\").concat(format!(\"{}\", strength));\n   |\
    \                ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzp6s1vtu.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = strength;\n        for letter in extension.chars()\
    \ {\n            if let Some(index) = class_name.chars().position(|c| c.to_ascii_lowercase()\
    \ == letter) {\n                class_name = &class_name[index..];\n         \
    \       strength = -1;\n                break;\n            }\n        }\n   \
    \     if strength > strength {\n            extension = extension;\n         \
    \   strength = strength;\n        }\n    }\n    class_name + extension\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvxun1uwj.rs:26:30\n   |\n\
    21 |         let mut class_name = class_name;\n   |                          \
    \    ---------- expected due to this value\n...\n26 |                 class_name\
    \ = &class_name[index..];\n   |                              ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n26 |                 class_name = (&class_name[index..]).to_string();\n\
    \   |                              +                    +++++++++++++\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpvxun1uwj.rs:27:28\n\
    \   |\n27 |                 strength = -1;\n   |                            ^^\n\
    \   |                            |\n   |                            cannot apply\
    \ unary operator `-`\n   |                            help: you may have meant\
    \ the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvxun1uwj.rs:36:18\n\
    \   |\n36 |     class_name + extension\n   |                  ^^^^^^^^^\n   |\
    \                  |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&extension`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0600.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension.chars() {\n            extension_map.insert(c.to_uppercase(),\
    \ c.to_lowercase());\n        }\n        extensions_map.insert(extension.clone(),\
    \ extension_map);\n    }\n    let mut strength = -1;\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<_>>();\n    extensions_sorted.sort_by_key(|x|\
    \ {\n        let mut c = x.chars().cloned().collect::<Vec<_>>();\n        c.sort_by_key(|y|\
    \ {\n            let mut c = y.chars().cloned().collect::<Vec<_>>();\n       \
    \     c.sort_by_key(|z| {\n                let mut c = z.chars().cloned().collect::<Vec<_>>();\n\
    \                c.sort_by_key(|a| {\n                    let mut c = a.chars().cloned().collect::<Vec<_>>();\n\
    \                    c.sort_by_key(|b| {\n                        let mut c =\
    \ b.chars().cloned().collect::<Vec<_>>();\n                        c.sort_by_key(|c|\
    \ {\n                            let mut c = c.chars().cloned().collect::<Vec<_>>();\n\
    \                            c.sort_by_key(|d| {\n                           \
    \     let mut c = d.chars().cloned().collect::<Vec<_>>();\n                  \
    \              c.sort_by_key(|e| {\n                                    let mut\
    \ c = e.chars().cloned().collect::<Vec<_>>();\n                              \
    \      c.sort_by_key(|f| {\n                                        let mut c\
    \ = f.chars().cloned().collect::<Vec<_>>();\n                                \
    \        c.sort_by_key(|g| {\n                                            let\
    \ mut c = g.chars().cloned().collect::<Vec<_>>();\n                          \
    \                  c.sort_by_key(|h| {\n                                     \
    \           let mut c = h.chars().cloned().collect::<Vec<_>>();\n            \
    \                                    c.sort_by_key(|i| {\n                   \
    \                                 let mut c = i.chars().cloned().collect::<Vec<_>>();\n\
    \                                                    c.sort_by_key(|j| {\n   \
    \                                                     let mut c = j.chars().cloned().collect::<Vec<_>>();\n\
    \                                                        c.sort_by_key(|k| {\n\
    \                                                            let mut c = k.chars().cloned().collect::<Vec<_>>();\n\
    \                                                            c.sort_by_key(|l|\
    \ {\n\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0emt_3ro.rs:71:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n28 |     extensions_sorted.sort_by_key(|x|\
    \ {\n   |                                  -    - unclosed delimiter\n   |   \
    \                               |\n   |                                  unclosed\
    \ delimiter\n29 |         let mut c = x.chars().cloned().collect::<Vec<_>>();\n\
    30 |         c.sort_by_key(|y| {\n   |                      -    - unclosed delimiter\n\
    \   |                      |\n   |                      unclosed delimiter\n31\
    \ |             let mut c = y.chars().cloned().collect::<Vec<_>>();\n32 |    \
    \         c.sort_by_key(|z| {\n   |                          -    - unclosed delimiter\n\
    \   |                          |\n   |                          unclosed delimiter\n\
    33 |                 let mut c = z.chars().cloned().collect::<Vec<_>>();\n34 |\
    \                 c.sort_by_key(|a| {\n   |                              -   \
    \ - unclosed delimiter\n   |                              |\n   |            \
    \                  unclosed delimiter\n35 |                     let mut c = a.chars().cloned().collect::<Vec<_>>();\n\
    36 |                     c.sort_by_key(|b| {\n   |                           \
    \       -    - unclosed delimiter\n   |                                  |\n \
    \  |                                  unclosed delimiter\n37 |               \
    \          let mut c = b.chars().cloned().collect::<Vec<_>>();\n38 |         \
    \                c.sort_by_key(|c| {\n   |                                   \
    \   -    - unclosed delimiter\n   |                                      |\n \
    \  |                                      unclosed delimiter\n39 |           \
    \                  let mut c = c.chars().cloned().collect::<Vec<_>>();\n40 | \
    \                            c.sort_by_key(|d| {\n   |                       \
    \                   -    - unclosed delimiter\n   |                          \
    \          "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension {\n            extension_map.insert(c.to_lowercase(),\
    \ 1);\n        }\n        extensions_map.insert(extension.to_lowercase(), extension_map);\n\
    \    }\n    let mut strength = -1;\n    let mut extensions_with_same_strength\
    \ = Vec::new();\n    for (extension, extension_map) in extensions_map.iter() {\n\
    \        let mut extension_strength = -1;\n        for c in extension {\n    \
    \        extension_strength += extension_map.get(c).unwrap();\n        }\n   \
    \     if extension_strength > strength {\n            strength = extension_strength;\n\
    \            extensions_with_same_strength.clear();\n        }\n        if extension_strength\
    \ == strength {\n            extensions_with_same_strength.push(extension);\n\
    \        }\n    }\n    if extensions_with_same_strength.len() > 1 {\n        let\
    \ mut extensions_with_same_strength_sorted = extensions_with_same_strength.iter().cloned().collect::<Vec<_>>();\n\
    \        extensions_with_same_strength_sorted.sort();\n        return format!(\"\
    {}.{}\", class_name, extensions_with_same_strength_sorted[0]);\n    } else {\n\
    \        return format!(\"{}.{}\", class_name, extensions_with_same_strength[0]);\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpsors9gml.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpsors9gml.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpsors9gml.rs:21:18\n\
    \   |\n21 |         for c in extension {\n   |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     if cap > sm {\n            strength = cap - sm;\n            extension =\
    \ extension.clone();\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpt5x0uh1t.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_len = extension.len();\n        let mut class_len =\
    \ class_name.len();\n        let mut i = 0;\n        while i < extension_len {\n\
    \            if extension[i] == class_name[i] {\n                i += 1;\n   \
    \             extension_len -= 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if extension_len > strength {\n           \
    \ strength = extension_len;\n            extension = extension;\n        }\n \
    \   }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0qm_7dar.rs:25:16\n\
    \   |\n25 |             if extension[i] == class_name[i] {\n   |             \
    \   ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0qm_7dar.rs:25:32\n   |\n25 |             if extension[i] == class_name[i]\
    \ {\n   |                                ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n \
    \ --> /tmp/tmp0qm_7dar.rs:18:24\n   |\n18 |     let mut strength = -1;\n   | \
    \                       ^^ the trait `Neg` is not implemented for `usize`\n  \
    \ |\n   = help: the following other types implement trait `Neg`:\n           \
    \  &f32\n             &f64\n             &i128\n             &i16\n          \
    \   &i32\n             &i64\n             &i8\n             &isize\n         \
    \  and 8 others\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(c) {\n            \
    \    extension_map.insert(c, strength + 1);\n            } else {\n          \
    \      extension_map.insert(c, 1);\n            }\n            if strength > extension_strength\
    \ {\n                extension_strength = strength;\n            }\n        }\n\
    \        extensions_map.insert(extension, extension_strength);\n    }\n    let\
    \ mut extensions_strength = -1;\n    for extension in extensions_map.keys() {\n\
    \        if extensions_strength < extensions_map.get(extension).unwrap() {\n \
    \           extensions_strength = extensions_map.get(extension).unwrap();\n  \
    \      }\n    }\n    format!(\"{}.{}\", class_name, extensions_map.get(&extensions_strength).unwrap())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpqxbgplom.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpqxbgplom.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `strength` in this scope\n  --> /tmp/tmpqxbgplom.rs:28:16\n\
    \   |\n28 |             if strength > extension_strength {\n   |             \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `strength`\
    \ in this scope\n  --> /tmp/tmpqxbgplom.rs:29:38\n   |\n29 |                 extension_strength\
    \ = strength;\n   |                                      ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > strength {\n            extension = e;\n   \
    \         strength = strength;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmpwp8jxyyl.rs:18:13\n\
    \   |\n18 |     let mut strength = -1;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to `strength`\
    \ is never read\n  --> /tmp/tmpwp8jxyyl.rs:30:13\n   |\n30 |             strength\
    \ = strength;\n   |             ^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpwp8jxyyl.rs:18:9\n   |\n\
    18 |     let mut strength = -1;\n   |         ----^^^^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0384]: cannot assign twice to immutable variable `strength`\n\
    \  --> /tmp/tmpwp8jxyyl.rs:30:13\n   |\n23 |         let strength = if cap > sm\
    \ {\n   |             --------\n   |             |\n   |             first assignment\
    \ to `strength`\n   |             help: consider making this binding mutable:\
    \ `mut strength`\n...\n30 |             strength = strength;\n   |           \
    \  ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to previous error; 3 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension.chars() {\n            extension_map.insert(c.to_ascii_lowercase(),\
    \ 0);\n        }\n        extensions_map.insert(extension.clone(), extension_map);\n\
    \    }\n    let mut extensions_sorted = Vec::new();\n    let mut extensions_strength\
    \ = Vec::new();\n    for extension in extensions {\n        let mut extension_map\
    \ = extensions_map.get(extension.clone());\n        if extension_map.is_none()\
    \ {\n            continue;\n        }\n        let mut extension_strength = extension_map.values().iter().max().unwrap();\n\
    \        extensions_sorted.push(extension);\n        extensions_strength.push(extension_strength);\n\
    \    }\n    let mut extensions_strength_sorted = Vec::new();\n    for extension_strength\
    \ in extensions_strength {\n        extensions_strength_sorted.push(extension_strength);\n\
    \    }\n    let mut extensions_strength_sorted = extensions_strength_sorted.iter().cloned().collect();\n\
    \    extensions_strength_sorted.sort();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect\n}\n\nfn main() {\n   \
    \ let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0mzyngsp.rs:54:92\n   |\n\
    54 |     let mut extensions_strength_sorted = extensions_strength_sorted.iter().cloned().collect\n\
    \   |                                                                        \
    \                    ^ help: add `;` here\n55 | }\n   | - unexpected token\n\n\
    error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp0mzyngsp.rs:18:30\n\
    \   |\n18 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp0mzyngsp.rs:20:33\n\
    \   |\n20 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0mzyngsp.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm - cap\n     \
    \   };\n        extension = extension.concat(e);\n    }\n    class_name.concat(\"\
    .\").concat(extension).concat(\".\").to_string()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp33e64axe.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0599]: no method named\
    \ `concat` found for struct `String` in the current scope\n  --> /tmp/tmp33e64axe.rs:28:31\n\
    \   |\n28 |         extension = extension.concat(e);\n   |                   \
    \            ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `concat` found for struct `String` in the current scope\n  --> /tmp/tmp33e64axe.rs:30:16\n\
    \   |\n30 |     class_name.concat(\".\").concat(extension).concat(\".\").to_string()\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.to_string();\n\
    \            break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpb06ott_l.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      let strength = cap - sm;\n        if strength > strength {\n          \
    \  extension = extension;\n            strength = strength;\n        }\n    }\n\
    \    class_name.to_string() + \".\" + extension.to_string()\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpascanpfa.rs:29:36\n   |\n\
    29 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension.chars() {\n            extension_map.insert(c.to_uppercase(),\
    \ c.to_lowercase());\n        }\n        extensions_map.insert(extension.clone(),\
    \ extension_map);\n    }\n    let mut strength = -1;\n    let mut best_extension\
    \ = String::from(\"\");\n    for extension in extensions {\n        let mut extension_map\
    \ = extensions_map.get(extension.clone());\n        if extension_map.is_none()\
    \ {\n            continue;\n        }\n        let mut extension_strength = -1;\n\
    \        for c in extension.chars() {\n            let mut extension_map = extensions_map.get(c.to_lowercase());\n\
    \            if extension_map.is_none() {\n                continue;\n       \
    \     }\n            let mut extension_strength = -1;\n            for c in extension.chars()\
    \ {\n                let mut extension_map = extensions_map.get(c.to_uppercase());\n\
    \                if extension_map.is_none() {\n                    continue;\n\
    \                }\n                let strength = extension_map.get(&c.to_lowercase()).unwrap().len()\
    \ - extension_map.get(&c.to_uppercase()).unwrap().len();\n                if strength\
    \ > extension_strength {\n                    extension_strength = strength;\n\
    \                    best_extension = extension.clone();\n                }\n\
    \            }\n        }\n        if extension_strength > strength {\n      \
    \      strength = extension_strength;\n            best_extension = extension.clone();\n\
    \        }\n    }\n    class_name.to_string() + \".\" + best_extension.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp9c2fo_nj.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp9c2fo_nj.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9c2fo_nj.rs:57:36\n   |\n\
    57 |     class_name.to_string() + \".\" + best_extension.to_string()\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |           \
    \                         |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&best_extension.to_string()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension = String::from(\"\");\n    for e in extensions {\n\
    \        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap\
    \ - sm;\n        if strength > 0 {\n            extension = e;\n        }\n  \
    \  }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxuwam9ql.rs:23:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = -1;\n        for c in extension.chars() {\n      \
    \      if c.is_uppercase() {\n                strength += 1;\n            }\n\
    \            if c.is_lowercase() {\n                strength += 1;\n         \
    \   }\n        }\n        if strength > strength {\n            extension = class_name;\n\
    \            strength = -1;\n        }\n    }\n    extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmpapwy62ye.rs:18:13\n\
    \   |\n18 |     let mut strength = -1;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to `extension`\
    \ is never read\n  --> /tmp/tmpapwy62ye.rs:33:13\n   |\n33 |             extension\
    \ = class_name;\n   |             ^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `strength` is never read\n  --> /tmp/tmpapwy62ye.rs:34:13\n\
    \   |\n34 |             strength = -1;\n   |             ^^^^^^^^\n   |\n   =\
    \ help: maybe it is overwritten before being read?\n\nwarning: variable does not\
    \ need to be mutable\n  --> /tmp/tmpapwy62ye.rs:18:9\n   |\n18 |     let mut strength\
    \ = -1;\n   |         ----^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpapwy62ye.rs:19:9\n   |\n\
    19 |     let mut extension = String::from(\"\");\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpapwy62ye.rs:21:13\n   |\n21 |        \
    \ let mut class_name = class_name;\n   |             ----^^^^^^^^^^\n   |    \
    \         |\n   |             help: remove this `mut`\n\nerror[E0382]: use of\
    \ moved value: `class_name`\n  --> /tmp/tmpapwy62ye.rs:21:30\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                        ----------\
    \ move occurs because `class_name` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n21 |         let mut class_name = class_name;\n   | \
    \                             ^^^^^^^^^^ value moved here, in previous iteration\
    \ of loop\n\nerror: aborting due to previous error; 6 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > strength {\n            extension = e;\n   \
    \         strength = strength;\n        }\n    }\n    class_name.to_string() +\
    \ \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1t_pmtb_.rs:33:36\n   |\n\
    33 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        let strength_fraction\
    \ = cap - sm;\n        if strength_fraction > strength {\n            extension\
    \ = e;\n            strength = strength_fraction;\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptqxh13tt.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptqxh13tt.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptqxh13tt.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptqxh13tt.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmptqxh13tt.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension: Option<String> = None;\n    for e in extensions {\n\
    \        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap\
    \ - sm;\n        if strength > 0 {\n            extension = Some(e);\n       \
    \ }\n    }\n    extension.unwrap_or(class_name + \".\" + extensions[0])\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvohilnym.rs:28:44\n   |\n\
    28 |     extension.unwrap_or(class_name + \".\" + extensions[0])\n   |       \
    \                                     ^^^^^^^^^^^^^\n   |                    \
    \                        |\n   |                                            expected\
    \ `&str`, found struct `String`\n   |                                        \
    \    help: consider borrowing here: `&extensions[0]`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
