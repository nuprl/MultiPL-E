language: rs
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut class_name =\
    \ class_name.clone();\n        let mut c = class_name.chars().count();\n     \
    \   let mut s = extension.chars().count();\n        let mut c = c - s;\n     \
    \   if c > strength {\n            strength = c;\n            extension = extension.clone();\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpv71gc69m.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(&letter) {\n      \
    \          extension_map.insert(letter, strength + 1);\n            } else {\n\
    \                extension_map.insert(letter, 1);\n            }\n        }\n\
    \        if let Some(strength) = extension_map.get(&'.') {\n            extension_strength\
    \ = strength;\n        }\n        extensions_map.insert(extension, extension_strength);\n\
    \    }\n    let mut extensions_strength = -1;\n    for extension in extensions_map.keys()\
    \ {\n        if let Some(strength) = extensions_map.get(&extension) {\n      \
    \      extensions_strength = strength;\n        }\n    }\n    if extensions_strength\
    \ == -1 {\n        return class_name;\n    }\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(&letter) {\n      \
    \          extension_map.insert(letter, strength + 1);\n            } else {\n\
    \                extension_map.insert(letter, 1);\n            }\n        }\n\
    \        if let Some(strength) = extension_map.get(&'.') {\n            extension_strength\
    \ = strength;\n        }\n        extensions_map.insert(extension, extension_strength);\n\
    \    }\n    let mut extensions_strength = -1;\n    for extension in extensions_map.keys()\
    \ {\n        if let Some(strength) = extensions_map.get(&extension) {\n      \
    \      extensions_strength = strength;\n        }\n    }\n    if extensions_strength\
    \ == -1 {\n        return class_name;\n    }\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(&letter) {\n      \
    \          extension_map.insert(letter, strength + 1);\n            } else {\n\
    \                extension_map.insert(letter, 1);\n            }\n        }\n\
    \        if let Some(strength) = extension_map.get(&'.') {\n            extension_strength\
    \ = strength;\n        }\n        extensions_map.insert(extension, extension_strength);\n\
    \    }\n    let mut extensions_strength = -1;\n    for extension in extensions_map.keys()\
    \ {\n        if let Some(strength) = extensions_\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpd4i1c6q9.rs:100:3\n\
    \    |\n17  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                                         \
    \                      - unclosed delimiter\n...\n85  |     for extension in extensions_map.keys()\
    \ {\n    |                                            - this delimiter might not\
    \ be properly closed...\n86  |         if let Some(strength) = extensions_\n87\
    \  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    100 | }\n    |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpd4i1c6q9.rs:87:1\n\
    \   |\n86 |         if let Some(strength) = extensions_\n   |         -- this\
    \ `if` expression has a condition, but no block\n87 | }\n   | ^ expected `{`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpd4i1c6q9.rs:18:30\n\
    \   |\n18 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpd4i1c6q9.rs:20:33\n\
    \   |\n20 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpd4i1c6q9.rs:43:30\n\
    \   |\n43 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpd4i1c6q9.rs:45:33\n\
    \   |\n45 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ fail"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    class_name.concat(\".\"\
    ).concat(extension).concat(\".\").concat(format!(\"{}\", strength));\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpzp6s1vtu.rs:28:31\n   |\n28 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpzp6s1vtu.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n \
    \  |\n   = help: the following other types implement trait `Neg`:\n          \
    \   &f32\n             &f64\n             &i128\n             &i16\n         \
    \    &i32\n             &i64\n             &i8\n             &isize\n        \
    \   and 8 others\n\nerror[E0599]: no method named `concat` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpzp6s1vtu.rs:30:16\n   |\n30 |     class_name.concat(\"\
    .\").concat(extension).concat(\".\").concat(format!(\"{}\", strength));\n   |\
    \                ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzp6s1vtu.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = strength;\n        for letter in extension.chars()\
    \ {\n            if let Some(index) = class_name.chars().position(|c| c.to_ascii_lowercase()\
    \ == letter) {\n                class_name = &class_name[index..];\n         \
    \       strength = -1;\n                break;\n            }\n        }\n   \
    \     if strength > strength {\n            extension = extension;\n         \
    \   strength = strength;\n        }\n    }\n    class_name + extension\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvxun1uwj.rs:26:30\n   |\n\
    21 |         let mut class_name = class_name;\n   |                          \
    \    ---------- expected due to this value\n...\n26 |                 class_name\
    \ = &class_name[index..];\n   |                              ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n26 |                 class_name = (&class_name[index..]).to_string();\n\
    \   |                              +                    +++++++++++++\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpvxun1uwj.rs:27:28\n\
    \   |\n27 |                 strength = -1;\n   |                            ^^\n\
    \   |                            |\n   |                            cannot apply\
    \ unary operator `-`\n   |                            help: you may have meant\
    \ the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvxun1uwj.rs:36:18\n\
    \   |\n36 |     class_name + extension\n   |                  ^^^^^^^^^\n   |\
    \                  |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&extension`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0600.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension.chars() {\n            extension_map.insert(c.to_uppercase(),\
    \ c.to_lowercase());\n        }\n        extensions_map.insert(extension.clone(),\
    \ extension_map);\n    }\n    let mut strength = -1;\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<_>>();\n    extensions_sorted.sort_by_key(|x|\
    \ {\n        let mut c = x.chars().cloned().collect::<Vec<_>>();\n        c.sort_by_key(|y|\
    \ {\n            let mut c = y.chars().cloned().collect::<Vec<_>>();\n       \
    \     c.sort_by_key(|z| {\n                let mut c = z.chars().cloned().collect::<Vec<_>>();\n\
    \                c.sort_by_key(|a| {\n                    let mut c = a.chars().cloned().collect::<Vec<_>>();\n\
    \                    c.sort_by_key(|b| {\n                        let mut c =\
    \ b.chars().cloned().collect::<Vec<_>>();\n                        c.sort_by_key(|c|\
    \ {\n                            let mut c = c.chars().cloned().collect::<Vec<_>>();\n\
    \                            c.sort_by_key(|d| {\n                           \
    \     let mut c = d.chars().cloned().collect::<Vec<_>>();\n                  \
    \              c.sort_by_key(|e| {\n                                    let mut\
    \ c = e.chars().cloned().collect::<Vec<_>>();\n                              \
    \      c.sort_by_key(|f| {\n                                        let mut c\
    \ = f.chars().cloned().collect::<Vec<_>>();\n                                \
    \        c.sort_by_key(|g| {\n                                            let\
    \ mut c = g.chars().cloned().collect::<Vec<_>>();\n                          \
    \                  c.sort_by_key(|h| {\n                                     \
    \           let mut c = h.chars().cloned().collect::<Vec<_>>();\n            \
    \                                    c.sort_by_key(|i| {\n                   \
    \                                 let mut c = i.chars().cloned().collect::<Vec<_>>();\n\
    \                                                    c.sort_by_key(|j| {\n   \
    \                                                     let mut c = j.chars().cloned().collect::<Vec<_>>();\n\
    \                                                        c.sort_by_key(|k| {\n\
    \                                                            let mut c = k.chars().cloned().collect::<Vec<_>>();\n\
    \                                                            c.sort_by_key(|l|\
    \ {\n\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0emt_3ro.rs:71:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n28 |     extensions_sorted.sort_by_key(|x|\
    \ {\n   |                                  -    - unclosed delimiter\n   |   \
    \                               |\n   |                                  unclosed\
    \ delimiter\n29 |         let mut c = x.chars().cloned().collect::<Vec<_>>();\n\
    30 |         c.sort_by_key(|y| {\n   |                      -    - unclosed delimiter\n\
    \   |                      |\n   |                      unclosed delimiter\n31\
    \ |             let mut c = y.chars().cloned().collect::<Vec<_>>();\n32 |    \
    \         c.sort_by_key(|z| {\n   |                          -    - unclosed delimiter\n\
    \   |                          |\n   |                          unclosed delimiter\n\
    33 |                 let mut c = z.chars().cloned().collect::<Vec<_>>();\n34 |\
    \                 c.sort_by_key(|a| {\n   |                              -   \
    \ - unclosed delimiter\n   |                              |\n   |            \
    \                  unclosed delimiter\n35 |                     let mut c = a.chars().cloned().collect::<Vec<_>>();\n\
    36 |                     c.sort_by_key(|b| {\n   |                           \
    \       -    - unclosed delimiter\n   |                                  |\n \
    \  |                                  unclosed delimiter\n37 |               \
    \          let mut c = b.chars().cloned().collect::<Vec<_>>();\n38 |         \
    \                c.sort_by_key(|c| {\n   |                                   \
    \   -    - unclosed delimiter\n   |                                      |\n \
    \  |                                      unclosed delimiter\n39 |           \
    \                  let mut c = c.chars().cloned().collect::<Vec<_>>();\n40 | \
    \                            c.sort_by_key(|d| {\n   |                       \
    \                   -    - unclosed delimiter\n   |                          \
    \          "
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension {\n            extension_map.insert(c.to_lowercase(),\
    \ 1);\n        }\n        extensions_map.insert(extension.to_lowercase(), extension_map);\n\
    \    }\n    let mut strength = -1;\n    let mut extensions_with_same_strength\
    \ = Vec::new();\n    for (extension, extension_map) in extensions_map.iter() {\n\
    \        let mut extension_strength = -1;\n        for c in extension {\n    \
    \        extension_strength += extension_map.get(c).unwrap();\n        }\n   \
    \     if extension_strength > strength {\n            strength = extension_strength;\n\
    \            extensions_with_same_strength.clear();\n        }\n        if extension_strength\
    \ == strength {\n            extensions_with_same_strength.push(extension);\n\
    \        }\n    }\n    if extensions_with_same_strength.len() > 1 {\n        let\
    \ mut extensions_with_same_strength_sorted = extensions_with_same_strength.iter().cloned().collect::<Vec<_>>();\n\
    \        extensions_with_same_strength_sorted.sort();\n        return format!(\"\
    {}.{}\", class_name, extensions_with_same_strength_sorted[0]);\n    } else {\n\
    \        return format!(\"{}.{}\", class_name, extensions_with_same_strength[0]);\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpsors9gml.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpsors9gml.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpsors9gml.rs:21:18\n\
    \   |\n21 |         for c in extension {\n   |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     if cap > sm {\n            strength = cap - sm;\n            extension =\
    \ extension.clone();\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpt5x0uh1t.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_len = extension.len();\n        let mut class_len =\
    \ class_name.len();\n        let mut i = 0;\n        while i < extension_len {\n\
    \            if extension[i] == class_name[i] {\n                i += 1;\n   \
    \             extension_len -= 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if extension_len > strength {\n           \
    \ strength = extension_len;\n            extension = extension;\n        }\n \
    \   }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0qm_7dar.rs:25:16\n\
    \   |\n25 |             if extension[i] == class_name[i] {\n   |             \
    \   ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0qm_7dar.rs:25:32\n   |\n25 |             if extension[i] == class_name[i]\
    \ {\n   |                                ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n \
    \ --> /tmp/tmp0qm_7dar.rs:18:24\n   |\n18 |     let mut strength = -1;\n   | \
    \                       ^^ the trait `Neg` is not implemented for `usize`\n  \
    \ |\n   = help: the following other types implement trait `Neg`:\n           \
    \  &f32\n             &f64\n             &i128\n             &i16\n          \
    \   &i32\n             &i64\n             &i8\n             &isize\n         \
    \  and 8 others\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(c) {\n            \
    \    extension_map.insert(c, strength + 1);\n            } else {\n          \
    \      extension_map.insert(c, 1);\n            }\n            if strength > extension_strength\
    \ {\n                extension_strength = strength;\n            }\n        }\n\
    \        extensions_map.insert(extension, extension_strength);\n    }\n    let\
    \ mut extensions_strength = -1;\n    for extension in extensions_map.keys() {\n\
    \        if extensions_strength < extensions_map.get(extension).unwrap() {\n \
    \           extensions_strength = extensions_map.get(extension).unwrap();\n  \
    \      }\n    }\n    format!(\"{}.{}\", class_name, extensions_map.get(&extensions_strength).unwrap())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpqxbgplom.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpqxbgplom.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `strength` in this scope\n  --> /tmp/tmpqxbgplom.rs:28:16\n\
    \   |\n28 |             if strength > extension_strength {\n   |             \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `strength`\
    \ in this scope\n  --> /tmp/tmpqxbgplom.rs:29:38\n   |\n29 |                 extension_strength\
    \ = strength;\n   |                                      ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > strength {\n            extension = e;\n   \
    \         strength = strength;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmpwp8jxyyl.rs:18:13\n\
    \   |\n18 |     let mut strength = -1;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to `strength`\
    \ is never read\n  --> /tmp/tmpwp8jxyyl.rs:30:13\n   |\n30 |             strength\
    \ = strength;\n   |             ^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpwp8jxyyl.rs:18:9\n   |\n\
    18 |     let mut strength = -1;\n   |         ----^^^^^^^^\n   |         |\n \
    \  |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0384]: cannot assign twice to immutable variable `strength`\n\
    \  --> /tmp/tmpwp8jxyyl.rs:30:13\n   |\n23 |         let strength = if cap > sm\
    \ {\n   |             --------\n   |             |\n   |             first assignment\
    \ to `strength`\n   |             help: consider making this binding mutable:\
    \ `mut strength`\n...\n30 |             strength = strength;\n   |           \
    \  ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to previous error; 3 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension.chars() {\n            extension_map.insert(c.to_ascii_lowercase(),\
    \ 0);\n        }\n        extensions_map.insert(extension.clone(), extension_map);\n\
    \    }\n    let mut extensions_sorted = Vec::new();\n    let mut extensions_strength\
    \ = Vec::new();\n    for extension in extensions {\n        let mut extension_map\
    \ = extensions_map.get(extension.clone());\n        if extension_map.is_none()\
    \ {\n            continue;\n        }\n        let mut extension_strength = extension_map.values().iter().max().unwrap();\n\
    \        extensions_sorted.push(extension);\n        extensions_strength.push(extension_strength);\n\
    \    }\n    let mut extensions_strength_sorted = Vec::new();\n    for extension_strength\
    \ in extensions_strength {\n        extensions_strength_sorted.push(extension_strength);\n\
    \    }\n    let mut extensions_strength_sorted = extensions_strength_sorted.iter().cloned().collect();\n\
    \    extensions_strength_sorted.sort();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect();\n    let mut extensions_strength_sorted\
    \ = extensions_strength_sorted.iter().cloned().collect\n}\n\nfn main() {\n   \
    \ let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0mzyngsp.rs:54:92\n   |\n\
    54 |     let mut extensions_strength_sorted = extensions_strength_sorted.iter().cloned().collect\n\
    \   |                                                                        \
    \                    ^ help: add `;` here\n55 | }\n   | - unexpected token\n\n\
    error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp0mzyngsp.rs:18:30\n\
    \   |\n18 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp0mzyngsp.rs:20:33\n\
    \   |\n20 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0mzyngsp.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm - cap\n     \
    \   };\n        extension = extension.concat(e);\n    }\n    class_name.concat(\"\
    .\").concat(extension).concat(\".\").to_string()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp33e64axe.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0599]: no method named\
    \ `concat` found for struct `String` in the current scope\n  --> /tmp/tmp33e64axe.rs:28:31\n\
    \   |\n28 |         extension = extension.concat(e);\n   |                   \
    \            ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `concat` found for struct `String` in the current scope\n  --> /tmp/tmp33e64axe.rs:30:16\n\
    \   |\n30 |     class_name.concat(\".\").concat(extension).concat(\".\").to_string()\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.to_string();\n\
    \            break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpb06ott_l.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      let strength = cap - sm;\n        if strength > strength {\n          \
    \  extension = extension;\n            strength = strength;\n        }\n    }\n\
    \    class_name.to_string() + \".\" + extension.to_string()\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpascanpfa.rs:29:36\n   |\n\
    29 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension.chars() {\n            extension_map.insert(c.to_uppercase(),\
    \ c.to_lowercase());\n        }\n        extensions_map.insert(extension.clone(),\
    \ extension_map);\n    }\n    let mut strength = -1;\n    let mut best_extension\
    \ = String::from(\"\");\n    for extension in extensions {\n        let mut extension_map\
    \ = extensions_map.get(extension.clone());\n        if extension_map.is_none()\
    \ {\n            continue;\n        }\n        let mut extension_strength = -1;\n\
    \        for c in extension.chars() {\n            let mut extension_map = extensions_map.get(c.to_lowercase());\n\
    \            if extension_map.is_none() {\n                continue;\n       \
    \     }\n            let mut extension_strength = -1;\n            for c in extension.chars()\
    \ {\n                let mut extension_map = extensions_map.get(c.to_uppercase());\n\
    \                if extension_map.is_none() {\n                    continue;\n\
    \                }\n                let strength = extension_map.get(&c.to_lowercase()).unwrap().len()\
    \ - extension_map.get(&c.to_uppercase()).unwrap().len();\n                if strength\
    \ > extension_strength {\n                    extension_strength = strength;\n\
    \                    best_extension = extension.clone();\n                }\n\
    \            }\n        }\n        if extension_strength > strength {\n      \
    \      strength = extension_strength;\n            best_extension = extension.clone();\n\
    \        }\n    }\n    class_name.to_string() + \".\" + best_extension.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp9c2fo_nj.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp9c2fo_nj.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9c2fo_nj.rs:57:36\n   |\n\
    57 |     class_name.to_string() + \".\" + best_extension.to_string()\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |           \
    \                         |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&best_extension.to_string()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension = String::from(\"\");\n    for e in extensions {\n\
    \        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap\
    \ - sm;\n        if strength > 0 {\n            extension = e;\n        }\n  \
    \  }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpxuwam9ql.rs:23:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = -1;\n        for c in extension.chars() {\n      \
    \      if c.is_uppercase() {\n                strength += 1;\n            }\n\
    \            if c.is_lowercase() {\n                strength += 1;\n         \
    \   }\n        }\n        if strength > strength {\n            extension = class_name;\n\
    \            strength = -1;\n        }\n    }\n    extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmpapwy62ye.rs:18:13\n\
    \   |\n18 |     let mut strength = -1;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to `extension`\
    \ is never read\n  --> /tmp/tmpapwy62ye.rs:33:13\n   |\n33 |             extension\
    \ = class_name;\n   |             ^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `strength` is never read\n  --> /tmp/tmpapwy62ye.rs:34:13\n\
    \   |\n34 |             strength = -1;\n   |             ^^^^^^^^\n   |\n   =\
    \ help: maybe it is overwritten before being read?\n\nwarning: variable does not\
    \ need to be mutable\n  --> /tmp/tmpapwy62ye.rs:18:9\n   |\n18 |     let mut strength\
    \ = -1;\n   |         ----^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpapwy62ye.rs:19:9\n   |\n\
    19 |     let mut extension = String::from(\"\");\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpapwy62ye.rs:21:13\n   |\n21 |        \
    \ let mut class_name = class_name;\n   |             ----^^^^^^^^^^\n   |    \
    \         |\n   |             help: remove this `mut`\n\nerror[E0382]: use of\
    \ moved value: `class_name`\n  --> /tmp/tmpapwy62ye.rs:21:30\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                        ----------\
    \ move occurs because `class_name` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n21 |         let mut class_name = class_name;\n   | \
    \                             ^^^^^^^^^^ value moved here, in previous iteration\
    \ of loop\n\nerror: aborting due to previous error; 6 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > strength {\n            extension = e;\n   \
    \         strength = strength;\n        }\n    }\n    class_name.to_string() +\
    \ \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1t_pmtb_.rs:33:36\n   |\n\
    33 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        let strength_fraction\
    \ = cap - sm;\n        if strength_fraction > strength {\n            extension\
    \ = e;\n            strength = strength_fraction;\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptqxh13tt.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptqxh13tt.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptqxh13tt.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptqxh13tt.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmptqxh13tt.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n            "
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension: Option<String> = None;\n    for e in extensions {\n\
    \        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap\
    \ - sm;\n        if strength > 0 {\n            extension = Some(e);\n       \
    \ }\n    }\n    extension.unwrap_or(class_name + \".\" + extensions[0])\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvohilnym.rs:28:44\n   |\n\
    28 |     extension.unwrap_or(class_name + \".\" + extensions[0])\n   |       \
    \                                     ^^^^^^^^^^^^^\n   |                    \
    \                        |\n   |                                            expected\
    \ `&str`, found struct `String`\n   |                                        \
    \    help: consider borrowing here: `&extensions[0]`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut i = 0;\n        while i < class_name.len() {\n            if\
    \ class_name[i] == extension[i] {\n                i += 1;\n            } else\
    \ {\n                break;\n            }\n        }\n        if strength ==\
    \ -1 || strength > i - extension.len() {\n            strength = i - extension.len();\n\
    \            extension = extension;\n        }\n    }\n    class_name + extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_tw_boor.rs:25:16\n\
    \   |\n25 |             if class_name[i] == extension[i] {\n   |             \
    \   ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp_tw_boor.rs:25:33\n   |\n\
    25 |             if class_name[i] == extension[i] {\n   |                    \
    \             ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp_tw_boor.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmp_tw_boor.rs:31:24\n   |\n31 |         if\
    \ strength == -1 || strength > i - extension.len() {\n   |                   \
    \     ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_tw_boor.rs:36:18\n   |\n36 |     class_name + extension\n\
    \   |                  ^^^^^^^^^\n   |                  |\n   |              \
    \    expected `&str`, found struct `String`\n   |                  help: consider\
    \ borrowing here: `&extension`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     strength = if cap > sm {\n            cap - sm\n        } else {\n     \
    \       sm - cap\n        };\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpta93_81b.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > strength {\n            extension = e;\n   \
    \         strength = strength;\n        }\n    }\n    class_name.to_string() +\
    \ \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1t_pmtb_.rs:33:36\n   |\n\
    33 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_strength = extension.chars().filter(|c| c.is_uppercase()).count()\
    \ - extension.chars().filter(|c| c.is_lowercase()).count();\n        if extension_strength\
    \ > strength {\n            strength = extension_strength;\n            extension\
    \ = extension;\n        }\n    }\n    class_name.to_string() + \".\" + extension.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmppqymn28y.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppqymn28y.rs:27:36\n   |\n27 |     class_name.to_string() + \".\" + extension.to_string()\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^\n   |         \
    \                           |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&extension.to_string()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = 0;\n        for letter in extension {\n\
    \            if letter == letter::CAPITAL {\n                extension_strength\
    \ += 1;\n            } else {\n                extension_strength += 2;\n    \
    \        }\n        }\n        extension_map.insert(extension, extension_strength);\n\
    \        extensions_map.insert(extension_map.keys().max().unwrap(), extension_map);\n\
    \    }\n    let mut extensions_strength = HashMap::new();\n    for extension in\
    \ extensions {\n        let mut extension_map = extensions_map.get(extension).unwrap();\n\
    \        let mut extension_strength = extension_map.keys().max().unwrap();\n \
    \       extensions_strength.insert(extension_strength, extension);\n    }\n  \
    \  let mut extensions_strength_max = extensions_strength.keys().max().unwrap();\n\
    \    let mut extensions_strength_max_index = extensions_strength.keys().iter().position(|&x|\
    \ x == extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_index\
    \ = extensions_strength_max_index - 1;\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength_max_value\
    \ = extensions_strength.get(extensions_strength_max).unwrap();\n    let mut extensions_strength\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_fngw1bx.rs:53:32\n   |\n\
    53 |     let mut extensions_strength\n   |                                ^ help:\
    \ add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `letter`\n  --> /tmp/tmp_fngw1bx.rs:23:26\n\
    \   |\n23 |             if letter == letter::CAPITAL {\n   |                 \
    \         ^^^^^^ use of undeclared crate or module `letter`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp_fngw1bx.rs:18:30\n\
    \   |\n18 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp_fngw1bx.rs:20:33\n\
    \   |\n20 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp_fngw1bx.rs:32:35\n\
    \   |\n32 |     let mut extensions_strength = HashMap::new();\n   |          \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ `String` is not an iterator\n   --> /tmp/tmp_fngw1bx.rs:22:23\n    |\n22  |\
    \         for letter in extension {\n    |                       ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_fngw1bx.rs:17:72\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |    -------------------                                   \
    \              ^^^^^^ expected struct `"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    for e in extensions {\n    \
    \    let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        if strength > 0 {\n            extension = e.to_string() + extension;\n\
    \        }\n    }\n    class_name + extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_kodz86i.rs:24:13\n   |\n\
    24 |             cap - sm\n   |             ^^^^^^^^ expected `i32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n24 |             (cap - sm).try_into().unwrap()\n \
    \  |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_kodz86i.rs:26:13\n   |\n\
    26 |             sm\n   |             ^^ expected `i32`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `i32` and panic if the converted value doesn't\
    \ fit\n   |\n26 |             sm.try_into().unwrap()\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_kodz86i.rs:29:41\n   |\n29 |             extension = e.to_string()\
    \ + extension;\n   |                                         ^^^^^^^^^\n   | \
    \                                        |\n   |                             \
    \            expected `&str`, found struct `String`\n   |                    \
    \                     help: consider borrowing here: `&extension`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_kodz86i.rs:32:18\n   |\n32 |     class_name\
    \ + extension\n   |                  ^^^^^^^^^\n   |                  |\n   |\
    \                  expected `&str`, found struct `String`\n   |              \
    \    help: consider borrowing here: `&extension`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = cap\
    \ - sm;\n        if strength > 0 {\n            extension = e.clone();\n     \
    \       break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp_le2bpz8.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm - cap\n     \
    \   };\n        extension = extension.concat(e);\n    }\n    class_name.concat(\"\
    .\").concat(extension).to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmphgj0vnme.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0599]: no method named `concat`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmphgj0vnme.rs:28:31\n\
    \   |\n28 |         extension = extension.concat(e);\n   |                   \
    \            ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `concat` found for struct `String` in the current scope\n  --> /tmp/tmphgj0vnme.rs:30:16\n\
    \   |\n30 |     class_name.concat(\".\").concat(extension).to_string()\n   | \
    \               ^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension.chars() {\n            extension_map.insert(c.to_ascii_lowercase(),\
    \ -1);\n        }\n        extensions_map.insert(extension.clone(), extension_map);\n\
    \    }\n    let mut strength = -1;\n    let mut best_extension = String::from(\"\
    \");\n    for extension in extensions {\n        let mut extension_map = extensions_map.get(extension);\n\
    \        if extension_map.is_none() {\n            continue;\n        }\n    \
    \    let mut extension_strength = 0;\n        for c in extension.chars() {\n \
    \           let c = c.to_ascii_lowercase();\n            let strength = extension_map.get(c).unwrap();\n\
    \            extension_strength += strength;\n        }\n        if extension_strength\
    \ > strength {\n            best_extension = extension.clone();\n            strength\
    \ = extension_strength;\n        }\n    }\n    class_name.to_string() + \".\"\
    \ + best_extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpod93_1_0.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpod93_1_0.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpod93_1_0.rs:44:36\n   |\n\
    44 |     class_name.to_string() + \".\" + best_extension.to_string()\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |           \
    \                         |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&best_extension.to_string()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension: String;\n    for extension in extensions {\n        let\
    \ mut class_name = class_name;\n        let mut extension = extension;\n     \
    \   let mut i = 0;\n        while i < extension.len() {\n            if class_name.chars().any(|c|\
    \ c.is_uppercase() && c != extension[i]) {\n                class_name = &class_name[..i];\n\
    \                break;\n            }\n            i += 1;\n        }\n     \
    \   let mut i = 0;\n        while i < extension.len() {\n            if class_name.chars().any(|c|\
    \ c.is_lowercase() && c != extension[i]) {\n                class_name = &class_name[..i];\n\
    \                break;\n            }\n            i += 1;\n        }\n     \
    \   if class_name.len() > 0 {\n            strength = extension.len() - class_name.len();\n\
    \            break;\n        }\n    }\n    if strength == -1 {\n        String::from(class_name)\n\
    \    } else {\n        String::from(&format!(\"{}.{}\", class_name, extensions[strength]))\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lkk8_fe.rs:25:68\n\
    \   |\n25 |             if class_name.chars().any(|c| c.is_uppercase() && c !=\
    \ extension[i]) {\n   |                                                      \
    \              ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4lkk8_fe.rs:26:30\n   |\n26 |              \
    \   class_name = &class_name[..i];\n   |                              ^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n26 |                 class_name = (&class_name[..i]).to_string();\n   |\
    \                              +                +++++++++++++\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lkk8_fe.rs:33:68\n\
    \   |\n33 |             if class_name.chars().any(|c| c.is_lowercase() && c !=\
    \ extension[i]) {\n   |                                                      \
    \              ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4lkk8_fe.rs:34:30\n   |\n34 |              \
    \   class_name = &class_name[..i];\n   |                              ^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n34 |                 class_name = (&class_name[..i]).to_string();\n   |\
    \                              +                +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4lkk8_fe.rs:40:24\n   |\n40 |             strength\
    \ = extension.len() - class_name.len();\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `i32`, found `usize`\n\nerror[E0277]: the type `[String]` cannot be\
    \ indexed by `i32`\n  --> /tmp/tmp4lkk8_fe.rs:47:52\n   |\n47 |         String::from(&format!(\"\
    {}.{}\", class_name, extensions[strength]))\n   |                            \
    \                        ^^^^^^^^^^^^^^^^^^^^ slice indices are of type "
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension {\n    \
    \        if let Some(strength) = extension_map.get(&c) {\n                extension_strength\
    \ = strength;\n            }\n            extension_map.insert(c, extension_strength);\n\
    \        }\n        extensions_map.insert(extension, extension_strength);\n  \
    \  }\n    let mut strength = -1;\n    let mut extension = String::from(\"\");\n\
    \    for c in class_name {\n        if let Some(strength) = extensions_map.get(&c)\
    \ {\n            if strength > strength {\n                extension = c;\n  \
    \              strength = strength;\n            }\n        }\n    }\n    extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpgondk_u5.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpgondk_u5.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpgondk_u5.rs:22:18\n\
    \    |\n22  |         for c in extension {\n    |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpgondk_u5.rs:32:14\n\
    \    |\n32  |     for c in class_name {\n    |              ^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<_>>();\n    extensions_sorted.sort_unstable_by_key(|x|\
    \ x.to_lowercase().chars().count() - x.to_lowercase().chars().count());\n    let\
    \ mut extensions_strength = vec![-1; extensions.len()];\n    for extension in\
    \ extensions_sorted {\n        let mut extension_strength = extension.chars().count()\
    \ - extension.chars().count() + 1;\n        for c in extension.chars().iter()\
    \ {\n            if c >= 'A' && c <= 'Z' {\n                extension_strength\
    \ -= 1;\n            }\n        }\n        extensions_strength[extensions.iter().position(|x|\
    \ x == extension).unwrap()] = extension_strength;\n    }\n    let mut class_strength\
    \ = class_name.chars().count() - class_name.chars().count() + 1;\n    for c in\
    \ class_name.chars().iter() {\n        if c >= 'A' && c <= 'Z' {\n           \
    \ class_strength -= 1;\n        }\n    }\n    if extensions_strength.iter().any(|&x|\
    \ x == -1) {\n        String::from(\"\")\n    } else {\n        let mut strongest_extension\
    \ = String::from(\"\");\n        let mut strength = -1;\n        for (i, &x) in\
    \ extensions_strength.iter().enumerate() {\n            if x == -1 {\n       \
    \         continue;\n            }\n            if strength < i {\n          \
    \      strength = i;\n                strongest_extension = x;\n            }\n\
    \        }\n        class_name.to_string() + \".\" + strongest_extension.to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpw76zmhgm.rs:23:36\n   |\n23 |         for c in extension.chars().iter()\
    \ {\n   |                                    ^^^^ private field, not a method\n\
    \nerror[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpw76zmhgm.rs:28:62\n\
    \   |\n28 |         extensions_strength[extensions.iter().position(|x| x == extension).unwrap()]\
    \ = extension_strength;\n   |                                                \
    \              ^^ no implementation for `&String == String`\n   |\n   = help:\
    \ the trait `PartialEq<String>` is not implemented for `&String`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpw76zmhgm.rs:20:40\n\
    \   |\n20 |     let mut extensions_strength = vec![-1; extensions.len()];\n  \
    \ |                                        ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0599]: no method named `iter` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpw76zmhgm.rs:31:33\n   |\n31 |     for c\
    \ in class_name.chars().iter() {\n   |                                 ^^^^ private\
    \ field, not a method\n\nerror[E0600]: cannot apply unary operator `-` to type\
    \ `usize`\n  --> /tmp/tmpw76zmhgm.rs:36:49\n   |\n36 |     if extensions_strength.iter().any(|&x|\
    \ x == -1) {\n   |                                                 ^^\n   |  \
    \                                               |\n   |                      \
    \                           cannot apply unary operator `-`\n   |            \
    \                                     help: you may have meant the maximum value\
    \ of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpw76zmhgm.rs:42:21\n\
    \   |\n42 |             if x == -1 {\n   |                     ^^\n   |      \
    \               |\n   |                     cannot apply unary operator `-`\n\
    \   |                     help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror["
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut cap = extension.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        let mut sm = extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        if cap > sm {\n            strength\
    \ = cap - sm;\n            extension = extension.clone();\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpufjy6nt3.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        strength =\
    \ if cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n\
    \        };\n        extension = if strength > 0 {\n            format!(\"{}.{}\"\
    , class_name, e)\n        } else {\n            e\n        };\n    }\n    extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpipk5q05w.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpipk5q05w.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpipk5q05w.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpipk5q05w.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpipk5q05w.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308"
  stdout: ''
  timestamp: 1659748934
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = cap\
    \ - sm;\n        if strength > 0 {\n            extension = e.to_string();\n \
    \           break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpxh_8jxcb.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      strength = if cap > sm {\n            cap - sm\n        } else {\n    \
    \        sm - cap\n        };\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5qffnhgb.rs:24:13\n   |\n\
    24 |             cap - sm\n   |             ^^^^^^^^ expected `i32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n24 |             (cap - sm).try_into().unwrap()\n \
    \  |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5qffnhgb.rs:26:13\n   |\n\
    26 |             sm - cap\n   |             ^^^^^^^^ expected `i32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n26 |             (sm - cap).try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength_fraction\
    \ = cap - sm;\n        if strength_fraction > strength {\n            extension\
    \ = e;\n            strength = strength_fraction;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp236217lg.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        strength =\
    \ if cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n\
    \        };\n        extension = extension.concat(e);\n    }\n    extension.concat(class_name.to_lowercase());\n\
    \    extension.concat(\".\").concat(extensions[extensions.iter().rposition(|e|\
    \ e == extension).unwrap()].to_lowercase());\n    extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptannvcvi.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptannvcvi.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptannvcvi.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptannvcvi.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmptannvcvi.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0599]: no method named `concat`\
    \ found for struct `String` in the current scope\n  --> /t"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm - cap\n     \
    \   };\n        extension = extension.concat(e);\n    }\n    extension.concat(\"\
    .\").concat(class_name.to_lowercase()).concat(\".\").concat(extensions[extensions.iter().position(|e|\
    \ e.to_lowercase() == extension).unwrap()].to_lowercase())\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpnxdn289r.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0599]: no method named `concat`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpnxdn289r.rs:28:31\n\
    \   |\n28 |         extension = extension.concat(e);\n   |                   \
    \            ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `concat` found for struct `String` in the current scope\n  --> /tmp/tmpnxdn289r.rs:30:15\n\
    \   |\n30 |     extension.concat(\".\").concat(class_name.to_lowercase()).concat(\"\
    .\").concat(extensions[extensions.iter().position(|e| e.to_lowercase()...\n  \
    \ |               ^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut i = 0;\n        while i < class_name.len() {\n            if\
    \ class_name[i] == extension[i] {\n                i += 1;\n            } else\
    \ {\n                break;\n            }\n        }\n        if i == class_name.len()\
    \ {\n            strength = -1;\n        } else {\n            strength = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() - extension.chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count();\n        }\n    }\n    if strength == -1 {\n        class_name\n\
    \    } else {\n        class_name.to_string() + extension.to_string() + &format!(\"\
    {}.{}\", class_name, strength)\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpapurgm17.rs:25:16\n\
    \   |\n25 |             if class_name[i] == extension[i] {\n   |             \
    \   ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpapurgm17.rs:25:33\n   |\n\
    25 |             if class_name[i] == extension[i] {\n   |                    \
    \             ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpapurgm17.rs:34:59\n   |\n34 | ...   strength = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() - extension.chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count();\n   |                                                     ^^^\n\
    \   |                                                     |\n   |            \
    \                                         expected `&char`, found `char`\n   |\
    \                                                     help: consider borrowing\
    \ here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpapurgm17.rs:34:71\n\
    \   |\n34 | ...   strength = class_name.chars().filter(|c| c >= 'A' && c <= 'Z').count()\
    \ - extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n   |        \
    \                                                         ^^^\n   |          \
    \                                                       |\n   |              \
    \                                                   expected `&char`, found `char`\n\
    \   |                                                                 help: consider\
    \ borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpapurgm17.rs:34:120\n\
    \   |\n34 | ...).count() - extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                  ^^^\n   |             \
    \                                     |\n   |                                \
    \                  expected `&char`, found `char`\n   |        "
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut class_name =\
    \ class_name.clone();\n        let mut letters = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let mut lowercase = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let mut capitals = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let mut strength = if letters > lowercase\
    \ {\n            letters - lowercase\n        } else if letters > capitals {\n\
    \            letters - capitals\n        } else {\n            lowercase - capitals\n\
    \        };\n        if strength > 0 {\n            break;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp44ep5qqe.rs:23:61\n   |\n\
    23 |         let mut letters = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                             ^^^\n   |  \
    \                                                           |\n   |          \
    \                                                   expected `&char`, found `char`\n\
    \   |                                                             help: consider\
    \ borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp44ep5qqe.rs:23:73\n\
    \   |\n23 |         let mut letters = extension.chars().filter(|c| c >= 'A' &&\
    \ c <= 'Z').count();\n   |                                                   \
    \                      ^^^\n   |                                             \
    \                            |\n   |                                         \
    \                                expected `&char`, found `char`\n   |        \
    \                                                                 help: consider\
    \ borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp44ep5qqe.rs:24:63\n\
    \   |\n24 |         let mut lowercase = extension.chars().filter(|c| c >= 'a'\
    \ && c <= 'z').count();\n   |                                                \
    \               ^^^\n   |                                                    \
    \           |\n   |                                                          \
    \     expected `&char`, found `char`\n   |                                   \
    \                            help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp44ep5qqe.rs:24:75\n   |\n24 |         let mut\
    \ lowercase = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n  \
    \ |                                                                          \
    \ ^^^\n   |                                                                  \
    \         |\n   |                                                            \
    \               expected `&char`, found `char`\n   |                         \
    \                                         "
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_strength = -1;\n        let mut extension_class = String::from(\"\
    \");\n        let mut extension_class_strength = -1;\n        let mut extension_class_name\
    \ = String::from(\"\");\n        let mut extension_class_name_strength = -1;\n\
    \        let mut extension_class_name_length = String::from(\"\");\n        let\
    \ mut extension_class_name_length_strength = -1;\n        let mut extension_class_name_length\
    \ = String::from(\"\");\n        let mut extension_class_name_length_strength\
    \ = -1;\n        let mut extension_class_name_length = String::from(\"\");\n \
    \       let mut extension_class_name_length_strength = -1;\n        let mut extension_class_name_length\
    \ = String::from(\"\");\n        let mut extension_class_name_length_strength\
    \ = -1;\n        let mut extension_class_name_length = String::from(\"\");\n \
    \       let mut extension_class_name_length_strength = -1;\n        let mut extension_class_name_length\
    \ = String::from(\"\");\n        let mut extension_class_name_length_strength\
    \ = -1;\n        let mut extension_class_name_length = String::from(\"\");\n \
    \       let mut extension_class_name_length_strength = -1;\n        let mut extension_class_name_length\
    \ = String::from(\"\");\n        let mut extension_class_name_length_strength\
    \ = -1;\n        let mut extension_class_name_length = String::from(\"\");\n \
    \       let mut extension_class_name_length_strength = -1;\n        let mut extension_class_name_length\
    \ = String::from(\"\");\n        let mut extension_class_name_length_strength\
    \ = -1;\n        let mut extension_class_name_length = String::from(\"\");\n \
    \       let mut extension_class_name_length_strength = -1;\n        let mut extension_class_name_length\
    \ = String::from(\"\");\n        let mut extension_class_name_length_strength\
    \ = -1;\n        let mut extension_class_name_length = String::from(\"\");\n \
    \       let mut extension_class_name_length_strength = -1;\n        let mut extension_class_name_length\
    \ = String::from(\"\");\n        let mut extension_class_name_length_strength\
    \ = -1;\n        let mut extension_class_name_length = String::from(\"\");\n \
    \       let mut extension_class_name_length_strength = -1;\n        let mut extension_class_name_length\
    \ = String::from(\"\");\n        let mut extension_class_name_length_strength\
    \ = -1;\n        let mut extension_class_name_length = String::from(\"\");\n \
    \       let mut extension_class_name_length_strength = -1;\n        let mut extension_class_name_length\
    \ = String::from(\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp19ao3d0h.rs:74:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n20 |     for extension in extensions\
    \ {\n   |                                 - this delimiter might not be properly\
    \ closed...\n...\n61 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n74 | }\n   |   ^\n\nerror: expected one of `.`, `;`, `?`, `else`, or an operator,\
    \ found `}`\n  --> /tmp/tmp19ao3d0h.rs:61:1\n   |\n61 | }\n   | ^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp19ao3d0h.rs:60:59\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                         \
    \                                                      - closing delimiter possibly\
    \ meant for this\n...\n60 |         let mut extension_class_name_length = String::from(\n\
    \   |                                                           ^ unclosed delimiter\n\
    61 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp19ao3d0h.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp4yougmos.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.to_string();\n\
    \            break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpb06ott_l.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<String>>();\n    extensions_sorted.sort_by_key(|x|\
    \ x.chars().filter(|c| c.is_uppercase()).count() - x.chars().filter(|c| c.is_lowercase()).count());\n\
    \    extensions_sorted.iter().next().unwrap().to_string() + class_name.to_string()\
    \ + extensions_sorted.iter().next().unwrap().to_string()\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpobusbymv.rs:20:60\n   |\n\
    20 |     extensions_sorted.iter().next().unwrap().to_string() + class_name.to_string()\
    \ + extensions_sorted.iter().next().unwrap().to_string()\n   |               \
    \                                             ^^^^^^^^^^^^^^^^^^^^^^\n   |   \
    \                                                         |\n   |            \
    \                                                expected `&str`, found struct\
    \ `String`\n   |                                                            help:\
    \ consider borrowing here: `&class_name.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpobusbymv.rs:20:85\n   |\n20 |     extensions_sorted.iter().next().unwrap().to_string()\
    \ + class_name.to_string() + extensions_sorted.iter().next().unwrap().to_string()\n\
    \   |                                                                        \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |     \
    \                                                                            \
    \    |\n   |                                                                 \
    \                    expected `&str`, found struct `String`\n   |            \
    \                                                                         help:\
    \ consider borrowing here: `&extensions_sorted.iter().next().unwrap().to_string()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     if cap > sm {\n            strength = cap - sm;\n            extension =\
    \ extension.clone();\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpt5x0uh1t.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension = String::from(\"\");\n    for e in extensions {\n\
    \        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap\
    \ - sm;\n        extension = extension.concat(e);\n    }\n    extension.concat(\"\
    .\")\n        .concat(&class_name)\n        .concat(\".\").concat(&extensions[extensions.iter().position(|x|\
    \ x.starts_with(extension)).unwrap()])\n        .to_string()\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgdskd7re.rs:24:31\n   |\n24 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `concat` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpgdskd7re.rs:26:15\n   |\n26 | \
    \    extension.concat(\".\")\n   |               ^^^^^^ method not found in `String`\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  --> /tmp/tmpgdskd7re.rs:28:86\n\
    \   |\n28 |         .concat(\".\").concat(&extensions[extensions.iter().position(|x|\
    \ x.starts_with(extension)).unwrap()])\n   |                                 \
    \                                                     ^^^^^^^^^\n   |        \
    \                                                                            \
    \  |\n   |                                                                   \
    \                   expected an implementor of trait `Pattern<'_>`\n   |     \
    \                                                                            \
    \     help: consider borrowing here: `&extension`\n   |\n   = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n   = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      strength += cap - sm;\n    }\n    if strength > 0 {\n        String::from(format!(\"\
    {}.{}\", class_name, extensions[extensions.iter().min_by_key(|e| strength).unwrap()]))\
    \ \n    } else {\n        String::from(\"\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp23hhasv0.rs:23:21\n   |\n\
    23 |         strength += cap - sm;\n   |                     ^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `i32`\n \
    \ --> /tmp/tmp23hhasv0.rs:23:18\n   |\n23 |         strength += cap - sm;\n  \
    \ |                  ^^ no implementation for `i32 += usize`\n   |\n   = help:\
    \ the trait `AddAssign<usize>` is not implemented for `i32`\n\nerror[E0277]: the\
    \ type `[String]` cannot be indexed by `&String`\n  --> /tmp/tmp23hhasv0.rs:26:51\n\
    \   |\n26 |         String::from(format!(\"{}.{}\", class_name, extensions[extensions.iter().min_by_key(|e|\
    \ strength).unwrap()])) \n   |                                               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `&String`\n   = note: required because of the requirements\
    \ on the impl of `Index<&String>` for `Vec<String>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension.chars() {\n            extension_map.insert(letter,\
    \ 0);\n        }\n        extensions_map.insert(extension, extension_map);\n \
    \   }\n    let mut strength = -1;\n    let mut extension = String::from(\"\");\n\
    \    let mut extension_map = extensions_map.get(&class_name);\n    while let Some(extension_map)\
    \ = extension_map {\n        for letter in extension.chars() {\n            if\
    \ let Some(strength) = extension_map.get(&letter) {\n                if strength\
    \ > strength {\n                    extension = extension.clone();\n         \
    \           strength = strength;\n                }\n            } else {\n  \
    \              extension = extension.clone();\n                strength = -1;\n\
    \            }\n        }\n        extension_map = extensions_map.get(&class_name);\n\
    \    }\n    extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpkyiezy6u.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpkyiezy6u.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension.chars() {\n            extension_map.insert(c.to_lowercase(),\
    \ 1);\n        }\n        extensions_map.insert(extension.clone(), extension_map);\n\
    \    }\n    let mut strength = -1;\n    let mut extensions_sorted_by_strength\
    \ = Vec::new();\n    for extension in extensions {\n        let mut extension_map\
    \ = extensions_map.get(extension.clone());\n        if extension_map.is_none()\
    \ {\n            continue;\n        }\n        let mut extension_strength = extension_map.values().iter().filter(|&x|\
    \ x == 1).count();\n        if extension_strength > strength {\n            strength\
    \ = extension_strength;\n            extensions_sorted_by_strength.clear();\n\
    \            extensions_sorted_by_strength.push(extension);\n        } else if\
    \ extension_strength == strength {\n            extensions_sorted_by_strength.push(extension);\n\
    \        }\n    }\n    if extensions_sorted_by_strength.is_empty() {\n       \
    \ return class_name;\n    }\n    let mut extensions_sorted_by_strength = extensions_sorted_by_strength.iter().cloned().collect::<Vec<_>>();\n\
    \    extensions_sorted_by_strength.sort_by_key(|&x| x.to_lowercase());\n    let\
    \ mut extensions_sorted_by_strength = extensions_sorted_by_strength.iter().cloned().collect::<Vec<_>>();\n\
    \    extensions_sorted_by_strength.sort_by_key(|&x| x.to_lowercase());\n    let\
    \ mut extensions_sorted_by_strength = extensions_sorted_by_strength.iter().cloned().collect::<Vec<_>>();\n\
    \    extensions_sorted_by_strength.sort_by_key(|&x| x.to_lowercase());\n    let\
    \ mut extensions_sorted_by_strength = extensions_sorted_by_strength.iter().cloned().collect::<Vec<_>>();\n\
    \    extensions_sorted_by_strength.sort_by_key(|&x| x.to_lowercase());\n    let\
    \ mut extensions_sorted_by_strength = extensions_sorted_by_strength.iter().cloned().collect::<Vec<_>>();\n\
    \    extensions_sorted_by_strength.sort_by_key(|&x| x.to_lowercase());\n    let\
    \ mut extensions_sorted_by_strength = extensions_sorted_by_strength.iter().cloned().collect::<Vec<_>>();\n\
    \    extensions_sorted_by_strength.sort_by_key(|&x| x.to_lowercase());\n    let\
    \ mut extensions_sorted_by_strength\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv2q05elm.rs:57:42\n   |\n\
    57 |     let mut extensions_sorted_by_strength\n   |                         \
    \                 ^ help: add `;` here\n58 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpv2q05elm.rs:18:30\n\
    \   |\n18 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpv2q05elm.rs:20:33\n\
    \   |\n20 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv2q05elm.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm\n       \
    \ };\n        if strength > strength {\n            extension = e;\n         \
    \   strength = strength;\n        }\n    }\n    class_name.to_string() + \".\"\
    \ + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_1oml0kb.rs:33:36\n   |\n\
    33 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut class_name =\
    \ class_name.clone();\n        let mut count = String::from(\"\");\n        let\
    \ mut cap = String::from(\"\");\n        let mut sm = String::from(\"\");\n  \
    \      while !extension.starts_with(\"_\") {\n            extension = extension.clone();\n\
    \            class_name = class_name.clone();\n            count = String::from(\"\
    \");\n            cap = String::from(\"\");\n            sm = String::from(\"\"\
    );\n            for c in extension.chars() {\n                if c.is_uppercase()\
    \ {\n                    cap = cap.clone();\n                    cap += c.to_string();\n\
    \                } else if c.is_lowercase() {\n                    sm = sm.clone();\n\
    \                    sm += c.to_string();\n                } else {\n        \
    \            count += c.to_string();\n                }\n            }\n     \
    \       strength = cap.len() - sm.len();\n            if strength > 0 {\n    \
    \            break;\n            }\n        }\n        if strength == 0 {\n  \
    \          extension = extension.clone();\n            class_name = class_name.clone();\n\
    \            count = String::from(\"\");\n            cap = String::from(\"\"\
    );\n            sm = String::from(\"\");\n            for c in extension.chars()\
    \ {\n                if c.is_uppercase() {\n                    cap = cap.clone();\n\
    \                    cap += c.to_string();\n                } else if c.is_lowercase()\
    \ {\n                    sm = sm.clone();\n                    sm += c.to_string();\n\
    \                } else {\n                    count += c.to_string();\n     \
    \           }\n            }\n            strength = cap.len() - sm.len();\n \
    \       }\n        if strength > 0 {\n            break;\n        }\n    }\n \
    \   format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0lk59dge.rs:35:28\n   |\n\
    35 |                     cap += c.to_string();\n   |                         \
    \   ^^^^^^^^^^^^^\n   |                            |\n   |                   \
    \         expected `&str`, found struct `String`\n   |                       \
    \     help: consider borrowing here: `&c.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0lk59dge.rs:38:27\n   |\n38 |                     sm +=\
    \ c.to_string();\n   |                           ^^^^^^^^^^^^^\n   |         \
    \                  |\n   |                           expected `&str`, found struct\
    \ `String`\n   |                           help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0lk59dge.rs:40:30\n   |\n40 |\
    \                     count += c.to_string();\n   |                          \
    \    ^^^^^^^^^^^^^\n   |                              |\n   |                \
    \              expected `&str`, found struct `String`\n   |                  \
    \            help: consider borrowing here: `&c.to_string()`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp0lk59dge.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0lk59dge.rs:57:28\n   |\n57 |                     cap += c.to_string();\n\
    \   |                            ^^^^^^^^^^^^^\n   |                         \
    \   |\n   |                            expected `&str`, found struct `String`\n\
    \   |                            help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0lk59dge.rs:60:27\n   |\n60 |\
    \                     sm += c.to_string();\n   |                           ^^^^^^^^^^^^^\n\
    \   |                           |\n   |                           expected `&str`,\
    \ found struct `String`\n   |                           help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0lk59dge.rs:62:30\n\
    \   |\n62 |                     count += c.t"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut i = 0;\n    \
    \    while i < extension.len() {\n            if extension[i] == extension[i].to_lowercase().chars().count()\
    \ {\n                i += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        let mut j = 0;\n        while j < extension.len()\
    \ {\n            if extension[j] == extension[j].to_uppercase().chars().count()\
    \ {\n                j += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if strength == -1 || strength > i - j {\n  \
    \          strength = i - j;\n            extension = extension.clone();\n   \
    \     }\n    }\n    class_name.to_string() + \".\" + extension.to_string()\n}\n\
    \nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpt9ruuy0v.rs:24:16\n\
    \   |\n24 |             if extension[i] == extension[i].to_lowercase().chars().count()\
    \ {\n   |                ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpt9ruuy0v.rs:24:32\n\
    \   |\n24 |             if extension[i] == extension[i].to_lowercase().chars().count()\
    \ {\n   |                                ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpt9ruuy0v.rs:32:16\n   |\n32 |             if extension[j] == extension[j].to_uppercase().chars().count()\
    \ {\n   |                ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpt9ruuy0v.rs:32:32\n\
    \   |\n32 |             if extension[j] == extension[j].to_uppercase().chars().count()\
    \ {\n   |                                ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  -->\
    \ /tmp/tmpt9ruuy0v.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |     \
    \                   ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpt9ruuy0v.rs:38:24\n\
    \   |\n38 |         if strength == -1 || strength > i - j {\n   |            \
    \            ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt9ruuy0v.rs:43:36\n   |\n43 |     class_name.to_string()\
    \ + \".\" + extension.to_string()\n   |                                    ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                    |\n   |                             \
    \       expec"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for e in extensions {\n    \
    \    let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        if strength > 0 {\n            extension = e.to_string();\n         \
    \   break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt7fduct1.rs:24:13\n   |\n\
    24 |             cap - sm\n   |             ^^^^^^^^ expected `i64`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i64` and panic if the converted\
    \ value doesn't fit\n   |\n24 |             (cap - sm).try_into().unwrap()\n \
    \  |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt7fduct1.rs:26:13\n   |\n\
    26 |             sm\n   |             ^^ expected `i64`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `i64` and panic if the converted value doesn't\
    \ fit\n   |\n26 |             sm.try_into().unwrap()\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = cap - sm;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpjy9eccc7.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if letter.is_uppercase() {\n                extension_map.insert(letter,\
    \ extension_strength);\n            }\n            extension_strength += 1;\n\
    \        }\n        extensions_map.insert(extension, extension_map);\n    }\n\
    \    let mut extensions_strength = -1;\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if letter.is_lowercase() {\n                extension_map.insert(letter,\
    \ extension_strength);\n            }\n            extension_strength += 1;\n\
    \        }\n        extensions_map.insert(extension, extension_map);\n    }\n\
    \    let mut extensions_map = HashMap::new();\n    for extension in extensions\
    \ {\n        let mut extension_map = HashMap::new();\n        let mut extension_strength\
    \ = -1;\n        for letter in extension.chars() {\n            if letter.is_uppercase()\
    \ {\n                extension_map.insert(letter, extension_strength);\n     \
    \       }\n            extension_strength += 1;\n        }\n        extensions_map.insert(extension,\
    \ extension_map);\n    }\n    let mut extensions_map = HashMap::new();\n    for\
    \ extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if letter.is_lowercase() {\n                extension_map.insert(letter,\
    \ extension_strength);\n            }\n            extension_strength += 1;\n\
    \        }\n        extensions_map.insert(extension, extension_map);\n    }\n\
    \    let mut extensions_map = HashMap::new();\n    for extension in extensions\
    \ {\n        let mut extension_map = HashMap::new();\n        let mut extension_strength\
    \ = -1;\n        for letter in extension.chars() {\n            if letter.is_uppercase()\
    \ {\n                extension_map.insert(letter, extension_strength);\n     \
    \       }\n            extension_strength += 1;\n        }\n        extensions_map.insert(extension,\
    \ extension_map);\n    }\n    let mut extensions_map = HashMap::new();\n    for\
    \ extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if \n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvovm3mhh.rs:98:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n80 |     for extension in extensions\
    \ {\n   |                                 - unclosed delimiter\n...\n83 |    \
    \     for letter in extension.chars() {\n   |                                \
    \         - this delimiter might not be properly closed...\n84 |             if\
    \ \n85 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    98 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpvovm3mhh.rs:85:1\n\
    \   |\n85 | }\n   | ^ expected expression\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpvovm3mhh.rs:18:30\n   |\n18\
    \ |     let mut extensions_map = HashMap::new();\n   |                       \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpvovm3mhh.rs:20:33\n   |\n20\
    \ |         let mut extension_map = HashMap::new();\n   |                    \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpvovm3mhh.rs:31:30\n\
    \   |\n31 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpvovm3mhh.rs:33:33\n\
    \   |\n33 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for char in extension {\n \
    \           if char.chars().count() > extension_strength {\n                extension_strength\
    \ = char.chars().count();\n            }\n            extension_map.insert(char,\
    \ 0);\n        }\n        extensions_map.insert(extension, extension_strength);\n\
    \    }\n    let mut strength = -1;\n    let mut extensions_strength = -1;\n  \
    \  for (extension, extension_strength) in extensions_map {\n        if extension_strength\
    \ > extensions_strength {\n            extensions_strength = extension_strength;\n\
    \            strength = extension_strength;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, extensions[extensions.iter().min_by_key(|&(_, strength)|\
    \ strength).unwrap().0]);\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphi0iqd2a.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmphi0iqd2a.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmphi0iqd2a.rs:22:21\n\
    \    |\n22  |         for char in extension {\n    |                     ^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphi0iqd2a.rs:38:76\n\
    \   |\n38 |     format!(\"{}.{}\", class_name, extensions[extensions.iter().min_by_key(|&(_,\
    \ strength)| strength).unwrap().0]);\n   |                                   \
    \                                         ^^^^^^^^^^^^-\n   |                \
    \                                                            |           |\n \
    \  |                                                                         \
    \   |           expected due to this\n   |                                   \
    \                                         expected struct `String`, found tuple\n\
    \   |\n   = note: expected struct `String`\n               found tuple `(_, _)`\n\
    \nerror[E0609]: no field `0` on type `&String`\n  --> /tmp/tmphi0iqd2a.rs:38:110\n\
    \   |\n38 |     format!(\"{}.{}\", class_name, extensions[extensions.iter().min_by_key(|&(_,\
    \ strength)| strength).unwrap().0]);\n   |                                   \
    \                                                                           ^\
    \ unknown f"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut i = 0;\n        while i < class_name.len() {\n            let\
    \ mut c = class_name[i];\n            if c.is_uppercase() {\n                c\
    \ -= 'A' as u8;\n            } else {\n                c -= 'a' as u8;\n     \
    \       }\n            i += 1;\n            class_name = &class_name[i..];\n \
    \           if class_name.len() == 0 {\n                break;\n            }\n\
    \        }\n        let mut i = 0;\n        while i < extension.len() {\n    \
    \        let mut c = extension[i];\n            if c.is_lowercase() {\n      \
    \          c -= 'a' as u8;\n            } else {\n                c -= 'A' as\
    \ u8;\n            }\n            i += 1;\n            extension = &extension[i..];\n\
    \            if extension.len() == 0 {\n                break;\n            }\n\
    \        }\n        if strength == -1 || strength > extension.len() as i32 {\n\
    \            strength = extension.len() as i32;\n            extension = class_name;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe8y5dtdv.rs:25:25\n\
    \   |\n25 |             let mut c = class_name[i];\n   |                     \
    \    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe8y5dtdv.rs:32:26\n   |\n32 |             class_name =\
    \ &class_name[i..];\n   |                          ^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n32\
    \ |             class_name = (&class_name[i..]).to_string();\n   |           \
    \               +                +++++++++++++\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpe8y5dtdv.rs:39:25\n   |\n39 |  \
    \           let mut c = extension[i];\n   |                         ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe8y5dtdv.rs:46:25\n\
    \   |\n46 |             extension = &extension[i..];\n   |                   \
    \      ^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n46 |             extension = (&extension[i..]).to_string();\n\
    \   |                         +               +++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for letter in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(&letter) {\n      \
    \          extension_map.insert(letter, strength + 1);\n            } else {\n\
    \                extension_map.insert(letter, 1);\n            }\n        }\n\
    \        if let Some(strength) = extension_map.get(&'.') {\n            extension_strength\
    \ = strength;\n        }\n        extensions_map.insert(extension, extension_strength);\n\
    \    }\n    let mut extensions_strength = -1;\n    for extension in extensions_map.keys()\
    \ {\n        if let Some(strength) = extensions_map.get(&extension) {\n      \
    \      extensions_strength = strength;\n        }\n    }\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<_>>();\n    extensions_sorted.sort_by(|a,\
    \ b| extensions_map.get(b).cmp(&extensions_map.get(a)));\n    extensions_sorted.first().to_string()\
    \ + extensions_strength.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpxlkqh1s8.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpxlkqh1s8.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: the method `to_string` exists for enum `Option<&String>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmpxlkqh1s8.rs:42:31\n\
    \    |\n42  |       extensions_sorted.first().to_string() + extensions_strength.to_string()\n\
    \    |                                 ^^^^^^^^^ method cannot be called on `Option<&String>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Option<&String>: std::fmt::Display`\n    \
    \        which is required by `Option<&String>: ToString`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension {\n            extension_map.insert(letter, 0);\n\
    \        }\n        extensions_map.insert(extension, extension_map);\n    }\n\
    \    let mut strength = -1;\n    let mut extensions_with_same_strength = Vec::new();\n\
    \    for (extension, extension_map) in extensions_map.iter() {\n        let mut\
    \ extension_with_same_strength = Vec::new();\n        for letter in extension\
    \ {\n            if let Some(count) = extension_map.get(letter) {\n          \
    \      extension_with_same_strength.push(letter);\n                extension_map.insert(letter,\
    \ count + 1);\n            } else {\n                extension_map.insert(letter,\
    \ 1);\n            }\n        }\n        if extension_with_same_strength.len()\
    \ > 0 {\n            extensions_with_same_strength.push(extension);\n        \
    \    strength = extension_with_same_strength.len() as i32;\n        }\n    }\n\
    \    if extensions_with_same_strength.len() > 0 {\n        String::from(format!(\"\
    {}.{}\", class_name, extensions_with_same_strength.iter().max().unwrap()))\n \
    \   } else {\n        String::from(class_name)\n    }\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp4c0ovlde.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp4c0ovlde.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmp4c0ovlde.rs:21:23\n\
    \    |\n21  |         for letter in extension {\n    |                       ^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = cap\
    \ - sm;\n        if strength > 0 {\n            extension = e.clone();\n     \
    \       break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp_le2bpz8.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        if cap > sm\
    \ {\n            strength = cap - sm;\n            extension = e;\n        }\n\
    \    }\n    class_name.to_string() + \".\" + extension.to_string()\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl5e30oqp.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl5e30oqp.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl5e30oqp.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpl5e30oqp.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpl5e30oqp.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpl5e30oqp.rs:28:36\n   |\n28 |     class_name.to_str"
  stdout: ''
  timestamp: 1659748934
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = cap - sm;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpjy9eccc7.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.to_string();\n\
    \            break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpb06ott_l.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm - cap\n     \
    \   };\n        extension = if strength == 0 {\n            e.to_string()\n  \
    \      } else {\n            format!(\"{}.{}\", class_name, e)\n        };\n \
    \   }\n    extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmppj9k3pqp.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = if strength > 0 {\n            format!(\"{}.{}\", class_name,\
    \ e)\n        } else {\n            e\n        };\n    }\n    extension\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp6d9q9_vl.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > strength {\n            extension = e;\n   \
    \         strength = strength;\n        }\n    }\n    class_name.to_string() +\
    \ \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1t_pmtb_.rs:33:36\n   |\n\
    33 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.to_string();\n\
    \            break;\n        }\n    }\n    class_name.to_string() + \".\" + extension.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprjt6towk.rs:33:36\n   |\n\
    33 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut cap = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let mut sm = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        if cap > sm {\n            cap = cap\
    \ - sm;\n        }\n        strength = if strength == -1 || cap > strength {\n\
    \            cap\n        } else {\n            strength\n        };\n    }\n\
    \    format!(\"{}.{}\", class_name, extensions[extensions.iter().min_by_key(|x|\
    \ x.cmp(&strength)).unwrap()])\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpab4v9iqm.rs:22:57\n   |\n\
    22 |         let mut cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                         ^^^\n   |      \
    \                                                   |\n   |                  \
    \                                       expected `&char`, found `char`\n   | \
    \                                                        help: consider borrowing\
    \ here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpab4v9iqm.rs:22:69\n\
    \   |\n22 |         let mut cap = extension.chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count();\n   |                                                        \
    \             ^^^\n   |                                                      \
    \               |\n   |                                                      \
    \               expected `&char`, found `char`\n   |                         \
    \                                            help: consider borrowing here: `&'Z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpab4v9iqm.rs:23:56\n   |\n23 |\
    \         let mut sm = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                                        ^^^\n   |       \
    \                                                 |\n   |                    \
    \                                    expected `&char`, found `char`\n   |    \
    \                                                    help: consider borrowing\
    \ here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpab4v9iqm.rs:23:68\n\
    \   |\n23 |         let mut sm = extension.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').count();\n   |                                                        \
    \            ^^^\n   |                                                       \
    \             |\n   |                                                        \
    \            expected `&char`, found `char`\n   |                            \
    \                                        help: consider borrowing here: `&'z'`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  "
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<String>>();\n    extensions_sorted.sort_unstable();\n\
    \    let mut strength = -1;\n    let mut extension = String::from(\"\");\n   \
    \ for extension in extensions_sorted {\n        let cap = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if cap > sm {\n            strength = cap - sm;\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpz1bbzryd.rs:20:24\n\
    \   |\n20 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut counter = 0;\n        while class_name.len() > 0 && extension.len()\
    \ > 0 {\n            if class_name.chars().any(|c| c.is_uppercase() == true) {\n\
    \                counter += 1;\n                class_name = &class_name[1..];\n\
    \            }\n            if extension.chars().any(|c| c.is_lowercase() == true)\
    \ {\n                counter += 1;\n                extension = &extension[1..];\n\
    \            }\n        }\n        if counter > strength {\n            strength\
    \ = counter;\n            extension = extension;\n        }\n    }\n    class_name\
    \ + extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n  \
    \  assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4bui1r4n.rs:27:30\n   |\n\
    27 |                 class_name = &class_name[1..];\n   |                    \
    \          ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n27 |                 class_name = (&class_name[1..]).to_string();\n\
    \   |                              +                +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4bui1r4n.rs:31:29\n   |\n31 |              \
    \   extension = &extension[1..];\n   |                             ^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n31 |                 extension = (&extension[1..]).to_string();\n   | \
    \                            +               +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4bui1r4n.rs:39:18\n   |\n39 |     class_name + extension\n\
    \   |                  ^^^^^^^^^\n   |                  |\n   |              \
    \    expected `&str`, found struct `String`\n   |                  help: consider\
    \ borrowing here: `&extension`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    for e in extensions {\n    \
    \    let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        if strength > 0 {\n            extension = e.clone();\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfbmq9stu.rs:24:13\n   |\n\
    24 |             cap - sm\n   |             ^^^^^^^^ expected `i32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n24 |             (cap - sm).try_into().unwrap()\n \
    \  |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfbmq9stu.rs:26:13\n   |\n\
    26 |             sm\n   |             ^^ expected `i32`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `i32` and panic if the converted value doesn't\
    \ fit\n   |\n26 |             sm.try_into().unwrap()\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension {\n            if c.is_uppercase() {\n           \
    \     extension_map.insert(c.to_lowercase(), -1);\n            } else {\n    \
    \            extension_map.insert(c.to_uppercase(), -1);\n            }\n    \
    \    }\n        extensions_map.insert(extension.clone(), extension_map);\n   \
    \ }\n    let mut strength = -1;\n    let mut extensions_iter = extensions_map.iter().cloned();\n\
    \    while let Some(extension) = extensions_iter.next() {\n        let mut extension_map\
    \ = extension.clone();\n        for (key, value) in extension_map {\n        \
    \    if value == -1 {\n                extension_map.remove(&key);\n         \
    \   } else {\n                strength = if value > strength {\n             \
    \       value\n                } else {\n                    strength\n      \
    \          };\n            }\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extensions_map.iter().next().unwrap().keys().collect::<Vec<_>>().join(\".\"\
    ));\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpkj2m22yr.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpkj2m22yr.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpkj2m22yr.rs:21:18\n\
    \    |\n21  |         for c in extension {\n    |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkj2m22yr.rs:17:72\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |    -------------------                                   \
    \              ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |  \
    \  implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut class_name =\
    \ class_name.clone();\n        let mut strength = -1;\n        for c in extension.chars()\
    \ {\n            if c.is_uppercase() {\n                strength += 1;\n     \
    \       }\n            if c.is_lowercase() {\n                strength += 1;\n\
    \            }\n        }\n        if strength > 0 {\n            break;\n   \
    \     }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpoj_c9275.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     if cap > sm {\n            strength = cap - sm;\n            extension =\
    \ extension.clone();\n        }\n    }\n    class_name.to_string() + \".\" + extension.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp1e99pijs.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1e99pijs.rs:28:36\n   |\n28 |     class_name.to_string() + \".\" + extension.to_string()\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^\n   |         \
    \                           |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&extension.to_string()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        strength =\
    \ if cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n\
    \        };\n        extension = extension.concat(e);\n    }\n    extension.concat(\"\
    .\").concat(class_name.to_lowercase()).concat(\".\").concat(extensions[extensions.iter().position(|e|\
    \ e == extension).unwrap()].to_lowercase()).to_string()\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp64py7jv4.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp64py7jv4.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp64py7jv4.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp64py7jv4.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp64py7jv4.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0599]: no method named `concat`\
    \ found for struct `String` in the current scope\n  --> /t"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut extension_len = extension.len();\n        let mut class_len\
    \ = class_name.len();\n        let mut i = 0;\n        while i < extension_len\
    \ {\n            if extension_name >= class_name[i as usize] {\n             \
    \   extension_len = i;\n            } else {\n                class_len = i;\n\
    \            }\n            i += 1;\n        }\n        let mut j = 0;\n     \
    \   while j < class_len {\n            if class_name >= class_name[j as usize]\
    \ {\n                class_len = j;\n            } else {\n                strength\
    \ = -1;\n            }\n            j += 1;\n        }\n        if strength ==\
    \ -1 {\n            strength = extension_len - class_len;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, extensions[strength])\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `extension_name` in this scope\n  --> /tmp/tmpbijzba9e.rs:25:16\n\
    \   |\n25 |             if extension_name >= class_name[i as usize] {\n   |  \
    \              ^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `extension_len`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbijzba9e.rs:25:34\n   |\n25 |             if extension_name >=\
    \ class_name[i as usize] {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpbijzba9e.rs:34:30\n   |\n34 |            \
    \ if class_name >= class_name[j as usize] {\n   |                            \
    \  ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbijzba9e.rs:42:24\n   |\n42 |             strength = extension_len\
    \ - class_len;\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror[E0277]: the type `[String]` cannot be indexed\
    \ by `i32`\n  --> /tmp/tmpbijzba9e.rs:45:34\n   |\n45 |     format!(\"{}.{}\"\
    , class_name, extensions[strength])\n   |                                  ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `i32`\n   = note: required\
    \ because of the requirements on the impl of `Index<i32>` for `Vec<String>`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut counter = 0;\n        while class_name.len() > 0 && extension.len()\
    \ > 0 {\n            if class_name.chars().any(|c| c.is_uppercase() && extension.chars().any(|c|\
    \ c.is_lowercase())) {\n                counter += 1;\n                class_name\
    \ = &class_name[..class_name.len() - extension.len()];\n                extension\
    \ = &extension[..extension.len() - class_name.len()];\n            } else {\n\
    \                break;\n            }\n        }\n        if counter > strength\
    \ {\n            strength = counter;\n            extension = extension;\n   \
    \     }\n    }\n    class_name + extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4qtkrfr1.rs:27:30\n   |\n\
    27 |                 class_name = &class_name[..class_name.len() - extension.len()];\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n27 |                 class_name = (&class_name[..class_name.len() - extension.len()]).to_string();\n\
    \   |                              +                                         \
    \        +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4qtkrfr1.rs:28:29\n\
    \   |\n28 |                 extension = &extension[..extension.len() - class_name.len()];\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n28 |                 extension = (&extension[..extension.len() - class_name.len()]).to_string();\n\
    \   |                             +                                          \
    \      +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4qtkrfr1.rs:38:18\n\
    \   |\n38 |     class_name + extension\n   |                  ^^^^^^^^^\n   |\
    \                  |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&extension`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    class_name.concat(\".\"\
    ).concat(extension).concat(\".\").to_owned()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpu07x91ik.rs:28:31\n   |\n28 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpu07x91ik.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpu07x91ik.rs:30:16\n   |\n30 |     class_name.concat(\"\
    .\").concat(extension).concat(\".\").to_owned()\n   |                ^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        let strength\
    \ = if cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n\
    \        };\n        if strength > strength {\n            extension = e;\n  \
    \          strength = strength;\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9q_1wq3w.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9q_1wq3w.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9q_1wq3w.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9q_1wq3w.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9q_1wq3w.rs:33:36\n   |\n33 |\
    \     class_name.to_string() + \".\" + extension.to_string()\n   |           \
    \                         ^^^^^^^^^^^^^^^^^^^^^\n   |                        \
    \            |\n   |                                    expected `&str`, found\
    \ struc"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = cap\
    \ - sm;\n        if strength > 0 {\n            extension = e.to_string();\n \
    \           break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpxh_8jxcb.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     strength = if cap > sm {\n            cap - sm\n        } else {\n     \
    \       sm - cap\n        };\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpta93_81b.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm - cap\n     \
    \   };\n        extension = if strength > 0 {\n            format!(\"{}.{}\",\
    \ class_name, e)\n        } else {\n            e\n        };\n    }\n    extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2qfvcd8k.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut extension_len = extension.len();\n        let mut class_len\
    \ = class_name.len();\n        let mut i = 0;\n        while i < extension_len\
    \ {\n            if extension[i] >= class_name[i] {\n                extension_len\
    \ = i;\n            } else {\n                class_len = i;\n            }\n\
    \            i += 1;\n        }\n        let strength = extension_len - class_len;\n\
    \        if strength > strength {\n            extension = extension;\n      \
    \      strength = strength;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0s2axr4e.rs:25:16\n\
    \   |\n25 |             if extension[i] >= class_name[i] {\n   |             \
    \   ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp0s2axr4e.rs:25:32\n   |\n25 |  \
    \           if extension[i] >= class_name[i] {\n   |                         \
    \       ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let mut sm = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if cap > sm {\n            strength = cap - sm;\n            extension\
    \ = extension.clone();\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpstag8f0o.rs:24:24\n   |\n\
    24 |             strength = cap - sm;\n   |                        ^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut extension = extension.clone();\n        let mut class_name\
    \ = class_name.clone();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<String>();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').collect::<String>();\n        let mut class_name = \n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvcgr_54s.rs:53:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n20 |     for extension in extensions\
    \ {\n   |                                 - this delimiter might not be properly\
    \ closed...\n...\n40 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n53 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpvcgr_54s.rs:40:1\n\
    \   |\n40 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvcgr_54s.rs:23:65\n   |\n23 |         let mut class_name = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').collect::<String>();\n   |                           \
    \                                      ^^^\n   |                             \
    \                                    |\n   |                                 \
    \                                expected `&char`, found `char`\n   |        \
    \                                                         help: consider borrowing\
    \ here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvcgr_54s.rs:23:77\n\
    \   |\n23 |         let mut class_name = class_name.chars().filter(|c| c >= 'A'\
    \ && c <= 'Z').collect::<String>();\n   |                                    \
    \                                         ^^^\n   |                          \
    \                                                   |\n   |                  \
    \                                                           expected `&char`,\
    \ found `char`\n   |                                                         \
    \                    help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvcgr_54s.rs:24:65\n   |\n24 |         let mut class_name\
    \ = class_name.chars().filter(|c| c >= 'a' && c <= 'z').collect::<String>();\n\
    \   |                                                                 ^^^\n  \
    \ |                                                                 |\n   |  \
    \                "
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut class_name = class_name.to_lowercase();\n        let mut\
    \ extension = extension.to_lowercase();\n        let mut strength = strength.cmp(&class_name.chars().filter(|c|\
    \ c.is_uppercase()).count() - extension.chars().filter(|c| c.is_lowercase()).count());\n\
    \        if strength == 0 {\n            strength = -1;\n        }\n    }\n  \
    \  format!(\"{}.{}\", class_name, extensions[extensions.iter().min_by_key(|&x|\
    \ x).unwrap()])\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvz76gn26.rs:23:41\n   |\n\
    23 | ...ngth.cmp(&class_name.chars().filter(|c| c.is_uppercase()).count() - extension.chars().filter(|c|\
    \ c.is_lowercase()).count());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&i64`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvz76gn26.rs:24:24\n\
    \   |\n24 |         if strength == 0 {\n   |                        ^ expected\
    \ enum `std::cmp::Ordering`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvz76gn26.rs:25:24\n   |\n25 |             strength = -1;\n   |\
    \                        ^^ expected enum `std::cmp::Ordering`, found integer\n\
    \nerror[E0277]: the type `[String]` cannot be indexed by `&String`\n  --> /tmp/tmpvz76gn26.rs:28:34\n\
    \   |\n28 |     format!(\"{}.{}\", class_name, extensions[extensions.iter().min_by_key(|&x|\
    \ x).unwrap()])\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `&String`\n   = note: required\
    \ because of the requirements on the impl of `Index<&String>` for `Vec<String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_len = extension.len();\n        let mut class_len =\
    \ class_name.len();\n        while extension_len > class_len {\n            extension_len\
    \ = extension_len - class_len;\n            class_len += 1;\n        }\n     \
    \   let mut diff = extension_len - class_len;\n        if diff > strength {\n\
    \            diff = strength;\n        }\n        if diff == 0 {\n           \
    \ extension = extension;\n        }\n    }\n    extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp24zo5_ub.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = 0;\n        for letter in extension.chars()\
    \ {\n            if let Some(key) = extension_map.get(&letter) {\n           \
    \     extension_map.insert(letter, key + 1);\n            } else {\n         \
    \       extension_map.insert(letter, 1);\n            }\n        }\n        for\
    \ (key, value) in extension_map.iter() {\n            extension_strength += value;\n\
    \        }\n        extensions_map.insert(extension, extension_strength);\n  \
    \  }\n    let mut max_extension_strength = -1;\n    let mut max_extension = String::from(\"\
    \");\n    for extension in extensions {\n        let extension_strength = extensions_map.get(extension).unwrap();\n\
    \        if extension_strength > max_extension_strength {\n            max_extension_strength\
    \ = extension_strength;\n            max_extension = extension;\n        }\n \
    \   }\n    class_name.to_string() + \".\" + max_extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp2a74c70j.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp2a74c70j.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2a74c70j.rs:43:36\n   |\n\
    43 |     class_name.to_string() + \".\" + max_extension\n   |                \
    \                    ^^^^^^^^^^^^^\n   |                                    |\n\
    \   |                                    expected `&str`, found struct `String`\n\
    \   |                                    help: consider borrowing here: `&max_extension`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        if cap > sm\
    \ {\n            strength = cap - sm;\n            extension = e;\n        }\n\
    \    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzd8vq87x.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzd8vq87x.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzd8vq87x.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzd8vq87x.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpzd8vq87x.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = -1;\n        for c in extension.chars() {\n      \
    \      if c.is_uppercase() {\n                class_name += c.to_lowercase();\n\
    \            } else {\n                class_name += c;\n            }\n     \
    \   }\n        for c in class_name.chars() {\n            if c.is_lowercase()\
    \ {\n                strength += 1;\n            } else {\n                strength\
    \ += 0;\n            }\n        }\n        if strength > strength {\n        \
    \    extension = class_name;\n            strength = strength;\n        }\n  \
    \  }\n    extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz0e0w4lg.rs:26:31\n   |\n\
    26 |                 class_name += c.to_lowercase();\n   |                   \
    \            ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToLowercase`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpz0e0w4lg.rs:28:31\n   |\n28 |  \
    \               class_name += c;\n   |                               ^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = cap - sm;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpjy9eccc7.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     if cap > sm {\n            strength = cap - sm;\n            extension =\
    \ extension.clone();\n        }\n    }\n    class_name.to_string() + \".\" + extension.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp1e99pijs.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1e99pijs.rs:28:36\n   |\n28 |     class_name.to_string() + \".\" + extension.to_string()\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^\n   |         \
    \                           |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&extension.to_string()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    class_name.concat(\".\"\
    ).concat(extension).concat(\".\")\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp52eejb45.rs:28:31\n   |\n28 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp52eejb45.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp52eejb45.rs:30:16\n   |\n30 |     class_name.concat(\"\
    .\").concat(extension).concat(\".\")\n   |                ^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = cap - sm;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpjy9eccc7.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        if cap > sm {\n \
    \           extension = e;\n            strength = cap - sm;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmphslsyqaq.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension: Option<String> = None;\n    for extension in extensions\
    \ {\n        let mut cap: i32 = 0;\n        let mut sm: i32 = 0;\n        for\
    \ c in extension.chars() {\n            if c.is_uppercase() {\n              \
    \  cap += 1;\n            } else if c.is_lowercase() {\n                sm +=\
    \ 1;\n            }\n        }\n        strength = if cap > sm {\n           \
    \ cap - sm\n        } else {\n            sm - cap\n        };\n        if strength\
    \ > 0 {\n            break;\n        }\n    }\n    match extension {\n       \
    \ Some(extension) => format!(\"{}.{}\", class_name, extension),\n        None\
    \ => format!(\"{}\", class_name),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp9anol9tr.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_length = extension.chars().count();\n        let mut\
    \ class_length = class_name.chars().count();\n        let mut strength_delta =\
    \ extension_length - class_length;\n        if strength_delta > strength {\n \
    \           strength = strength_delta;\n            extension = extension;\n \
    \       }\n    }\n    class_name.to_string() + extension.to_string()\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp_251b7ig.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_251b7ig.rs:29:30\n   |\n29 |     class_name.to_string() + extension.to_string()\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^\n   |               \
    \               |\n   |                              expected `&str`, found struct\
    \ `String`\n   |                              help: consider borrowing here: `&extension.to_string()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for e in extensions {\n    \
    \    let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap -\
    \ sm;\n        extension = extension.concat(e);\n    }\n    extension.concat(\"\
    .\").concat(class_name.to_lowercase()).concat(\".\").concat(extensions[extensions.iter().position(|e|\
    \ e == extension).unwrap()].to_lowercase())\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxwow0pvb.rs:23:21\n   |\n\
    23 |         strength += cap - sm;\n   |                     ^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror[E0599]: no method named `concat` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpxwow0pvb.rs:24:31\n   |\n24 | \
    \        extension = extension.concat(e);\n   |                              \
    \ ^^^^^^ method not found in `String`\n\nerror[E0277]: cannot add-assign `usize`\
    \ to `i32`\n  --> /tmp/tmpxwow0pvb.rs:23:18\n   |\n23 |         strength += cap\
    \ - sm;\n   |                  ^^ no implementation for `i32 += usize`\n   |\n\
    \   = help: the trait `AddAssign<usize>` is not implemented for `i32`\n\nerror[E0599]:\
    \ no method named `concat` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpxwow0pvb.rs:26:15\n   |\n26 |     extension.concat(\".\").concat(class_name.to_lowercase()).concat(\"\
    .\").concat(extensions[extensions.iter().position(|e| e == extension)....\n  \
    \ |               ^^^^^^ method not found in `String`\n\nerror[E0277]: can't compare\
    \ `&String` with `String`\n  --> /tmp/tmpxwow0pvb.rs:26:124\n   |\n26 | ...(extensions[extensions.iter().position(|e|\
    \ e == extension).unwrap()].to_lowercase())\n   |                            \
    \                     ^^ no implementation for `&String == String`\n   |\n   =\
    \ help: the trait `PartialEq<String>` is not implemented for `&String`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_strength = extension.chars().filter(|c| c.is_uppercase()).count()\
    \ - extension.chars().filter(|c| c.is_lowercase()).count();\n        if extension_strength\
    \ > strength {\n            strength = extension_strength;\n            extension\
    \ = extension;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmprh079p4a.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 0;\n\
    \    let mut extension: Option<String> = None;\n    for extension in extensions.iter()\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      strength += cap - sm;\n    }\n    if strength == 0 {\n        class_name\n\
    \    } else {\n        let mut extension = extensions[0];\n        for extension\
    \ in extensions.iter() {\n            if extension.chars().filter(|c| c.is_uppercase()).count()\
    \ > extension.chars().filter(|c| c.is_lowercase()).count() {\n               \
    \ extension = extension;\n            }\n        }\n        format!(\"{}.{}\"\
    , class_name, extension)\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpph52tuge.rs:23:21\n   |\n\
    23 |         strength += cap - sm;\n   |                     ^^^^^^^^ expected\
    \ `i64`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `i64`\n \
    \ --> /tmp/tmpph52tuge.rs:23:18\n   |\n23 |         strength += cap - sm;\n  \
    \ |                  ^^ no implementation for `i64 += usize`\n   |\n   = help:\
    \ the trait `AddAssign<usize>` is not implemented for `i64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      strength = if cap > sm {\n            cap - sm\n        } else {\n    \
    \        sm - cap\n        };\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyx4hi9s9.rs:24:13\n   |\n\
    24 |             cap - sm\n   |             ^^^^^^^^ expected `i64`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i64` and panic if the converted\
    \ value doesn't fit\n   |\n24 |             (cap - sm).try_into().unwrap()\n \
    \  |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyx4hi9s9.rs:26:13\n   |\n\
    26 |             sm - cap\n   |             ^^^^^^^^ expected `i64`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i64` and panic if the converted\
    \ value doesn't fit\n   |\n26 |             (sm - cap).try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension: String = String::from(\"\");\n    for e in extensions\
    \ {\n        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n     \
    \   let sm = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength_fraction\
    \ = cap - sm;\n        if strength_fraction > strength {\n            extension\
    \ = e;\n            strength = strength_fraction;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo0i2qk5i.rs:24:32\n   |\n\
    24 |         if strength_fraction > strength {\n   |                         \
    \       ^^^^^^^^ expected `usize`, found `i32`\n   |\nhelp: you can convert an\
    \ `i32` to a `usize` and panic if the converted value doesn't fit\n   |\n24 |\
    \         if strength_fraction > strength.try_into().unwrap() {\n   |        \
    \                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo0i2qk5i.rs:26:24\n   |\n26 |             strength = strength_fraction;\n\
    \   |                        ^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for e in extensions {\n    \
    \    let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap -\
    \ sm;\n        extension = extension.concat(e);\n    }\n    extension.concat(\"\
    .\").concat(class_name.to_lowercase()).concat(\".\").concat(extensions[extensions.iter().min_by_key(|e|\
    \ e.chars().filter(|c| c.is_lowercase()).count()).unwrap().to_string()])\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0ku_ej2m.rs:23:21\n   |\n\
    23 |         strength += cap - sm;\n   |                     ^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror[E0599]: no method named `concat` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp0ku_ej2m.rs:24:31\n   |\n24 | \
    \        extension = extension.concat(e);\n   |                              \
    \ ^^^^^^ method not found in `String`\n\nerror[E0277]: cannot add-assign `usize`\
    \ to `i32`\n  --> /tmp/tmp0ku_ej2m.rs:23:18\n   |\n23 |         strength += cap\
    \ - sm;\n   |                  ^^ no implementation for `i32 += usize`\n   |\n\
    \   = help: the trait `AddAssign<usize>` is not implemented for `i32`\n\nerror[E0599]:\
    \ no method named `concat` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp0ku_ej2m.rs:26:15\n   |\n26 |     extension.concat(\".\").concat(class_name.to_lowercase()).concat(\"\
    .\").concat(extensions[extensions.iter().min_by_key(|e| e.chars().filt...\n  \
    \ |               ^^^^^^ method not found in `String`\n\nerror[E0277]: the type\
    \ `[String]` cannot be indexed by `String`\n  --> /tmp/tmp0ku_ej2m.rs:26:80\n\
    \   |\n26 | ...).concat(extensions[extensions.iter().min_by_key(|e| e.chars().filter(|c|\
    \ c.is_lowercase()).count()).unwrap().to_string()])\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `String`\n   = note: required\
    \ because of the requirements on the impl of `Index<String>` for `Vec<String>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = if strength > 0 {\n            format!(\"{}.{}\", class_name,\
    \ e)\n        } else {\n            e\n        };\n    }\n    extension\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp6d9q9_vl.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension: Option<String> = None;\n    for e in extensions {\n  \
    \      let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap\
    \ - sm;\n        if strength > 0 {\n            extension = Some(e);\n       \
    \ }\n    }\n    match extension {\n        Some(e) => format!(\"{}.{}\", class_name,\
    \ e),\n        None => format!(\"{}.{}\", class_name, extensions[0]),\n    }\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqsz1gwdj.rs:23:21\n   |\n\
    23 |         strength += cap - sm;\n   |                     ^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `i32`\n \
    \ --> /tmp/tmpqsz1gwdj.rs:23:18\n   |\n23 |         strength += cap - sm;\n  \
    \ |                  ^^ no implementation for `i32 += usize`\n   |\n   = help:\
    \ the trait `AddAssign<usize>` is not implemented for `i32`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension.chars() {\n            extension_map.insert(letter,\
    \ 0);\n        }\n        extensions_map.insert(extension, extension_map);\n \
    \   }\n    let mut strength = -1;\n    let mut extensions_iter = extensions_map.iter();\n\
    \    let mut extensions_iter2 = extensions_map.iter();\n    let mut extensions_iter3\
    \ = extensions_map.iter();\n    let mut extensions_iter4 = extensions_map.iter();\n\
    \    let mut extensions_iter5 = extensions_map.iter();\n    let mut extensions_iter6\
    \ = extensions_map.iter();\n    let mut extensions_iter7 = extensions_map.iter();\n\
    \    let mut extensions_iter8 = extensions_map.iter();\n    let mut extensions_iter9\
    \ = extensions_map.iter();\n    let mut extensions_iter10 = extensions_map.iter();\n\
    \    let mut extensions_iter11 = extensions_map.iter();\n    let mut extensions_iter12\
    \ = extensions_map.iter();\n    let mut extensions_iter13 = extensions_map.iter();\n\
    \    let mut extensions_iter14 = extensions_map.iter();\n    let mut extensions_iter15\
    \ = extensions_map.iter();\n    let mut extensions_iter16 = extensions_map.iter();\n\
    \    let mut extensions_iter17 = extensions_map.iter();\n    let mut extensions_iter18\
    \ = extensions_map.iter();\n    let mut extensions_iter19 = extensions_map.iter();\n\
    \    let mut extensions_iter20 = extensions_map.iter();\n    let mut extensions_iter21\
    \ = extensions_map.iter();\n    let mut extensions_iter22 = extensions_map.iter();\n\
    \    let mut extensions_iter23 = extensions_map.iter();\n    let mut extensions_iter24\
    \ = extensions_map.iter();\n    let mut extensions_iter25 = extensions_map.iter();\n\
    \    let mut extensions_iter26 = extensions_map.iter();\n    let mut extensions_iter27\
    \ = extensions_map.iter();\n    let mut extensions_iter28 = extensions_map.iter();\n\
    \    let mut extensions_iter29 = extensions_map.iter();\n    let mut extensions_iter30\
    \ = extensions_map.iter();\n    let mut extensions_iter31 = extensions_map.iter();\n\
    \    let mut extensions_iter32 = extensions_map.iter();\n    let mut extensions_iter33\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1af11qd9.rs:59:30\n   |\n\
    59 |     let mut extensions_iter33\n   |                              ^ help:\
    \ add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp1af11qd9.rs:18:30\n   |\n18\
    \ |     let mut extensions_map = HashMap::new();\n   |                       \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp1af11qd9.rs:20:33\n   |\n20\
    \ |         let mut extension_map = HashMap::new();\n   |                    \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1af11qd9.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      let strength = cap - sm;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpnqgt89k4.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \        let sm = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \        let strength = cap - sm;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprppr2xcx.rs:21:53\n   |\n\
    21 |         let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                     ^^^\n   |          \
    \                                           |\n   |                          \
    \                           expected `&char`, found `char`\n   |             \
    \                                        help: consider borrowing here: `&'A'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprppr2xcx.rs:21:65\n   |\n21 |\
    \         let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \   |                                                                 ^^^\n  \
    \ |                                                                 |\n   |  \
    \                                                               expected `&char`,\
    \ found `char`\n   |                                                         \
    \        help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprppr2xcx.rs:22:52\n   |\n22 |         let sm = extension.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \             ^^^\n   |                                                    |\n\
    \   |                                                    expected `&char`, found\
    \ `char`\n   |                                                    help: consider\
    \ borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprppr2xcx.rs:22:64\n\
    \   |\n22 |         let sm = extension.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \   |                                                                ^^^\n   |\
    \                                                                |\n   |     \
    \                                                           expected `&char`,\
    \ found `char`\n   |                                                         \
    \       help: consider borrowing here: `&'z'`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = cap - sm;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpjy9eccc7.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp4yougmos.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut counter = 0;\n        while counter < CAP_LETTERS.len() {\n \
    \           if class_name.contains(&CAP_LETTERS[counter]) {\n                class_name\
    \ = class_name.replace(&CAP_LETTERS[counter], \"\");\n                counter\
    \ = CAP_LETTERS.len();\n            }\n            counter += 1;\n        }\n\
    \        let mut counter = 0;\n        while counter < CAP_LETTERS.len() {\n \
    \           if extension.contains(&CAP_LETTERS[counter]) {\n                extension\
    \ = extension.replace(&CAP_LETTERS[counter], \"\");\n                counter =\
    \ CAP_LETTERS.len();\n            }\n            counter += 1;\n        }\n  \
    \      if class_name != extension {\n            strength = counter - CAP_LETTERS.len();\n\
    \            break;\n        }\n    }\n    if strength == -1 {\n        String::from(\"\
    \")\n    } else {\n        class_name.to_string() + \".\" + extension.to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `CAP_LETTERS` in this scope\n  --> /tmp/tmprvjlww79.rs:24:25\n\
    \   |\n24 |         while counter < CAP_LETTERS.len() {\n   |                \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `CAP_LETTERS` in this scope\n  --> /tmp/tmprvjlww79.rs:25:37\n   |\n25 |   \
    \          if class_name.contains(&CAP_LETTERS[counter]) {\n   |             \
    \                        ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `CAP_LETTERS` in this scope\n  --> /tmp/tmprvjlww79.rs:26:50\n\
    \   |\n26 |                 class_name = class_name.replace(&CAP_LETTERS[counter],\
    \ \"\");\n   |                                                  ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `CAP_LETTERS` in this\
    \ scope\n  --> /tmp/tmprvjlww79.rs:27:27\n   |\n27 |                 counter =\
    \ CAP_LETTERS.len();\n   |                           ^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `CAP_LETTERS` in this scope\n\
    \  --> /tmp/tmprvjlww79.rs:32:25\n   |\n32 |         while counter < CAP_LETTERS.len()\
    \ {\n   |                         ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `CAP_LETTERS` in this scope\n  --> /tmp/tmprvjlww79.rs:33:36\n\
    \   |\n33 |             if extension.contains(&CAP_LETTERS[counter]) {\n   | \
    \                                   ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `CAP_LETTERS` in this scope\n  --> /tmp/tmprvjlww79.rs:34:48\n\
    \   |\n34 |                 extension = extension.replace(&CAP_LETTERS[counter],\
    \ \"\");\n   |                                                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `CAP_LETTERS` in this\
    \ scope\n  --> /tmp/tmprvjlww79.rs:35:27\n   |\n35 |                 counter =\
    \ CAP_LETTERS.len();\n   |                           ^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `CAP_LETTERS` in this scope\n\
    \  --> /tmp/tmprvjlww79.rs:40:34\n   |\n40 |             strength = counter -\
    \ CAP_LETTERS.len();\n   |                        "
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension: Option<String> = None;\n    for extension in extensions.iter()\
    \ {\n        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut extension_len = extension.len();\n        let mut extension_strength\
    \ = -1;\n        while extension_len > 0 {\n            let mut extension_char\
    \ = extension.chars().next().unwrap();\n            let mut extension_char_strength\
    \ = -1;\n            while extension_char_strength < 0 {\n                let\
    \ mut extension_char_char = extension_char.chars().next().unwrap();\n        \
    \        while extension_char_char != extension_char {\n                    extension_char_char\
    \ = extension_char_char.chars().next().unwrap();\n                }\n        \
    \        extension_char_strength = extension_char_char.chars().next().unwrap().to_ascii_lowercase().cmp(&extension_char).unwrap();\n\
    \            }\n            if extension_strength < extension_char_strength {\n\
    \                extension_strength = extension_char_strength;\n             \
    \   extension = Some(extension.clone());\n            }\n            extension_len\
    \ = extension_len - 1;\n            extension_char = extension.chars().next().unwrap();\n\
    \        }\n        if strength < extension_strength {\n            strength =\
    \ extension_strength;\n            extension = Some(extension.clone());\n    \
    \    }\n    }\n    match extension {\n        Some(extension) => format!(\"{}.{}\"\
    , class_name, extension),\n        None => format!(\"{}\", class_name),\n    }\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpdl_icf_7.rs:29:62\n   |\n29 |                 let mut extension_char_char\
    \ = extension_char.chars().next().unwrap();\n   |                            \
    \                                  ^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdl_icf_7.rs:37:29\n   |\n37 |              \
    \   extension = Some(extension.clone());\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&String`, found enum `Option`\n   |\n   = note: expected reference\
    \ `&String`\n                   found enum `Option<String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdl_icf_7.rs:44:25\n   |\n44 |             extension = Some(extension.clone());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^ expected `&String`, found\
    \ enum `Option`\n   |\n   = note: expected reference `&String`\n             \
    \      found enum `Option<String>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_len = extension.len();\n        let mut class_len =\
    \ class_name.len();\n        while extension_len > class_len {\n            extension\
    \ = extension.chars().filter(|c| c >= 'A' && c <= 'Z').collect::<String>().to_owned();\n\
    \            extension_len -= extension.len();\n            class_len -= extension.len();\n\
    \        }\n        let mut class_len = class_name.len();\n        while class_len\
    \ > extension_len {\n            class_len = class_name.chars().filter(|c| c >=\
    \ 'a' && c <= 'z').collect::<String>().to_owned().len();\n            extension\
    \ = extension.chars().filter(|c| c >= 'A' && c <= 'Z').collect::<String>().to_owned();\n\
    \            extension_len -= extension.len();\n        }\n        let mut strength\
    \ = extension_len - class_len;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpusdbfage.rs:24:59\n   |\n\
    24 |             extension = extension.chars().filter(|c| c >= 'A' && c <= 'Z').collect::<String>().to_owned();\n\
    \   |                                                           ^^^\n   |    \
    \                                                       |\n   |              \
    \                                             expected `&char`, found `char`\n\
    \   |                                                           help: consider\
    \ borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpusdbfage.rs:24:71\n\
    \   |\n24 |             extension = extension.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').collect::<String>().to_owned();\n   |                              \
    \                                         ^^^\n   |                          \
    \                                             |\n   |                        \
    \                                               expected `&char`, found `char`\n\
    \   |                                                                       help:\
    \ consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpusdbfage.rs:30:60\n\
    \   |\n30 |             class_len = class_name.chars().filter(|c| c >= 'a' &&\
    \ c <= 'z').collect::<String>().to_owned().len();\n   |                      \
    \                                      ^^^\n   |                             \
    \                               |\n   |                                      \
    \                      expected `&char`, found `char`\n   |                  \
    \                                          help: consider borrowing here: `&'a'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpusdbfage.rs:30:72\n   |\n30 |\
    \             class_len = class_name.chars().filter(|c| c >= 'a' && c <= 'z').collect::<String>().to_owned().len();\n\
    \   |                                                                        ^^^\n\
    \   |                                                                        |\n\
    \   |                                                                        expected\
    \ `&char`, found `char`\n   |         "
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut class_name =\
    \ class_name.clone();\n        let mut len = extension.len();\n        let mut\
    \ i = 0;\n        while i < len {\n            if extension[i] == extension[i].chars().filter(|c|\
    \ c.is_uppercase()).count() {\n                i += 1;\n                len -=\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        let mut i = 0;\n        while i < len {\n            if extension[i]\
    \ == extension[i].chars().filter(|c| c.is_lowercase()).count() {\n           \
    \     i += 1;\n                len -= 1;\n            } else {\n             \
    \   break;\n            }\n        }\n        let mut i = 0;\n        while i\
    \ < len {\n            if extension[i] == extension[i].chars().count() {\n   \
    \             i += 1;\n                len -= 1;\n            } else {\n     \
    \           break;\n            }\n        }\n        let mut i = 0;\n       \
    \ while i < len {\n            if extension[i] == extension[i].chars().count()\
    \ {\n                i += 1;\n                len -= 1;\n            } else {\n\
    \                break;\n            }\n        }\n        let mut i = 0;\n  \
    \      while i < len {\n            if extension[i] == extension[i].chars().count()\
    \ {\n                i += 1;\n                len -= 1;\n            } else {\n\
    \                break;\n            }\n        }\n        let mut i = 0;\n  \
    \      while i < len {\n            if extension[i] == extension[i].chars().count()\
    \ {\n                i += 1;\n                len -= 1;\n            } else {\n\
    \                break;\n            }\n        }\n        let mut i = 0;\n  \
    \      while i < len {\n            if extension[i] == extension[i].chars().count()\
    \ {\n                i += 1;\n                len -= 1;\n            } else {\n\
    \                break;\n            }\n        }\n        let mut i = 0;\n  \
    \      while i < len {\n            if extension[i] == extension[i].chars().count()\
    \ {\n                i += 1;\n                len -= 1;\n            } else {\n\
    \                break;\n            }\n        }\n        let mut i = 0;\n  \
    \      while i < len {\n            if extension[i] == extension[i].chars().count()\
    \ {\n                i += 1;\n                len -= 1;\n            } else {\n\
    \                break;\n            }\n        }\n        let mut i = 0;\n  \
    \      while i < len {\n            if extension[i] == extension[i].chars().count()\
    \ {\n                i += 1;\n                len -= 1;\n            } else {\n\
    \                break;\n            }\n        }\n        let mut i = 0;\n  \
    \      while i < len {\n            if extension[i] == extension[i].chars().count()\
    \ {\n                i += 1;\n                len -= 1;\n            } else {\n\
    \                break;\n            }\n        }\n        let mut i = 0;\n  \
    \      while i < len {\n            if extension[i] == extension[i].chars().count()\
    \ {\n                i += 1;\n                len -= 1;\n            } else {\n\
    \                break;\n            }\n        }\n        let mu\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpryy7ysip.rs:146:3\n\
    \    |\n17  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                                         \
    \                      - unclosed delimiter\n...\n20  |     for extension in extensions\
    \ {\n    |                                 - this delimiter might not be properly\
    \ closed...\n...\n133 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n146 | }\n    |   ^\n\nerror: expected `;`, found `}`\n   -->\
    \ /tmp/tmpryy7ysip.rs:132:15\n    |\n132 |         let mu\n    |             \
    \  ^ help: add `;` here\n133 | }\n    | - unexpected token\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpryy7ysip.rs:26:16\n\
    \   |\n26 |             if extension[i] == extension[i].chars().filter(|c| c.is_uppercase()).count()\
    \ {\n   |                ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpryy7ysip.rs:26:32\n\
    \   |\n26 |             if extension[i] == extension[i].chars().filter(|c| c.is_uppercase()).count()\
    \ {\n   |                                ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpryy7ysip.rs:35:16\n   |\n35 |             if extension[i] == extension[i].chars().filter(|c|\
    \ c.is_lowercase()).count() {\n   |                ^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpryy7ysip.rs:35:32\n   |\n35 |             if extension[i] == extension[i].chars().filter(|c|\
    \ c.is_lowercase()).count() {\n   |                                ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented "
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_strength = -1;\n        let mut extension_class = String::from(\"\
    \");\n        for c in extension {\n            if c.is_uppercase() {\n      \
    \          extension_strength += 1;\n                extension_class += c;\n \
    \           } else if c.is_lowercase() {\n                extension_strength +=\
    \ 2;\n                extension_class += c;\n            }\n        }\n      \
    \  if extension_strength > strength {\n            strength = extension_strength;\n\
    \            extension = extension_class;\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp6vcqvmth.rs:23:18\n\
    \    |\n23  |         for c in extension {\n    |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6vcqvmth.rs:37:36\n\
    \   |\n37 |     class_name.to_string() + \".\" + extension.to_string()\n   | \
    \                                   ^^^^^^^^^^^^^^^^^^^^^\n   |              \
    \                      |\n   |                                    expected `&str`,\
    \ found struct `String`\n   |                                    help: consider\
    \ borrowing here: `&extension.to_string()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_length = extension.len();\n        let mut class_length\
    \ = class_name.len();\n        let mut i = 0;\n        while i < extension_length\
    \ {\n            if extension[i] >= class_name[i] {\n                extension_length\
    \ -= 1;\n            } else {\n                class_length -= 1;\n          \
    \  }\n            i += 1;\n        }\n        if extension_length == 0 {\n   \
    \         strength = -1;\n            break;\n        }\n        if class_length\
    \ == 0 {\n            strength = -1;\n            break;\n        }\n        let\
    \ mut class_name = class_name.clone();\n        class_name.truncate(class_length);\n\
    \        let mut extension = extension.clone();\n        extension.truncate(extension_length);\n\
    \        let strength = class_name.cmp(&extension);\n        if strength == 0\
    \ {\n            break;\n        }\n    }\n    if strength == -1 {\n        String::from(\"\
    \")\n    } else {\n        class_name.concat(\".\").concat(extension)\n    }\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6gjuf_5r.rs:25:16\n\
    \   |\n25 |             if extension[i] >= class_name[i] {\n   |             \
    \   ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp6gjuf_5r.rs:25:32\n   |\n25 |  \
    \           if extension[i] >= class_name[i] {\n   |                         \
    \       ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6gjuf_5r.rs:45:24\n   |\n45 |         if strength == 0\
    \ {\n   |                        ^ expected enum `std::cmp::Ordering`, found integer\n\
    \nerror[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp6gjuf_5r.rs:52:20\n   |\n52 |         class_name.concat(\"\
    .\").concat(extension)\n   |                    ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    extension.concat(\".\").concat(class_name.to_lowercase()).concat(\"\
    .\").concat(extensions[extensions.iter().position(|e| e == extension).unwrap()].to_lowercase());\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp896k92pn.rs:28:31\n   |\n28 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp896k92pn.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp896k92pn.rs:30:15\n   |\n30 |     extension.concat(\".\"\
    ).concat(class_name.to_lowercase()).concat(\".\").concat(extensions[extensions.iter().position(|e|\
    \ e == extension)....\n   |               ^^^^^^ method not found in `String`\n\
    \nerror[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmp896k92pn.rs:30:124\n\
    \   |\n30 | ...(extensions[extensions.iter().position(|e| e == extension).unwrap()].to_lowercase());\n\
    \   |                                                 ^^ no implementation for\
    \ `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not implemented\
    \ for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp896k92pn.rs:17:72\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |    -------------------                                   \
    \              ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |  \
    \  implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     strength = if cap > sm {\n            cap - sm\n        } else {\n     \
    \       sm\n        };\n        if strength > 0 {\n            break;\n      \
    \  }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3y8v087q.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm\n       \
    \ };\n        if strength > strength {\n            extension = e;\n         \
    \   strength = strength;\n        }\n    }\n    class_name.to_string() + \".\"\
    \ + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_1oml0kb.rs:33:36\n   |\n\
    33 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension {\n            extension_map.insert(c.to_ascii_lowercase(),\
    \ 1);\n        }\n        extensions_map.insert(extension.to_ascii_lowercase(),\
    \ extension_map);\n    }\n    let mut strength = -1;\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<_>>();\n    extensions_sorted.sort_by_key(|x|\
    \ {\n        let mut c = x.to_ascii_lowercase();\n        let mut s = strength;\n\
    \        if let Some(mut e) = extensions_map.get(&c) {\n            e = e.clone();\n\
    \            e.into_iter().for_each(|e| {\n                s = e.value().max(s);\n\
    \            });\n        }\n        (c, s)\n    });\n    let mut extensions_sorted\
    \ = extensions_sorted.iter().cloned().collect::<Vec<_>>();\n    extensions_sorted.sort_by_key(|x|\
    \ {\n        let mut c = x.to_ascii_lowercase();\n        let mut s = strength;\n\
    \        if let Some(mut e) = extensions_map.get(&c) {\n            e = e.clone();\n\
    \            e.into_iter().for_each(|e| {\n                s = e.value().min(s);\n\
    \            });\n        }\n        (c, s)\n    });\n    let mut extensions_sorted\
    \ = extensions_sorted.iter().cloned().collect::<Vec<_>>();\n    extensions_sorted.sort_by_key(|x|\
    \ {\n        let mut c = x.to_ascii_lowercase();\n        let mut s = strength;\n\
    \        if let Some(mut e) = extensions_map.get(&c) {\n            e = e.clone();\n\
    \            e.into_iter().for_each(|e| {\n                s = e.value().max(s);\n\
    \            });\n        }\n        (c, s)\n    });\n    let mut extensions_sorted\
    \ = extensions_sorted.iter().cloned().collect::<Vec<_>>();\n    extensions_sorted.sort_by_key(|x|\
    \ {\n        let mut c = x.to_ascii_lowercase();\n        let mut s = strength;\n\
    \        if let Some(mut e) = extensions_map.get(&c) {\n            e = e.clone();\n\
    \            e.into_iter().for_each(|e| {\n                s = e.value().min(s);\n\
    \            });\n        }\n        (c, s)\n    });\n    let mut extensions_sorted\
    \ = extensions_sorted.iter().cloned().collect::<Vec<_>>\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: field expressions cannot have generic arguments\n  --> /tmp/tmpeblxw_g9.rs:75:76\n\
    \   |\n75 |     let mut extensions_sorted = extensions_sorted.iter().cloned().collect::<Vec<_>>\n\
    \   |                                                                        \
    \    ^^^^^^^^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpeblxw_g9.rs:75:84\n\
    \   |\n75 |     let mut extensions_sorted = extensions_sorted.iter().cloned().collect::<Vec<_>>\n\
    \   |                                                                        \
    \            ^ help: add `;` here\n76 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpeblxw_g9.rs:18:30\n\
    \   |\n18 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpeblxw_g9.rs:20:33\n\
    \   |\n20 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ `String` is not an iterator\n   --> /tmp/tmpeblxw_g9.rs:21:18\n    |\n21  |\
    \         for c in extension {\n    |                  ^^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait\
    \ `Iterator` is not implemented for `String`\n    = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0615]: attempted to take value of method `collect`\
    \ on type `Cloned<std::slice::Iter<'_, String>>`\n  --> /tmp/tmpeblxw_g9.rs:75:67\n\
    \   |\n75 |     let mut extensions_sorted = extensions_sorted.iter().cloned().collect::<Vec<_>>\n\
    \   |                                                                   ^^^^^^^\
    \ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n\
    75 |     let mut extensions_sorted = extensions_sorted.iter().clone"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(c) {\n            \
    \    extension_map.insert(c, strength + 1);\n            } else {\n          \
    \      extension_map.insert(c, 1);\n            }\n            if strength > extension_strength\
    \ {\n                extension_strength = strength;\n            }\n        }\n\
    \        extensions_map.insert(extension, extension_map);\n    }\n    let mut\
    \ extensions_strength = -1;\n    let mut extensions_map = HashMap::new();\n  \
    \  for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension.chars()\
    \ {\n            if let Some(strength) = extensions_map.get(c) {\n           \
    \     extensions_map.insert(c, strength + 1);\n            } else {\n        \
    \        extensions_map.insert(c, 1);\n            }\n            if strength\
    \ > extensions_strength {\n                extensions_strength = strength;\n \
    \           }\n        }\n    }\n    let mut strength = extensions_map.get(class_name);\n\
    \    if strength == Some(0) {\n        strength = extensions_map.get(extensions[0]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[1]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[2]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[3]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[4]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[5]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[6]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[7]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[8]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[9]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[10]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[11]);\n\
    \    }\n    if strength == Some(0) {\n        strength = extensions_map.get(extensions[12]);\n\
    \    }\n    if strength == Some(0) {\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp1bor7q76.rs:104:3\n\
    \    |\n17  | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n    |                                                         \
    \                      - unclosed delimiter\n...\n90  |     if strength == Some(0)\
    \ {\n    |                            - this delimiter might not be properly closed...\n\
    91  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    104 | }\n    |   ^\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `HashMap`\n  --> /tmp/tmp1bor7q76.rs:18:30\n   |\n18 |     let mut extensions_map\
    \ = HashMap::new();\n   |                              ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp1bor7q76.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `strength` in this scope\n  --> /tmp/tmp1bor7q76.rs:28:16\n\
    \   |\n28 |             if strength > extension_strength {\n   |             \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `strength`\
    \ in this scope\n  --> /tmp/tmp1bor7q76.rs:29:38\n   |\n29 |                 extension_strength\
    \ = strength;\n   |                                      ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \  --> /tmp/tmp1bor7q76.rs:35:30\n   |\n35 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp1bor7q76.rs:37:33\n   |\n37 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ no"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension {\n            extension_map.insert(c.to_lowercase(),\
    \ 0);\n        }\n        extensions_map.insert(extension.clone(), extension_map);\n\
    \    }\n    let mut strength = -1;\n    let mut extensions_iter = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter2 = extensions_map.iter().cloned();\n    let mut extensions_iter3\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter4 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter5 = extensions_map.iter().cloned();\n    let mut extensions_iter6\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter7 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter8 = extensions_map.iter().cloned();\n    let mut extensions_iter9\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter10 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter11 = extensions_map.iter().cloned();\n    let mut\
    \ extensions_iter12 = extensions_map.iter().cloned();\n    let mut extensions_iter13\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter14 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter15 = extensions_map.iter().cloned();\n    let mut\
    \ extensions_iter16 = extensions_map.iter().cloned();\n    let mut extensions_iter17\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter18 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter19 = extensions_map.iter().cloned();\n    let mut\
    \ extensions_iter20 = extensions_map.iter().cloned();\n    let mut extensions_iter21\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter22 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter23 = extensions_map.iter().cloned();\n    let mut\
    \ extensions_iter24 = extensions_map.iter().cloned();\n    let mut extensions_iter25\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter26 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter27 = extensions_map.iter\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1xv_v6rs.rs:53:52\n   |\n\
    53 |     let mut extensions_iter27 = extensions_map.iter\n   |               \
    \                                     ^ help: add `;` here\n54 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \  --> /tmp/tmp1xv_v6rs.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp1xv_v6rs.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmp1xv_v6rs.rs:21:18\n\
    \    |\n21  |         for c in extension {\n    |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1xv_v6rs.rs:17:72\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |    -------------------                                   \
    \              ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |  \
    \  implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut class_name =\
    \ class_name.clone();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_digit()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_punct()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_whitespace()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_control()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_letter()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_digit()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_punct()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_whitespace()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_control()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_letter()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_digit()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_punct()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_whitespace()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_control()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_letter()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_digit()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_punct()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_whitespace()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_control()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_letter()).count();\n        let mut class_name = class_name.chars().filter(|c|\
    \ c.is_digit()).count();\n        let mut class_name = class_name.\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpyy8m4nop.rs:60:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n20 |     for extension in extensions\
    \ {\n   |                                 - this delimiter might not be properly\
    \ closed...\n...\n47 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n60 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpyy8m4nop.rs:47:1\n\
    \   |\n47 | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpyy8m4nop.rs:46:41\n\
    \   |\n46 |         let mut class_name = class_name.\n   |                   \
    \                      ^ help: add `;` here\n47 | }\n   | - unexpected token\n\
    \nerror[E0599]: no method named `chars` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpyy8m4nop.rs:24:41\n   |\n24 |         let mut class_name\
    \ = class_name.chars().filter(|c| c.is_lowercase()).count();\n   |           \
    \                              ^^^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyy8m4nop.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension: Option<String> = None;\n    for e in extensions {\n  \
    \      let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm\n       \
    \ };\n        extension = Some(e);\n    }\n    match extension {\n        Some(e)\
    \ => format!(\"{}.{}\", class_name, e),\n        None => format!(\"{}\", class_name),\n\
    \    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1mkhs55q.rs:24:13\n   |\n\
    24 |             cap - sm\n   |             ^^^^^^^^ expected `i32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n24 |             (cap - sm).try_into().unwrap()\n \
    \  |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1mkhs55q.rs:26:13\n   |\n\
    26 |             sm\n   |             ^^ expected `i32`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `i32` and panic if the converted value doesn't\
    \ fit\n   |\n26 |             sm.try_into().unwrap()\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        if cap > sm {\n \
    \           strength = cap - sm;\n            extension = e;\n        }\n    }\n\
    \    class_name.to_string() + \".\" + extension.to_string()\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpjom6mong.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjom6mong.rs:28:36\n   |\n28 |     class_name.to_string() + \".\" + extension.to_string()\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^\n   |         \
    \                           |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&extension.to_string()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut class_name =\
    \ class_name.clone();\n        let mut strength = -1;\n        for c in extension.chars()\
    \ {\n            if c.is_uppercase() {\n                strength += 1;\n     \
    \       }\n            if c.is_lowercase() {\n                strength += 2;\n\
    \            }\n        }\n        if strength > strength {\n            extension\
    \ = class_name;\n            strength = strength;\n        }\n    }\n    extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpd8_xjumz.rs:42:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for e in extensions {\n    \
    \    let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap -\
    \ sm;\n        extension = extension.concat(e);\n    }\n    extension.concat(&format!(\"\
    {}.{}\", class_name, extensions[strength].to_lowercase()))\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4m1tulep.rs:23:21\n   |\n\
    23 |         strength += cap - sm;\n   |                     ^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror[E0599]: no method named `concat` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp4m1tulep.rs:24:31\n   |\n24 | \
    \        extension = extension.concat(e);\n   |                              \
    \ ^^^^^^ method not found in `String`\n\nerror[E0277]: cannot add-assign `usize`\
    \ to `i32`\n  --> /tmp/tmp4m1tulep.rs:23:18\n   |\n23 |         strength += cap\
    \ - sm;\n   |                  ^^ no implementation for `i32 += usize`\n   |\n\
    \   = help: the trait `AddAssign<usize>` is not implemented for `i32`\n\nerror[E0599]:\
    \ no method named `concat` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp4m1tulep.rs:26:15\n   |\n26 |     extension.concat(&format!(\"{}.{}\"\
    , class_name, extensions[strength].to_lowercase()))\n   |               ^^^^^^\
    \ method not found in `String`\n\nerror[E0277]: the type `[String]` cannot be\
    \ indexed by `i32`\n  --> /tmp/tmp4m1tulep.rs:26:52\n   |\n26 |     extension.concat(&format!(\"\
    {}.{}\", class_name, extensions[strength].to_lowercase()))\n   |             \
    \                                       ^^^^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `i32`\n   = note: required because of the requirements\
    \ on the impl of `Index<i32>` for `Vec<String>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = -1;\n        for c in extension.chars() {\n      \
    \      if c.is_uppercase() {\n                strength += 1;\n            }\n\
    \            if c.is_lowercase() {\n                strength += 1;\n         \
    \   }\n        }\n        if strength > strength {\n            extension = class_name;\n\
    \            strength = -1;\n        }\n    }\n    extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmpapwy62ye.rs:18:13\n\
    \   |\n18 |     let mut strength = -1;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to `extension`\
    \ is never read\n  --> /tmp/tmpapwy62ye.rs:33:13\n   |\n33 |             extension\
    \ = class_name;\n   |             ^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `strength` is never read\n  --> /tmp/tmpapwy62ye.rs:34:13\n\
    \   |\n34 |             strength = -1;\n   |             ^^^^^^^^\n   |\n   =\
    \ help: maybe it is overwritten before being read?\n\nwarning: variable does not\
    \ need to be mutable\n  --> /tmp/tmpapwy62ye.rs:18:9\n   |\n18 |     let mut strength\
    \ = -1;\n   |         ----^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpapwy62ye.rs:19:9\n   |\n\
    19 |     let mut extension = String::from(\"\");\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpapwy62ye.rs:21:13\n   |\n21 |        \
    \ let mut class_name = class_name;\n   |             ----^^^^^^^^^^\n   |    \
    \         |\n   |             help: remove this `mut`\n\nerror[E0382]: use of\
    \ moved value: `class_name`\n  --> /tmp/tmpapwy62ye.rs:21:30\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                        ----------\
    \ move occurs because `class_name` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n21 |         let mut class_name = class_name;\n   | \
    \                             ^^^^^^^^^^ value moved here, in previous iteration\
    \ of loop\n\nerror: aborting due to previous error; 6 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut extension = extension.clone();\n        let mut extension\
    \ = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= 'a' && *c <= 'z').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= '0' && *c <= '9').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= 'a' && *c <= 'z').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= '0' && *c <= '9').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= 'a' && *c <= 'z').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= '0' && *c <= '9').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= 'a' && *c <= 'z').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= '0' && *c <= '9').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= 'a' && *c <= 'z').collect::<String>();\n\
    \        let mut extension = extension.chars().filter(|c| *c >= '0' && *c <= '9').collect::<String>();\n\
    \        let mut extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzi9xacoq.rs:51:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n20 |     for extension in extensions\
    \ {\n   |                                 - this delimiter might not be properly\
    \ closed...\n...\n38 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n51 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpzi9xacoq.rs:37:26\n\
    \   |\n37 |         let mut extension\n   |                          ^ help: add\
    \ `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzi9xacoq.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.to_string();\n\
    \            break;\n        }\n    }\n    class_name.to_string() + \".\" + extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0fq3ca_g.rs:33:36\n   |\n\
    33 |     class_name.to_string() + \".\" + extension\n   |                    \
    \                ^^^^^^^^^\n   |                                    |\n   |  \
    \                                  expected `&str`, found struct `String`\n  \
    \ |                                    help: consider borrowing here: `&extension`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        if cap > sm {\n \
    \           extension = e;\n            strength = cap - sm;\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpwycts6t3.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.to_string() +\
    \ extension;\n        }\n    }\n    class_name + extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi2yana1p.rs:29:41\n   |\n\
    29 |             extension = e.to_string() + extension;\n   |                \
    \                         ^^^^^^^^^\n   |                                    \
    \     |\n   |                                         expected `&str`, found struct\
    \ `String`\n   |                                         help: consider borrowing\
    \ here: `&extension`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi2yana1p.rs:32:18\n\
    \   |\n32 |     class_name + extension\n   |                  ^^^^^^^^^\n   |\
    \                  |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&extension`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(c) {\n            \
    \    extension_map.insert(c, strength + 1);\n            } else {\n          \
    \      extension_map.insert(c, 1);\n            }\n            if strength > extension_strength\
    \ {\n                extension_strength = strength;\n            }\n        }\n\
    \        extensions_map.insert(extension.clone(), extension_map);\n    }\n   \
    \ let mut extensions_strength = -1;\n    for extension in extensions {\n     \
    \   let mut extension_map = extensions_map.get(extension.clone());\n        if\
    \ let Some(strength) = extension_map {\n            extensions_strength = strength;\n\
    \        }\n    }\n    if extensions_strength == -1 {\n        return class_name;\n\
    \    }\n    let mut extensions_map = extensions_map.clone();\n    let mut extensions_strength\
    \ = extensions_strength.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_strength = extensions_strength.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_strength = extensions_strength.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_strength\
    \ = extensions_strength.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_strength = extensions_strength.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_strength = extensions_strength.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_strength\
    \ = extensions_strength.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_strength = extensions_strength.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_strength = extensions_strength.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_strength\
    \ = extensions_strength.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_strength = extensions_strength.clone();\n    let mut extensions_map\
    \ = extensions_map.clone();\n    let mut extensions_strength = extensions_strength.clone();\n\
    \    let mut extensions_map = extensions_map.clone();\n    let mut extensions_strength\
    \ = extensions_strength.clone();\n    let mut extensions_map = extensions_map.clone();\n\
    \    let mut extensions_strength = \n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp3_wmr5e0.rs:72:1\n\
    \   |\n72 | }\n   | ^ expected expression\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp3_wmr5e0.rs:18:30\n   |\n18\
    \ |     let mut extensions_map = HashMap::new();\n   |                       \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp3_wmr5e0.rs:20:33\n   |\n20\
    \ |         let mut extension_map = HashMap::new();\n   |                    \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `strength` in this scope\n  --> /tmp/tmp3_wmr5e0.rs:28:16\n\
    \   |\n28 |             if strength > extension_strength {\n   |             \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `strength`\
    \ in this scope\n  --> /tmp/tmp3_wmr5e0.rs:29:38\n   |\n29 |                 extension_strength\
    \ = strength;\n   |                                      ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = -1;\n        for c in extension.chars() {\n      \
    \      if c.is_uppercase() {\n                strength += 1;\n            } else\
    \ if c.is_lowercase() {\n                strength += 2;\n            }\n     \
    \   }\n        if strength > strength {\n            extension = class_name;\n\
    \            strength = -1;\n        }\n    }\n    extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmpkfdqif2l.rs:18:13\n\
    \   |\n18 |     let mut strength = -1;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to `extension`\
    \ is never read\n  --> /tmp/tmpkfdqif2l.rs:32:13\n   |\n32 |             extension\
    \ = class_name;\n   |             ^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `strength` is never read\n  --> /tmp/tmpkfdqif2l.rs:33:13\n\
    \   |\n33 |             strength = -1;\n   |             ^^^^^^^^\n   |\n   =\
    \ help: maybe it is overwritten before being read?\n\nwarning: variable does not\
    \ need to be mutable\n  --> /tmp/tmpkfdqif2l.rs:18:9\n   |\n18 |     let mut strength\
    \ = -1;\n   |         ----^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpkfdqif2l.rs:19:9\n   |\n\
    19 |     let mut extension = String::from(\"\");\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpkfdqif2l.rs:21:13\n   |\n21 |        \
    \ let mut class_name = class_name;\n   |             ----^^^^^^^^^^\n   |    \
    \         |\n   |             help: remove this `mut`\n\nerror[E0382]: use of\
    \ moved value: `class_name`\n  --> /tmp/tmpkfdqif2l.rs:21:30\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                        ----------\
    \ move occurs because `class_name` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n21 |         let mut class_name = class_name;\n   | \
    \                             ^^^^^^^^^^ value moved here, in previous iteration\
    \ of loop\n\nerror: aborting due to previous error; 6 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension.chars() {\n            extension_map.insert(letter,\
    \ 0);\n        }\n        extensions_map.insert(extension, extension_map);\n \
    \   }\n    let mut strength = -1;\n    let mut extensions_iter = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter2 = extensions_map.iter().cloned();\n    let mut extensions_iter3\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter4 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter5 = extensions_map.iter().cloned();\n    let mut extensions_iter6\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter7 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter8 = extensions_map.iter().cloned();\n    let mut extensions_iter9\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter10 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter11 = extensions_map.iter().cloned();\n    let mut\
    \ extensions_iter12 = extensions_map.iter().cloned();\n    let mut extensions_iter13\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter14 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter15 = extensions_map.iter().cloned();\n    let mut\
    \ extensions_iter16 = extensions_map.iter().cloned();\n    let mut extensions_iter17\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter18 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter19 = extensions_map.iter().cloned();\n    let mut\
    \ extensions_iter20 = extensions_map.iter().cloned();\n    let mut extensions_iter21\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter22 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter23 = extensions_map.iter().cloned();\n    let mut\
    \ extensions_iter24 = extensions_map.iter().cloned();\n    let mut extensions_iter25\
    \ = extensions_map.iter().cloned();\n    let mut extensions_iter26 = extensions_map.iter().cloned();\n\
    \    let mut extensions_iter27 = extensions_map.iter().\n}\n\nfn main() {\n  \
    \  let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpdp210gwu.rs:54:1\n   |\n54\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpdp210gwu.rs:53:55\n\
    \   |\n53 |     let mut extensions_iter27 = extensions_map.iter().\n   |     \
    \                                                  ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashMap`\n  --> /tmp/tmpdp210gwu.rs:18:30\n   |\n18 |     let mut extensions_map\
    \ = HashMap::new();\n   |                              ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpdp210gwu.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp210gwu.rs:17:72\n   |\n\
    17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String\
    \ {\n   |    -------------------                                             \
    \    ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = -1;\n        for c in extension.chars() {\n      \
    \      if c.is_uppercase() {\n                strength += 1;\n               \
    \ class_name = class_name.to_lowercase();\n            } else if c.is_lowercase()\
    \ {\n                strength += 1;\n                class_name = class_name.to_uppercase();\n\
    \            }\n        }\n        if strength > strength {\n            extension\
    \ = extension;\n            strength = strength;\n        }\n    }\n    class_name\
    \ + extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n  \
    \  assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpftmpfyu2.rs:38:18\n   |\n\
    38 |     class_name + extension\n   |                  ^^^^^^^^^\n   |       \
    \           |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&extension`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = -1;\n        while class_name.len() > 0 {\n      \
    \      let mut class_name = class_name[..class_name.length()-1];\n           \
    \ let mut extension = extension;\n            let mut strength = -1;\n       \
    \     while extension.len() > 0 {\n                let mut extension = extension[..extension.length()-1];\n\
    \                let mut strength = -1;\n                while class_name.len()\
    \ > 0 {\n                    let mut class_name = class_name[..class_name.length()-1];\n\
    \                    let mut extension = extension;\n                    let mut\
    \ strength = -1;\n                    while extension.len() > 0 {\n          \
    \              let mut extension = extension[..extension.length()-1];\n      \
    \                  let mut strength = -1;\n                        strength =\
    \ class_name.chars().filter(|c| c.is_uppercase()).count() - extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n                        if strength > strength {\n\
    \                            strength = class_name.chars().filter(|c| c.is_lowercase()).count()\
    \ - extension.chars().filter(|c| c.is_uppercase()).count();\n                \
    \            extension = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        if strength > strength {\n            strength = -1;\n\
    \            extension = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        }\n    }\n    class_name + extension\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpc7nc1f6p.rs:25:58\n   |\n25 |             let mut\
    \ class_name = class_name[..class_name.length()-1];\n   |                    \
    \                                      ^^^^^^ method not found in `String`\n\n\
    error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpc7nc1f6p.rs:25:17\n   |\n25 |             let mut class_name\
    \ = class_name[..class_name.length()-1];\n   |                 ^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n25 |             let mut class_name = &class_name[..class_name.length()-1];\n\
    \   |                                  +\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpc7nc1f6p.rs:29:59\n\
    \   |\n29 |                 let mut extension = extension[..extension.length()-1];\n\
    \   |                                                           ^^^^^^ method\
    \ not found in `String`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmpc7nc1f6p.rs:29:21\n   |\n29 |  \
    \               let mut extension = extension[..extension.length()-1];\n   | \
    \                    ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n29 |\
    \                 let mut extension = &extension[..extension.length()-1];\n  \
    \ |                                     +\n\nerror[E0599]: no method named `length`\
    \ found for type `str` in the current scope\n  --> /tmp/tmpc7nc1f6p.rs:32:66\n\
    \   |\n32 |                     let mut class_name = class_name[..class_name.length()-1];\n\
    \   |             "
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut strength = -1;\n        for c in extension.chars() {\n      \
    \      if c.is_uppercase() {\n                strength += 1;\n            }\n\
    \            if c.is_lowercase() {\n                strength += 1;\n         \
    \   }\n        }\n        if strength > strength {\n            extension = class_name;\n\
    \            strength = -1;\n        }\n    }\n    extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `strength`\n  --> /tmp/tmpapwy62ye.rs:18:13\n\
    \   |\n18 |     let mut strength = -1;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_strength`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to `extension`\
    \ is never read\n  --> /tmp/tmpapwy62ye.rs:33:13\n   |\n33 |             extension\
    \ = class_name;\n   |             ^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `strength` is never read\n  --> /tmp/tmpapwy62ye.rs:34:13\n\
    \   |\n34 |             strength = -1;\n   |             ^^^^^^^^\n   |\n   =\
    \ help: maybe it is overwritten before being read?\n\nwarning: variable does not\
    \ need to be mutable\n  --> /tmp/tmpapwy62ye.rs:18:9\n   |\n18 |     let mut strength\
    \ = -1;\n   |         ----^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpapwy62ye.rs:19:9\n   |\n\
    19 |     let mut extension = String::from(\"\");\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpapwy62ye.rs:21:13\n   |\n21 |        \
    \ let mut class_name = class_name;\n   |             ----^^^^^^^^^^\n   |    \
    \         |\n   |             help: remove this `mut`\n\nerror[E0382]: use of\
    \ moved value: `class_name`\n  --> /tmp/tmpapwy62ye.rs:21:30\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |                        ----------\
    \ move occurs because `class_name` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n21 |         let mut class_name = class_name;\n   | \
    \                             ^^^^^^^^^^ value moved here, in previous iteration\
    \ of loop\n\nerror: aborting due to previous error; 6 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    class_name.concat(\".\"\
    ).concat(extension).concat(\".\")\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp52eejb45.rs:28:31\n   |\n28 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp52eejb45.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp52eejb45.rs:30:16\n   |\n30 |     class_name.concat(\"\
    .\").concat(extension).concat(\".\")\n   |                ^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp4yougmos.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     strength = if cap > sm {\n            cap - sm\n        } else {\n     \
    \       sm - cap\n        };\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpta93_81b.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension.chars() {\n            extension_map.insert(letter,\
    \ 0);\n        }\n        extensions_map.insert(extension, extension_map);\n \
    \   }\n    let mut strength = -1;\n    let mut extensions_iter = extensions_map.iter();\n\
    \    while let Some(extension) = extensions_iter.next() {\n        let mut extension_map\
    \ = extension.clone();\n        let mut extension_map_iter = extension_map.iter();\n\
    \        while let Some(letter) = extension_map_iter.next() {\n            if\
    \ let Some(count) = extensions_map.get(&letter) {\n                extension_map.insert(letter,\
    \ count + 1);\n            } else {\n                extension_map.insert(letter,\
    \ 1);\n            }\n        }\n        if extension_map.len() > strength {\n\
    \            strength = extension_map.len();\n        }\n    }\n    class_name.to_string()\
    \ + extensions[strength].to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6_81q5ba.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp6_81q5ba.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp6_81q5ba.rs:26:24\n\
    \   |\n26 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6_81q5ba.rs:42:30\n   |\n42 |     class_name.to_string() + extensions[strength].to_string()\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |    \
    \                          |\n   |                              expected `&str`,\
    \ found struct `String`\n   |                              help: consider borrowing\
    \ here: `&extensions[strength].to_string()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp4yougmos.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension: Option<String> = None;\n    for extension in extensions.iter()\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      let strength = cap - sm;\n        if strength > strength {\n          \
    \  extension = Some(extension);\n            strength = cap - sm;\n        }\n\
    \    }\n    extension.unwrap().to_string() + class_name.to_string() + \".\" +\
    \ extensions[0].to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_vzkl8l1.rs:25:25\n   |\n\
    25 |             extension = Some(extension);\n   |                         ^^^^^^^^^^^^^^^\
    \ expected `&String`, found enum `Option`\n   |\n   = note: expected reference\
    \ `&String`\n                   found enum `Option<&String>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_vzkl8l1.rs:29:38\n   |\n29 |     extension.unwrap().to_string()\
    \ + class_name.to_string() + \".\" + extensions[0].to_string()\n   |         \
    \                             ^^^^^^^^^^^^^^^^^^^^^^\n   |                   \
    \                   |\n   |                                      expected `&str`,\
    \ found struct `String`\n   |                                      help: consider\
    \ borrowing here: `&class_name.to_string()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_vzkl8l1.rs:29:69\n   |\n29 |     extension.unwrap().to_string()\
    \ + class_name.to_string() + \".\" + extensions[0].to_string()\n   |         \
    \                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                                     |\n\
    \   |                                                                     expected\
    \ `&str`, found struct `String`\n   |                                        \
    \                             help: consider borrowing here: `&extensions[0].to_string()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension.chars() {\n            extension_map.insert(letter,\
    \ 0);\n        }\n        extensions_map.insert(extension, extension_map);\n \
    \   }\n    let mut extensions_strength = HashMap::new();\n    for extension in\
    \ extensions {\n        let mut extension_strength = HashMap::new();\n       \
    \ for letter in extension.chars() {\n            extension_strength.insert(letter,\
    \ 0);\n        }\n        extensions_strength.insert(extension, extension_strength);\n\
    \    }\n    let mut max_strength = -1;\n    let mut max_extension = String::from(\"\
    \");\n    for extension in extensions {\n        let mut extension_map = extensions_map.get(&extension);\n\
    \        if extension_map.is_none() {\n            continue;\n        }\n    \
    \    for letter in extension.chars() {\n            let mut extension_strength\
    \ = extensions_strength.get(&extension);\n            if extension_strength.is_none()\
    \ {\n                continue;\n            }\n            let strength = extension_strength.get(&letter);\n\
    \            if strength > max_strength {\n                max_strength = strength;\n\
    \                max_extension = extension;\n            }\n            extension_strength.insert(letter,\
    \ strength);\n        }\n    }\n    format!(\"{}.{}\", class_name, max_extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpt9ta1szt.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpt9ta1szt.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpt9ta1szt.rs:26:35\n   |\n26 |     let mut extensions_strength =\
    \ HashMap::new();\n   |                                   ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpt9ta1szt.rs:28:38\n   |\n28 |         let mut extension_strength\
    \ = HashMap::new();\n   |                                      ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut num_caps = 0;\n        let mut num_lowers = 0;\n        while\
    \ class_name.len() > 0 {\n            if class_name[0] >= 'A' && class_name[0]\
    \ <= 'Z' {\n                num_caps += 1;\n            }\n            if class_name[0]\
    \ >= 'a' && class_name[0] <= 'z' {\n                num_lowers += 1;\n       \
    \     }\n            class_name = &class_name[1..];\n        }\n        let strength\
    \ = num_caps - num_lowers;\n        if strength > strength {\n            extension\
    \ = extension;\n            strength = num_caps - num_lowers;\n        }\n   \
    \ }\n    class_name + extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpjwv1qoeo.rs:26:16\n   |\n26 |             if class_name[0] >= 'A' &&\
    \ class_name[0] <= 'Z' {\n   |                ^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpjwv1qoeo.rs:26:40\n   |\n26 |             if class_name[0]\
    \ >= 'A' && class_name[0] <= 'Z' {\n   |                                     \
    \   ^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjwv1qoeo.rs:29:16\n\
    \   |\n29 |             if class_name[0] >= 'a' && class_name[0] <= 'z' {\n  \
    \ |                ^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n \
    \  |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjwv1qoeo.rs:29:40\n\
    \   |\n29 |             if class_name[0] >= 'a' && class_name[0] <= 'z' {\n  \
    \ |                                        ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwv1qoeo.rs:32:26\n\
    \   |\n32 |             class_name = &class_name[1..];\n   |                 \
    \         ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n32 |             class_name = (&class_name[1..]).to_string();\n\
    \   |                          +                +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjwv1qoeo.rs:40:18\n   |\n40 |     class_name\
    \ + extension\n   |                  ^^^^^^^^^\n   |                  |\n   |\
    \                  expected `&str`, found struct `String`\n   |              \
    \    help: consider borrowing here: `&extension`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome error"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = cap\
    \ - sm;\n        if strength > 0 {\n            extension = e.clone();\n     \
    \       break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp_le2bpz8.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    class_name.concat(\".\"\
    ).concat(extension).concat(\".\")\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp52eejb45.rs:28:31\n   |\n28 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp52eejb45.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp52eejb45.rs:30:16\n   |\n30 |     class_name.concat(\"\
    .\").concat(extension).concat(\".\")\n   |                ^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for e in extensions {\n    \
    \    let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap -\
    \ sm;\n        if strength > 0 {\n            extension = e.to_string();\n   \
    \     }\n    }\n    class_name.to_string() + \".\" + extension\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp__2e2x1g.rs:23:21\n   |\n\
    23 |         strength += cap - sm;\n   |                     ^^^^^^^^ expected\
    \ `i64`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `i64`\n \
    \ --> /tmp/tmp__2e2x1g.rs:23:18\n   |\n23 |         strength += cap - sm;\n  \
    \ |                  ^^ no implementation for `i64 += usize`\n   |\n   = help:\
    \ the trait `AddAssign<usize>` is not implemented for `i64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp__2e2x1g.rs:28:36\n   |\n28 |     class_name.to_string()\
    \ + \".\" + extension\n   |                                    ^^^^^^^^^\n   |\
    \                                    |\n   |                                 \
    \   expected `&str`, found struct `String`\n   |                             \
    \       help: consider borrowing here: `&extension`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        strength =\
    \ if cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n\
    \        };\n        extension = if strength > 0 {\n            format!(\"{}.{}\"\
    , class_name, e)\n        } else {\n            e\n        };\n    }\n    extension\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpipk5q05w.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpipk5q05w.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpipk5q05w.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpipk5q05w.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpipk5q05w.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308"
  stdout: ''
  timestamp: 1659748934
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp4yougmos.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 0;\n\
    \    let mut extension = String::new();\n    for e in extensions {\n        let\
    \ cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm = e.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        strength += cap - sm;\n        if strength\
    \ > 0 {\n            extension = e.clone();\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgyo84mey.rs:23:21\n   |\n\
    23 |         strength += cap - sm;\n   |                     ^^^^^^^^ expected\
    \ `i64`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `i64`\n \
    \ --> /tmp/tmpgyo84mey.rs:23:18\n   |\n23 |         strength += cap - sm;\n  \
    \ |                  ^^ no implementation for `i64 += usize`\n   |\n   = help:\
    \ the trait `AddAssign<usize>` is not implemented for `i64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_len = extension.len();\n        let mut class_len =\
    \ class_name.len();\n        let mut i = 0;\n        while i < extension_len &&\
    \ i < class_len {\n            if extension[i] == class_name[i] {\n          \
    \      i += 1;\n                extension_len -= 1;\n                class_len\
    \ -= 1;\n            } else {\n                i += 1;\n            }\n      \
    \  }\n        if extension_len > strength {\n            strength = extension_len;\n\
    \            extension = extension;\n        }\n    }\n    extension\n}\n\nfn\
    \ main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfgn38jpd.rs:25:16\n\
    \   |\n25 |             if extension[i] == class_name[i] {\n   |             \
    \   ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpfgn38jpd.rs:25:32\n   |\n25 |  \
    \           if extension[i] == class_name[i] {\n   |                         \
    \       ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpfgn38jpd.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = cap\
    \ - sm;\n        if strength > 0 {\n            extension = e.to_string();\n \
    \           break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpxh_8jxcb.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    class_name.concat(\".\"\
    ).concat(extension).concat(\".\")\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp52eejb45.rs:28:31\n   |\n28 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp52eejb45.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp52eejb45.rs:30:16\n   |\n30 |     class_name.concat(\"\
    .\").concat(extension).concat(\".\")\n   |                ^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp4yougmos.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension.chars() {\n            extension_map.insert(letter,\
    \ 0);\n        }\n        extensions_map.insert(extension, extension_map);\n \
    \   }\n    let mut strength = -1;\n    let mut extension = String::from(\"\");\n\
    \    let mut extension_map = extensions_map.get(&class_name);\n    while extension_map.len()\
    \ > 0 {\n        let mut extension_map = extensions_map.remove(&extension);\n\
    \        for letter in extension.chars() {\n            if let Some(strength)\
    \ = extension_map.get(&letter) {\n                if strength > strength {\n \
    \                   extension = extension.to_string();\n                    strength\
    \ = strength;\n                }\n            }\n            extension_map.insert(letter,\
    \ 0);\n        }\n    }\n    extension.to_string()\n}\n\nfn main() {\n    let\
    \ candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"\
    ), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp_xv8a21g.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp_xv8a21g.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension {\n            extension_map.insert(letter, 0);\n\
    \        }\n        extensions_map.insert(extension, extension_map);\n    }\n\
    \    let mut extensions_strength = HashMap::new();\n    for extension in extensions\
    \ {\n        let mut extension_map = extensions_map.get(extension);\n        if\
    \ extension_map.is_none() {\n            continue;\n        }\n        let mut\
    \ extension_strength = HashMap::new();\n        for letter in extension {\n  \
    \          extension_strength.insert(letter, 0);\n        }\n        for letter\
    \ in extension {\n            extension_map.insert(letter, extension_strength.get(letter).unwrap()\
    \ + 1);\n        }\n        extensions_strength.insert(extension, extension_map);\n\
    \    }\n    let mut max_extension_strength = -1;\n    let mut max_extension =\
    \ String::from(\"\");\n    for extension in extensions {\n        let mut extension_map\
    \ = extensions_strength.get(extension);\n        if extension_map.is_none() {\n\
    \            continue;\n        }\n        let mut extension_strength = extension_map.get(&0);\n\
    \        if extension_strength > max_extension_strength {\n            max_extension_strength\
    \ = extension_strength;\n            max_extension = extension;\n        }\n \
    \   }\n    format!(\"{}.{}\", class_name, max_extension)\n}\n\nfn main() {\n \
    \   let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpgk_o_5ph.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpgk_o_5ph.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpgk_o_5ph.rs:26:35\n   |\n26 |     let mut extensions_strength =\
    \ HashMap::new();\n   |                                   ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpgk_o_5ph.rs:32:38\n   |\n32 |         let mut extension_strength\
    \ = HashMap::new();\n   |                                      ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpgk_o_5ph.rs:21:23\n\
    \    |\n21  |         for letter in extension {\n    |                       ^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror[E0277]: `String` is not an iterator\n \
    \  --> /tmp/tmpgk_o_5ph.rs:33:23\n    |\n33  |         for letter in extension\
    \ {\n    |                       ^^^^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `String`\n    = note: required because of the requirements on the impl of\
    \ `Into"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension {\n            if let Some(index) = extensions_map.get(&letter)\
    \ {\n                extension_map.insert(index, extension);\n            } else\
    \ {\n                extensions_map.insert(letter, extension);\n            }\n\
    \        }\n    }\n    let mut strength = -1;\n    let mut extensions_iter = extensions_map.iter().rev();\n\
    \    for extension in extensions_iter {\n        let mut extension_map = HashMap::new();\n\
    \        for letter in extension {\n            if let Some(index) = extension_map.get(&letter)\
    \ {\n                extension_map.insert(index, extension);\n            } else\
    \ {\n                extension_map.insert(letter, extension);\n            }\n\
    \        }\n        let mut extension_map_iter = extension_map.iter().rev();\n\
    \        let mut extension_strength = -1;\n        for extension in extension_map_iter\
    \ {\n            if extension_strength > extension_strength {\n              \
    \  extension_strength = extension_map.get(&letter).unwrap().len();\n         \
    \   }\n        }\n        if extension_strength > strength {\n            strength\
    \ = extension_strength;\n        }\n    }\n    class_name.to_string() + extensions[extensions_map.get(&'A').unwrap().len()].to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpxwq__jau.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpxwq__jau.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpxwq__jau.rs:32:33\n   |\n32 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `letter` in this scope\n  --> /tmp/tmpxwq__jau.rs:44:57\n\
    \   |\n44 |                 extension_strength = extension_map.get(&letter).unwrap().len();\n\
    \   |                                                         ^^^^^^ not found\
    \ in this scope\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpxwq__jau.rs:21:23\n\
    \    |\n21  |         for letter in extension {\n    |                       ^^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension: Option<String> = None;\n    for extension in extensions.iter()\
    \ {\n        let mut class_name = class_name;\n        let mut extension = extension;\n\
    \        let mut extension_len = extension.len();\n        let mut i = 0;\n  \
    \      while i < extension_len {\n            let mut c = extension[i];\n    \
    \        if c >= 'A' && c <= 'Z' {\n                c -= 'A' as i32;\n       \
    \         i += 1;\n            } else if c >= 'a' && c <= 'z' {\n            \
    \    c -= 'a' as i32;\n                i += 1;\n            } else if c >= '0'\
    \ && c <= '9' {\n                c -= '0' as i32;\n                i += 1;\n \
    \           } else {\n                break;\n            }\n            class_name\
    \ = class_name.to_string() + &c.to_string();\n        }\n        let mut class_len\
    \ = class_name.len();\n        let mut i = 0;\n        while i < class_len {\n\
    \            let mut c = class_name[i];\n            if c >= 'A' && c <= 'Z' {\n\
    \                c -= 'A' as i32;\n                i += 1;\n            } else\
    \ if c >= 'a' && c <= 'z' {\n                c -= 'a' as i32;\n              \
    \  i += 1;\n            } else if c >= '0' && c <= '9' {\n                c -=\
    \ '0' as i32;\n                i += 1;\n            } else {\n               \
    \ break;\n            }\n            strength += 1;\n        }\n    }\n    if\
    \ strength == 0 {\n        class_name\n    } else {\n        class_name.to_string()\
    \ + &(strength as i32).to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpc4hg1k0r.rs:26:25\n\
    \   |\n26 |             let mut c = extension[i];\n   |                      \
    \   ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpc4hg1k0r.rs:44:25\n   |\n44 |  \
    \           let mut c = class_name[i];\n   |                         ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 0;\n\
    \    let mut extension: Option<String> = None;\n    for extension in extensions.iter()\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      strength = if cap > sm {\n            cap - sm\n        } else {\n    \
    \        sm - cap\n        };\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    match extension {\n        Some(extension) => format!(\"\
    {}.{}\", class_name, extension),\n        None => format!(\"{}.{}\", class_name,\
    \ StrongestExtensionName(extensions)),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `StrongestExtensionName`\
    \ in this scope\n  --> /tmp/tmpgsw2ksvu.rs:34:46\n   |\n34 |         None => format!(\"\
    {}.{}\", class_name, StrongestExtensionName(extensions)),\n   |              \
    \                                ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgsw2ksvu.rs:24:13\n   |\n24 |\
    \             cap - sm\n   |             ^^^^^^^^ expected `i64`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i64` and panic if the converted\
    \ value doesn't fit\n   |\n24 |             (cap - sm).try_into().unwrap()\n \
    \  |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgsw2ksvu.rs:26:13\n   |\n\
    26 |             sm - cap\n   |             ^^^^^^^^ expected `i64`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i64` and panic if the converted\
    \ value doesn't fit\n   |\n26 |             (sm - cap).try_into().unwrap()\n \
    \  |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = if strength > 0 {\n            format!(\"{}.{}\", class_name,\
    \ e)\n        } else {\n            e\n        };\n    }\n    extension\n}\n\n\
    fn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp6d9q9_vl.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    class_name.concat(\".\"\
    ).concat(extension).concat(\".\").to_string()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpekv_8vfl.rs:28:31\n   |\n28 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpekv_8vfl.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpekv_8vfl.rs:30:16\n   |\n30 |     class_name.concat(\"\
    .\").concat(extension).concat(\".\").to_string()\n   |                ^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = cap - sm;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpjy9eccc7.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = cap - sm;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpjy9eccc7.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp4yougmos.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for e in extensions {\n        let mut extension = extensions_map.entry(e.to_lowercase()).or_insert(0);\n\
    \        extension += 1;\n        extensions_map.entry(e.to_lowercase()).or_insert(extension);\n\
    \    }\n    let mut extensions_strength = HashMap::new();\n    for e in extensions\
    \ {\n        let mut extension = extensions_strength.entry(e.to_lowercase()).or_insert(0);\n\
    \        extension += 1;\n        extensions_strength.entry(e.to_lowercase()).or_insert(extension);\n\
    \    }\n    let mut extensions_strength_sum = HashMap::new();\n    for e in extensions\
    \ {\n        let mut extension = extensions_strength_sum.entry(e.to_lowercase()).or_insert(0);\n\
    \        extension += 1;\n        extensions_strength_sum.entry(e.to_lowercase()).or_insert(extension);\n\
    \    }\n    let mut extensions_strength_max = HashMap::new();\n    for e in extensions\
    \ {\n        let mut extension = extensions_strength_max.entry(e.to_lowercase()).or_insert(0);\n\
    \        extension += 1;\n        extensions_strength_max.entry(e.to_lowercase()).or_insert(extension);\n\
    \    }\n    let mut extensions_strength_min = HashMap::new();\n    for e in extensions\
    \ {\n        let mut extension = extensions_strength_min.entry(e.to_lowercase()).or_insert(0);\n\
    \        extension += 1;\n        extensions_strength_min.entry(e.to_lowercase()).or_insert(extension);\n\
    \    }\n    let mut extensions_strength_avg = HashMap::new();\n    for e in extensions\
    \ {\n        let mut extension = extensions_strength_avg.entry(e.to_lowercase()).or_insert(0);\n\
    \        extension += 1;\n        extensions_strength_avg.entry(e.to_lowercase()).or_insert(extension);\n\
    \    }\n    let mut extensions_strength_sum = HashMap::new();\n    for e in extensions\
    \ {\n        let mut extension = extensions_strength_sum.entry(e.to_lowercase()).or_insert(0);\n\
    \        extension += 1;\n        extensions_strength_sum.entry(e.to_lowercase()).or_insert(extension);\n\
    \    }\n    let mut extensions_strength_max = HashMap::new();\n    for e in extensions\
    \ {\n        let mut extension = extensions_strength_max.entry(e.to_lowercase()).or_insert(0);\n\
    \        extension += 1;\n        extensions_strength_max.entry(e.to_lowercase()).or_insert(extension);\n\
    \    }\n    let mut extensions_strength_min = \n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpnymmm6cn.rs:67:1\n\
    \   |\n67 | }\n   | ^ expected expression\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpnymmm6cn.rs:18:30\n   |\n18\
    \ |     let mut extensions_map = HashMap::new();\n   |                       \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpnymmm6cn.rs:24:35\n   |\n24\
    \ |     let mut extensions_strength = HashMap::new();\n   |                  \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpnymmm6cn.rs:30:39\n\
    \   |\n30 |     let mut extensions_strength_sum = HashMap::new();\n   |      \
    \                                 ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpnymmm6cn.rs:36:39\n   |\n36 |     let mut extensions_strength_max\
    \ = HashMap::new();\n   |                                       ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpnymmm6cn.rs:42:39\n   |\n42 |     let mut extensions_strength_min\
    \ = HashMap::new();\n   |                                       ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpnymmm6cn.rs:48:39\n   |\n48 |     let mut extensions_strength_avg\
    \ = HashMap::new();\n   |                                       ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E04"
  stdout: ''
  timestamp: 1659748935
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     let strength = cap - sm;\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmpjy9eccc7.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength_fraction\
    \ = cap - sm;\n        if strength_fraction > strength {\n            extension\
    \ = e;\n            strength = strength_fraction;\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp81tg8ubh.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp81tg8ubh.rs:29:36\n   |\n29 |     class_name.to_string() + \".\" + extension.to_string()\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^\n   |         \
    \                           |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&extension.to_string()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension.chars()\
    \ {\n            if let Some(strength) = extension_map.get(c) {\n            \
    \    extension_map.insert(c, strength + 1);\n            } else {\n          \
    \      extension_map.insert(c, 1);\n            }\n        }\n        if let Some(strength)\
    \ = extension_map.get(&'.') {\n            extension_map.insert(&'.', strength\
    \ + 1);\n        }\n        if let Some(strength) = extension_map.get(&'$') {\n\
    \            extension_map.insert(&'$', strength + 1);\n        }\n        if\
    \ let Some(strength) = extension_map.get(&'#') {\n            extension_map.insert(&'#',\
    \ strength + 1);\n        }\n        if let Some(strength) = extension_map.get(&'&')\
    \ {\n            extension_map.insert(&'&', strength + 1);\n        }\n      \
    \  if let Some(strength) = extension_map.get(&'(') {\n            extension_map.insert(&'(',\
    \ strength + 1);\n        }\n        if let Some(strength) = extension_map.get(&')')\
    \ {\n            extension_map.insert(&')', strength + 1);\n        }\n      \
    \  if let Some(strength) = extension_map.get(&'-') {\n            extension_map.insert(&'-',\
    \ strength + 1);\n        }\n        if let Some(strength) = extension_map.get(&'_')\
    \ {\n            extension_map.insert(&'_', strength + 1);\n        }\n      \
    \  if let Some(strength) = extension_map.get(&'^') {\n            extension_map.insert(&'^',\
    \ strength + 1);\n        }\n        if let Some(strength) = extension_map.get(&'|')\
    \ {\n            extension_map.insert(&'|', strength + 1);\n        }\n      \
    \  if let Some(strength) = extension_map.get(&'~') {\n            extension_map.insert(&'~',\
    \ strength + 1);\n        }\n        if let Some(strength) = extension_map.get(&'!')\
    \ {\n            extension_map.insert(&'!', strength + 1);\n        }\n      \
    \  if let Some(strength) = extension_map.get(&'@') {\n            extension_map.insert(&'@',\
    \ strength + 1);\n        }\n        if let Some(strength) = extension_map.get(&'{')\
    \ {\n            extension_map.insert(&'{', strength + 1);\n        }\n      \
    \  if let Some(strength) = extension_map.get(&'}') {\n            extension_map.insert(&'}',\
    \ strength + 1);\n        }\n        if let Some(strength) = \n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmph0cj4sk9.rs:88:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n18 |     let mut extensions_map =\
    \ HashMap::new();\n19 |     for extension in extensions {\n   |              \
    \                   - this delimiter might not be properly closed...\n...\n75\
    \ | }\n   | - ...as it matches this but it has different indentation\n...\n88\
    \ | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmph0cj4sk9.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected expression\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmph0cj4sk9.rs:18:30\n   |\n18\
    \ |     let mut extensions_map = HashMap::new();\n   |                       \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmph0cj4sk9.rs:20:33\n   |\n20\
    \ |         let mut extension_map = HashMap::new();\n   |                    \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph0cj4sk9.rs:17:72\n   |\n17 | fn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n   |    -------------------  \
    \                                               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension_strength = -1;\n        let mut extension_class = String::from(\"\
    \");\n        for c in extension.chars() {\n            if c.is_uppercase() {\n\
    \                extension_strength += 1;\n                extension_class +=\
    \ c.to_lowercase();\n            } else if c.is_lowercase() {\n              \
    \  extension_strength += 1;\n                extension_class += c.to_uppercase();\n\
    \            }\n        }\n        if extension_strength > strength {\n      \
    \      strength = extension_strength;\n            extension = extension_class;\n\
    \        }\n    }\n    class_name.to_string() + \".\" + extension.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf75dpdtv.rs:26:36\n   |\n\
    26 |                 extension_class += c.to_lowercase();\n   |              \
    \                      ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf75dpdtv.rs:29:36\n   |\n29 |\
    \                 extension_class += c.to_uppercase();\n   |                 \
    \                   ^^^^^^^^^^^^^^^^ expected `&str`, found struct `ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf75dpdtv.rs:37:36\n   |\n37 |\
    \     class_name.to_string() + \".\" + extension.to_string()\n   |           \
    \                         ^^^^^^^^^^^^^^^^^^^^^\n   |                        \
    \            |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        if strength > 0 {\n            extension = e.clone();\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmplc4mybso.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm - cap\n     \
    \   };\n        extension = extension.concat(e);\n    }\n    extension.concat(\"\
    .\").concat(class_name.to_lowercase()).concat(\".\").concat(extensions[extensions.iter().position(|e|\
    \ e == extension).unwrap()].to_lowercase())\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpaoun5nbv.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0599]: no method named `concat`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpaoun5nbv.rs:28:31\n\
    \   |\n28 |         extension = extension.concat(e);\n   |                   \
    \            ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `concat` found for struct `String` in the current scope\n  --> /tmp/tmpaoun5nbv.rs:30:15\n\
    \   |\n30 |     extension.concat(\".\").concat(class_name.to_lowercase()).concat(\"\
    .\").concat(extensions[extensions.iter().position(|e| e == extension)....\n  \
    \ |               ^^^^^^ method not found in `String`\n\nerror[E0277]: can't compare\
    \ `&String` with `String`\n  --> /tmp/tmpaoun5nbv.rs:30:124\n   |\n30 | ...(extensions[extensions.iter().position(|e|\
    \ e == extension).unwrap()].to_lowercase())\n   |                            \
    \                     ^^ no implementation for `&String == String`\n   |\n   =\
    \ help: the trait `PartialEq<String>` is not implemented for `&String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension = String::from(\"\");\n    for e in extensions {\n\
    \        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_lowercase()).count();\n        strength += cap\
    \ - sm;\n        extension = extension.concat(e);\n    }\n    if strength == 0\
    \ {\n        class_name\n    } else {\n        class_name.concat(\".\").concat(extension.chars().filter(|c|\
    \ c.is_uppercase()).collect::<String>().to_lowercase())\n    }\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp32raytwn.rs:24:31\n   |\n24 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `concat` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp32raytwn.rs:29:20\n   |\n29 | \
    \        class_name.concat(\".\").concat(extension.chars().filter(|c| c.is_uppercase()).collect::<String>().to_lowercase())\n\
    \   |                    ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let mut class_name = class_name.clone();\n        let mut extension\
    \ = extension.clone();\n        let mut letters = String::from(\"\");\n      \
    \  let mut letters_count = String::from(\"\");\n        let mut letters_count_cap\
    \ = String::from(\"\");\n        let mut letters_count_low = String::from(\"\"\
    );\n        let mut letters_count_cap_low = String::from(\"\");\n        let mut\
    \ letters_count_cap_lower = String::from(\"\");\n        let mut letters_count_cap_lower_upper\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit =\
    \ String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n        let mut letters_count_cap_lower_upper_digit_digit_digit_digit_digit_digit_digit_digit\
    \ = String::from(\"\");\n\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0zzuys3g.rs:61:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n20 |     for extension in extensions\
    \ {\n   |                                 - this delimiter might not be properly\
    \ closed...\n...\n48 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n61 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0zzuys3g.rs:17:72\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |    -------------------                                   \
    \              ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |  \
    \  implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: usize =\
    \ 0;\n    let mut extension = String::from(\"\");\n    for e in extensions {\n\
    \        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength_diff\
    \ = cap - sm;\n        if strength_diff > strength {\n            strength = strength_diff;\n\
    \            extension = e;\n        }\n    }\n    class_name.to_string() + \"\
    .\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprwws2et6.rs:29:36\n   |\n\
    29 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm\n        };\n\
    \        extension = extension.concat(e);\n    }\n    extension.concat(\".\").concat(class_name.to_lowercase()).concat(\"\
    .\").concat(extensions[extensions.iter().position(|e| e.to_lowercase() == extension).unwrap()].to_lowercase())\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `concat` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpsrpg7cwp.rs:28:31\n   |\n28 |         extension\
    \ = extension.concat(e);\n   |                               ^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpsrpg7cwp.rs:18:24\n   |\n18 |     let mut strength = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpsrpg7cwp.rs:30:15\n   |\n30 |     extension.concat(\".\"\
    ).concat(class_name.to_lowercase()).concat(\".\").concat(extensions[extensions.iter().position(|e|\
    \ e.to_lowercase()...\n   |               ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        let strength\
    \ = if cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n\
    \        };\n        if strength > 0 {\n            extension = e.clone();\n \
    \           break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0xsrdsqv.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0xsrdsqv.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0xsrdsqv.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0xsrdsqv.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        let strength\
    \ = if cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n\
    \        };\n        if strength > strength {\n            extension = e;\n  \
    \          strength = strength;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n   \
    \ assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"),\
    \ String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprw1tra9r.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprw1tra9r.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprw1tra9r.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprw1tra9r.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension {\n    \
    \        if c.is_uppercase() {\n                extension_map.insert(c.to_string(),\
    \ extension_strength);\n            }\n            if c.is_lowercase() {\n   \
    \             extension_strength += 1;\n            }\n        }\n        extensions_map.insert(extension.to_string(),\
    \ extension_map);\n    }\n    let mut extensions_strength = -1;\n    let mut extensions_map\
    \ = HashMap::new();\n    for extension in extensions {\n        let mut extension_map\
    \ = HashMap::new();\n        let mut extension_strength = -1;\n        for c in\
    \ extension {\n            if c.is_uppercase() {\n                extension_map.insert(c.to_string(),\
    \ extension_strength);\n            }\n            if c.is_lowercase() {\n   \
    \             extension_strength += 1;\n            }\n        }\n        extensions_map.insert(extension.to_string(),\
    \ extension_map);\n    }\n    let mut extensions_map = HashMap::new();\n    for\
    \ extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension {\n    \
    \        if c.is_uppercase() {\n                extension_map.insert(c.to_string(),\
    \ extension_strength);\n            }\n            if c.is_lowercase() {\n   \
    \             extension_strength += 1;\n            }\n        }\n        extensions_map.insert(extension.to_string(),\
    \ extension_map);\n    }\n    let mut extensions_map = HashMap::new();\n    for\
    \ extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension {\n    \
    \        if c.is_uppercase() {\n                extension_map.insert(c.to_string(),\
    \ extension_strength);\n            }\n            if c.is_lowercase() {\n   \
    \             extension_strength += 1;\n            }\n        }\n        extensions_map.insert(extension.to_string(),\
    \ extension_map);\n    }\n    let mut extensions_map = HashMap::new();\n    for\
    \ extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension {\n    \
    \        if c.is_uppercase() {\n                extension_map.insert(c.to_string(),\
    \ extension_strength);\n            }\n            if c.is_lowercase() {\n   \
    \             extension_strength += 1;\n            }\n        }\n        extensions_map.insert(extension.to_string(),\
    \ extension_map);\n    }\n    let mut extensions_map = HashMap::new();\n    for\
    \ \n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1tu_c1ns.rs:91:1\n  \
    \ |\n91 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashMap`\n  --> /tmp/tmp1tu_c1ns.rs:18:30\n   |\n18 |     let\
    \ mut extensions_map = HashMap::new();\n   |                              ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp1tu_c1ns.rs:20:33\n   |\n20\
    \ |         let mut extension_map = HashMap::new();\n   |                    \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp1tu_c1ns.rs:33:30\n\
    \   |\n33 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp1tu_c1ns.rs:35:33\n\
    \   |\n35 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp1tu_c1ns.rs:47:30\n\
    \   |\n47 |     let mut extensions_map = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp1tu_c1ns.rs:49:33\n\
    \   |\n49 |         let mut extension_map = HashMap::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tm"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut class_name =\
    \ class_name.clone();\n        let mut letters = String::from(\"\");\n       \
    \ let mut letters_count = String::from(\"\");\n        while !extension.chars().all(|c|\
    \ c.is_uppercase()) {\n            letters += c;\n            letters_count +=\
    \ c.chars().filter(|c| c.is_lowercase()).count();\n            extension = extension.clone();\n\
    \        }\n        let mut letters_count = letters_count.to_string();\n     \
    \   let mut letters = letters.to_string();\n        while letters_count.len()\
    \ < letters.len() {\n            letters += letters.chars().filter(|c| c.is_lowercase()).collect::<String>();\n\
    \            letters_count += letters_count.chars().filter(|c| c.is_lowercase()).count();\n\
    \        }\n        let mut letters = letters.to_string();\n        let mut letters_count\
    \ = letters_count.to_string();\n        while letters_count.len() < letters.len()\
    \ {\n            letters += letters.chars().filter(|c| c.is_uppercase()).collect::<String>();\n\
    \            letters_count += letters_count.chars().filter(|c| c.is_uppercase()).count();\n\
    \        }\n        let mut letters = letters.to_string();\n        let mut letters_count\
    \ = letters_count.to_string();\n        while letters_count.len() < letters.len()\
    \ {\n            letters += letters.chars().filter(|c| c.is_lowercase()).collect::<String>();\n\
    \            letters_count += letters_count.chars().filter(|c| c.is_lowercase()).count();\n\
    \        }\n        let mut letters = letters.to_string();\n        let mut letters_count\
    \ = letters_count.to_string();\n        while letters_count.len() < letters.len()\
    \ {\n            letters += letters.chars().filter(|c| c.is_uppercase()).collect::<String>();\n\
    \            letters_count += letters_count.chars().filter(|c| c.is_uppercase()).count();\n\
    \        }\n        let mut letters = letters.to_string();\n        let mut letters_count\
    \ = letters_count.to_string();\n        while letters_count.len() < letters.len()\
    \ {\n            letters += letters.chars().filter(|c| c.is_lowercase()).collect::<String>();\n\
    \            letters_count += letters_count.chars().filter(|c| c.is_lowercase()).count();\n\
    \        }\n        let mut letters = letters.to_string();\n        let mut letters_count\
    \ = letter\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpctvsqjpj.rs:75:3\n\
    \   |\n17 | fn Strongest_Extension(class_name: String, extensions: Vec<String>)\
    \ -> String {\n   |                                                          \
    \                     - unclosed delimiter\n...\n20 |     for extension in extensions\
    \ {\n   |                                 - this delimiter might not be properly\
    \ closed...\n...\n62 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n75 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpctvsqjpj.rs:61:39\n\
    \   |\n61 |         let mut letters_count = letter\n   |                     \
    \                  ^ help: add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `c` in this scope\n  --> /tmp/tmpctvsqjpj.rs:26:24\n   |\n\
    26 |             letters += c;\n   |                        ^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpctvsqjpj.rs:27:30\n\
    \   |\n27 |             letters_count += c.chars().filter(|c| c.is_lowercase()).count();\n\
    \   |                              ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `letter` in this scope\n  --> /tmp/tmpctvsqjpj.rs:61:33\n\
    \   |\n61 |         let mut letters_count = letter\n   |                     \
    \            ^^^^^^ help: a local variable with a similar name exists: `letters`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpctvsqjpj.rs:33:24\n   |\n33 |\
    \             letters += letters.chars().filter(|c| c.is_lowercase()).collect::<String>();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                        |\n   |                        expected `&str`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&letters.chars().filter(|c| c.is_lowercase()).collect::<String>()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpctvsqjpj.rs:34:30\n   |\n34 |             letters_count\
    \ += letters_count.chars().filter(|c| c.is_lowercase()).count();\n   |       \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension {\n    \
    \        if c.is_uppercase() {\n                extension_map.insert(c.to_lowercase(),\
    \ 1);\n            } else {\n                extension_map.insert(c.to_uppercase(),\
    \ 1);\n            }\n        }\n        if extension_map.len() > extension_strength\
    \ {\n            extension_strength = extension_map.len();\n        }\n      \
    \  extensions_map.insert(extension.to_lowercase(), extension_strength);\n    }\n\
    \    let mut strength = -1;\n    let mut extension = class_name;\n    let mut\
    \ extension_strength = -1;\n    for c in extension {\n        if c.is_uppercase()\
    \ {\n            if extension_map.contains_key(&c.to_lowercase()) {\n        \
    \        if extension_map.get(&c.to_lowercase()).unwrap() > extension_strength\
    \ {\n                    extension_strength = extension_map.get(&c.to_lowercase()).unwrap();\n\
    \                }\n            }\n        } else {\n            if extension_map.contains_key(&c.to_uppercase())\
    \ {\n                if extension_map.get(&c.to_uppercase()).unwrap() > extension_strength\
    \ {\n                    extension_strength = extension_map.get(&c.to_uppercase()).unwrap();\n\
    \                }\n            }\n        }\n    }\n    if extension_strength\
    \ > strength {\n        strength = extension_strength;\n        extension = class_name.to_lowercase();\n\
    \    }\n    extension.to_lowercase() + \".\" + extensions_map.get(extension.to_lowercase()).unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpu3bf730d.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpu3bf730d.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `extension_map` in this scope\n  -->\
    \ /tmp/tmpu3bf730d.rs:39:16\n   |\n39 |             if extension_map.contains_key(&c.to_lowercase())\
    \ {\n   |                ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `extensions_map`\n\nerror[E0425]: cannot find value `extension_map`\
    \ in this scope\n  --> /tmp/tmpu3bf730d.rs:40:20\n   |\n40 |                 if\
    \ extension_map.get(&c.to_lowercase()).unwrap() > extension_strength {\n   | \
    \                   ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `extensions_map`\n\nerror[E0425]: cannot find value `extension_map` in this\
    \ scope\n  --> /tmp/tmpu3bf730d.rs:41:42\n   |\n41 |                     extension_strength\
    \ = extension_map.get(&c.to_lowercase()).unwrap();\n   |                     \
    \                     ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `extensions_map`\n\nerror[E0425]: cannot find value `extension_map`\
    \ in this scope\n  --> /tmp/tmpu3bf730d.rs:45:16\n   |\n45 |             if extension_map.contains_key(&c.to_uppercase())\
    \ {\n   |                ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `extensions_map`\n\nerror[E0425]: cannot find value `extension_map`\
    \ in this scope\n  --> /tmp/tmpu3bf730d.rs:46:20\n   |\n46 |                 if\
    \ extension_map.get(&c.to_uppercase()).unwrap() > extension_strength {\n   | \
    \                   ^^^^^^^^^^^^^ help: a local variable with a simila"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     if cap > sm {\n            strength = cap - sm;\n            extension =\
    \ extension.to_string();\n        }\n    }\n    class_name.to_string() + \".\"\
    \ + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2jms9sfz.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2jms9sfz.rs:28:36\n   |\n28 |     class_name.to_string() + \".\" + extension.to_string()\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^\n   |         \
    \                           |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&extension.to_string()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = -1;\n\
    \    let mut extension = String::from(\"\");\n    for e in extensions {\n    \
    \    let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        strength =\
    \ if cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n\
    \        };\n        extension = if strength == 0 {\n            e.to_string()\n\
    \        } else {\n            format!(\"{}.{}\", class_name, e)\n        };\n\
    \    }\n    extension\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe3e_tz4s.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe3e_tz4s.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe3e_tz4s.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpe3e_tz4s.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe3e_tz4s.rs:24:13\n   |\n24 |\
    \             cap - sm\n   |             ^^^^^^^^ expected `i32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n24 |             (cap - sm).try_into().unwrap()\n \
    \  |\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        strength = if cap\
    \ > sm {\n            cap - sm\n        } else {\n            sm - cap\n     \
    \   };\n        extension = extension.concat(e);\n    }\n    extension.concat(\"\
    .\").concat(class_name.to_lowercase()).concat(\".\").concat(extensions[extensions.iter().min_by_key(|e|\
    \ strength)].to_lowercase())\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpudf7edem.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0599]: no method named `concat`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpudf7edem.rs:28:31\n\
    \   |\n28 |         extension = extension.concat(e);\n   |                   \
    \            ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `concat` found for struct `String` in the current scope\n  --> /tmp/tmpudf7edem.rs:30:15\n\
    \   |\n30 |     extension.concat(\".\").concat(class_name.to_lowercase()).concat(\"\
    .\").concat(extensions[extensions.iter().min_by_key(|e| strength)].to_...\n  \
    \ |               ^^^^^^ method not found in `String`\n\nerror[E0277]: the type\
    \ `[String]` cannot be indexed by `Option<&String>`\n  --> /tmp/tmpudf7edem.rs:30:80\n\
    \   |\n30 | ...\".\").concat(extensions[extensions.iter().min_by_key(|e| strength)].to_lowercase())\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[String]>` is not implemented for `Option<&String>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<&String>>`\
    \ for `Vec<String>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        let mut extension_strength = -1;\n        for c in extension {\n    \
    \        if c.is_uppercase() {\n                extension_map.insert(c.to_lowercase(),\
    \ 1);\n            } else {\n                extension_map.insert(c.to_uppercase(),\
    \ 1);\n            }\n        }\n        if extension_map.len() > extension_strength\
    \ {\n            extension_strength = extension_map.len();\n        }\n      \
    \  extensions_map.insert(extension.to_lowercase(), extension_strength);\n    }\n\
    \    let mut extensions_strength = -1;\n    let mut extensions_strongest = String::from(\"\
    \");\n    for extension in extensions {\n        let extension_strength = extensions_map.get(extension.to_lowercase());\n\
    \        if extension_strength == -1 {\n            continue;\n        }\n   \
    \     if extensions_strength < extension_strength {\n            extensions_strength\
    \ = extension_strength;\n            extensions_strongest = extension.to_lowercase();\n\
    \        }\n    }\n    class_name.to_lowercase() + \".\" + extensions_strongest\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmplv_tklvq.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmplv_tklvq.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmplv_tklvq.rs:22:18\n\
    \    |\n22  |         for c in extension {\n    |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplv_tklvq.rs:46:39\n\
    \   |\n46 |     class_name.to_lowercase() + \".\" + extensions_strongest\n   |\
    \                                       ^^^^^^^^^^^^^^^^^^^^\n   |           \
    \                            |\n   |                                       expected\
    \ `&str`, found struct `String`\n   |                                       help:\
    \ consider borrowing here: `&extensions_strongest`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > strength {\n            extension = e;\n   \
    \         strength = strength;\n        }\n    }\n    class_name.to_string() +\
    \ \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1t_pmtb_.rs:33:36\n   |\n\
    33 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        let strength\
    \ = if cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n\
    \        };\n        if strength > strength {\n            extension = e;\n  \
    \          strength = strength;\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9q_1wq3w.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9q_1wq3w.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9q_1wq3w.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9q_1wq3w.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9q_1wq3w.rs:33:36\n   |\n33 |\
    \     class_name.to_string() + \".\" + extension.to_string()\n   |           \
    \                         ^^^^^^^^^^^^^^^^^^^^^\n   |                        \
    \            |\n   |                                    expected `&str`, found\
    \ struc"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i32 = 0;\n\
    \    let mut extension = String::from(\"\");\n    for e in extensions {\n    \
    \    let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let\
    \ sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n        strength +=\
    \ cap - sm;\n        extension = e.to_string() + extension;\n    }\n    extension.split_whitespace().join(\"\
    .\").to_string()\n        .to_string()\n        .replace(&extension[..extension.len()],\
    \ &class_name.to_string())\n        .to_string()\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvrcsefnq.rs:21:45\n   |\n\
    21 |         let cap = e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n \
    \  |                                             ^^^\n   |                   \
    \                          |\n   |                                           \
    \  expected `&char`, found `char`\n   |                                      \
    \       help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvrcsefnq.rs:21:57\n   |\n21 |         let cap = e.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n   |                                       \
    \                  ^^^\n   |                                                 \
    \        |\n   |                                                         expected\
    \ `&char`, found `char`\n   |                                                \
    \         help: consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvrcsefnq.rs:22:44\n   |\n22 |         let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n   |                                       \
    \     ^^^\n   |                                            |\n   |           \
    \                                 expected `&char`, found `char`\n   |       \
    \                                     help: consider borrowing here: `&'a'`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvrcsefnq.rs:22:56\n   |\n22 |  \
    \       let sm = e.chars().filter(|c| c >= 'a' && c <= 'z').count();\n   |   \
    \                                                     ^^^\n   |              \
    \                                          |\n   |                           \
    \                             expected `&char`, found `char`\n   |           \
    \                                             help: consider borrowing here: `&'z'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvrcsefnq.rs:23:21\n   |\n23 |\
    \         strength += cap - sm;\n   |                     ^^^^^^^^ expected `i32`,\
    \ found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `i32`\n  --> /tmp/tmpvrcsefnq.rs:23:18\n\
    \   |\n23 |         strength += cap - sm;\n   |         "
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let mut extension = extension.clone();\n        let mut cap = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let mut sm = extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        if cap > sm {\n            strength = cap\
    \ - sm;\n            extension = extension.clone();\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + extension.to_string() + \".\" + extensions[extensions.iter().position(|x|\
    \ x.to_lowercase().cmp(&extension).unwrap()).unwrap()].to_string()\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmph78pek_t.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmph78pek_t.rs:29:36\n   |\n29 |     class_name.to_string() + \".\" + extension.to_string()\
    \ + \".\" + extensions[extensions.iter().position(|x| x.to_lowercase().cmp(&extensio...\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^\n   |         \
    \                           |\n   |                                    expected\
    \ `&str`, found struct `String`\n   |                                    help:\
    \ consider borrowing here: `&extension.to_string()`\n\nerror[E0599]: no method\
    \ named `unwrap` found for enum `std::cmp::Ordering` in the current scope\n  -->\
    \ /tmp/tmph78pek_t.rs:29:141\n   |\n29 | ...ition(|x| x.to_lowercase().cmp(&extension).unwrap()).unwrap()].to_string()\n\
    \   |                                               ^^^^^^ method not found in\
    \ `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph78pek_t.rs:29:66\n\
    \   |\n29 | ...() + \".\" + extensions[extensions.iter().position(|x| x.to_lowercase().cmp(&extension).unwrap()).unwrap()].to_string()\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |               |\n   |               expected `&str`, found struct `String`\n\
    \   |               help: consider borrowing here: `&extensions[extensions.iter().position(|x|\
    \ x.to_lowercase().cmp(&extension).unwrap()).unwrap()].to_string()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<String>>();\n    extensions_sorted.sort_by_key(|x|\
    \ x.chars().filter(|c| c.is_uppercase()).count() - x.chars().filter(|c| c.is_lowercase()).count());\n\
    \    extensions_sorted.iter().next().unwrap().to_string()\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"niNE\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp9bog8qzv.rs:25:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        if cap > sm {\n \
    \           extension = e;\n            strength = cap - sm;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main() {\n    let candidate\
    \ = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"),\
    \ vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\"\
    )]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmphslsyqaq.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748935
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<String>>();\n    extensions_sorted.sort_by(|a,\
    \ b| b.cmp(a));\n    let mut extensions_strength = Vec::new();\n    for extension\
    \ in extensions_sorted {\n        let mut extension_strength = extension.chars().filter(|c|\
    \ c.is_uppercase()).count() - extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if extension_strength > 0 {\n            extensions_strength.push(extension_strength);\n\
    \        }\n    }\n    let mut max_strength = -1;\n    let mut max_extension =\
    \ String::from(\"\");\n    for extension_strength in extensions_strength {\n \
    \       if extension_strength > max_strength {\n            max_strength = extension_strength;\n\
    \            max_extension = extension;\n        }\n    }\n    class_name.to_string()\
    \ + \".\" + max_extension.to_string()\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `extension` in this scope\n  --> /tmp/tmp26n7c7lt.rs:32:29\n\
    \   |\n32 |             max_extension = extension;\n   |                     \
    \        ^^^^^^^^^ help: a local variable with a similar name exists: `extensions`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp26n7c7lt.rs:27:28\n\
    \   |\n27 |     let mut max_strength = -1;\n   |                            ^^\
    \ the trait `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp26n7c7lt.rs:35:36\n   |\n35 |     class_name.to_string() + \".\"\
    \ + max_extension.to_string()\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                    |\n   |                             \
    \       expected `&str`, found struct `String`\n   |                         \
    \           help: consider borrowing here: `&max_extension.to_string()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut extensions_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut extension_map = HashMap::new();\n\
    \        for c in extension {\n            if c.is_uppercase() {\n           \
    \     extension_map.insert(c.to_lowercase(), 1);\n            } else {\n     \
    \           extension_map.insert(c.to_uppercase(), 1);\n            }\n      \
    \  }\n        extensions_map.insert(extension.to_lowercase(), extension_map);\n\
    \    }\n    let mut max_extension_strength = -1;\n    let mut max_extension =\
    \ String::from(\"\");\n    for extension in extensions {\n        let mut extension_strength\
    \ = extensions_map.get(extension.to_lowercase()).unwrap().len();\n        if extension_strength\
    \ > max_extension_strength {\n            max_extension_strength = extension_strength;\n\
    \            max_extension = extension;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, max_extension)\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n\
    \    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"\
    ), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"\
    ));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"\
    nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"\
    32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"\
    __YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"\
    nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"\
    123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"\
    K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"\
    ), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"\
    __HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"\
    781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpoj943suw.rs:18:30\n   |\n18 |     let mut extensions_map = HashMap::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpoj943suw.rs:20:33\n   |\n20 |         let mut extension_map = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpoj943suw.rs:21:18\n\
    \    |\n21  |         for c in extension {\n    |                  ^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    class_name.to_string() + \".\" + extension.to_string()\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4__ggsjv.rs:33:36\n   |\n\
    33 |     class_name.to_string() + \".\" + extension.to_string()\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^\n   |                     \
    \               |\n   |                                    expected `&str`, found\
    \ struct `String`\n   |                                    help: consider borrowing\
    \ here: `&extension.to_string()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength: i64 = 0;\n\
    \    let mut extension: Option<String> = None;\n    for extension in extensions\
    \ {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n  \
    \      strength += cap - sm;\n    }\n    if strength == 0 {\n        class_name\n\
    \    } else {\n        class_name.to_string() + extension.map(|e| e.to_string()).unwrap_or(\"\
    \")\n    }\n}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqi_tizr.rs:23:21\n   |\n\
    23 |         strength += cap - sm;\n   |                     ^^^^^^^^ expected\
    \ `i64`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `i64`\n \
    \ --> /tmp/tmpmqi_tizr.rs:23:18\n   |\n23 |         strength += cap - sm;\n  \
    \ |                  ^^ no implementation for `i64 += usize`\n   |\n   = help:\
    \ the trait `AddAssign<usize>` is not implemented for `i64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmqi_tizr.rs:28:77\n   |\n28 |         class_name.to_string()\
    \ + extension.map(|e| e.to_string()).unwrap_or(\"\")\n   |                   \
    \                                                          ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \                                           |\n   |                          \
    \                                                   expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmqi_tizr.rs:28:34\n\
    \   |\n28 |         class_name.to_string() + extension.map(|e| e.to_string()).unwrap_or(\"\
    \")\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                  |\n   |                               \
    \   expected `&str`, found struct `String`\n   |                             \
    \     help: consider borrowing here: `&extension.map(|e| e.to_string()).unwrap_or(\"\
    \")`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748936
- exit_code: 101
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.clone();\n  \
    \          break;\n        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n\
    }\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Watashi.tEN\"`,\n right: `\"Watashi.eIGHt8OKe\"`', /tmp/tmp4yougmos.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for extension in extensions {\n\
    \        let cap = extension.chars().filter(|c| c.is_uppercase()).count();\n \
    \       let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n   \
    \     strength = if cap > sm {\n            cap - sm\n        } else {\n     \
    \       sm - cap\n        };\n        if strength > 0 {\n            break;\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extension)\n}\n\nfn main()\
    \ {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpta93_81b.rs:18:24\n\
    \   |\n18 |     let mut strength = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748934
- exit_code: 1
  program: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
    my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"\
    CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name:\
    \ String, extensions: Vec<String>) -> String {\n    let mut strength = -1;\n \
    \   let mut extension = String::from(\"\");\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_uppercase()).count();\n        let sm\
    \ = e.chars().filter(|c| c.is_lowercase()).count();\n        let strength = if\
    \ cap > sm {\n            cap - sm\n        } else {\n            sm - cap\n \
    \       };\n        if strength > 0 {\n            extension = e.to_string() +\
    \ extension;\n        }\n    }\n    class_name + extension\n}\n\nfn main() {\n\
    \    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
    Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
    eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
    Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
    YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
    ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
    t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
    ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
    __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
    Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\"\
    )]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"\
    ), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"\
    ), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
    YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
    WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"\
    YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"\
    ), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"),\
    \ String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
    _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
    ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
    ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi2yana1p.rs:29:41\n   |\n\
    29 |             extension = e.to_string() + extension;\n   |                \
    \                         ^^^^^^^^^\n   |                                    \
    \     |\n   |                                         expected `&str`, found struct\
    \ `String`\n   |                                         help: consider borrowing\
    \ here: `&extension`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi2yana1p.rs:32:18\n\
    \   |\n32 |     class_name + extension\n   |                  ^^^^^^^^^\n   |\
    \                  |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&extension`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748935
