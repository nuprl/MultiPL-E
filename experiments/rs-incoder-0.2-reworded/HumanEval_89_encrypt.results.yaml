language: rs
name: HumanEval_89_encrypt
results:
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpwm30v6d6.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpytujwhhu.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp91y9y9lc.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpfjibt3ak.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfjibt3ak.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfjibt3ak.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfjibt3ak.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfjibt3ak.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfjibt3ak.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfjibt3ak.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfjibt3ak.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfjibt3ak.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp2pg1ozca.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2pg1ozca.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2pg1ozca.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2pg1ozca.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2pg1ozca.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2pg1ozca.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2pg1ozca.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2pg1ozca.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2pg1ozca.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    let mut result = String::new();\n    for\
    \ c in s.chars() {\n        result.push(alphabet[alphabet.len() - alphabet.iter().rev().next().unwrap().cmp(&c).unwrap()]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8read16v.rs:19:89\n   |\n\
    19 |         result.push(alphabet[alphabet.len() - alphabet.iter().rev().next().unwrap().cmp(&c).unwrap()]);\n\
    \   |                                                                        \
    \                 ^^ expected `&str`, found `char`\n   |\n   = note: expected\
    \ reference `&&str`\n              found reference `&char`\n\nerror[E0599]: no\
    \ method named `unwrap` found for enum `std::cmp::Ordering` in the current scope\n\
    \  --> /tmp/tmp8read16v.rs:19:93\n   |\n19 |         result.push(alphabet[alphabet.len()\
    \ - alphabet.iter().rev().next().unwrap().cmp(&c).unwrap()]);\n   |          \
    \                                                                            \
    \       ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8read16v.rs:19:21\n   |\n19 |         result.push(alphabet[alphabet.len()\
    \ - alphabet.iter().rev().next().unwrap().cmp(&c).unwrap()]);\n   |          \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpaafkcdmo.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:18:19\n \
    \  |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:20:19\n\
    \   |\n20 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:21:19\n\
    \   |\n21 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:22:19\n\
    \   |\n22 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:23:19\n\
    \   |\n23 |     alphabet.push(alphabet.last"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmprjm_lwq3.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprjm_lwq3.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprjm_lwq3.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprjm_lwq3.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprjm_lwq3.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprjm_lwq3.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprjm_lwq3.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprjm_lwq3.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprjm_lwq3.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.sort_by_key(|&x| x.to_ascii_lowercase());\n    alphabet.push(String::from(\"\
    z\"));\n    alphabet.push(String::from(\"y\"));\n    alphabet.push(String::from(\"\
    x\"));\n    alphabet.push(String::from(\"w\"));\n    alphabet.push(String::from(\"\
    v\"));\n    alphabet.push(String::from(\"u\"));\n    alphabet.push(String::from(\"\
    t\"));\n    alphabet.push(String::from(\"s\"));\n    alphabet.push(String::from(\"\
    r\"));\n    alphabet.push(String::from(\"q\"));\n    alphabet.push(String::from(\"\
    p\"));\n    alphabet.push(String::from(\"o\"));\n    alphabet.push(String::from(\"\
    n\"));\n    alphabet.push(String::from(\"m\"));\n    alphabet.push(String::from(\"\
    l\"));\n    alphabet.push(String::from(\"k\"));\n    alphabet.push(String::from(\"\
    j\"));\n    alphabet.push(String::from(\"h\"));\n    alphabet.push(String::from(\"\
    g\"));\n    alphabet.push(String::from(\"f\"));\n    alphabet.push(String::from(\"\
    e\"));\n    alphabet.push(String::from(\"d\"));\n    alphabet.push(String::from(\"\
    c\"));\n    alphabet.push(String::from(\"b\"));\n    alphabet.push(String::from(\"\
    a\"));\n    alphabet.push(String::from(\"z\"));\n    alphabet.push(String::from(\"\
    y\"));\n    alphabet.push(String::from(\"x\"));\n    alphabet.push(String::from(\"\
    w\"));\n    alphabet.push(String::from(\"v\"));\n    alphabet.push(String::from(\"\
    u\"));\n    alphabet.push(String::from(\"t\"));\n    alphabet.push(String::from(\"\
    s\"));\n    alphabet.push(String::from(\"r\"));\n    alphabet.push(String::from(\"\
    q\"));\n    alphabet.push(String::from(\"p\"));\n    alphabet.push(String::from(\"\
    o\"));\n    alphabet.push(String::from(\"n\"));\n    alphabet.push(String::from(\"\
    m\"));\n    alphabet.push(String::from(\"l\"));\n    alphabet.push(String::from(\"\
    k\"));\n    alphabet.push(String::from(\"j\"));\n    alphabet.push(String::from(\"\
    h\"));\n    alphabet.push(String::from\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp6y543vmm.rs:60:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n60 |     alphabet.push(String::from\n\
    \   |                  ^ unclosed delimiter\n61 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6y543vmm.rs:17:19\n\
    \   |\n17 |     alphabet.push(String::from(\"z\"));\n   |                   ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6y543vmm.rs:18:19\n   |\n18 |     alphabet.push(String::from(\"\
    y\"));\n   |                   ^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6y543vmm.rs:19:19\n\
    \   |\n19 |     alphabet.push(String::from(\"x\"));\n   |                   ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6y543vmm.rs:20:19\n   |\n20 |     alphabet.push(String::from(\"\
    w\"));\n   |                   ^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6y543vmm.rs:21:19\n\
    \   |\n21 |     alphabet.push(String::from(\"v\"));\n   |                   ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6y543vmm.rs:22:19\n   |\n22 |     alphabet.push(String::from(\"\
    u\"));\n   |                   ^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6y543vmm.rs:23:19\n\
    \   |\n23 |     alphabet.push(String::from(\"t\"));\n   |                   ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6y543vmm.rs:24:19\n   |\n24 |     alphabet.push(String::from(\"\
    s\"));\n   |                   ^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6y543vmm.rs:25:19\n\
    \   |\n25 |     alphabet.push(String::from(\"r\"));\n   |                   ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `Stri"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpwiojhc2y.rs:64:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n64 |     alphabet.push(alphabet.last().\n\
    \   |                  ^ unclosed delimiter\n65 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: unexpected token: `)`\n  --> /tmp/tmpwiojhc2y.rs:65:1\n\
    \   |\n65 | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwiojhc2y.rs:16:19\n\
    \   |\n16 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n16 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwiojhc2y.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwiojhc2y.rs:18:19\n\
    \   |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwiojhc2y.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwiojhc2y.rs:20:19\n\
    \   |\n20 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: misma"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    let mut result = String::new();\n    for\
    \ c in s.chars() {\n        result.push(*alphabet[alphabet.index(c) + 1]);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for struct `Vec<&str>` in the\
    \ current scope\n  --> /tmp/tmpi2zdj0ce.rs:19:40\n   |\n19 |         result.push(*alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                        ^^^^^ method not found in\
    \ `Vec<&str>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpavlsnw5n.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    let mut cipher = Cipher::new(&alphabet);\n    cipher.encrypt(&s);\n    cipher.to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpcuaemxpe.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Cipher`\n  --> /tmp/tmpcuaemxpe.rs:17:22\n\
    \   |\n17 |     let mut cipher = Cipher::new(&alphabet);\n   |               \
    \       ^^^^^^ use of undeclared type `Cipher`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmped7q3wrh.rs:14:26\n   |\n\
    14 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['z' - 1, 'a' - 1, 'b' - 1,\
    \ 'c' - 1, 'd' - 1, 'e' - 1, 'f' - 1, 'g' - 1, 'h' - 1, 'i' - 1, 'j' - 1, 'k'\
    \ - 1, 'l' - 1, 'm' - 1, 'n' - 1, 'o' - 1, 'p' - 1, 'q' - 1, 'r' - 1, 's' - 1,\
    \ 't' - 1, 'u' - 1, 'v' - 1, 'w' - 1, 'x' - 1, 'y' - 1, 'z' - 1];\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    \n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpkzn9g6zy.rs:15:33\n\
    \   |\n15 |     let mut alphabet = vec!['z' - 1, 'a' - 1, 'b' - 1, 'c' - 1, 'd'\
    \ - 1, 'e' - 1, 'f' - 1, 'g' - 1, 'h' - 1, 'i' - 1, 'j' - 1, 'k' - 1, '...\n \
    \  |                             --- ^ - {integer}\n   |                     \
    \        |\n   |                             char\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `char`\n  --> /tmp/tmpkzn9g6zy.rs:15:42\n   |\n15 |     let\
    \ mut alphabet = vec!['z' - 1, 'a' - 1, 'b' - 1, 'c' - 1, 'd' - 1, 'e' - 1, 'f'\
    \ - 1, 'g' - 1, 'h' - 1, 'i' - 1, 'j' - 1, 'k' - 1, '...\n   |               \
    \                       --- ^ - {integer}\n   |                              \
    \        |\n   |                                      char\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `char`\n  --> /tmp/tmpkzn9g6zy.rs:15:51\n   |\n15\
    \ |     let mut alphabet = vec!['z' - 1, 'a' - 1, 'b' - 1, 'c' - 1, 'd' - 1, 'e'\
    \ - 1, 'f' - 1, 'g' - 1, 'h' - 1, 'i' - 1, 'j' - 1, 'k' - 1, '...\n   |      \
    \                                         --- ^ - {integer}\n   |            \
    \                                   |\n   |                                  \
    \             char\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n\
    \  --> /tmp/tmpkzn9g6zy.rs:15:60\n   |\n15 |     let mut alphabet = vec!['z' -\
    \ 1, 'a' - 1, 'b' - 1, 'c' - 1, 'd' - 1, 'e' - 1, 'f' - 1, 'g' - 1, 'h' - 1, 'i'\
    \ - 1, 'j' - 1, 'k' - 1, '...\n   |                                          \
    \              --- ^ - {integer}\n   |                                       \
    \                 |\n   |                                                    \
    \    char\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpkzn9g6zy.rs:15:69\n\
    \   |\n15 |     let mut alphabet = vec!['z' - 1, 'a' - 1, 'b' - 1, 'c' - 1, 'd'\
    \ - 1, 'e' - 1, 'f' - 1, 'g' - 1, 'h' - 1, 'i' - 1, 'j' - 1, 'k' - 1, '...\n \
    \  |                                                                 --- ^ - {integer}\n\
    \   |                                                                 |\n   |\
    \                                       "
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['z', 'y', 'x', 'w', 'v', 'u',\
    \ 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e',\
    \ 'd', 'c', 'b', 'a'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet[0]);\n\
    \    alphabet.push(alphabet[1]);\n    alphabet.push(alphabet[2]);\n    alphabet.push(alphabet[3]);\n\
    \    alphabet.push(alphabet[4]);\n    alphabet.push(alphabet[5]);\n    alphabet.push(alphabet[6]);\n\
    \    alphabet.push(alphabet[7]);\n    alphabet.push(alphabet[8]);\n    alphabet.push(alphabet[9]);\n\
    \    alphabet.push(alphabet[10]);\n    alphabet.push(alphabet[11]);\n    alphabet.push(alphabet[12]);\n\
    \    alphabet.push(alphabet[13]);\n    alphabet.push(alphabet[14]);\n    alphabet.push(alphabet[15]);\n\
    \    alphabet.push(alphabet[16]);\n    alphabet.push(alphabet[17]);\n    alphabet.push(alphabet[18]);\n\
    \    alphabet.push(alphabet[19]);\n    alphabet.push(alphabet[20]);\n    alphabet.push(alphabet[21]);\n\
    \    alphabet.push(alphabet[22]);\n    alphabet.push(alphabet[23]);\n    alphabet.push(alphabet[24]);\n\
    \    alphabet.push(alphabet[25]);\n    alphabet.push(alphabet[26]);\n    alphabet.push(alphabet[27]);\n\
    \    alphabet.push(alphabet[28]);\n    alphabet.push(alphabet[29]);\n    alphabet.push(alphabet[30]);\n\
    \    alphabet.push(alphabet[31]);\n    alphabet.push(alphabet[32]);\n    alphabet.push(alphabet[33]);\n\
    \    alphabet.push(alphabet[34]);\n    alphabet.push(alphabet[35]);\n    alphabet.push(alphabet[36]);\n\
    \    alphabet.push(alphabet[37]);\n    alphabet.push(alphabet[38]);\n    alphabet.push(alphabet[39]);\n\
    \    alphabet.push(alphabet[40]);\n    alphabet.push(alphabet[41]);\n    alphabet.push(alphabet[42]);\n\
    \    alphabet.push(alphabet[43]);\n    alphabet.push(alphabet[44]);\n    alphabet.push(alphabet[45]);\n\
    \    alphabet.push(alphabet[46]);\n    alphabet.push(alphabet[47]);\n    alphabet.push(alphabet[48]);\n\
    \    alphabet.push(alphabet[49]);\n    alphabet.push(alphabet[50]);\n    alphabet.push(alphabet[51]);\n\
    \    alphabet.push(alphabet[5\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp8qzbl2kj.rs:69:27\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n69 |     alphabet.push(alphabet[5\n\
    \   |                           ^ unclosed delimiter\n70 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8qzbl2kj.rs:69:5\n\
    \   |\n14 |   fn encrypt(s: String) -> String {\n   |                        \
    \    ------ expected `String` because of return type\n...\n69 | /     alphabet.push(alphabet[5\n\
    70 | | }\n   | |_^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(alphabet.len()\
    \ - 1);\n    alphabet.push(alphabet.len() - 1);\n    alphabet.push(\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmplp87co8h.rs:65:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n65 |     alphabet.push(\n\
    \   |                  ^ unclosed delimiter\n66 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp87co8h.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.len() - 1);\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp87co8h.rs:18:19\n\
    \   |\n18 |     alphabet.push(alphabet.len() - 1);\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp87co8h.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.len() - 1);\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp87co8h.rs:20:19\n\
    \   |\n20 |     alphabet.push(alphabet.len() - 1);\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp87co8h.rs:21:19\n\
    \   |\n21 |     alphabet.push(alphabet.len() - 1);\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp87co8h.rs:22:19\n\
    \   |\n22 |     alphabet.push(alphabet.len() - 1);\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp87co8h.rs:23:19\n\
    \   |\n23 |     alphabet.push(alphabet.len() - 1);\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp87co8h.rs:24:19\n\
    \   |\n24 |     alphabet.push(alphabet.len() - 1);\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp87co8h.rs:25:19\n\
    \   |\n25 |     alphabet.push(alphabet.len() - 1);\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplp87co8h.rs:26:1"
  stdout: ''
  timestamp: 1659748215
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    let mut cipher = Cipher::new(alphabet);\n    cipher.encrypt(&s);\n    cipher.to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpnyvb22t_.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Cipher`\n  --> /tmp/tmpnyvb22t_.rs:17:22\n\
    \   |\n17 |     let mut cipher = Cipher::new(alphabet);\n   |                \
    \      ^^^^^^ use of undeclared type `Cipher`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['z', 'y', 'x', 'w', 'v', 'u',\
    \ 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'f', 'd', 'h', 'g', 'e',\
    \ 'a', 'i', 'c', 'b', 'h', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'f', 'd', 'h', 'g', 'e', 'a', 'i', 'c', 'b', 'h', 'y',\
    \ 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'f',\
    \ 'd', 'h', 'g', 'e', 'a', 'i', 'c', 'b', 'h', 'y', 'x', 'w', 'v', 'u', 't', 's',\
    \ 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'f', 'd', 'h', 'g', 'e', 'a', 'i',\
    \ 'c', 'b', 'h', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n', 'm',\
    \ 'l', 'k', 'j', 'f', 'd', 'h', 'g', 'e', 'a', 'i', 'c', 'b', 'h', 'y', 'x', 'w',\
    \ 'v', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'f', 'd', 'h',\
    \ 'g', 'e', 'a', 'i', 'c', 'b', 'h', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q',\
    \ 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'f', 'd', 'h', 'g', 'e', 'a', 'i', 'c', 'b',\
    \ 'h', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k',\
    \ 'j', 'f', 'd', 'h', 'g', 'e', 'a', 'i', 'c', 'b', 'h', 'y', 'x', 'w', 'v', 'u',\
    \ 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'f', 'd', 'h', 'g', 'e',\
    \ 'a', 'i', 'c', 'b', 'h', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o',\
    \ 'n', 'm', 'l', 'k', 'j', 'f', 'd', 'h', 'g', 'e', 'a', 'i', 'c', 'b', 'h', 'y',\
    \ 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'f',\
    \ 'd', 'h', 'g', 'e', 'a', 'i', 'c', 'b', 'h', 'y', 'x', 'w', 'v', 'u', 't', 's',\
    \ 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'f', 'd', 'h', 'g', 'e', 'a', 'i',\
    \ 'c', 'b', 'h', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n', 'm',\
    \ 'l', 'k', 'j', 'f', 'd', 'h', 'g', 'e', 'a', 'i', 'c', 'b', 'h', 'y', 'x', 'w',\
    \ 'v', 'u', 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpbrhi2q9v.rs:16:1\n   |\n16 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpbrhi2q9v.rs:15:28\n   |\n14 | fn encrypt(s: String) -> String {\n  \
    \ |                                 - closing delimiter possibly meant for this\n\
    15 |     let mut alphabet = vec!['z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r',\
    \ 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'f', 'd', 'h', 'g', 'e',...\n   |  \
    \                          ^ unclosed delimiter\n16 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmped7q3wrh.rs:14:26\n   |\n\
    14 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().for_each(|c| {\n        *c\
    \ = *c + 1;\n    });\n    String::from_utf8(alphabet).unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpji4qpqv1.rs:18:17\n\
    \   |\n18 |         *c = *c + 1;\n   |              -- ^ - {integer}\n   |   \
    \           |\n   |              char\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpji4qpqv1.rs:20:23\n   |\n20 |     String::from_utf8(alphabet).unwrap()\n\
    \   |                       ^^^^^^^^ expected `u8`, found `char`\n   |\n   = note:\
    \ expected struct `Vec<u8>`\n              found struct `Vec<char>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa3s22_ix.rs:47:21\n   |\n\
    47 |     let mut alphabet\n   |                     ^ help: add `;` here\n48 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa3s22_ix.rs:14:26\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['z', 'y', 'x', 'w', 'u', 't',\
    \ 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'h', 'f', 'e', 'd', 'c', 'b',\
    \ 'a'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n \
    \   alphabet.push(alphabet.first());\n    let mut result = String::new();\n  \
    \  for c in s.chars() {\n        result.push(alphabet[alphabet.index(c)]);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8hmrmhna.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8hmrmhna.rs:18:19\n   |\n18 |     alphabet.push(alphabet.first());\n\
    \   |                   ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0599]: no method named `index` found for struct `Vec<char>` in the current\
    \ scope\n  --> /tmp/tmp8hmrmhna.rs:21:39\n   |\n21 |         result.push(alphabet[alphabet.index(c)]);\n\
    \   |                                       ^^^^^ method not found in `Vec<char>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |               "
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:18:19\n \
    \  |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:20:19\n\
    \   |\n20 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:21:19\n\
    \   |\n21 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:22:19\n\
    \   |\n22 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:23:19\n\
    \   |\n23 |     alphabet.push(alphabet.last"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.first());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n   \
    \ alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n   \
    \ alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n   \
    \ alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n \
    \   alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n   \
    \ alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n \
    \   alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n   \
    \ alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n \
    \   alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n   \
    \ alphabet.push(alphabet.first());\n    alphabet.push(alphab\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmph0nl68km.rs:67:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n67 |     alphabet.push(alphab\n\
    \   |                  ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0425]: cannot find value `alphab` in this scope\n  --> /tmp/tmph0nl68km.rs:67:19\n\
    \   |\n67 |     alphabet.push(alphab\n   |                   ^^^^^^ help: a local\
    \ variable with a similar name exists: `alphabet`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph0nl68km.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph0nl68km.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.first());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph0nl68km.rs:19:19\n   |\n19 |     alphabet.push(alphabet.first());\n\
    \   |                   ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph0nl68km.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph0nl68km.rs:21:19\n   |\n21 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph0nl68km.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.first());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   "
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:16:19\n   |\n\
    16 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:21:19\n   |\n21 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:23:19\n   |\n23 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.iter().for_each(|c| s.push_str(&alphabet[alphabet.index(c)]));\n\
    \    s\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpnbho4msw.rs:18:64\n   |\n18 |     alphabet.iter().for_each(|c|\
    \ s.push_str(&alphabet[alphabet.index(c)]));\n   |                           \
    \                                     ^^^^^ method not found in `Vec<char>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    let mut cipher = s.chars().map(|c| alphabet.iter().position(|x|\
    \ x == c).unwrap()).collect::<Vec<_>>();\n    cipher.rotate_left(2);\n    cipher.iter().map(|c|\
    \ alphabet.iter().position(|x| x == c).unwrap()).collect::<Vec<_>>().join(\"\"\
    )\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmpheaxwaw0.rs:17:71\n\
    \   |\n17 |     let mut cipher = s.chars().map(|c| alphabet.iter().position(|x|\
    \ x == c).unwrap()).collect::<Vec<_>>();\n   |                               \
    \                                        ^^ no implementation for `&&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&&str`\n\
    \nerror[E0277]: can't compare `&str` with `usize`\n  --> /tmp/tmpheaxwaw0.rs:19:58\n\
    \   |\n19 |     cipher.iter().map(|c| alphabet.iter().position(|x| x == c).unwrap()).collect::<Vec<_>>().join(\"\
    \")\n   |                                                          ^^ no implementation\
    \ for `&str == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&str`\n   = note: required because of the requirements on the impl of `PartialEq<&usize>`\
    \ for `&&str`\n\nerror[E0599]: the method `join` exists for struct `Vec<usize>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpheaxwaw0.rs:19:94\n \
    \  |\n19 |     cipher.iter().map(|c| alphabet.iter().position(|x| x == c).unwrap()).collect::<Vec<_>>().join(\"\
    \")\n   |                                                                    \
    \                          ^^^^ method cannot be called on `Vec<usize>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `<[usize] as Join<_>>::Output = _`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |               "
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:16:19\n   |\n\
    16 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:21:19\n   |\n21 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:23:19\n   |\n23 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:16:19\n   |\n\
    16 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:21:19\n   |\n21 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:23:19\n   |\n23 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().for_each(|c| {\n        alphabet.push(c);\n\
    \    });\n    String::from_iter(alphabet)\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph7zi_ynu.rs:18:23\n   |\n\
    18 |         alphabet.push(c);\n   |                       ^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |   \
    \      alphabet.push(*c);\n   |                       +\n\nerror[E0599]: no function\
    \ or associated item named `from_iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmph7zi_ynu.rs:20:13\n   |\n20 |     String::from_iter(alphabet)\n\
    \   |             ^^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::iter::FromIterator;\n   |\nhelp: there is an associated\
    \ function with a similar name\n   |\n20 |     String::from_utf8(alphabet)\n \
    \  |             ~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpklvv9fcy.rs:14:26\n   |\n\
    14 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c as char).collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c as char).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&char` as `char` is invalid\n  --> /tmp/tmpur4_yjkj.rs:17:29\n\
    \   |\n17 |     alphabet.iter().map(|c| c as char).collect::<String>()\n   | \
    \                            ^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v',\
    \ 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'h', 'g', 'f', 'e', 'd',\
    \ 'c', 'b', 'a'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet[0]);\n\
    \    alphabet.push(alphabet[1]);\n    alphabet.push(alphabet[2]);\n    alphabet.push(alphabet[3]);\n\
    \    alphabet.push(alphabet[4]);\n    alphabet.push(alphabet[5]);\n    alphabet.push(alphabet[6]);\n\
    \    alphabet.push(alphabet[7]);\n    alphabet.push(alphabet[8]);\n    alphabet.push(alphabet[9]);\n\
    \    alphabet.push(alphabet[10]);\n    alphabet.push(alphabet[11]);\n    alphabet.push(alphabet[12]);\n\
    \    alphabet.push(alphabet[13]);\n    alphabet.push(alphabet[14]);\n    alphabet.push(alphabet[15]);\n\
    \    alphabet.push(alphabet[16]);\n    alphabet.push(alphabet[17]);\n    alphabet.push(alphabet[18]);\n\
    \    alphabet.push(alphabet[19]);\n    alphabet.push(alphabet[20]);\n    alphabet.push(alphabet[21]);\n\
    \    alphabet.push(alphabet[22]);\n    alphabet.push(alphabet[23]);\n    alphabet.push(alphabet[24]);\n\
    \    alphabet.push(alphabet[25]);\n    alphabet.push(alphabet[26]);\n    alphabet.push(alphabet[27]);\n\
    \    alphabet.push(alphabet[28]);\n    alphabet.push(alphabet[29]);\n    alphabet.push(alphabet[30]);\n\
    \    alphabet.push(alphabet[31]);\n    alphabet.push(alphabet[32]);\n    alphabet.push(alphabet[33]);\n\
    \    alphabet.push(alphabet[34]);\n    alphabet.push(alphabet[35]);\n    alphabet.push(alphabet[36]);\n\
    \    alphabet.push(alphabet[37]);\n    alphabet.push(alphabet[38]);\n    alphabet.push(alphabet[39]);\n\
    \    alphabet.push(alphabet[40]);\n    alphabet.push(alphabet[41]);\n    alphabet.push(alphabet[42]);\n\
    \    alphabet.push(alphabet[43]);\n    alphabet.push(alphabet[44]);\n    alphabet.push(alphabet[45]);\n\
    \    alphabet.push(alphabet[46]);\n    alphabet.push(alphabet[47]);\n    alphabet.push(alphabet[48]);\n\
    \    alphabet.push(alphabet[49]);\n    alphabet.push(alphabet[50]);\n    alphabet.push(alphabet[51]);\n\
    \    alphabet.push(alphabet[5\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpms25m3yj.rs:69:27\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n69 |     alphabet.push(alphabet[5\n\
    \   |                           ^ unclosed delimiter\n70 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpms25m3yj.rs:69:5\n\
    \   |\n14 |   fn encrypt(s: String) -> String {\n   |                        \
    \    ------ expected `String` because of return type\n...\n69 | /     alphabet.push(alphabet[5\n\
    70 | | }\n   | |_^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:16:19\n   |\n\
    16 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:21:19\n   |\n21 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:23:19\n   |\n23 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |               "
  stdout: ''
  timestamp: 1659748215
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<char>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0615]: attempted to take value of method `swap` on type `Vec<char>`\n\
    \  --> /tmp/tmpwelcnk1w.rs:57:14\n   |\n57 |     alphabet.swap\n   |         \
    \     ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n57 |     alphabet.swap(_, _)\n   |                  ++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0615`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |               "
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().for_each(|c| {\n        alphabet.push(c);\n\
    \    });\n    String::from_iter(alphabet)\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph7zi_ynu.rs:18:23\n   |\n\
    18 |         alphabet.push(c);\n   |                       ^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |   \
    \      alphabet.push(*c);\n   |                       +\n\nerror[E0599]: no function\
    \ or associated item named `from_iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmph7zi_ynu.rs:20:13\n   |\n20 |     String::from_iter(alphabet)\n\
    \   |             ^^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::iter::FromIterator;\n   |\nhelp: there is an associated\
    \ function with a similar name\n   |\n20 |     String::from_utf8(alphabet)\n \
    \  |             ~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:18:19\n \
    \  |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:20:19\n\
    \   |\n20 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:21:19\n\
    \   |\n21 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:22:19\n\
    \   |\n22 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:23:19\n\
    \   |\n23 |     alphabet.push(alphabet.last"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.sort_unstable();\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphab\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphab` in this scope\n  --> /tmp/tmprf_78s5q.rs:71:5\n\
    \   |\n71 |     alphab\n   |     ^^^^^^ help: a local variable with a similar\
    \ name exists: `alphabet`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprf_78s5q.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprf_78s5q.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprf_78s5q.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprf_78s5q.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprf_78s5q.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprf_78s5q.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprf_78s5q.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: "
  stdout: ''
  timestamp: 1659748215
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmped7q3wrh.rs:14:26\n   |\n\
    14 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    let mut result = String::new();\n    for\
    \ c in s.chars() {\n        result.push(alphabet[alphabet.index(c)]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for struct `Vec<&str>` in the\
    \ current scope\n  --> /tmp/tmpl16s2vx_.rs:19:39\n   |\n19 |         result.push(alphabet[alphabet.index(c)]);\n\
    \   |                                       ^^^^^ method not found in `Vec<&str>`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<char>>();\n\
    \    alphabet.sort_unstable();\n    alphabet.push(alphabet[0]);\n    alphabet.push(alphabet[1]);\n\
    \    alphabet.push(alphabet[2]);\n    alphabet.push(alphabet[3]);\n    alphabet.push(alphabet[4]);\n\
    \    alphabet.push(alphabet[5]);\n    alphabet.push(alphabet[6]);\n    alphabet.push(alphabet[7]);\n\
    \    alphabet.push(alphabet[8]);\n    alphabet.push(alphabet[9]);\n    alphabet.push(alphabet[10]);\n\
    \    alphabet.push(alphabet[11]);\n    alphabet.push(alphabet[12]);\n    alphabet.push(alphabet[13]);\n\
    \    alphabet.push(alphabet[14]);\n    alphabet.push(alphabet[15]);\n    alphabet.push(alphabet[16]);\n\
    \    alphabet.push(alphabet[17]);\n    alphabet.push(alphabet[18]);\n    alphabet.push(alphabet[19]);\n\
    \    alphabet.push(alphabet[20]);\n    alphabet.push(alphabet[21]);\n    alphabet.push(alphabet[22]);\n\
    \    alphabet.push(alphabet[23]);\n    alphabet.push(alphabet[24]);\n    alphabet.push(alphabet[25]);\n\
    \    alphabet.push(alphabet[26]);\n    alphabet.push(alphabet[27]);\n    alphabet.push(alphabet[28]);\n\
    \    alphabet.push(alphabet[29]);\n    alphabet.push(alphabet[30]);\n    alphabet.push(alphabet[31]);\n\
    \    alphabet.push(alphabet[32]);\n    alphabet.push(alphabet[33]);\n    alphabet.push(alphabet[34]);\n\
    \    alphabet.push(alphabet[35]);\n    alphabet.push(alphabet[36]);\n    alphabet.push(alphabet[37]);\n\
    \    alphabet.push(alphabet[38]);\n    alphabet.push(alphabet[39]);\n    alphabet.push(alphabet[40]);\n\
    \    alphabet.push(alphabet[41]);\n    alphabet.push(alphabet[42]);\n    alphabet.push(alphabet[43]);\n\
    \    alphabet.push(alphabet[44]);\n    alphabet.push(alphabet[45]);\n    alphabet.push(alphabet[46]);\n\
    \    alphabet.push(alphabet[47]);\n    alphabet.push(alphabet[48]);\n    alphabet.push(alphabet[49]);\n\
    \    alphabet.push(alphabet[50]);\n    alphabet.push(alphabet[51]);\n    alphabet.push(alphabet[52]);\n\
    \    alphabet.push(alphabet[53]);\n    alphabet.push(alphabet[54]);\n    alphabet.push(alphabet[55\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp3c0o6_v4.rs:72:27\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n72 |     alphabet.push(alphabet[55\n\
    \   |                           ^ unclosed delimiter\n73 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3c0o6_v4.rs:72:5\n\
    \   |\n14 |   fn encrypt(s: String) -> String {\n   |                        \
    \    ------ expected `String` because of return type\n...\n72 | /     alphabet.push(alphabet[55\n\
    73 | | }\n   | |_^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.collect::<String>()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0qrq2ip6.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0qrq2ip6.rs:18:19\n   |\n18 |     alphabet.push(alphabet.first());\n\
    \   |                   ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0599]: the method `collect` exists for struct `Vec<char>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp0qrq2ip6.rs:19:14\n    |\n19  |  \
    \     alphabet.collect::<String>()\n    |                ^^^^^^^ method cannot\
    \ be called on `Vec<char>` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<char>: Iterator`\n\
    \            which is required by `&mut Vec<char>: Iterator`\n            `[char]:\
    \ Iterator`\n            which is required by `&mut [char]: Iterator`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v',\
    \ 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e',\
    \ 'd', 'c', 'b', 'a'];\n    alphabet.rotate_left(2);\n    let mut result = String::new();\n\
    \    for c in s.chars() {\n        let index = alphabet.iter().position(|&x| x\
    \ == c).unwrap();\n        result.push((alphabet[index as usize] + alphabet[(index\
    \ + 1) as usize]).to_string());\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmp7seqps2u.rs:20:47\n\
    \   |\n20 |         result.push((alphabet[index as usize] + alphabet[(index +\
    \ 1) as usize]).to_string());\n   |                      ------------------------\
    \ ^ ------------------------------ char\n   |                      |\n   |   \
    \                   char\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmped7q3wrh.rs:14:26\n   |\n\
    14 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap_remove(alphabet.len()\
    \ - 1);\n    alphabet.swap_remove(alphabet.len() - 1);\n    alphabet.swap\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0615]: attempted to take value of method `swap` on type `Vec<char>`\n\
    \  --> /tmp/tmptewiv6o5.rs:57:14\n   |\n57 |     alphabet.swap\n   |         \
    \     ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n57 |     alphabet.swap(_, _)\n   |                  ++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0615`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:18:19\n \
    \  |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:20:19\n\
    \   |\n20 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:21:19\n\
    \   |\n21 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:22:19\n\
    \   |\n22 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:23:19\n\
    \   |\n23 |     alphabet.push(alphabet.last"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c as char).collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c as char).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&char` as `char` is invalid\n  --> /tmp/tmpur4_yjkj.rs:17:29\n\
    \   |\n17 |     alphabet.iter().map(|c| c as char).collect::<String>()\n   | \
    \                            ^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<char>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzf7ta5lu.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf7ta5lu.rs:18:19\n \
    \  |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf7ta5lu.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf7ta5lu.rs:20:19\n\
    \   |\n20 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf7ta5lu.rs:21:19\n\
    \   |\n21 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf7ta5lu.rs:22:19\n\
    \   |\n22 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf7ta5lu.rs:23:19\n\
    \   |\n23 |     alphabet.push(alphabet.last"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['z', 'y', 'x', 'w', 'u', 'v',\
    \ 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'h', 'f', 'g', 'e', 'd',\
    \ 'c', 'b', 'a'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet[0]);\n\
    \    alphabet.push(alphabet[1]);\n    alphabet.push(alphabet[2]);\n    alphabet.push(alphabet[3]);\n\
    \    alphabet.push(alphabet[4]);\n    alphabet.push(alphabet[5]);\n    alphabet.push(alphabet[6]);\n\
    \    alphabet.push(alphabet[7]);\n    alphabet.push(alphabet[8]);\n    alphabet.push(alphabet[9]);\n\
    \    alphabet.push(alphabet[10]);\n    alphabet.push(alphabet[11]);\n    alphabet.push(alphabet[12]);\n\
    \    alphabet.push(alphabet[13]);\n    alphabet.push(alphabet[14]);\n    alphabet.push(alphabet[15]);\n\
    \    alphabet.push(alphabet[16]);\n    alphabet.push(alphabet[17]);\n    alphabet.push(alphabet[18]);\n\
    \    alphabet.push(alphabet[19]);\n    alphabet.push(alphabet[20]);\n    alphabet.push(alphabet[21]);\n\
    \    alphabet.push(alphabet[22]);\n    alphabet.push(alphabet[23]);\n    alphabet.push(alphabet[24]);\n\
    \    alphabet.push(alphabet[25]);\n    alphabet.push(alphabet[26]);\n    alphabet.push(alphabet[27]);\n\
    \    alphabet.push(alphabet[28]);\n    alphabet.push(alphabet[29]);\n    alphabet.push(alphabet[30]);\n\
    \    alphabet.push(alphabet[31]);\n    alphabet.push(alphabet[32]);\n    alphabet.push(alphabet[33]);\n\
    \    alphabet.push(alphabet[34]);\n    alphabet.push(alphabet[35]);\n    alphabet.push(alphabet[36]);\n\
    \    alphabet.push(alphabet[37]);\n    alphabet.push(alphabet[38]);\n    alphabet.push(alphabet[39]);\n\
    \    alphabet.push(alphabet[40]);\n    alphabet.push(alphabet[41]);\n    alphabet.push(alphabet[42]);\n\
    \    alphabet.push(alphabet[43]);\n    alphabet.push(alphabet[44]);\n    alphabet.push(alphabet[45]);\n\
    \    alphabet.push(alphabet[46]);\n    alphabet.push(alphabet[47]);\n    alphabet.push(alphabet[48]);\n\
    \    alphabet.push(alphabet[49]);\n    alphabet.push(alphabet[50]);\n    alphabet.push(alphabet[51]);\n\
    \    alphabet.push(alphabet[5\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp5l5r1str.rs:69:27\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n69 |     alphabet.push(alphabet[5\n\
    \   |                           ^ unclosed delimiter\n70 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5l5r1str.rs:69:5\n\
    \   |\n14 |   fn encrypt(s: String) -> String {\n   |                        \
    \    ------ expected `String` because of return type\n...\n69 | /     alphabet.push(alphabet[5\n\
    70 | | }\n   | |_^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<char>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpw61ruj0u.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw61ruj0u.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw61ruj0u.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw61ruj0u.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw61ruj0u.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw61ruj0u.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw61ruj0u.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw61ruj0u.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw61ruj0u.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
  timestamp: 1659748215
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<char>>();\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push((alphabet.last() + 2)\
    \ % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % 26);\n    alphabet.push((alphabet.last() + 2) % 26);\n    alphabet.push((alphabet.last()\
    \ + 2) % \n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpzjvnyl17.rs:51:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n51 |     alphabet.push((alphabet.last()\
    \ + 2) % \n   |                  ^ unclosed delimiter\n52 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: expected expression, found `)`\n  --> /tmp/tmpzjvnyl17.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzjvnyl17.rs:16:19\n   |\n16 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<&char>`\n  --> /tmp/tmpzjvnyl17.rs:17:36\n\
    \   |\n17 |     alphabet.push((alphabet.last() + 2) % 26);\n   |             \
    \       --------------- ^ - {integer}\n   |                    |\n   |       \
    \             Option<&char>\n\nerror[E0369]: cannot add `{integer}` to `Option<&char>`\n\
    \  --> /tmp/tmpzjvnyl17.rs:18:36\n   |\n18 |     alphabet.push((alphabet.last()\
    \ + 2) % 26);\n   |                    --------------- ^ - {integer}\n   |   \
    \                 |\n   |                    Option<&char>\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<&char>`\n  --> /tmp/tmpzjvnyl17.rs:19:36\n   |\n\
    19 |     alphabet.push((alphabet.last() + 2) % 26);\n   |                    ---------------\
    \ ^ - {integer}\n   |                    |\n   |                    Option<&char>\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<&char>`\n  --> /tmp/tmpzjvnyl17.rs:20:36\n\
    \   |\n20 |     alphabet.push((alphabet.last() + 2) % 26);\n   |             \
    \       --------------- ^ - {integer}\n   |                    |\n   |       \
    \             Option<&char>\n\nerror[E0369]: cannot add `{integer}` to `Option<&char>`\n\
    \  --> /tmp/tmpzjvnyl17.rs:21:36\n   |\n21 |     alphabet.push((alphabet.last()\
    \ + 2) % 26);\n   |                    --------------- ^ - {integer}\n   |   \
    \                 |\n   |                    Option<&char>\n\nerror[E0369]: cann"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c.to_ascii_lowercase());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpant9gajd.rs:65:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n65 |     alphabet.push(\n\
    \   |                  ^ unclosed delimiter\n66 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0599]: no method named `push` found for struct `Map` in\
    \ the current scope\n  --> /tmp/tmpant9gajd.rs:16:14\n   |\n16 |     alphabet.push(alphabet.last().unwrap());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmpant9gajd.rs:15:38:\
    \ 15:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpant9gajd.rs:17:14\n   |\n17 |     alphabet.push(alphabet.last().unwrap());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmpant9gajd.rs:15:38:\
    \ 15:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpant9gajd.rs:18:14\n   |\n18 |     alphabet.push(alphabet.last().unwrap());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmpant9gajd.rs:15:38:\
    \ 15:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpant9gajd.rs:19:14\n   |\n19 |     alphabet.push(alphabet.last().unwrap());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmpant9gajd.rs:15:38:\
    \ 15:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpant9gajd.rs:20:14\n   |\n20 |     alphabet.push(alphabet.last().unwrap());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmpant9gajd.rs:15:38:\
    \ 15:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpant9gajd.rs:21:14\n   |\n21 |     alphabet.push(alphabet.last().unwrap());\n\
    \   |              ^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmpant9gajd.rs:15:38:\
    \ 15:64]>`\n\nerror[E0599]: no method named `push` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmpan"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:18:19\n \
    \  |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:20:19\n\
    \   |\n20 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:21:19\n\
    \   |\n21 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:22:19\n\
    \   |\n22 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:23:19\n\
    \   |\n23 |     alphabet.push(alphabet.last"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    let mut cipher = Cipher::new(alphabet);\n    cipher.encrypt(&s);\n    cipher.to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpnyvb22t_.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Cipher`\n  --> /tmp/tmpnyvb22t_.rs:17:22\n\
    \   |\n17 |     let mut cipher = Cipher::new(alphabet);\n   |                \
    \      ^^^^^^ use of undeclared type `Cipher`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c as char).collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c as char).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&char` as `char` is invalid\n  --> /tmp/tmpur4_yjkj.rs:17:29\n\
    \   |\n17 |     alphabet.iter().map(|c| c as char).collect::<String>()\n   | \
    \                            ^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.sort_unstable();\n    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpp94_sg3m.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(\n}\n\nfn main() {\n   \
    \ let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpiljigk2w.rs:67:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n67 |     alphabet.push(\n\
    \   |                  ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiljigk2w.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `&str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n\
    \                   found enum `Option<&&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiljigk2w.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `&str`, found enum `Option`\n\
    \   |\n   = note: expected reference `&str`\n                   found enum `Option<&&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiljigk2w.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `&str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n\
    \                   found enum `Option<&&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiljigk2w.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `&str`, found enum `Option`\n\
    \   |\n   = note: expected reference `&str`\n                   found enum `Option<&&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiljigk2w.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `&str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n\
    \                   found enum `Option<&&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiljigk2w.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `&str`, found enum `Option`\n\
    \   |\n   = note: expected reference `&str`\n                   found enum `Option<&&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiljigk2w.rs:23:19\n   |\n23 |\
    \     alphabet.push("
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.iter().for_each(|c| s.chars().next().unwrap().push(alphabet.iter().find(|c|\
    \ c == c).unwrap()));\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpiy9n1eeu.rs:18:60\n   |\n18 |     alphabet.iter().for_each(|c|\
    \ s.chars().next().unwrap().push(alphabet.iter().find(|c| c == c).unwrap()));\n\
    \   |                                                            ^^^^ method not\
    \ found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa3s22_ix.rs:47:21\n   |\n\
    47 |     let mut alphabet\n   |                     ^ help: add `;` here\n48 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa3s22_ix.rs:14:26\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.to_owned()\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd6slto9o.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd6slto9o.rs:18:19\n   |\n18 |     alphabet.push(alphabet.first());\n\
    \   |                   ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd6slto9o.rs:19:5\n   |\n14 | fn\
    \ encrypt(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n...\n19 |     alphabet.to_owned()\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n  \
    \ = note: expected struct `String`\n              found struct `Vec<char>`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c as char).collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c as char).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&char` as `char` is invalid\n  --> /tmp/tmpur4_yjkj.rs:17:29\n\
    \   |\n17 |     alphabet.iter().map(|c| c as char).collect::<String>()\n   | \
    \                            ^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found enum `Option`\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n                found enum `Option<&std::ops::Range<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgarg8lp_.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |               "
  stdout: ''
  timestamp: 1659748215
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().for_each(|c| {\n        if\
    \ c < 'a' || c > 'z' {\n            alphabet.push(c);\n        }\n    });\n  \
    \  String::from(alphabet)\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu1c87m_k.rs:18:16\n   |\n\
    18 |         if c < 'a' || c > 'z' {\n   |                ^^^\n   |          \
    \      |\n   |                expected `&char`, found `char`\n   |           \
    \     help: consider borrowing here: `&'a'`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu1c87m_k.rs:18:27\n   |\n18 |         if c < 'a' || c > 'z' {\n\
    \   |                           ^^^\n   |                           |\n   |  \
    \                         expected `&char`, found `char`\n   |               \
    \            help: consider borrowing here: `&'z'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu1c87m_k.rs:19:27\n   |\n19 |             alphabet.push(c);\n\
    \   |                           ^ expected `char`, found `&char`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n19 |             alphabet.push(*c);\n\
    \   |                           +\n\nerror[E0277]: the trait bound `String: From<Vec<char>>`\
    \ is not satisfied\n   --> /tmp/tmpu1c87m_k.rs:22:5\n    |\n22  |     String::from(alphabet)\n\
    \    |     ^^^^^^^^^^^^ the trait `From<Vec<char>>` is not implemented for `String`\n\
    \    |\n    = help: the following implementations were found:\n              <String\
    \ as From<&String>>\n              <String as From<&mut str>>\n              <String\
    \ as From<&str>>\n              <String as From<Box<str>>>\n            and 2\
    \ others\nnote: required by `from`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().for_each(|c| {\n        if\
    \ *c >= 'a' && *c <= 'z' {\n            *c += 2\n        }\n    })\n    .collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmp4fpbx3np.rs:19:13\n   |\n19 |             *c += 2\n  \
    \ |             --^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `char`\n\nerror[E0599]: the method `collect` exists for unit type `()`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp4fpbx3np.rs:22:6\n  \
    \ |\n22 |     .collect::<String>()\n   |      ^^^^^^^ method cannot be called\
    \ on `()` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0368, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['z', 'y', 'x', 'w', 'v', 'u',\
    \ 't', 's', 'r', 'q', 'p', 'o', 'n', 'm', 'l', 'k', 'j', 'h', 'g', 'f', 'e', 'd',\
    \ 'c', 'b', 'a'];\n    alphabet.rotate_left(2);\n    let mut result = String::new();\n\
    \    for c in s.chars() {\n        result.push(alphabet[alphabet.index(c) + 1]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp5k8vu3zp.rs:19:39\n   |\n19 |         result.push(alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                       ^^^^^ method not found in\
    \ `Vec<char>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c as char).collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c as char).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&char` as `char` is invalid\n  --> /tmp/tmpur4_yjkj.rs:17:29\n\
    \   |\n17 |     alphabet.iter().map(|c| c as char).collect::<String>()\n   | \
    \                            ^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.first());\n\
    \    alphabet.to_owned()\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd6slto9o.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpd6slto9o.rs:18:19\n   |\n18 |     alphabet.push(alphabet.first());\n\
    \   |                   ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd6slto9o.rs:19:5\n   |\n14 | fn\
    \ encrypt(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n...\n19 |     alphabet.to_owned()\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n  \
    \ = note: expected struct `String`\n              found struct `Vec<char>`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<char>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp3rch58yr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphab\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp4zkk4ez4.rs:67:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n67 |     alphabet.push(alphab\n\
    \   |                  ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0425]: cannot find value `alphab` in this scope\n  --> /tmp/tmp4zkk4ez4.rs:67:19\n\
    \   |\n67 |     alphabet.push(alphab\n   |                   ^^^^^^ help: a local\
    \ variable with a similar name exists: `alphabet`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4zkk4ez4.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4zkk4ez4.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4zkk4ez4.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4zkk4ez4.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4zkk4ez4.rs:21:19\n   |\n21 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4zkk4ez4.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   ="
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(\n}\n\nfn main() {\n   \
    \ let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpiljigk2w.rs:67:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n67 |     alphabet.push(\n\
    \   |                  ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiljigk2w.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `&str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n\
    \                   found enum `Option<&&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiljigk2w.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `&str`, found enum `Option`\n\
    \   |\n   = note: expected reference `&str`\n                   found enum `Option<&&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiljigk2w.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `&str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n\
    \                   found enum `Option<&&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiljigk2w.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `&str`, found enum `Option`\n\
    \   |\n   = note: expected reference `&str`\n                   found enum `Option<&&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiljigk2w.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `&str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n\
    \                   found enum `Option<&&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpiljigk2w.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `&str`, found enum `Option`\n\
    \   |\n   = note: expected reference `&str`\n                   found enum `Option<&&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiljigk2w.rs:23:19\n   |\n23 |\
    \     alphabet.push("
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    alphabet.rotate_left(2);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:17:19\n   |\n\
    17 |     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:18:19\n   |\n18 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:19:19\n   |\n19 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:20:19\n   |\n20 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:21:19\n   |\n21 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:22:19\n   |\n22 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:23:19\n   |\n23 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:24:19\n   |\n24 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:25:19\n   |\n25 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:26:19\n   |\n26 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:27:19\n   |\n27 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:28:19\n   |\n28 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:29:19\n   |\n29 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:30:19\n   |\n30 |\
    \     alphabet.push(0);\n   |            "
  stdout: ''
  timestamp: 1659748215
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    alphabet.rotate_left(2);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:17:19\n   |\n\
    17 |     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:18:19\n   |\n18 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:19:19\n   |\n19 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:20:19\n   |\n20 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:21:19\n   |\n21 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:22:19\n   |\n22 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:23:19\n   |\n23 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:24:19\n   |\n24 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:25:19\n   |\n25 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:26:19\n   |\n26 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:27:19\n   |\n27 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:28:19\n   |\n28 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:29:19\n   |\n29 |\
    \     alphabet.push(0);\n   |                   ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt7fn9a2.rs:30:19\n   |\n30 |\
    \     alphabet.push(0);\n   |            "
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:18:19\n \
    \  |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:20:19\n\
    \   |\n20 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:21:19\n\
    \   |\n21 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:22:19\n\
    \   |\n22 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:23:19\n\
    \   |\n23 |     alphabet.push(alphabet.last"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().for_each(|c| c.to_ascii_lowercase());\n\
    \    String::from_iter(alphabet)\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp12mj6jdt.rs:17:34\n   |\n\
    17 |     alphabet.iter().for_each(|c| c.to_ascii_lowercase());\n   |         \
    \                         ^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found `char`\n\
    \nerror[E0599]: no function or associated item named `from_iter` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp12mj6jdt.rs:18:13\n   |\n18 | \
    \    String::from_iter(alphabet)\n   |             ^^^^^^^^^ function or associated\
    \ item not found in `String`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n\
    \   |\nhelp: there is an associated function with a similar name\n   |\n18 | \
    \    String::from_utf8(alphabet)\n   |             ~~~~~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c as char).collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c as char).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&char` as `char` is invalid\n  --> /tmp/tmpur4_yjkj.rs:17:29\n\
    \   |\n17 |     alphabet.iter().map(|c| c as char).collect::<String>()\n   | \
    \                            ^^^^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.sort_unstable();\n    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpp94_sg3m.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    let mut result = String::new();\n    for c in s.chars() {\n        result.push_str(&alphabet[alphabet.index(c)\
    \ + 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for struct `Vec<&str>` in the\
    \ current scope\n  --> /tmp/tmpcudyysme.rs:20:44\n   |\n20 |         result.push_str(&alphabet[alphabet.index(c)\
    \ + 1]);\n   |                                            ^^^^^ method not found\
    \ in `Vec<&str>`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['z' - 1, 'a' - 1, 'b' - 1,\
    \ 'c' - 1, 'd' - 1, 'e' - 1, 'f' - 1, 'g' - 1, 'h' - 1, 'i' - 1, 'j' - 1, 'k'\
    \ - 1, 'l' - 1, 'm' - 1, 'n' - 1, 'o' - 1, 'p' - 1, 'q' - 1, 'r' - 1, 's' - 1,\
    \ 't' - 1, 'u' - 1, 'v' - 1, 'w' - 1, 'x' - 1, 'y' - 1, 'z' - 1];\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n    alphabet.push(0);\n\
    \    alphabet.push(0);\n    \n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpkzn9g6zy.rs:15:33\n\
    \   |\n15 |     let mut alphabet = vec!['z' - 1, 'a' - 1, 'b' - 1, 'c' - 1, 'd'\
    \ - 1, 'e' - 1, 'f' - 1, 'g' - 1, 'h' - 1, 'i' - 1, 'j' - 1, 'k' - 1, '...\n \
    \  |                             --- ^ - {integer}\n   |                     \
    \        |\n   |                             char\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `char`\n  --> /tmp/tmpkzn9g6zy.rs:15:42\n   |\n15 |     let\
    \ mut alphabet = vec!['z' - 1, 'a' - 1, 'b' - 1, 'c' - 1, 'd' - 1, 'e' - 1, 'f'\
    \ - 1, 'g' - 1, 'h' - 1, 'i' - 1, 'j' - 1, 'k' - 1, '...\n   |               \
    \                       --- ^ - {integer}\n   |                              \
    \        |\n   |                                      char\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `char`\n  --> /tmp/tmpkzn9g6zy.rs:15:51\n   |\n15\
    \ |     let mut alphabet = vec!['z' - 1, 'a' - 1, 'b' - 1, 'c' - 1, 'd' - 1, 'e'\
    \ - 1, 'f' - 1, 'g' - 1, 'h' - 1, 'i' - 1, 'j' - 1, 'k' - 1, '...\n   |      \
    \                                         --- ^ - {integer}\n   |            \
    \                                   |\n   |                                  \
    \             char\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n\
    \  --> /tmp/tmpkzn9g6zy.rs:15:60\n   |\n15 |     let mut alphabet = vec!['z' -\
    \ 1, 'a' - 1, 'b' - 1, 'c' - 1, 'd' - 1, 'e' - 1, 'f' - 1, 'g' - 1, 'h' - 1, 'i'\
    \ - 1, 'j' - 1, 'k' - 1, '...\n   |                                          \
    \              --- ^ - {integer}\n   |                                       \
    \                 |\n   |                                                    \
    \    char\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpkzn9g6zy.rs:15:69\n\
    \   |\n15 |     let mut alphabet = vec!['z' - 1, 'a' - 1, 'b' - 1, 'c' - 1, 'd'\
    \ - 1, 'e' - 1, 'f' - 1, 'g' - 1, 'h' - 1, 'i' - 1, 'j' - 1, 'k' - 1, '...\n \
    \  |                                                                 --- ^ - {integer}\n\
    \   |                                                                 |\n   |\
    \                                       "
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>();\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    \n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:16:19\n   |\n\
    16 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:21:19\n   |\n21 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsq3j2ucu.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsq3j2ucu.rs:23:19\n   |\n23 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note:"
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c ^ 0x20).collect::<Vec<_>>();\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(0x20);\n    alphabet.push(0x20);\n    alphabet.push(0x20);\n\
    \    alphabet.push(\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp1lqe87xv.rs:85:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n85 |     alphabet.push(\n\
    \   |                  ^ unclosed delimiter\n86 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0369]: no implementation for `char ^ {integer}`\n  --> /tmp/tmp1lqe87xv.rs:15:44\n\
    \   |\n15 |     let mut alphabet = s.chars().map(|c| c ^ 0x20).collect::<Vec<_>>();\n\
    \   |                                          - ^ ---- {integer}\n   |      \
    \                                    |\n   |                                 \
    \         char\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmp1lqe87xv.rs:85:14\n     |\n85   |     alphabet.push(\n\
    \     |              ^^^^- supplied 0 arguments\n     |              |\n     |\
    \              expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1lqe87xv.rs:85:5\n   |\n\
    14 |   fn encrypt(s: String) -> String {\n   |                            ------\
    \ expected `String` because of return type\n...\n85 | /     alphabet.push(\n86\
    \ | | }\n   | |_^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet = alphabet.iter().cloned().collect::<Vec<_>>();\n\
    \    alphabet.swap_remove(alphabet.len() - 1);\n    let mut alphabet\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa3s22_ix.rs:47:21\n   |\n\
    47 |     let mut alphabet\n   |                     ^ help: add `;` here\n48 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa3s22_ix.rs:14:26\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<char>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmprcbly6xm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<char>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmprcbly6xm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp8fdmh62j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().cloned().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp6et0718c.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp3p2nle1x.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_left(2);\n\
    \    let mut cipher = Cipher::new(alphabet);\n    cipher.encrypt(&s);\n    cipher.to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpnyvb22t_.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Cipher`\n  --> /tmp/tmpnyvb22t_.rs:17:22\n\
    \   |\n17 |     let mut cipher = Cipher::new(alphabet);\n   |                \
    \      ^^^^^^ use of undeclared type `Cipher`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748213
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n    alphabet.rotate_left(2);\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmped7q3wrh.rs:14:26\n   |\n\
    14 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A'..'Z'];\n    alphabet.rotate_left(2);\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    \n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl0h2vyyt.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found reference\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n           found reference `&std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl0h2vyyt.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found reference\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n           found reference `&std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl0h2vyyt.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found reference\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n           found reference `&std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl0h2vyyt.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found reference\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n           found reference `&std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl0h2vyyt.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found reference\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n           found reference `&std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl0h2vyyt.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found reference\n   |\n   = note: expected\
    \ struct `std::ops::Range<char>`\n           found reference `&std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl0h2vyyt.rs:23:19\n   |\n23 |\
    \     alphabet.push(a"
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmppebi7f07.rs:62:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n62 |     alphabet.push(\n\
    \   |                  ^ unclosed delimiter\n63 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0061]: this function takes 1 argument but 0 arguments were\
    \ supplied\n    --> /tmp/tmppebi7f07.rs:62:14\n     |\n62   |     alphabet.push(\n\
    \     |              ^^^^- supplied 0 arguments\n     |              |\n     |\
    \              expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppebi7f07.rs:62:5\n   |\n\
    14 |   fn encrypt(s: String) -> String {\n   |                            ------\
    \ expected `String` because of return type\n...\n62 | /     alphabet.push(\n63\
    \ | | }\n   | |_^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748214
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    \    alphabet.push(alphabet.last().unwrap());\n    alphabet.push(alphabet.last().unwrap());\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:17:19\n   |\n\
    17 |     alphabet.push(alphabet.last().unwrap());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |     alphabet.push(*alphabet.last().unwrap());\n   |              \
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:18:19\n \
    \  |\n18 |     alphabet.push(alphabet.last().unwrap());\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:19:19\n\
    \   |\n19 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:20:19\n\
    \   |\n20 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:21:19\n\
    \   |\n21 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:22:19\n\
    \   |\n22 |     alphabet.push(alphabet.last().unwrap());\n   |               \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     alphabet.push(*alphabet.last().unwrap());\n\
    \   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_37hdco.rs:23:19\n\
    \   |\n23 |     alphabet.push(alphabet.last"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphab\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp4zkk4ez4.rs:67:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n67 |     alphabet.push(alphab\n\
    \   |                  ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0425]: cannot find value `alphab` in this scope\n  --> /tmp/tmp4zkk4ez4.rs:67:19\n\
    \   |\n67 |     alphabet.push(alphab\n   |                   ^^^^^^ help: a local\
    \ variable with a similar name exists: `alphabet`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4zkk4ez4.rs:17:19\n   |\n17 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4zkk4ez4.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4zkk4ez4.rs:19:19\n   |\n19 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4zkk4ez4.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4zkk4ez4.rs:21:19\n   |\n21 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4zkk4ez4.rs:22:19\n   |\n22 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   ="
  stdout: ''
  timestamp: 1659748215
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.iter().map(|c| c.to_string()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpgnctr2jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone());\n\
    \    alphabet.push(alphabet.clone());\n    alphabet.push(alphabet.clone\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpzs07ucvg.rs:70:18\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n70 |     alphabet.push(alphabet.clone\n\
    \   |                  ^ unclosed delimiter\n71 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzs07ucvg.rs:16:19\n\
    \   |\n16 |     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzs07ucvg.rs:17:19\n   |\n17 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzs07ucvg.rs:18:19\n   |\n18 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzs07ucvg.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzs07ucvg.rs:20:19\n   |\n20 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct `std::ops::Range`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `std::ops::Range<_>`\n              found struct `Vec<std::ops::Range<_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzs07ucvg.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.clone());\n   |                   ^^^^^^^^^^^^^^^^\
    \ expected struct "
  stdout: ''
  timestamp: 1659748215
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(2);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpsxgzd7_v.rs:72:1\n   |\n72\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:17:19\n\
    \   |\n17 |     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:18:19\n   |\n18 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:19:19\n   |\n19 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:20:19\n   |\n20 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:21:19\n   |\n21 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:22:19\n   |\n22 |     alphabet.push(alphabet.last());\n\
    \   |                   ^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsxgzd7_v.rs:23:19\n   |\n23 |\
    \     alphabet.push(alphabet.last());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<&char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsxgzd7_v.rs:24:19\n   |\n24 |     alphabet.push(alphabet.last());\n\
    \   |       "
  stdout: ''
