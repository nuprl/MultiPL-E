language: rs
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, _)| k.is_lowercase()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspl596xz.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for k in dict.keys() {\n        if k.len() != 1 {\n     \
    \       return false;\n        }\n    }\n    for k in dict.keys() {\n        if\
    \ k.len() != 1 {\n            return false;\n        }\n        if k.to_lowercase()\
    \ != k.to_uppercase() {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8ke_dqw0.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n            Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n            Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n            _ => false,\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n21 |             Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:22:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n22 |             Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n   |             ^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.to_lowercase() == key {\n            true\n        } else {\n \
    \           false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpawrs0snr.rs:19:31\n\
    \   |\n19 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.to_lowercase() == key {\n            true\n        } else {\n \
    \           false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpawrs0snr.rs:19:31\n\
    \   |\n19 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpodiku0ay.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => true,\n        _ => dict.values().iter().all(|s| s.is_lowercase()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::collections::hash_map::Values`\
    \ in the current scope\n  --> /tmp/tmpdyjjg3ig.rs:21:28\n   |\n21 |         _\
    \ => dict.values().iter().all(|s| s.is_lowercase()),\n   |                   \
    \         ^^^^ method not found in `std::collections::hash_map::Values<'_, String,\
    \ String>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     match value.to_lowercase() {\n            Some(value) => true,\n       \
    \     None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa8r15dfp.rs:20:13\n   |\n\
    19 |         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n20 |             Some(value) => true,\n \
    \  |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n \
    \  |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa8r15dfp.rs:21:13\n   |\n19 |\
    \         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n20 |             Some(value) => true,\n21\
    \ |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, _)| k.is_lowercase()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspl596xz.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       let mut key = key.to_lowercase();\n        let mut value = value.to_lowercase();\n\
    \        key == value || key.to_uppercase() == value\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4g6f9hl9.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, _)| k.is_lowercase()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspl596xz.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n21 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmpxnl2hkgy.rs:21:42\n   |\n\
    21 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if let Some(key) = key.to_lowercase() {\n            true\n        } else\
    \ if let Some(key) = key.to_uppercase() {\n            true\n        } else {\n\
    \            false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkx36ec5k.rs:19:16\n   |\n\
    19 |         if let Some(key) = key.to_lowercase() {\n   |                ^^^^^^^^^\
    \   ------------------ this expression has type `String`\n   |               \
    \ |\n   |                expected struct `String`, found enum `Option`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkx36ec5k.rs:21:23\n   |\n21 |\
    \         } else if let Some(key) = key.to_uppercase() {\n   |               \
    \        ^^^^^^^^^   ------------------ this expression has type `String`\n  \
    \ |                       |\n   |                       expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n            None => false,\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxe6pj37.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n   |             ^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxe6pj37.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n21 |             None => false,\n   |             ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys();\n    while let Some(key) = keys.next()\
    \ {\n        if key.to_lowercase() == key {\n            continue;\n        }\n\
    \        if key.to_uppercase() == key {\n            continue;\n        }\n  \
    \      return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp9pvzjxq1.rs:23:31\n\
    \   |\n23 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmp9pvzjxq1.rs:26:31\n   |\n\
    26 |         if key.to_uppercase() == key {\n   |                            \
    \   ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, _)| k.is_lowercase()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspl596xz.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n21 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmpxnl2hkgy.rs:21:42\n   |\n\
    21 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     let mut lower = String::new();\n        let mut upper = String::new();\n\
    \        value.chars().for_each(|c| {\n            match c {\n               \
    \ 'A' => {\n                    lower = String::from(c.to_string());\n       \
    \         }\n                'a' => {\n                    lower = String::from(c.to_string());\n\
    \                }\n                'B' => {\n                    upper = String::from(c.to_string());\n\
    \                }\n                'b' => {\n                    upper = String::from(c.to_string());\n\
    \                }\n                _ => {}\n            }\n        });\n    \
    \    lower == upper\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpov9xfnyl.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys();\n    while let Some(key) = keys.next()\
    \ {\n        if key.to_lowercase() == key {\n            continue;\n        }\n\
    \        if key.to_uppercase() == key {\n            continue;\n        }\n  \
    \      return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp54nhbf69.rs:23:31\n\
    \   |\n23 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmp54nhbf69.rs:26:31\n   |\n\
    26 |         if key.to_uppercase() == key {\n   |                            \
    \   ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.to_lowercase() == key {\n            true\n        } else {\n \
    \           false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpawrs0snr.rs:19:31\n\
    \   |\n19 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8o3qz87c.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     let mut lower = value.to_lowercase();\n        let mut upper = value.to_uppercase();\n\
    \        lower.chars().all(|c| !c.is_ascii_lowercase());\n        upper.chars().all(|c|\
    \ !c.is_ascii_uppercase());\n        lower == upper\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpye20zxot.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpinmqtwy1.rs:18:52\n   |\n18 |     !dict.is_empty()\
    \ && dict.iter().all(|(_, v)| v.is_lowercase() || v.is_uppercase())\n   |    \
    \                                                ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no\
    \ method named `is_uppercase` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpinmqtwy1.rs:18:72\n   |\n18 |     !dict.is_empty() && dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                                            ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfmvlzhaj.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(_, v)| v.is_lowercase() || v.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(key_lower) => key_lower ==\
    \ value,\n            None => false,\n        }\n    })\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdvhvnb88.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => key_lower\
    \ == value,\n   |             ^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdvhvnb88.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => key_lower\
    \ == value,\n21 |             None => false,\n   |             ^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.to_lowercase() == key {\n            true\n        } else {\n \
    \           false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpawrs0snr.rs:19:31\n\
    \   |\n19 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n            None => false,\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxe6pj37.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n   |             ^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxe6pj37.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n21 |             None => false,\n   |             ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.len() != value.len() {\n            return false;\n        }\n\
    \        key.chars().all(|c| c >= 'a' && c <= 'z')\n            || key.chars().all(|c|\
    \ c >= 'A' && c <= 'Z')\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp32e1tsvu.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, _)| key.to_lowercase()\
    \ == key)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpf0693or9.rs:18:51\n\
    \   |\n18 |     dict.iter().all(|(key, _)| key.to_lowercase() == key)\n   |  \
    \                                                 ^^ no implementation for `String\
    \ == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n            None => false,\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxe6pj37.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n   |             ^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxe6pj37.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n21 |             None => false,\n   |             ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            None => false,\n            Some(lower)\
    \ => value == lower,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprr7igls1.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprr7igls1.rs:21:13\n   |\n19 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n20 |             None => false,\n21 |             Some(lower)\
    \ => value == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, _)| k.is_lowercase()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspl596xz.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       key.to_lowercase() == value.to_lowercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4fhcmjca.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n21 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmpxnl2hkgy.rs:21:42\n   |\n\
    21 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       let mut lower = String::new();\n        let mut upper = String::new();\n\
    \        key.to_lowercase(&mut lower);\n        value.to_uppercase(&mut upper);\n\
    \        lower == upper\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpo5wcdzbx.rs:21:13\n    |\n21  |         key.to_lowercase(&mut\
    \ lower);\n    |             ^^^^^^^^^^^^ ---------- supplied 1 argument\n   \
    \ |             |\n    |             expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmpo5wcdzbx.rs:22:15\n    |\n22  |      \
    \   value.to_uppercase(&mut upper);\n    |               ^^^^^^^^^^^^ ----------\
    \ supplied 1 argument\n    |               |\n    |               expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     match value.to_lowercase() {\n            Some(value) => true,\n       \
    \     None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa8r15dfp.rs:20:13\n   |\n\
    19 |         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n20 |             Some(value) => true,\n \
    \  |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n \
    \  |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa8r15dfp.rs:21:13\n   |\n19 |\
    \         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n20 |             Some(value) => true,\n21\
    \ |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys().collect::<Vec<_>>();\n    let\
    \ mut keys_lower = keys.iter().map(|&key| key.to_lowercase()).collect::<Vec<_>>();\n\
    \    let mut keys_upper = keys.iter().map(|&key| key.to_uppercase()).collect::<Vec<_>>();\n\
    \    let mut keys_diff = keys_lower - keys_upper;\n    if keys_diff.is_empty()\
    \ {\n        return true;\n    }\n    let mut keys_diff_lower = keys_diff.iter().map(|&key|\
    \ key.to_lowercase()).collect::<Vec<_>>();\n    let mut keys_diff_upper = keys_diff.iter().map(|&key|\
    \ key.to_uppercase()).collect::<Vec<_>>();\n    let mut keys_diff_diff = keys_diff_lower\
    \ - keys_diff_upper;\n    if keys_diff_diff.is_empty() {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `Vec<String>` from `Vec<String>`\n  --> /tmp/tmpg61mpptg.rs:24:36\n\
    \   |\n24 |     let mut keys_diff = keys_lower - keys_upper;\n   |           \
    \              ---------- ^ ---------- Vec<String>\n   |                     \
    \    |\n   |                         Vec<String>\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n21 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmpxnl2hkgy.rs:21:42\n   |\n\
    21 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       key.to_lowercase() == value.to_lowercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4fhcmjca.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => value == key.to_uppercase(),\n        }\n    })\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsbwt4bjh.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsbwt4bjh.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => value == key.to_uppercase(),\n   |             ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror[E0277]: can't compare `&String`\
    \ with `String`\n  --> /tmp/tmpsbwt4bjh.rs:21:27\n   |\n21 |             None\
    \ => value == key.to_uppercase(),\n   |                           ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.is_lowercase() {\n            true\n        } else if key.is_uppercase()\
    \ {\n            true\n        } else {\n            false\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpkh94oow4.rs:19:16\n   |\n19 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpkh94oow4.rs:21:23\n\
    \   |\n21 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys();\n    let mut keys_iter = keys.iter();\n\
    \    let mut current_key = keys_iter.next();\n    let mut current_value = current_key.clone();\n\
    \    while current_key != None {\n        if current_key.clone() != current_value.clone()\
    \ {\n            return false;\n        }\n        current_key = keys_iter.next();\n\
    \        current_value = current_key.clone();\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::collections::hash_map::Keys`\
    \ in the current scope\n  --> /tmp/tmpf11bsxdk.rs:22:30\n   |\n22 |     let mut\
    \ keys_iter = keys.iter();\n   |                              ^^^^ method not\
    \ found in `std::collections::hash_map::Keys<'_, String, String>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lower = true;\n    let mut upper = true;\n    for\
    \ (_, val) in dict.iter() {\n        if !val.to_lowercase().is_ok() {\n      \
    \      lower = false;\n        }\n        if !val.to_uppercase().is_ok() {\n \
    \           upper = false;\n        }\n    }\n    lower && upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ok` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpxpp8ykfu.rs:24:32\n   |\n24 |         if !val.to_lowercase().is_ok()\
    \ {\n   |                                ^^^^^ method not found in `String`\n\n\
    error[E0599]: no method named `is_ok` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpxpp8ykfu.rs:27:32\n   |\n27 |         if !val.to_uppercase().is_ok()\
    \ {\n   |                                ^^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            None => false,\n            Some(lower)\
    \ => value == lower,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprr7igls1.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprr7igls1.rs:21:13\n   |\n19 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n20 |             None => false,\n21 |             Some(lower)\
    \ => value == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys().collect::<Vec<_>>();\n    let\
    \ mut keys_lower = keys.iter().map(|key| key.to_lowercase()).collect::<Vec<_>>();\n\
    \    let mut keys_upper = keys.iter().map(|key| key.to_uppercase()).collect::<Vec<_>>();\n\
    \    keys_lower.sort();\n    keys_upper.sort();\n    if keys_lower == keys_upper\
    \ {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1yfmmn5l.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n            Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n            Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n            Some(\"state\") => value.to_lowercase()\
    \ == String::from(\"nc\"),\n            Some(\"zip\") => value.to_lowercase()\
    \ == String::from(\"12345\"),\n            _ => false,\n        }\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr4fwwoqh.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr4fwwoqh.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n21 |             Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr4fwwoqh.rs:22:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n22 |             Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n   |             ^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpr4fwwoqh.rs:23:13\n   |\n19 |         match key.to_lowercase() {\n \
    \  |               ------------------ this expression has type `String`\n...\n\
    23 |             Some(\"state\") => value.to_lowercase() == String::from(\"nc\"\
    ),\n   |             ^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr4fwwoqh.rs:24:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n...\n24 |             Some(\"zip\") => value.to_lowercase()\
    \ == String::from(\"12345\"),\n   |             ^^^^^^^^^^^ expect"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, _)| {\n     \
    \   key.to_lowercase() == key\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpgzyh4r4m.rs:19:28\n\
    \   |\n19 |         key.to_lowercase() == key\n   |                          \
    \  ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.len() != value.len() {\n            return false\n        }\n \
    \       let mut i = 0;\n        while i < key.len() {\n            if key[i] !=\
    \ value[i] {\n                return false\n            }\n            i += 1;\n\
    \        }\n        true\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmaf9sp40.rs:24:16\n\
    \   |\n24 |             if key[i] != value[i] {\n   |                ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpmaf9sp40.rs:24:26\n   |\n24 |             if key[i]\
    \ != value[i] {\n   |                          ^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.is_lowercase() {\n            true\n        } else if key.is_uppercase()\
    \ {\n            true\n        } else {\n            false\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpkh94oow4.rs:19:16\n   |\n19 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpkh94oow4.rs:21:23\n\
    \   |\n21 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.len() > 1 && key.to_lowercase() == key {\n            false\n \
    \       } else {\n            true\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpjvc7pagj.rs:19:48\n\
    \   |\n19 |         if key.len() > 1 && key.to_lowercase() == key {\n   |    \
    \                                            ^^ no implementation for `String\
    \ == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n21 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmpxnl2hkgy.rs:21:42\n   |\n\
    21 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut iter = dict.iter();\n    let mut key_iter = iter.keys().cloned();\n\
    \    let mut value_iter = iter.values().cloned();\n    let mut first_key_is_upper\
    \ = false;\n    let mut first_value_is_upper = false;\n    loop {\n        let\
    \ key = key_iter.next().unwrap();\n        let value = value_iter.next().unwrap();\n\
    \        if first_key_is_upper {\n            if key.to_lowercase() == key {\n\
    \                first_key_is_upper = false;\n            } else {\n         \
    \       return false;\n            }\n        }\n        if first_value_is_upper\
    \ {\n            if value.to_lowercase() == value {\n                first_value_is_upper\
    \ = false;\n            } else {\n                return false;\n            }\n\
    \        }\n        if key.to_lowercase() == key {\n            first_key_is_upper\
    \ = true;\n        }\n        if value.to_lowercase() == value {\n           \
    \ first_value_is_upper = true;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `keys` found for struct `std::collections::hash_map::Iter`\
    \ in the current scope\n  --> /tmp/tmpqg2lw80i.rs:22:29\n   |\n22 |     let mut\
    \ key_iter = iter.keys().cloned();\n   |                             ^^^^ method\
    \ not found in `std::collections::hash_map::Iter<'_, String, String>`\n\nerror[E0599]:\
    \ no method named `values` found for struct `std::collections::hash_map::Iter`\
    \ in the current scope\n  --> /tmp/tmpqg2lw80i.rs:23:31\n   |\n23 |     let mut\
    \ value_iter = iter.values().cloned();\n   |                               ^^^^^^\
    \ method not found in `std::collections::hash_map::Iter<'_, String, String>`\n\
    \nwarning: unreachable expression\n  --> /tmp/tmpqg2lw80i.rs:50:5\n   |\n26 |\
    \ /     loop {\n27 | |         let key = key_iter.next().unwrap();\n28 | |   \
    \      let value = value_iter.next().unwrap();\n29 | |         if first_key_is_upper\
    \ {\n...  |\n48 | |         }\n49 | |     }\n   | |_____- any code following this\
    \ expression is unreachable\n50 |       true\n   |       ^^^^ unreachable expression\n\
    \   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n            Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n            Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n            _ => false,\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n21 |             Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:22:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n22 |             Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n   |             ^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, _)| k.is_lowercase()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspl596xz.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.len() == 1 && value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbheozlhi.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.len() == 0 {\n            return false;\n        }\n        if\
    \ key.len() == 1 && key[0] >= 'A' && key[0] <= 'Z' {\n            return true;\n\
    \        }\n        if key.len() == 1 && key[0] >= 'a' && key[0] <= 'z' {\n  \
    \          return true;\n        }\n        return false;\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpgd1hcm9a.rs:22:30\n   |\n22 |         if key.len() == 1 && key[0] >=\
    \ 'A' && key[0] <= 'Z' {\n   |                              ^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpgd1hcm9a.rs:22:47\n   |\n22 |         if key.len()\
    \ == 1 && key[0] >= 'A' && key[0] <= 'Z' {\n   |                             \
    \                  ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n  \
    \ = help: the trait `Index<{integer}>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpgd1hcm9a.rs:25:30\n\
    \   |\n25 |         if key.len() == 1 && key[0] >= 'a' && key[0] <= 'z' {\n  \
    \ |                              ^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpgd1hcm9a.rs:25:47\n\
    \   |\n25 |         if key.len() == 1 && key[0] >= 'a' && key[0] <= 'z' {\n  \
    \ |                                               ^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       key.to_lowercase() == value.to_lowercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4fhcmjca.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for entry in dict.iter() {\n        let key = entry.key().to_lowercase();\n\
    \        let value = entry.value().to_lowercase();\n        if key != value {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `key` found for tuple `(&String, &String)`\
    \ in the current scope\n  --> /tmp/tmpdq0ce_xk.rs:22:25\n   |\n22 |         let\
    \ key = entry.key().to_lowercase();\n   |                         ^^^ method not\
    \ found in `(&String, &String)`\n\nerror[E0599]: no method named `value` found\
    \ for tuple `(&String, &String)` in the current scope\n  --> /tmp/tmpdq0ce_xk.rs:23:27\n\
    \   |\n23 |         let value = entry.value().to_lowercase();\n   |          \
    \                 ^^^^^ method not found in `(&String, &String)`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            None => false,\n            Some(lower)\
    \ => value == lower,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprr7igls1.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprr7igls1.rs:21:13\n   |\n19 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n20 |             None => false,\n21 |             Some(lower)\
    \ => value == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     let value = value.to_lowercase();\n        !value.is_empty() && value.is_uppercase()\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpd8x4giih.rs:20:36\n   |\n20 |         !value.is_empty()\
    \ && value.is_uppercase()\n   |                                    ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(\"name\") => value.to_lowercase()\
    \ == Some(\"john\"),\n            Some(\"age\") => value.to_lowercase() == Some(\"\
    36\"),\n            Some(\"city\") => value.to_lowercase() == Some(\"houston\"\
    ),\n            _ => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2azv0hhf.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == Some(\"john\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2azv0hhf.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == Some(\"john\"),\n21 |             Some(\"age\") => value.to_lowercase() ==\
    \ Some(\"36\"),\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2azv0hhf.rs:22:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n22 |             Some(\"city\") => value.to_lowercase()\
    \ == Some(\"houston\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0277]: can't compare `String` with `Option<&str>`\n\
    \  --> /tmp/tmp2azv0hhf.rs:20:50\n   |\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == Some(\"john\"),\n   |                                                  ^^\
    \ no implementation for `String == Option<&str>`\n   |\n   = help: the trait `PartialEq<Option<&str>>`\
    \ is not implemented for `String`\n\nerror[E0277]: can't compare `String` with\
    \ `Option<&str>`\n  --> /tmp/tmp2azv0hhf.rs:21:49\n   |\n21 |             Some(\"\
    age\") => value.to_lowercase() == Some(\"36\"),\n   |                        \
    \                         ^^ no implementation for `String == Option<&str>`\n\
    \   |\n   = help: the trait `PartialEq<Option<&str>>` is not implemented for `String`\n\
    \nerror[E0277]: can't compare `String` with `Opt"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => true,\n        _ => dict.values().iter().all(|s| s.is_lowercase()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::collections::hash_map::Values`\
    \ in the current scope\n  --> /tmp/tmpdyjjg3ig.rs:21:28\n   |\n21 |         _\
    \ => dict.values().iter().all(|s| s.is_lowercase()),\n   |                   \
    \         ^^^^ method not found in `std::collections::hash_map::Values<'_, String,\
    \ String>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpinmqtwy1.rs:18:52\n   |\n18 |     !dict.is_empty()\
    \ && dict.iter().all(|(_, v)| v.is_lowercase() || v.is_uppercase())\n   |    \
    \                                                ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no\
    \ method named `is_uppercase` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpinmqtwy1.rs:18:72\n   |\n18 |     !dict.is_empty() && dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                                            ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => value == key.to_uppercase(),\n        }\n    })\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsbwt4bjh.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsbwt4bjh.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => value == key.to_uppercase(),\n   |             ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror[E0277]: can't compare `&String`\
    \ with `String`\n  --> /tmp/tmpsbwt4bjh.rs:21:27\n   |\n21 |             None\
    \ => value == key.to_uppercase(),\n   |                           ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => value == key.to_uppercase(),\n        }\n    })\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsbwt4bjh.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsbwt4bjh.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => value == key.to_uppercase(),\n   |             ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror[E0277]: can't compare `&String`\
    \ with `String`\n  --> /tmp/tmpsbwt4bjh.rs:21:27\n   |\n21 |             None\
    \ => value == key.to_uppercase(),\n   |                           ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, _)| k.is_lowercase()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspl596xz.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if let Ok(key) = key.to_lowercase() {\n            true\n        } else\
    \ if let Ok(key) = key.to_uppercase() {\n            true\n        } else {\n\
    \            false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphtsax_wk.rs:19:16\n   |\n\
    19 |         if let Ok(key) = key.to_lowercase() {\n   |                ^^^^^^^\
    \   ------------------ this expression has type `String`\n   |               \
    \ |\n   |                expected struct `String`, found enum `Result`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Result<_, _>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphtsax_wk.rs:21:23\n   |\n21 |\
    \         } else if let Ok(key) = key.to_uppercase() {\n   |                 \
    \      ^^^^^^^   ------------------ this expression has type `String`\n   |  \
    \                     |\n   |                       expected struct `String`,\
    \ found enum `Result`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Result<_, _>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys();\n    while let Some(key) = keys.next()\
    \ {\n        if key.to_lowercase() == key {\n            return false;\n     \
    \   }\n        if key.to_uppercase() == key {\n            return false;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp1ufa7m3q.rs:23:31\n\
    \   |\n23 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmp1ufa7m3q.rs:26:31\n   |\n\
    26 |         if key.to_uppercase() == key {\n   |                            \
    \   ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys();\n    while let Some(key) = keys.next()\
    \ {\n        if key.to_lowercase() == key {\n            return false;\n     \
    \   }\n        if key.to_uppercase() == key {\n            return false;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp1ufa7m3q.rs:23:31\n\
    \   |\n23 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmp1ufa7m3q.rs:26:31\n   |\n\
    26 |         if key.to_uppercase() == key {\n   |                            \
    \   ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(_, value)| {\n  \
    \      value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk8226pi2.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(_, value)| {\n   |                      ^^^^^^^^^^-\n\
    \   |                      |         |\n   |                      |         expected\
    \ due to this\n   |                      expected tuple, found reference\n   |\n\
    \   = note:  expected tuple `(&String, &String)`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpinmqtwy1.rs:18:52\n   |\n18 |     !dict.is_empty()\
    \ && dict.iter().all(|(_, v)| v.is_lowercase() || v.is_uppercase())\n   |    \
    \                                                ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no\
    \ method named `is_uppercase` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpinmqtwy1.rs:18:72\n   |\n18 |     !dict.is_empty() && dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                                            ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, _)| {\n     \
    \   key.to_lowercase() == key\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpgzyh4r4m.rs:19:28\n\
    \   |\n19 |         key.to_lowercase() == key\n   |                          \
    \  ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys().collect::<Vec<_>>();\n    let\
    \ mut values = dict.values().collect::<Vec<_>>();\n    let mut i = 0;\n    while\
    \ i < keys.len() {\n        if keys[i].is_uppercase() {\n            if !values[i].is_lowercase()\
    \ {\n                return false;\n            }\n        } else if keys[i].is_lowercase()\
    \ {\n            if !values[i].is_uppercase() {\n                return false;\n\
    \            }\n        } else {\n            return false;\n        }\n     \
    \   i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpux_hwofs.rs:25:20\n   |\n25 |         if\
    \ keys[i].is_uppercase() {\n   |                    ^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `to_uppercase`\n\nerror[E0599]:\
    \ no method named `is_lowercase` found for reference `&String` in the current\
    \ scope\n  --> /tmp/tmpux_hwofs.rs:26:27\n   |\n26 |             if !values[i].is_lowercase()\
    \ {\n   |                           ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_lowercase` found for reference `&String` in the current scope\n  --> /tmp/tmpux_hwofs.rs:29:27\n\
    \   |\n29 |         } else if keys[i].is_lowercase() {\n   |                 \
    \          ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpux_hwofs.rs:30:27\n   |\n30 |\
    \             if !values[i].is_uppercase() {\n   |                           ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     match value.to_lowercase() {\n            true => true,\n            false\
    \ => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2srw4h2q.rs:20:13\n   |\n\
    19 |         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n20 |             true => true,\n   |    \
    \         ^^^^ expected struct `String`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2srw4h2q.rs:21:13\n   |\n19 |         match value.to_lowercase()\
    \ {\n   |               -------------------- this expression has type `String`\n\
    20 |             true => true,\n21 |             false => false,\n   |       \
    \      ^^^^^ expected struct `String`, found `bool`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            None => false,\n            Some(lower)\
    \ => lower == value,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp83agat1a.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp83agat1a.rs:21:13\n   |\n19 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n20 |             None => false,\n21 |             Some(lower)\
    \ => lower == value,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpodiku0ay.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys();\n    let mut values = dict.values();\n\
    \    while let Some(key) = keys.next() {\n        if key.to_lowercase() == key\
    \ {\n            if !values.next().is_some() {\n                return false;\n\
    \            }\n        } else {\n            if key.to_uppercase() == key {\n\
    \                if !values.next().is_some() {\n                    return false;\n\
    \                }\n            } else {\n                return false;\n    \
    \        }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp8doue4ct.rs:24:31\n\
    \   |\n24 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmp8doue4ct.rs:29:35\n   |\n\
    29 |             if key.to_uppercase() == key {\n   |                        \
    \           ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(_, value)| {\n  \
    \      value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk8226pi2.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(_, value)| {\n   |                      ^^^^^^^^^^-\n\
    \   |                      |         |\n   |                      |         expected\
    \ due to this\n   |                      expected tuple, found reference\n   |\n\
    \   = note:  expected tuple `(&String, &String)`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lower = true;\n    let mut upper = true;\n    for\
    \ (key, value) in dict {\n        if key.is_lowercase() {\n            lower =\
    \ false;\n        }\n        if key.is_uppercase() {\n            upper = false;\n\
    \        }\n    }\n    lower && upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp38snwj_9.rs:24:16\n   |\n24 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp38snwj_9.rs:27:16\n\
    \   |\n27 |         if key.is_uppercase() {\n   |                ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.to_lowercase() == key {\n            true\n        } else {\n \
    \           false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpawrs0snr.rs:19:31\n\
    \   |\n19 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == String::from(lower),\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiowg87_9.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ String::from(lower),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiowg87_9.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ String::from(lower),\n21 |             None => false,\n   |             ^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<_>`\n\nerror[E0277]: can't compare\
    \ `&String` with `String`\n  --> /tmp/tmpiowg87_9.rs:20:34\n   |\n20 |       \
    \      Some(lower) => value == String::from(lower),\n   |                    \
    \              ^^ no implementation for `&String == String`\n   |\n   = help:\
    \ the trait `PartialEq<String>` is not implemented for `&String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8o3qz87c.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, _)| {\n     \
    \   key.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n  \
    \  })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfkd35vs1.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, _)| {\n     \
    \   key.to_lowercase() == key\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpgzyh4r4m.rs:19:28\n\
    \   |\n19 |         key.to_lowercase() == key\n   |                          \
    \  ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfmvlzhaj.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(_, v)| v.is_lowercase() || v.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n            Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n            Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n            _ => false,\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n21 |             Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:22:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n22 |             Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n   |             ^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if let Some(key) = key.to_lowercase() {\n            true\n        } else\
    \ if let Some(key) = key.to_uppercase() {\n            true\n        } else {\n\
    \            false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkx36ec5k.rs:19:16\n   |\n\
    19 |         if let Some(key) = key.to_lowercase() {\n   |                ^^^^^^^^^\
    \   ------------------ this expression has type `String`\n   |               \
    \ |\n   |                expected struct `String`, found enum `Option`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkx36ec5k.rs:21:23\n   |\n21 |\
    \         } else if let Some(key) = key.to_uppercase() {\n   |               \
    \        ^^^^^^^^^   ------------------ this expression has type `String`\n  \
    \ |                       |\n   |                       expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     match value.to_lowercase() {\n            Some(value) => true,\n       \
    \     None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa8r15dfp.rs:20:13\n   |\n\
    19 |         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n20 |             Some(value) => true,\n \
    \  |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n \
    \  |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa8r15dfp.rs:21:13\n   |\n19 |\
    \         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n20 |             Some(value) => true,\n21\
    \ |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n            Some(key_upper) => value.to_uppercase() == key_upper,\n\
    \            _ => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7kc52j8v.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n   |             ^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7kc52j8v.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n21 |             Some(key_upper) => value.to_uppercase() == key_upper,\n\
    \   |             ^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if let Ok(key) = key.to_lowercase() {\n            true\n        } else\
    \ if let Ok(key) = key.to_uppercase() {\n            true\n        } else {\n\
    \            false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphtsax_wk.rs:19:16\n   |\n\
    19 |         if let Ok(key) = key.to_lowercase() {\n   |                ^^^^^^^\
    \   ------------------ this expression has type `String`\n   |               \
    \ |\n   |                expected struct `String`, found enum `Result`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Result<_, _>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphtsax_wk.rs:21:23\n   |\n21 |\
    \         } else if let Ok(key) = key.to_uppercase() {\n   |                 \
    \      ^^^^^^^   ------------------ this expression has type `String`\n   |  \
    \                     |\n   |                       expected struct `String`,\
    \ found enum `Result`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Result<_, _>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, _)| {\n     \
    \   key.to_lowercase() == key\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpgzyh4r4m.rs:19:28\n\
    \   |\n19 |         key.to_lowercase() == key\n   |                          \
    \  ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        1 => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9yjmqnth.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     match value.to_lowercase() {\n            Some(lower) => true,\n       \
    \     None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykgei81r.rs:20:13\n   |\n\
    19 |         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n20 |             Some(lower) => true,\n \
    \  |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n \
    \  |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpykgei81r.rs:21:13\n   |\n19 |\
    \         match value.to_lowercase() {\n   |               --------------------\
    \ this expression has type `String`\n20 |             Some(lower) => true,\n21\
    \ |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, _)| k.is_lowercase()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspl596xz.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            None => false,\n            Some(lower)\
    \ => value == lower,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprr7igls1.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprr7igls1.rs:21:13\n   |\n19 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n20 |             None => false,\n21 |             Some(lower)\
    \ => value == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            None => false,\n            Some(lower)\
    \ => value == lower,\n        }\n    })\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprr7igls1.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             None => false,\n   |   \
    \          ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprr7igls1.rs:21:13\n   |\n19 |         match\
    \ key.to_lowercase() {\n   |               ------------------ this expression\
    \ has type `String`\n20 |             None => false,\n21 |             Some(lower)\
    \ => value == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       let mut lower = String::new();\n        let mut upper = String::new();\n\
    \        key.to_lowercase(&mut lower);\n        value.to_uppercase(&mut upper);\n\
    \        lower == upper\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpo5wcdzbx.rs:21:13\n    |\n21  |         key.to_lowercase(&mut\
    \ lower);\n    |             ^^^^^^^^^^^^ ---------- supplied 1 argument\n   \
    \ |             |\n    |             expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmpo5wcdzbx.rs:22:15\n    |\n22  |      \
    \   value.to_uppercase(&mut upper);\n    |               ^^^^^^^^^^^^ ----------\
    \ supplied 1 argument\n    |               |\n    |               expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, _)| k.is_lowercase()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspl596xz.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.iter().all(|&(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpde3rw2f2.rs:18:42\n   |\n\
    18 |     !dict.is_empty() && dict.iter().all(|&(_, v)| v.is_lowercase() || v.is_uppercase())\n\
    \   |                                          ^^^^^^-\n   |                 \
    \                         |     |\n   |                                      \
    \    |     expected due to this\n   |                                        \
    \  expected tuple, found reference\n   |\n   = note:  expected tuple `(&String,\
    \ &String)`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpodiku0ay.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        1 => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpodiku0ay.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(_key, val)| {\n \
    \       match val.to_lowercase() {\n            Some(val) => val == key,\n   \
    \         None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `key` in this scope\n  --> /tmp/tmpe8yk9rn4.rs:20:33\n\
    \   |\n20 |             Some(val) => val == key,\n   |                       \
    \          ^^^ help: a local variable with a similar name exists: `_key`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe8yk9rn4.rs:18:22\n   |\n18 |     dict.iter().all(|&(_key,\
    \ val)| {\n   |                      ^^^^^^^^^^^-\n   |                      |\
    \          |\n   |                      |          expected due to this\n   |\
    \                      expected tuple, found reference\n   |\n   = note:  expected\
    \ tuple `(&String, &String)`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|&(k, _)| k.is_lowercase()\
    \ || k.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspl596xz.rs:18:22\n   |\n\
    18 |     dict.iter().all(|&(k, _)| k.is_lowercase() || k.is_uppercase())\n   |\
    \                      ^^^^^^-\n   |                      |     |\n   |      \
    \                |     expected due to this\n   |                      expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(&String, &String)`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n            Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n            Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n            _ => false,\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n21 |             Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:22:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n22 |             Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n   |             ^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n            None => value.to_uppercase() == key,\n        }\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0ttau9cw.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n   |             ^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ttau9cw.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => value.to_lowercase()\
    \ == key_lower,\n21 |             None => value.to_uppercase() == key,\n   | \
    \            ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmp0ttau9cw.rs:21:42\n   |\n\
    21 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys().collect::<Vec<_>>();\n    let\
    \ mut keys_lower = keys.iter().map(|key| {\n        if key.to_lowercase() == key\
    \ {\n            key\n        } else {\n            key.to_lowercase()\n     \
    \   }\n    }).collect::<Vec<_>>();\n    let mut keys_upper = keys.iter().map(|key|\
    \ {\n        if key.to_uppercase() == key {\n            key\n        } else {\n\
    \            key.to_uppercase()\n        }\n    }).collect::<Vec<_>>();\n    let\
    \ mut keys_diff = keys.iter().filter(|key| {\n        if key.to_lowercase() !=\
    \ key.to_uppercase() {\n            true\n        } else {\n            false\n\
    \        }\n    }).collect::<Vec<_>>();\n    if keys_lower.is_empty() && keys_upper.is_empty()\
    \ && keys_diff.is_empty() {\n        return true;\n    }\n    if keys_lower.is_empty()\
    \ && keys_upper.is_empty() && keys_diff.is_some() {\n        return false;\n \
    \   }\n    if keys_lower.is_some() && keys_upper.is_some() && keys_diff.is_some()\
    \ {\n        return false;\n    }\n    if keys_lower.is_some() && keys_upper.is_some()\
    \ && keys_diff.is_none() {\n        return true;\n    }\n    if keys_lower.is_none()\
    \ && keys_upper.is_none() && keys_diff.is_none() {\n        return true;\n   \
    \ }\n    if keys_lower.is_none() && keys_upper.is_none() && keys_diff.is_some()\
    \ {\n        return false;\n    }\n    if keys_lower.is_some() && keys_upper.is_some()\
    \ && keys_diff.is_none() {\n        return false;\n    }\n    if keys_lower.is_some()\
    \ && keys_upper.is_some() && keys_diff.is_some() {\n        return false;\n  \
    \  }\n    if keys_lower.is_some() && keys_upper.is_some() && keys_diff.is_some()\
    \ {\n        return false;\n    }\n    if keys_lower.is_some() && keys_upper.is_some()\
    \ && keys_diff.is_some() {\n        return false;\n    }\n    if keys_lower.is_some()\
    \ && keys_upper.is_some() && keys_diff.is_some() {\n        return false;\n  \
    \  }\n    if keys_lower.is_some() && keys_upper.is_some() && keys_diff.is_some()\
    \ {\n        return false;\n    }\n    if keys_lower.is_some() && keys_upper.is_some()\
    \ && keys_diff.is_some() {\n        return false;\n    }\n    if keys_lower.is_some()\
    \ && keys_upper.is_some() && keys_diff.is_some() {\n        return false;\n  \
    \  }\n    if keys_lower.is_some() && keys_upper.is_some() && keys_diff.is_some()\
    \ {\n        return false;\n    }\n    if keys_lower.is_some() && keys_upper.is_some()\
    \ && keys_diff.is_some() {\n        return false;\n    }\n    if \n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpwzlttuxy.rs:92:1\n\
    \   |\n92 | }\n   | ^ expected expression\n\nerror[E0277]: can't compare `String`\
    \ with `&&String`\n  --> /tmp/tmpwzlttuxy.rs:23:31\n   |\n23 |         if key.to_lowercase()\
    \ == key {\n   |                               ^^ no implementation for `String\
    \ == &&String`\n   |\n   = help: the trait `PartialEq<&&String>` is not implemented\
    \ for `String`\n\nerror[E0308]: `if` and `else` have incompatible types\n  -->\
    \ /tmp/tmpwzlttuxy.rs:26:13\n   |\n23 | /         if key.to_lowercase() == key\
    \ {\n24 | |             key\n   | |             --- expected because of this\n\
    25 | |         } else {\n26 | |             key.to_lowercase()\n   | |       \
    \      ^^^^^^^^^^^^^^^^^^ expected `&&String`, found struct `String`\n27 | | \
    \        }\n   | |_________- `if` and `else` have incompatible types\n\nerror[E0277]:\
    \ can't compare `String` with `&&String`\n  --> /tmp/tmpwzlttuxy.rs:30:31\n  \
    \ |\n30 |         if key.to_uppercase() == key {\n   |                       \
    \        ^^ no implementation for `String == &&String`\n   |\n   = help: the trait\
    \ `PartialEq<&&String>` is not implemented for `String`\n\nerror[E0308]: `if`\
    \ and `else` have incompatible types\n  --> /tmp/tmpwzlttuxy.rs:33:13\n   |\n\
    30 | /         if key.to_uppercase() == key {\n31 | |             key\n   | |\
    \             --- expected because of this\n32 | |         } else {\n33 | |  \
    \           key.to_uppercase()\n   | |             ^^^^^^^^^^^^^^^^^^ expected\
    \ `&&String`, found struct `String`\n34 | |         }\n   | |_________- `if` and\
    \ `else` have incompatible types\n\nerror[E0599]: no method named `is_some` found\
    \ for struct `Vec<&&String>` in the current scope\n  --> /tmp/tmpwzlttuxy.rs:46:68\n\
    \   |\n46 |     if keys_lower.is_empty() && keys_upper.is_empty() && keys_diff.is_some()\
    \ {\n   |                                                                    ^^^^^^^\
    \ method not found in `Vec<&&String>`\n\nerror[E0599]: no method named `is_some`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpwzlttuxy.rs:49:19\n\
    \   |\n49 |     if keys_lower.is_some() && key"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.is_lowercase() {\n            true\n        } else {\n        \
    \    false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpwnlcpc9s.rs:19:16\n   |\n19 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.to_lowercase() == key {\n            true\n        } else {\n \
    \           false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpawrs0snr.rs:19:31\n\
    \   |\n19 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     let mut iter = value.chars().filter(|c| c.is_ascii_lowercase()).collect::<Vec<_>>();\n\
    \        iter.iter().all(|c| !c.is_ascii_uppercase())\n    })\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppnofkhj5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.len() != value.len() {\n            return false;\n        }\n\
    \        for (i, c) in key.chars().enumerate() {\n            if c != c.to_lowercase()\
    \ {\n                return false;\n            }\n        }\n        for (i,\
    \ c) in key.chars().enumerate() {\n            if c != c.to_uppercase() {\n  \
    \              return false;\n            }\n        }\n        true\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuytifklp.rs:23:21\n   |\n\
    23 |             if c != c.to_lowercase() {\n   |                     ^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuytifklp.rs:28:21\n   |\n28 |             if c != c.to_uppercase()\
    \ {\n   |                     ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToUppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n            Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n            Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n            _ => false,\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n21 |             Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:22:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n22 |             Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n   |             ^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value.to_lowercase()\
    \ == lower,\n            None => value.to_uppercase() == key,\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxnl2hkgy.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value.to_lowercase()\
    \ == lower,\n21 |             None => value.to_uppercase() == key,\n   |     \
    \        ^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `String` with `&String`\n  --> /tmp/tmpxnl2hkgy.rs:21:42\n   |\n\
    21 |             None => value.to_uppercase() == key,\n   |                  \
    \                        ^^ no implementation for `String == &String`\n   |\n\
    \   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       key.to_lowercase() == value.to_lowercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4fhcmjca.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.to_lowercase() == key {\n            true\n        } else {\n \
    \           false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpawrs0snr.rs:19:31\n\
    \   |\n19 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut keys = dict.keys().collect::<Vec<_>>();\n    keys.sort();\n\
    \    for k in keys {\n        let v = dict.get(k).unwrap();\n        if v.len()\
    \ != 1 {\n            return false;\n        }\n        if v.chars().any(|c| !c.is_ascii_lowercase())\
    \ {\n            return false;\n        }\n        if v.chars().any(|c| !c.is_ascii_uppercase())\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzv79bvr8.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n            Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n            Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n            _ => false,\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n21 |             Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn4deezd.rs:22:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n22 |             Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n   |             ^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => true,\n\
    \        1 => dict.get(String::from(\"a\")).map(|s| s.to_lowercase()).unwrap_or(false)\
    \ == true,\n        _ => dict\n            .iter()\n            .all(|(_, v)|\
    \ v.to_lowercase() == dict.get(String::from(\"a\")).unwrap_or(false)),\n    }\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpprbn02_h.rs:20:23\n   |\n\
    20 |         1 => dict.get(String::from(\"a\")).map(|s| s.to_lowercase()).unwrap_or(false)\
    \ == true,\n   |                       ^^^^^^^^^^^^^^^^^\n   |               \
    \        |\n   |                       expected reference, found struct `String`\n\
    \   |                       help: consider borrowing here: `&String::from(\"a\"\
    )`\n   |\n   = note: expected reference `&_`\n                 found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpprbn02_h.rs:20:78\n   |\n20 |\
    \         1 => dict.get(String::from(\"a\")).map(|s| s.to_lowercase()).unwrap_or(false)\
    \ == true,\n   |                                                             \
    \                 ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                                                        \
    \      |\n   |                                                               \
    \               expected struct `String`, found `bool`\n\nerror[E0277]: can't\
    \ compare `String` with `bool`\n  --> /tmp/tmpprbn02_h.rs:20:85\n   |\n20 |  \
    \       1 => dict.get(String::from(\"a\")).map(|s| s.to_lowercase()).unwrap_or(false)\
    \ == true,\n   |                                                             \
    \                        ^^ no implementation for `String == bool`\n   |\n   =\
    \ help: the trait `PartialEq<bool>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpprbn02_h.rs:23:56\n   |\n23 |             .all(|(_,\
    \ v)| v.to_lowercase() == dict.get(String::from(\"a\")).unwrap_or(false)),\n \
    \  |                                                        ^^^^^^^^^^^^^^^^^\n\
    \   |                                                        |\n   |         \
    \                                               expected reference, found struct\
    \ `String`\n   |                                                        help:\
    \ consider borrowing here: `&String::from(\"a\")`\n   |\n   = note: expected reference\
    \ `&_`\n                 found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpprbn02_h.rs:23:85\n   |\n23 |   "
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == String::from(lower),\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiowg87_9.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ String::from(lower),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiowg87_9.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ String::from(lower),\n21 |             None => false,\n   |             ^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<_>`\n\nerror[E0277]: can't compare\
    \ `&String` with `String`\n  --> /tmp/tmpiowg87_9.rs:20:34\n   |\n20 |       \
    \      Some(lower) => value == String::from(lower),\n   |                    \
    \              ^^ no implementation for `&String == String`\n   |\n   = help:\
    \ the trait `PartialEq<String>` is not implemented for `&String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(key_lower) => key_lower ==\
    \ value,\n            None => false,\n        }\n    })\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdvhvnb88.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => key_lower\
    \ == value,\n   |             ^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdvhvnb88.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(key_lower) => key_lower\
    \ == value,\n21 |             None => false,\n   |             ^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       let mut key = key.to_lowercase();\n        let mut value = value.to_lowercase();\n\
    \        key.chars().all(|c| {\n            value.chars().all(|c| c.is_ascii_lowercase())\n\
    \        })\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3iihx_3p.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       key.to_lowercase() == value.to_lowercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4fhcmjca.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       let mut lower = String::new();\n        let mut upper = String::new();\n\
    \        key.to_lowercase(&mut lower);\n        value.to_uppercase(&mut upper);\n\
    \        lower == upper\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpo5wcdzbx.rs:21:13\n    |\n21  |         key.to_lowercase(&mut\
    \ lower);\n    |             ^^^^^^^^^^^^ ---------- supplied 1 argument\n   \
    \ |             |\n    |             expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmpo5wcdzbx.rs:22:15\n    |\n22  |      \
    \   value.to_uppercase(&mut upper);\n    |               ^^^^^^^^^^^^ ----------\
    \ supplied 1 argument\n    |               |\n    |               expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       if key.to_lowercase() == key {\n            true\n        } else {\n \
    \           false\n        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpawrs0snr.rs:19:31\n\
    \   |\n19 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.is_lowercase() || value.is_uppercase()\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:15\n   |\n19 |         value.is_lowercase()\
    \ || value.is_uppercase()\n   |               ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpge1eo_w7.rs:19:39\n\
    \   |\n19 |         value.is_lowercase() || value.is_uppercase()\n   |       \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower,\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower,\n   |             ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprju_4dep.rs:21:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n20 |             Some(lower) => value == lower,\n\
    21 |             None => false,\n   |             ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(lower) => value == lower.to_lowercase(),\n\
    \            None => false,\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc8yy1t2j.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower.to_lowercase(),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc8yy1t2j.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(lower) => value ==\
    \ lower.to_lowercase(),\n21 |             None => false,\n   |             ^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<_>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n \
    \       match key.to_lowercase() {\n            Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n            Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n            Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n            Some(\"state\") => value.to_lowercase()\
    \ == String::from(\"nc\"),\n            Some(\"zip\") => value.to_lowercase()\
    \ == String::from(\"12345\"),\n            _ => false,\n        }\n    })\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr4fwwoqh.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr4fwwoqh.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n21 |             Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr4fwwoqh.rs:22:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n22 |             Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n   |             ^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpr4fwwoqh.rs:23:13\n   |\n19 |         match key.to_lowercase() {\n \
    \  |               ------------------ this expression has type `String`\n...\n\
    23 |             Some(\"state\") => value.to_lowercase() == String::from(\"nc\"\
    ),\n   |             ^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr4fwwoqh.rs:24:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n...\n24 |             Some(\"zip\") => value.to_lowercase()\
    \ == String::from(\"12345\"),\n   |             ^^^^^^^^^^^ expect"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.iter().all(|(key,\
    \ value)| {\n        let key = key.to_lowercase();\n        let value = value.to_lowercase();\n\
    \        key == value || key.to_uppercase() == value\n    })\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4lfh2djg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.iter().all(|(key,\
    \ value)| {\n        match key.to_lowercase() {\n            Some(\"name\") =>\
    \ value.to_lowercase() == String::from(\"john\"),\n            Some(\"age\") =>\
    \ value.to_lowercase() == String::from(\"36\"),\n            Some(\"city\") =>\
    \ value.to_lowercase() == String::from(\"houston\"),\n            Some(\"state\"\
    ) => value.to_lowercase() == String::from(\"nc\"),\n            Some(\"zip\")\
    \ => value.to_lowercase() == String::from(\"12345\"),\n            _ => false,\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph81ebbgq.rs:20:13\n   |\n\
    19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n   |             ^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph81ebbgq.rs:21:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n20 |             Some(\"name\") => value.to_lowercase()\
    \ == String::from(\"john\"),\n21 |             Some(\"age\") => value.to_lowercase()\
    \ == String::from(\"36\"),\n   |             ^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph81ebbgq.rs:22:13\n\
    \   |\n19 |         match key.to_lowercase() {\n   |               ------------------\
    \ this expression has type `String`\n...\n22 |             Some(\"city\") => value.to_lowercase()\
    \ == String::from(\"houston\"),\n   |             ^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmph81ebbgq.rs:23:13\n   |\n19 |         match key.to_lowercase() {\n \
    \  |               ------------------ this expression has type `String`\n...\n\
    23 |             Some(\"state\") => value.to_lowercase() == String::from(\"nc\"\
    ),\n   |             ^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph81ebbgq.rs:24:13\n   |\n19 |\
    \         match key.to_lowercase() {\n   |               ------------------ this\
    \ expression has type `String`\n...\n24 |             Some(\"zip\") => value.to_lowercase()\
    \ == String::from(\"12345\"),\n   |             ^^^^^^^^^^^ expect"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, v)| v.is_lowercase()\
    \ || v.is_uppercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:32\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpa_ps5kwn.rs:18:52\n   |\n18 |     dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                        ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, _)| {\n     \
    \   key.to_lowercase() == key\n    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpgzyh4r4m.rs:19:28\n\
    \   |\n19 |         key.to_lowercase() == key\n   |                          \
    \  ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, _)| {\n     \
    \   key.chars().all(|c| c.is_lowercase() || c.is_uppercase())\n    })\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphpoaqiva.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(_, value)| {\n   \
    \     value.len() == 1 && value.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_uppercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbheozlhi.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    !dict.is_empty() && dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpinmqtwy1.rs:18:52\n   |\n18 |     !dict.is_empty()\
    \ && dict.iter().all(|(_, v)| v.is_lowercase() || v.is_uppercase())\n   |    \
    \                                                ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no\
    \ method named `is_uppercase` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpinmqtwy1.rs:18:72\n   |\n18 |     !dict.is_empty() && dict.iter().all(|(_,\
    \ v)| v.is_lowercase() || v.is_uppercase())\n   |                            \
    \                                            ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749165
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.len() {\n        0 => false,\n\
    \        _ => true,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa0fp00vv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749166
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, _)| key.to_lowercase()\
    \ == key)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpf0693or9.rs:18:51\n\
    \   |\n18 |     dict.iter().all(|(key, _)| key.to_lowercase() == key)\n   |  \
    \                                                 ^^ no implementation for `String\
    \ == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749166
