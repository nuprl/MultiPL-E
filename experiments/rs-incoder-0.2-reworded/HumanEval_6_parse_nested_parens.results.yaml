name: HumanEval_6_parse_nested_parens
language: rs
results:
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    for paren in paren_string.chars() {\n \
    \       if paren == '(' {\n            paren_stack.push(paren_level);\n      \
    \      paren_level += 1;\n        } else if paren == ')' {\n            paren_level\
    \ -= 1;\n            if paren_level == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpifgr9nrv.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_len = paren_stack.len();\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmipcdcjg.rs:40:42\n   |\n\
    40 |     let mut paren_levels_len_init = paren\n   |                         \
    \                 ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `paren` in this scope\n  --> /tmp/tmpmipcdcjg.rs:40:37\n \
    \  |\n40 |     let mut paren_levels_len_init = paren\n   |                   \
    \                  ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpmipcdcjg.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().rev();\n \
    \   let mut paren_levels_iter_next = paren_levels_iter.next();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.next();\n    while paren_levels_iter_next.is_some() {\n\
    \        let paren_level = paren_levels_iter_next.unwrap();\n        paren_levels.push(paren_level);\n\
    \        paren_levels_iter_next = paren_levels_iter.next();\n    }\n    paren_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuh3tsyjr.rs:14:27\n   |\n\
    14 |         paren_levels.push(paren_level);\n   |                           ^^^^^^^^^^^\
    \ expected integer, found tuple\n   |\n   = note: expected type `{integer}`\n\
    \             found tuple `(usize, char)`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_max = paren_levels_stack.len();\n    let mut paren_levels_stack_max_pos\
    \ = 0;\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n \
    \   let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa08o1sny.rs:37:36\n   |\n\
    37 |     let mut paren_levels_stack_max_\n   |                               \
    \     ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpa08o1sny.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_stack = vec![0];\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph3lxok1a.rs:43:55\n   |\n\
    43 |     let mut paren_level_stack_top = paren_level_stack_\n   |            \
    \                                           ^ help: add `;` here\n44 | }\n   |\
    \ - unexpected token\n\nerror[E0425]: cannot find value `paren_level_stack_` in\
    \ this scope\n  --> /tmp/tmph3lxok1a.rs:43:37\n   |\n43 |     let mut paren_level_stack_top\
    \ = paren_level_stack_\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_level_stack`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmph3lxok1a.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr = 0;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = \n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpmvwhxjcg.rs:36:1\n\
    \   |\n36 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_levels_stack\
    \ = vec![0];\n    let mut paren_levels_stack_ptr = 0;\n    let mut paren_levels_ptr\
    \ = 0;\n    let mut paren_levels_ptr_end = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr = paren_levels_ptr;\n    let mut\
    \ paren_levels_ptr_end_ptr_end_ptr_end = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaic40uc2.rs:27:37\n   |\n\
    27 |     let mut paren_levels_ptr_end_ptr\n   |                              \
    \       ^ help: add `;` here\n28 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpaic40uc2.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_stack = vec![];\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppgr70m4d.rs:43:55\n   |\n\
    43 |     let mut paren_level_stack_top = paren_level_stack_\n   |            \
    \                                           ^ help: add `;` here\n44 | }\n   |\
    \ - unexpected token\n\nerror[E0425]: cannot find value `paren_level_stack_` in\
    \ this scope\n  --> /tmp/tmppgr70m4d.rs:43:37\n   |\n43 |     let mut paren_level_stack_top\
    \ = paren_level_stack_\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_level_stack`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppgr70m4d.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_max = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_val\
    \ = paren_levels_stack[paren_levels_stack_max_pos];\n    let mut paren_levels_stack_max_val_pos\
    \ = 0;\n    let mut paren_levels_stack_max_val_val = paren_levels_stack[paren_levels_stack_max_val_pos];\n\
    \    let mut paren_levels_stack_max_val_val_pos = 0;\n    let mut paren_levels_stack_max_val_val_val\
    \ = paren_levels_stack[paren_levels_stack_max_val_val_pos];\n    let mut paren_levels_stack_max_val_val_val_pos\
    \ = 0;\n    let mut paren_levels_stack_max_val_val_val_val = paren_levels_stack[paren_levels_stack_max_val_val_val_pos];\n\
    \    let mut paren_levels_stack_max_val_val_val_val_pos = 0;\n    let mut paren_levels_stack_max_val_val_val_val_val\
    \ = paren_levels_stack[paren_levels_stack_max_val_val_val_val_pos];\n    let mut\
    \ paren_levels_stack_max_val_val_val_val_val_pos = 0;\n    let mut paren_levels_stack_max_val_val_val_val_val_val\
    \ = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_pos];\n    let\
    \ mut paren_levels_stack_max_val_val_val_val_val_val_pos = 0;\n    let mut paren_levels_stack_max_val_val_val_val_val_val_val\
    \ = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_pos];\n\
    \    let mut paren_levels_stack_max_val_val_val_val_val_val_val_pos = 0;\n   \
    \ let mut paren_levels_stack_max_val_val_val_val_val_val_val_val = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_val_pos];\n\
    \    let mut paren_levels_stack_max_val_val_val_val_val_val_val_val_pos = 0;\n\
    \    let mut paren_levels_stack_max_val_val_val_val_val_val_val_val_val = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_val_val_pos];\n\
    \    let mut paren_levels_stack_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0rsaxgph.rs:30:32\n   |\n\
    30 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `paren_levels_stack_max_val_val_val_val_val_val_val_pos` in this scope\n  -->\
    \ /tmp/tmp0rsaxgph.rs:25:85\n   |\n25 |     let mut paren_levels_stack_max_val_val_val_val_val_val_val\
    \ = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_pos];\n\
    \   |                                                                        \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `paren_levels_stack_max_val_val_val_val_val_val_pos`\n\
    \nerror[E0425]: cannot find value `paren_levels_stack_max_val_val_val_val_val_val_val_val_pos`\
    \ in this scope\n  --> /tmp/tmp0rsaxgph.rs:27:89\n   |\n27 | ...l_val_val = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_val_pos];\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_stack_max_val_val_val_val_val_val_val_pos`\n\
    \nerror[E0425]: cannot find value `paren_levels_stack_max_val_val_val_val_val_val_val_val_val_pos`\
    \ in this scope\n  --> /tmp/tmp0rsaxgph.rs:29:93\n   |\n29 | ...val_val = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_val_val_pos];\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_stack_max_val_val_val_val_val_val_val_val_pos`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp0rsaxgph.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_stack\
    \ = Vec::new();\n    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len\
    \ = paren_level_stack.len();\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg_eqn_u6.rs:43:43\n   |\n\
    43 |     let mut paren_level_stack_top = paren_\n   |                        \
    \                   ^ help: add `;` here\n44 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `paren_` in this scope\n  --> /tmp/tmpg_eqn_u6.rs:43:37\n\
    \   |\n43 |     let mut paren_level_stack_top = paren_\n   |                 \
    \                    ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpg_eqn_u6.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_level = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            paren_stack.push(paren_depth);\n \
    \           paren_depth += 1;\n            paren_level += 1;\n        } else if\
    \ paren == ')' {\n            paren_depth -= 1;\n            paren_level -= 1;\n\
    \            if paren_stack.pop() == 0 {\n                paren_level += 1;\n\
    \            }\n        }\n    }\n    paren_stack.len()\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4k_ynfl7.rs:18:37\n   |\n\
    18 |             if paren_stack.pop() == 0 {\n   |                           \
    \          ^ expected enum `Option`, found integer\n   |\n   = note: expected\
    \ enum `Option<{integer}>`\n              found type `{integer}`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n18 |             if paren_stack.pop() == Some(0)\
    \ {\n   |                                     +++++ +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4k_ynfl7.rs:23:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n23 |     paren_stack.len()\n\
    \   |     ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n                found type `usize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpicselc24.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpaob4li6b.rs:38:1\n  \
    \ |\n38 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_chars = vec![0];\n\
    \    let mut paren_level_chars_index = 0;\n    let mut paren_level_chars_index2\
    \ = 0;\n    let mut paren_level_chars_index3 = 0;\n    let mut paren_level_chars_index4\
    \ = 0;\n    let mut paren_level_chars_index5 = 0;\n    let mut paren_level_chars_index6\
    \ = 0;\n    let mut paren_level_chars_index7 = 0;\n    let mut paren_level_chars_index8\
    \ = 0;\n    let mut paren_level_chars_index9 = 0;\n    let mut paren_level_chars_index10\
    \ = 0;\n    let mut paren_level_chars_index11 = 0;\n    let mut paren_level_chars_index12\
    \ = 0;\n    let mut paren_level_chars_index13 = 0;\n    let mut paren_level_chars_index14\
    \ = 0;\n    let mut paren_level_chars_index15 = 0;\n    let mut paren_level_chars_index16\
    \ = 0;\n    let mut paren_level_chars_index17 = 0;\n    let mut paren_level_chars_index18\
    \ = 0;\n    let mut paren_level_chars_index19 = 0;\n    let mut paren_level_chars_index20\
    \ = 0;\n    let mut paren_level_chars_index21 = 0;\n    let mut paren_level_chars_index22\
    \ = 0;\n    let mut paren_level_chars_index23 = 0;\n    let mut paren_level_chars_index24\
    \ = 0;\n    let mut paren_level_chars_index25 = 0;\n    let mut paren_level_chars_index26\
    \ = 0;\n    let mut paren_level_chars_index27 = 0;\n    let mut paren_level_chars_index28\
    \ = 0;\n    let mut paren_level_chars_index29 = 0;\n    let mut paren_level_chars_index30\
    \ = 0;\n    let mut paren_level_chars_index31 = 0;\n    let mut paren_level_chars_index32\
    \ = 0;\n    let mut paren_level_chars_index33 = 0;\n    let mut paren_level_chars_index34\
    \ = 0;\n    let mut paren_level_chars_index35 = 0;\n    let mut paren_level_chars_index36\
    \ = 0;\n    let mut paren_level_chars_index37 = 0;\n    let mut paren_level_chars_index38\
    \ = 0;\n    let mut paren_level_chars_index39 = 0;\n    let mut paren_level_chars_index40\
    \ = 0;\n    let mut paren_level_chars_index41 = 1;\n    let mut paren_level_chars_index42\
    \ = 1;\n    let mut paren_level_chars_index43 = 1;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3hz__14i.rs:55:1\n\
    \   |\n55 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx0jaeeu5.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpx0jaeeu5.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_nestings = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_nestings_stack\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_nestings_stack_ptr = paren_nestings_stack.len();\n    let mut\
    \ paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_ptr\
    \ = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_ptr\
    \ = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_ptr\
    \ = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp64isyqy8.rs:39:26\n   |\n\
    39 |     let mut paren_levels_\n   |                          ^ help: add `;`\
    \ here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp64isyqy8.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_size\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5wnb8qab.rs:30:55\n   |\n\
    30 |     let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr\n   |            \
    \                                           ^ help: add `;` here\n31 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5wnb8qab.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr98hrsnt.rs:35:27\n   |\n\
    35 |     let mut paren_nesting_\n   |                           ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpr98hrsnt.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_levels_size = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_end\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1ucuuwh4.rs:44:44\n   |\n\
    44 |     let mut paren_levels_pos = paren_string\n   |                       \
    \                     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp1ucuuwh4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5o4jl_vd.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5o4jl_vd.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
