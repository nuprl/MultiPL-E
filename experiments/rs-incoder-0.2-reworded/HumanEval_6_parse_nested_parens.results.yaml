language: rs
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    for paren in paren_string.chars() {\n \
    \       if paren == '(' {\n            paren_stack.push(paren_level);\n      \
    \      paren_level += 1;\n        } else if paren == ')' {\n            paren_level\
    \ -= 1;\n            if paren_level == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpifgr9nrv.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_len = paren_stack.len();\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren_levels_len;\n\
    \    let mut paren_levels_len_init = paren_levels_len;\n    let mut paren_levels_len_init\
    \ = paren_levels_len;\n    let mut paren_levels_len_init = paren\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmipcdcjg.rs:40:42\n   |\n\
    40 |     let mut paren_levels_len_init = paren\n   |                         \
    \                 ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `paren` in this scope\n  --> /tmp/tmpmipcdcjg.rs:40:37\n \
    \  |\n40 |     let mut paren_levels_len_init = paren\n   |                   \
    \                  ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpmipcdcjg.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().rev();\n \
    \   let mut paren_levels_iter_next = paren_levels_iter.next();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.next();\n    while paren_levels_iter_next.is_some() {\n\
    \        let paren_level = paren_levels_iter_next.unwrap();\n        paren_levels.push(paren_level);\n\
    \        paren_levels_iter_next = paren_levels_iter.next();\n    }\n    paren_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuh3tsyjr.rs:14:27\n   |\n\
    14 |         paren_levels.push(paren_level);\n   |                           ^^^^^^^^^^^\
    \ expected integer, found tuple\n   |\n   = note: expected type `{integer}`\n\
    \             found tuple `(usize, char)`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_max = paren_levels_stack.len();\n    let mut paren_levels_stack_max_pos\
    \ = 0;\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n \
    \   let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_max_len = paren_levels_stack.len();\n    let mut paren_levels_stack_max_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa08o1sny.rs:37:36\n   |\n\
    37 |     let mut paren_levels_stack_max_\n   |                               \
    \     ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpa08o1sny.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_stack = vec![0];\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph3lxok1a.rs:43:55\n   |\n\
    43 |     let mut paren_level_stack_top = paren_level_stack_\n   |            \
    \                                           ^ help: add `;` here\n44 | }\n   |\
    \ - unexpected token\n\nerror[E0425]: cannot find value `paren_level_stack_` in\
    \ this scope\n  --> /tmp/tmph3lxok1a.rs:43:37\n   |\n43 |     let mut paren_level_stack_top\
    \ = paren_level_stack_\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_level_stack`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmph3lxok1a.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr = 0;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr_end = \n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpmvwhxjcg.rs:36:1\n\
    \   |\n36 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_levels_stack\
    \ = vec![0];\n    let mut paren_levels_stack_ptr = 0;\n    let mut paren_levels_ptr\
    \ = 0;\n    let mut paren_levels_ptr_end = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end = paren_levels_ptr;\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr = paren_levels_ptr;\n    let mut\
    \ paren_levels_ptr_end_ptr_end_ptr_end = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr;\n    let mut paren_levels_ptr_end_ptr\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaic40uc2.rs:27:37\n   |\n\
    27 |     let mut paren_levels_ptr_end_ptr\n   |                              \
    \       ^ help: add `;` here\n28 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpaic40uc2.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_stack = vec![];\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppgr70m4d.rs:43:55\n   |\n\
    43 |     let mut paren_level_stack_top = paren_level_stack_\n   |            \
    \                                           ^ help: add `;` here\n44 | }\n   |\
    \ - unexpected token\n\nerror[E0425]: cannot find value `paren_level_stack_` in\
    \ this scope\n  --> /tmp/tmppgr70m4d.rs:43:37\n   |\n43 |     let mut paren_level_stack_top\
    \ = paren_level_stack_\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_level_stack`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppgr70m4d.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_max = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_max_pos = 0;\n    let mut paren_levels_stack_max_val\
    \ = paren_levels_stack[paren_levels_stack_max_pos];\n    let mut paren_levels_stack_max_val_pos\
    \ = 0;\n    let mut paren_levels_stack_max_val_val = paren_levels_stack[paren_levels_stack_max_val_pos];\n\
    \    let mut paren_levels_stack_max_val_val_pos = 0;\n    let mut paren_levels_stack_max_val_val_val\
    \ = paren_levels_stack[paren_levels_stack_max_val_val_pos];\n    let mut paren_levels_stack_max_val_val_val_pos\
    \ = 0;\n    let mut paren_levels_stack_max_val_val_val_val = paren_levels_stack[paren_levels_stack_max_val_val_val_pos];\n\
    \    let mut paren_levels_stack_max_val_val_val_val_pos = 0;\n    let mut paren_levels_stack_max_val_val_val_val_val\
    \ = paren_levels_stack[paren_levels_stack_max_val_val_val_val_pos];\n    let mut\
    \ paren_levels_stack_max_val_val_val_val_val_pos = 0;\n    let mut paren_levels_stack_max_val_val_val_val_val_val\
    \ = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_pos];\n    let\
    \ mut paren_levels_stack_max_val_val_val_val_val_val_pos = 0;\n    let mut paren_levels_stack_max_val_val_val_val_val_val_val\
    \ = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_pos];\n\
    \    let mut paren_levels_stack_max_val_val_val_val_val_val_val_pos = 0;\n   \
    \ let mut paren_levels_stack_max_val_val_val_val_val_val_val_val = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_val_pos];\n\
    \    let mut paren_levels_stack_max_val_val_val_val_val_val_val_val_pos = 0;\n\
    \    let mut paren_levels_stack_max_val_val_val_val_val_val_val_val_val = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_val_val_pos];\n\
    \    let mut paren_levels_stack_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0rsaxgph.rs:30:32\n   |\n\
    30 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `paren_levels_stack_max_val_val_val_val_val_val_val_pos` in this scope\n  -->\
    \ /tmp/tmp0rsaxgph.rs:25:85\n   |\n25 |     let mut paren_levels_stack_max_val_val_val_val_val_val_val\
    \ = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_pos];\n\
    \   |                                                                        \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `paren_levels_stack_max_val_val_val_val_val_val_pos`\n\
    \nerror[E0425]: cannot find value `paren_levels_stack_max_val_val_val_val_val_val_val_val_pos`\
    \ in this scope\n  --> /tmp/tmp0rsaxgph.rs:27:89\n   |\n27 | ...l_val_val = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_val_pos];\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_stack_max_val_val_val_val_val_val_val_pos`\n\
    \nerror[E0425]: cannot find value `paren_levels_stack_max_val_val_val_val_val_val_val_val_val_pos`\
    \ in this scope\n  --> /tmp/tmp0rsaxgph.rs:29:93\n   |\n29 | ...val_val = paren_levels_stack[paren_levels_stack_max_val_val_val_val_val_val_val_val_val_pos];\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_stack_max_val_val_val_val_val_val_val_val_pos`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp0rsaxgph.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting "
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_stack\
    \ = Vec::new();\n    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len\
    \ = paren_level_stack.len();\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_level_stack_len;\n\
    \    let mut paren_level_stack_bottom = paren_level_stack_len;\n    let mut paren_level_stack_top\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom = paren_level_stack_len;\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_top = paren_\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg_eqn_u6.rs:43:43\n   |\n\
    43 |     let mut paren_level_stack_top = paren_\n   |                        \
    \                   ^ help: add `;` here\n44 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `paren_` in this scope\n  --> /tmp/tmpg_eqn_u6.rs:43:37\n\
    \   |\n43 |     let mut paren_level_stack_top = paren_\n   |                 \
    \                    ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpg_eqn_u6.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_level = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            paren_stack.push(paren_depth);\n \
    \           paren_depth += 1;\n            paren_level += 1;\n        } else if\
    \ paren == ')' {\n            paren_depth -= 1;\n            paren_level -= 1;\n\
    \            if paren_stack.pop() == 0 {\n                paren_level += 1;\n\
    \            }\n        }\n    }\n    paren_stack.len()\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4k_ynfl7.rs:18:37\n   |\n\
    18 |             if paren_stack.pop() == 0 {\n   |                           \
    \          ^ expected enum `Option`, found integer\n   |\n   = note: expected\
    \ enum `Option<{integer}>`\n              found type `{integer}`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n18 |             if paren_stack.pop() == Some(0)\
    \ {\n   |                                     +++++ +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4k_ynfl7.rs:23:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n23 |     paren_stack.len()\n\
    \   |     ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n                found type `usize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n    let mut paren_level_chars\
    \ = vec![];\n    let mut paren_level_char_index = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpicselc24.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpaob4li6b.rs:38:1\n  \
    \ |\n38 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_chars = vec![0];\n\
    \    let mut paren_level_chars_index = 0;\n    let mut paren_level_chars_index2\
    \ = 0;\n    let mut paren_level_chars_index3 = 0;\n    let mut paren_level_chars_index4\
    \ = 0;\n    let mut paren_level_chars_index5 = 0;\n    let mut paren_level_chars_index6\
    \ = 0;\n    let mut paren_level_chars_index7 = 0;\n    let mut paren_level_chars_index8\
    \ = 0;\n    let mut paren_level_chars_index9 = 0;\n    let mut paren_level_chars_index10\
    \ = 0;\n    let mut paren_level_chars_index11 = 0;\n    let mut paren_level_chars_index12\
    \ = 0;\n    let mut paren_level_chars_index13 = 0;\n    let mut paren_level_chars_index14\
    \ = 0;\n    let mut paren_level_chars_index15 = 0;\n    let mut paren_level_chars_index16\
    \ = 0;\n    let mut paren_level_chars_index17 = 0;\n    let mut paren_level_chars_index18\
    \ = 0;\n    let mut paren_level_chars_index19 = 0;\n    let mut paren_level_chars_index20\
    \ = 0;\n    let mut paren_level_chars_index21 = 0;\n    let mut paren_level_chars_index22\
    \ = 0;\n    let mut paren_level_chars_index23 = 0;\n    let mut paren_level_chars_index24\
    \ = 0;\n    let mut paren_level_chars_index25 = 0;\n    let mut paren_level_chars_index26\
    \ = 0;\n    let mut paren_level_chars_index27 = 0;\n    let mut paren_level_chars_index28\
    \ = 0;\n    let mut paren_level_chars_index29 = 0;\n    let mut paren_level_chars_index30\
    \ = 0;\n    let mut paren_level_chars_index31 = 0;\n    let mut paren_level_chars_index32\
    \ = 0;\n    let mut paren_level_chars_index33 = 0;\n    let mut paren_level_chars_index34\
    \ = 0;\n    let mut paren_level_chars_index35 = 0;\n    let mut paren_level_chars_index36\
    \ = 0;\n    let mut paren_level_chars_index37 = 0;\n    let mut paren_level_chars_index38\
    \ = 0;\n    let mut paren_level_chars_index39 = 0;\n    let mut paren_level_chars_index40\
    \ = 0;\n    let mut paren_level_chars_index41 = 1;\n    let mut paren_level_chars_index42\
    \ = 1;\n    let mut paren_level_chars_index43 = 1;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3hz__14i.rs:55:1\n\
    \   |\n55 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx0jaeeu5.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpx0jaeeu5.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_nestings = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_nestings_stack\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_nestings_stack_ptr = paren_nestings_stack.len();\n    let mut\
    \ paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_ptr\
    \ = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_ptr\
    \ = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_ptr\
    \ = paren_levels.len();\n    let mut paren_nestings_ptr = paren_nestings.len();\n\
    \    let mut paren_levels_ptr = paren_levels.len();\n    let mut paren_nestings_ptr\
    \ = paren_nestings.len();\n    let mut paren_levels_ptr = paren_levels.len();\n\
    \    let mut paren_nestings_ptr = paren_nestings.len();\n    let mut paren_levels_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp64isyqy8.rs:39:26\n   |\n\
    39 |     let mut paren_levels_\n   |                          ^ help: add `;`\
    \ here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp64isyqy8.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_size\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5wnb8qab.rs:30:55\n   |\n\
    30 |     let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr\n   |            \
    \                                           ^ help: add `;` here\n31 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5wnb8qab.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr98hrsnt.rs:35:27\n   |\n\
    35 |     let mut paren_nesting_\n   |                           ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpr98hrsnt.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_levels_size = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_end\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string.len();\n    let mut paren_levels_pos\
    \ = paren_string.len();\n    let mut paren_levels_pos = paren_string.len();\n\
    \    let mut paren_levels_pos = paren_string\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1ucuuwh4.rs:44:44\n   |\n\
    44 |     let mut paren_levels_pos = paren_string\n   |                       \
    \                     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp1ucuuwh4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5o4jl_vd.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5o4jl_vd.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut paren_depth\
    \ = 0;\n    let mut paren_level = 0;\n    let mut paren_level_depth = vec![];\n\
    \    let mut paren_level_depth_counter = vec![];\n    let mut paren_level_depth_counter_index\
    \ = 0;\n    let mut paren_level_depth_counter_size = paren_level_depth_counter.len();\n\
    \    let mut paren_level_depth_counter_pos = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_size = paren_level_depth_counter_pos.len();\n\
    \    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_level_depth_counter_pos_index\
    \ = 0;\n    let mut paren_level_depth_counter_pos_index = 0;\n    let mut paren_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl5an0hn5.rs:46:19\n   |\n\
    46 |     let mut paren_\n   |                   ^ help: add `;` here\n47 | }\n\
    \   | - unexpected token\n\nerror[E0689]: can't call method `len` on ambiguous\
    \ numeric type `{integer}`\n  --> /tmp/tmpl5an0hn5.rs:16:80\n   |\n16 |     let\
    \ mut paren_level_depth_counter_pos_size = paren_level_depth_counter_pos.len();\n\
    \   |                                                                        \
    \        ^^^\n   |\nhelp: you must specify a type for this binding, like `i32`\n\
    \   |\n14 |     let mut paren_level_depth_counter_pos: i32 = 0;\n   |        \
    \ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpl5an0hn5.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppo59uo84.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5i5q7iq_.rs:50:18\n   |\n\
    50 |     let mut paren\n   |                  ^ help: add `;` here\n51 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5i5q7iq_.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_level = 0;\n    let mut paren_level_depth\
    \ = Vec::new();\n    let mut paren_level_level = 0;\n    let mut paren_level_level_depth\
    \ = Vec::new();\n    let mut paren_level_level_level = 0;\n    let mut paren_level_level_level_level\
    \ = 0;\n    let mut paren_level_level_level_level_level = 0;\n    let mut paren_level_level_level_level_level_level\
    \ = 0;\n    let mut paren_level_level_level_level_level_level_level = 0;\n   \
    \ let mut paren_level_level_level_level_level_level_level_level = 0;\n    let\
    \ mut paren_level_level_level_level_level_level_level_level = 0;\n    let mut\
    \ paren_level_level_level_level_level_level_level_level = 0;\n    let mut paren_level_level_level_level_level_level_level_level\
    \ = 0;\n    let mut paren_level_level_level_level_level_level_level_level = 0;\n\
    \    let mut paren_level_level_level_level_level_level_level_level = 0;\n    let\
    \ mut paren_level_level_level_level_level_level_level_level = 0;\n    let mut\
    \ paren_level_level_level_level_level_level_level_level = 0;\n    let mut paren_level_level_level_level_level_level_level_level\
    \ = 0;\n    let mut paren_level_level_level_level_level_level_level_level = 0;\n\
    \    let mut paren_level_level_level_level_level_level_level_level = 0;\n    let\
    \ mut paren_level_level_level_level_level_level_level_level = 0;\n    let mut\
    \ paren_level_level_level_level_level_level_level_level = 0;\n    let mut paren_level_level_level_level_level_level_level_level_level\
    \ = 0;\n    let mut paren_level_level_level_level_level_level_level_level_level\
    \ = 0;\n    let mut paren_level_level_level_level_level_level_level_level = 0;\n\
    \    let mut paren_level_level_level_level_level_level_level = 0;\n    let mut\
    \ paren_level_level_level_level_level_level_level_level = 0;\n    let mut paren_level_level_level_level_level_level_level_level\
    \ = 0;\n    let mut paren_level_level_level_level_level_level_level_level = 0;\n\
    \    let mut paren_level_level_level_level_level_level_level_level = 0;\n    let\
    \ mut paren_level_level_level_level_level_level_level_level = 0;\n    let mut\
    \ paren_level_level_level_level_level_level_level_level = 0;\n    let mut paren_level_level_level_level_level_level_level_level\
    \ = 0;\n    let mut paren_level_level_level_level_level_level_level_level = 0;\n\
    \    let mut paren_level_level_level_level_level_level_level_level\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu22uppny.rs:43:66\n   |\n\
    43 |     let mut paren_level_level_level_level_level_level_level_level\n   | \
    \                                                                 ^ help: add\
    \ `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpu22uppny.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = vec![];\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char = 0;\n    let mut paren_level_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_count = 0;\n    let mut paren_level_char_pos_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char = 0;\n    let\
    \ mut paren_level_char_pos_char_pos_char_pos_char_pos = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char = 0;\n\
    \    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos = 0;\n \
    \   let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_count = 0;\n\
    \    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char = 0;\n\
    \    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnu50oq_d.rs:38:48\n   |\n\
    38 |     let mut paren_level_char_pos_char_pos_char_\n   |                   \
    \                             ^ help: add `;` here\n39 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnu50oq_d.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_indexes:\
    \ Vec<isize> = Vec::new();\n    let mut paren_level_indexes_len = 0;\n    let\
    \ mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_indexes\
    \ = 0;\n    let mut paren_level_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexes_len\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_index = 0;\n    let mut\
    \ paren_level_indexes_len_indexes_len_indexes = 0;\n    let mut paren_level_indexes_len_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len = 0;\n   \
    \ let mut paren_level_indexes_len_indexes_len_indexes_len_index = 0;\n    let\
    \ mut paren_level_indexes_len_indexes_len_indexes_len_indexes = 0;\n    let mut\
    \ paren_level_indexes_len_indexes_len_indexes_len_indexe = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes_\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_li07qvb.rs:34:45\n   |\n\
    34 |     let mut paren_level_indexes_len_indexes_\n   |                      \
    \                       ^ help: add `;` here\n35 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp_li07qvb.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdk2lxcnp.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpaob4li6b.rs:38:1\n  \
    \ |\n38 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    for paren in paren_string.chars() {\n \
    \       if paren == '(' {\n            paren_stack.push(paren_level);\n      \
    \      paren_level += 1;\n        } else if paren == ')' {\n            paren_level\
    \ -= 1;\n            if paren_level == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpifgr9nrv.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2rj21ub7.rs:37:32\n   |\n\
    37 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp2rj21ub7.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut paren_depth\
    \ = 0;\n    for paren in paren_string.chars() {\n        if paren == '(' {\n \
    \           paren_depth += 1;\n            paren_stack.push(paren_depth);\n  \
    \      } else if paren == ')' {\n            paren_depth -= 1;\n            if\
    \ paren_depth == 0 {\n                paren_stack.push(paren_depth);\n       \
    \     }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2, 0, 1, 2, 3, 0, 1, 0, 1, 2, 3, 2, 2, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmps1vbr2vb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr98hrsnt.rs:35:27\n   |\n\
    35 |     let mut paren_nesting_\n   |                           ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpr98hrsnt.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string_index = 0;\n    while paren_level_string_index\
    \ < paren_string.len() {\n        let mut paren_level_string = paren_string;\n\
    \        let mut paren_level_string_index = 0;\n        while paren_level_string_index\
    \ < paren_string.len() {\n            let mut paren_level_string = paren_string;\n\
    \            let mut paren_level_string_index = 0;\n            while paren_level_string_index\
    \ < paren_string.len() {\n                let mut paren_level_string = paren_string;\n\
    \                let mut paren_level_string_index = 0;\n                while\
    \ paren_level_string_index < paren_string.len() {\n                    let mut\
    \ paren_level_string = paren_string;\n                    let mut paren_level_string_index\
    \ = 0;\n                    while paren_level_string_index < paren_string.len()\
    \ {\n                        let mut paren_level_string = paren_string;\n    \
    \                    let mut paren_level_string_index = 0;\n                 \
    \       while paren_level_string_index < paren_string.len() {\n              \
    \              let mut paren_level_string = paren_string;\n                  \
    \          let mut paren_level_string_index = 0;\n                           \
    \ while paren_level_string_index < paren_string.len() {\n                    \
    \            let mut paren_level_string = paren_string;\n                    \
    \            let mut paren_level_string_index = 0;\n                         \
    \       while paren_level_string_index < paren_string.len() {\n              \
    \                      let mut paren_level_string = paren_string;\n          \
    \                          let mut paren_level_string_index = 0;\n           \
    \                         while paren_level_string_index < paren_string.len()\
    \ {\n                                        let mut paren_level_string = paren_string;\n\
    \                                        let mut paren_level_string_index = 0;\n\
    \                                        while paren_level_string_index < paren_string.len()\
    \ {\n                                            let mut paren_level_string =\
    \ paren_string;\n                                            let mut paren_level_string_index\
    \ = 0;\n                                            if paren_level_string == \"\
    (\" || paren_level_string == \"{\" || paren_level_string == \"[\"\n          \
    \                                      || paren_level_string == \"(\" || paren_level_string\
    \ == \"{\" || paren_level_string == \"[\"\n                                  \
    \              || paren_level_string == \"(\" || paren_level_string == \"{\" ||\
    \ paren_level_string == \"[\"\n                                              \
    \  || paren_level_string == \"(\" || paren_level_string == \"{\" || paren_level_string\
    \ == \"\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp2tk56luy.rs:52:54\n\
    \   |\n52 |       assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n\
    \   |  ______________________________________________________^\n53 | | }\n   |\
    \ |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.chars().enumerate().filter(|(_,\
    \ c)| c != '(' && c != ')').collect::<Vec<_>>();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.into_iter().map(|(_, c)| paren_level += 1).collect::<Vec<_>>();\n\
    \    let mut paren_levels_iter = paren_levels_iter.into_iter().map(|(_, c)| if\
    \ c == '(' {\n        paren_level += 1;\n        paren_level\n    } else {\n \
    \       paren_level -= 1;\n        paren_level\n    }).collect::<Vec<_>>();\n\
    \    let mut paren_levels_iter = paren_levels_iter.into_iter().map(|(_, c)| if\
    \ c == ')' {\n        paren_level -= 1;\n        paren_level\n    } else {\n \
    \       paren_level += 1;\n        paren_level\n    }).collect::<Vec<_>>();\n\
    \    let mut paren_levels_iter = paren_levels_iter.into_iter().map(|(_, c)| if\
    \ c == '(' {\n        paren_level += 1;\n        paren_level\n    } else {\n \
    \       paren_level -= 1;\n        paren_level\n    }).collect::<Vec<_>>();\n\
    \    let mut paren_levels_iter = paren_levels_iter.into_iter().map(|(_, c)| if\
    \ c == ')' {\n        paren_level -= 1;\n        paren_level\n    } else {\n \
    \       paren_level += 1;\n        paren_level\n    }).collect::<Vec<_>>();\n\
    \    let mut paren_levels_iter = paren_levels_iter.into_iter().map(|(_, c)| if\
    \ c == '(' {\n        paren_level += 1;\n        paren_level\n    } else {\n \
    \       paren_level -= 1;\n        paren_level\n    }).collect::<Vec<_>>();\n\
    \    let mut paren_levels_iter = paren_levels_iter.into_iter().map(|(_, c)| if\
    \ c == ')' {\n        paren_level -= 1;\n        paren_level\n    } else {\n \
    \       paren_level += 1;\n        paren_level\n    }).collect::<Vec<_>>();\n\
    \    let mut paren_levels_iter = paren_levels_iter.into_iter().map(|(_, c)| if\
    \ c == '(' {\n        \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp27mwtjs6.rs:62:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n53 |     let mut paren_levels_iter = paren_levels_iter.into_iter().map(|(_,\
    \ c)| if c == '(' {\n   |                                                    \
    \              - unclosed delimiter\n...\n62 | }\n   |   ^\n\nerror: expected\
    \ one of `)`, `,`, `.`, `?`, `else`, or an operator, found keyword `fn`\n  -->\
    \ /tmp/tmp27mwtjs6.rs:57:1\n   |\n55 | }\n   |  - expected one of `)`, `,`, `.`,\
    \ `?`, `else`, or an operator\n56 | \n57 | fn main() {\n   | ^^ unexpected token\n\
    \nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: -1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().rev();\n \
    \   let mut paren_levels_iter_next = paren_levels_iter.next();\n    while paren_levels_iter_next.is_some()\
    \ {\n        let mut paren_level = paren_level + 1;\n        let mut paren_levels_iter_next\
    \ = paren_levels_iter.next();\n        while paren_levels_iter_next.is_some()\
    \ {\n            let mut paren_level = paren_level + 1;\n            let mut paren_levels_iter_next\
    \ = paren_levels_iter.next();\n        }\n        paren_levels.push(paren_level);\n\
    \    }\n    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659748338
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut paren_level\
    \ = 0;\n    for paren in paren_string.chars() {\n        if paren == '(' {\n \
    \           paren_stack.push(paren_level);\n            paren_level += 1;\n  \
    \      } else if paren == ')' {\n            paren_level -= 1;\n            if\
    \ paren_level == 0 {\n                paren_stack.push(paren_level);\n       \
    \     }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpik2exgmz.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_len;\n    let mut paren_level\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprhqemx9x.rs:35:24\n   |\n\
    35 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmprhqemx9x.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = Vec::new();\n    let mut paren_level_max_count\
    \ = Vec::new();\n    let mut paren_level_max_count_index = Vec::new();\n    let\
    \ mut paren_level_max_count_index2 = Vec::new();\n    let mut paren_level_max_count_index3\
    \ = Vec::new();\n    let mut paren_level_max_count_index4 = Vec::new();\n    let\
    \ mut paren_level_max_count_index5 = Vec::new();\n    let mut paren_level_max_count_index6\
    \ = Vec::new();\n    let mut paren_level_max_count_index7 = Vec::new();\n    let\
    \ mut paren_level_max_count_index8 = Vec::new();\n    let mut paren_level_max_count_index9\
    \ = Vec::new();\n    let mut paren_level_max_count_index10 = Vec::new();\n   \
    \ let mut paren_level_max_count_index11 = Vec::new();\n    let mut paren_level_max_count_index12\
    \ = Vec::new();\n    let mut paren_level_max_count_index13 = Vec::new();\n   \
    \ let mut paren_level_max_count_index14 = Vec::new();\n    let mut paren_level_max_count_index15\
    \ = Vec::new();\n    let mut paren_level_max_count_index16 = Vec::new();\n   \
    \ let mut paren_level_max_count_index17 = Vec::new();\n    let mut paren_level_max_count_index18\
    \ = Vec::new();\n    let mut paren_level_max_count_index19 = Vec::new();\n   \
    \ let mut paren_level_max_count_index20 = Vec::new();\n    let mut paren_level_max_count_index21\
    \ = Vec::new();\n    let mut paren_level_max_count_index22 = Vec::new();\n   \
    \ let mut paren_level_max_count_index23 = Vec::new();\n    let mut paren_level_max_count_index24\
    \ = Vec::new();\n    let mut paren_level_max_count_index25 = Vec::new();\n   \
    \ let mut paren_level_max_count_index26 = Vec::new();\n    let mut paren_level_max_count_index27\
    \ = Vec::new();\n    let mut paren_level_max_count_index28 = Vec::new();\n   \
    \ let mut paren_level_max_count_index29 = Vec::new();\n    let mut paren_level_max_count_index30\
    \ = Vec::new();\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpij4z_pkz.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5kg54n7h.rs:50:18\n   |\n\
    50 |     let mut paren\n   |                  ^ help: add `;` here\n51 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp5kg54n7h.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_chars = vec![];\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphidcl4w7.rs:50:25\n   |\n\
    50 |     let mut paren_level_\n   |                         ^ help: add `;` here\n\
    51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmphidcl4w7.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_count_prev = 0;\n    let mut paren_level_char_pos_count_prev2\
    \ = 0;\n    let mut paren_level_char_pos_count_prev3 = 0;\n    let mut paren_level_char_pos_count_prev4\
    \ = 0;\n    let mut paren_level_char_pos_count_prev5 = 0;\n    let mut paren_level_char_pos_count_prev6\
    \ = 0;\n    let mut paren_level_char_pos_count_prev7 = 0;\n    let mut paren_level_char_pos_count_prev8\
    \ = 0;\n    let mut paren_level_char_pos_count_prev9 = 0;\n    let mut paren_level_char_pos_count_prev10\
    \ = 0;\n    let mut paren_level_char_pos_count_prev11 = 0;\n    let mut paren_level_char_pos_count_prev12\
    \ = 0;\n    let mut paren_level_char_pos_count_prev13 = 0;\n    let mut paren_level_char_pos_count_prev14\
    \ = 0;\n    let mut paren_level_char_pos_count_prev15 = 0;\n    let mut paren_level_char_pos_count_prev16\
    \ = 0;\n    let mut paren_level_char_pos_count_prev17 = 0;\n    let mut paren_level_char_pos_count_prev18\
    \ = 0;\n    let mut paren_level_char_pos_count_prev19 = 0;\n    let mut paren_level_char_pos_count_prev20\
    \ = 0;\n    let mut paren_level_char_pos_count_prev21 = 0;\n    let mut paren_level_char_pos_count_prev22\
    \ = 0;\n    let mut paren_level_char_pos_count_prev23 = 0;\n    let mut paren_level_char_pos_count_prev24\
    \ = 0;\n    let mut paren_level_char_pos_count_prev25 = 0;\n    let mut paren_level_char_pos_count_prev26\
    \ = 0;\n    let mut paren_level_char_pos_count_prev27 = 0;\n    let mut paren_level_char_pos_count_prev28\
    \ = 0;\n    let mut paren_level_char_pos_count_prev29 = 0;\n    let mut paren_level_char_pos_count_prev30\
    \ = 0;\n    let mut paren_level_char_pos_count_prev31 = 0;\n    let mut paren_level_char_pos_count_prev32\
    \ = 0;\n    let mut paren_level_char_pos_count_prev33 = 0;\n    let mut paren_level_char_pos_count_prev34\
    \ = 0;\n    let mut paren_level_char_pos_count_prev35 = 0;\n    let mut \n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpsty5bxf8.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level = 0;\n    let mut paren_level_count = vec![];\n    let mut\
    \ paren_level_max_count = vec![];\n    let mut paren_level_max_count_index = -1;\n\
    \    let mut paren_level_max_count_index2 = -1;\n    let mut paren_level_max_count_index3\
    \ = -1;\n    let mut paren_level_max_count_index4 = -1;\n    let mut paren_level_max_count_index5\
    \ = -1;\n    let mut paren_level_max_count_index6 = -1;\n    let mut paren_level_max_count_index7\
    \ = -1;\n    let mut paren_level_max_count_index8 = -1;\n    let mut paren_level_max_count_index9\
    \ = -1;\n    let mut paren_level_max_count_index10 = -1;\n    let mut paren_level_max_count_index11\
    \ = -1;\n    let mut paren_level_max_count_index12 = -1;\n    let mut paren_level_max_count_index13\
    \ = -1;\n    let mut paren_level_max_count_index14 = -1;\n    let mut paren_level_max_count_index15\
    \ = -1;\n    let mut paren_level_max_count_index16 = -1;\n    let mut paren_level_max_count_index17\
    \ = -1;\n    let mut paren_level_max_count_index18 = -1;\n    let mut paren_level_max_count_index19\
    \ = -1;\n    let mut paren_level_max_count_index20 = -1;\n    let mut paren_level_max_count_index21\
    \ = -1;\n    let mut paren_level_max_count_index22 = -1;\n    let mut paren_level_max_count_index23\
    \ = -1;\n    let mut paren_level_max_count_index24 = -1;\n    let mut paren_level_max_count_index25\
    \ = -1;\n    let mut paren_level_max_count_index26 = -1;\n    let mut paren_level_max_count_index27\
    \ = -1;\n    let mut paren_level_max_count_index28 = -1;\n    let mut paren_level_max_count_index29\
    \ = -1;\n    let mut paren_level_max_count_index30 = -1;\n    let mut paren_level_max_count_index31\
    \ = -1;\n    let mut paren_level_max_count_index32 = -1;\n    let mut paren_level_max_count_index33\
    \ = -1;\n    let mut paren_level_max_count_index34 = -1;\n    let mut paren_level_max_count_index35\
    \ = -1;\n    let mut paren_level_max_count_index36 = -1;\n    let mut paren_level_max_count_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp98f1gu0h.rs:47:35\n   |\n\
    47 |     let mut paren_level_max_count_\n   |                                \
    \   ^ help: add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp98f1gu0h.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm4iwxh7r.rs:38:26\n   |\n\
    38 |     let mut paren_levels_\n   |                          ^ help: add `;`\
    \ here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpm4iwxh7r.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_char_count_in_paren = 0;\n    let mut paren_level_char_count_in_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren =\
    \ 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren\
    \ = 0;\n    let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl15zvc6w.rs:26:159\n   |\n\
    26 |     let mut paren_level_char_count_in_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_paren_after_\n\
    \   |                                                                        \
    \                                                                            \
    \           ^ help: add `;` here\n27 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpl15zvc6w.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5o4jl_vd.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5o4jl_vd.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_level = 0;\n    let mut paren_level_count\
    \ = paren_stack.len();\n    let mut paren_level_counts = paren_stack.clone();\n\
    \    let mut paren_level_counts_len = paren_level_counts.len();\n    let mut paren_level_counts_len\
    \ = paren_level_counts_len.saturating_add((paren_level_counts_len as usize));\n\
    \    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n    let mut paren_level_count\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp9zzacnu.rs:27:30\n   |\n\
    27 |     let mut paren_level_count\n   |                              ^ help:\
    \ add `;` here\n28 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses\
    \ around method argument\n  --> /tmp/tmpp9zzacnu.rs:13:76\n   |\n13 |     let\
    \ mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n   |                                                          \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmpp9zzacnu.rs:14:76\n   |\n\
    14 |     let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n   |                                                          \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpp9zzacnu.rs:15:76\n\
    \   |\n15 |     let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n   |                                                          \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpp9zzacnu.rs:16:76\n\
    \   |\n16 |     let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n   |                                                          \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpp9zzacnu.rs:17:76\n\
    \   |\n17 |     let mut paren_level_counts_len = paren_level_counts_len.saturating_add((paren_level_counts_len\
    \ as usize));\n   |                                                          \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n\
    \nwarning: unnecessary parenth"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5o4jl_vd.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5o4jl_vd.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo94cdj3d.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpo94cdj3d.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string_index = 0;\n    let mut paren_level_char: char;\n\
    \    let mut paren_level_char_next: char;\n    let mut paren_level_char_next_index\
    \ = 0;\n    let mut paren_level_char_next_index2 = 0;\n    let mut paren_level_char_next_index3\
    \ = 0;\n    let mut paren_level_char_next_index4 = 0;\n    let mut paren_level_char_next_index5\
    \ = 0;\n    let mut paren_level_char_next_index6 = 0;\n    let mut paren_level_char_next_index7\
    \ = 0;\n    let mut paren_level_char_next_index8 = 0;\n    let mut paren_level_char_next_index9\
    \ = 0;\n    let mut paren_level_char_next_index10 = 0;\n    let mut paren_level_char_next_index11\
    \ = 0;\n    let mut paren_level_char_next_index12 = 0;\n    let mut paren_level_char_next_index13\
    \ = 0;\n    let mut paren_level_char_next_index14 = 0;\n    let mut paren_level_char_next_index15\
    \ = 0;\n    let mut paren_level_char_next_index16 = 0;\n    let mut paren_level_char_next_index17\
    \ = 0;\n    let mut paren_level_char_next_index18 = 0;\n    let mut paren_level_char_next_index19\
    \ = 0;\n    let mut paren_level_char_next_index20 = 0;\n    let mut paren_level_char_next_index21\
    \ = 0;\n    let mut paren_level_char_next_index22 = 0;\n    let mut paren_level_char_next_index23\
    \ = 0;\n    let mut paren_level_char_next_index24 = 0;\n    let mut paren_level_char_next_index25\
    \ = 0;\n    let mut paren_level_char_next_index26 = 0;\n    let mut paren_level_char_next_index27\
    \ = 0;\n    let mut paren_level_char_next_index28 = 0;\n    let mut paren_level_char_next_index29\
    \ = 0;\n    let mut paren_level_char_next_index30 = 0;\n    let mut paren_level_char_next_index31\
    \ = 0;\n    let mut paren_level_char_next_index32 = 0;\n    let mut paren_level_char_next_index33\
    \ = 0;\n    let mut paren_level_char_next_index34 = 0;\n    let mut paren_level_char_next_index35\
    \ = 0;\n    let mut paren_level_char_next_index36 = 0;\n    let mut paren_level_char_next_index37\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkz2fxjnk.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n\
    \    let mut paren_levels_stack_size = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_level\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbe2lexbl.rs:31:24\n   |\n\
    31 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpbe2lexbl.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len()\
    \ - 1;\n    let mut paren_levels_stack_ptr_next = paren_levels_stack_ptr;\n  \
    \  let mut paren_levels_stack_ptr_prev = paren_levels_stack_ptr;\n    let mut\
    \ paren_levels_stack_ptr_next_prev = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_next_next_next_next_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmployqdcla.rs:29:56\n   |\n\
    29 |     let mut paren_levels_stack_ptr_next_next_next_next_\n   |           \
    \                                             ^ help: add `;` here\n30 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmployqdcla.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr = Vec::new();\n    let mut paren_levels_ptr_next\
    \ = Vec::new();\n    let mut paren_levels_ptr_next_ptr = Vec::new();\n    let\
    \ mut paren_levels_ptr_next_ptr_next = Vec::new();\n    let mut paren_levels_ptr_next_ptr_next_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_next_ptr_next_ptr_next = Vec::new();\n\
    \    let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr = Vec::new();\n    let\
    \ mut paren_levels_ptr_next_ptr_next_ptr_next_ptr_next = Vec::new();\n    let\
    \ mut paren_levels_ptr_next_ptr_next_ptr_next_ptr_next_ptr = Vec::new();\n   \
    \ let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next = Vec::new();\n\
    \    let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr = Vec::new();\n\
    \    let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next\
    \ = Vec::new();\n    let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next\
    \ = Vec::new();\n    let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdk_rzkix.rs:28:56\n   |\n\
    28 |     let mut paren_levels_ptr_next_ptr_next_ptr_next_ptr\n   |           \
    \                                             ^ help: add `;` here\n29 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdk_rzkix.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level = 0;\n    for paren in paren_string.chars() {\n        if\
    \ paren == '(' {\n            paren_stack.push(paren_level);\n            paren_level\
    \ += 1;\n        } else if paren == ')' {\n            paren_level -= 1;\n   \
    \         if paren_level == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpx7rqhlka.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels =\
    \ Vec::new();\n    let mut paren_level = 0;\n    let mut paren_levels_stack =\
    \ Vec::new();\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end = paren_levels_stack_ptr;\n  \
    \  let mut paren_levels_stack_ptr_end_ptr_end_ptr = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_stack_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr =\
    \ paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_stack_ptr;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2m8_miyp.rs:27:76\n   |\n\
    27 |     let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_\n\
    \   |                                                                        \
    \    ^ help: add `;` here\n28 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp2m8_miyp.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_depth = 0;\n    let mut paren_level_depth_max\
    \ = 0;\n    let mut paren_level_depth_max_index = 0;\n    let mut paren_level_depth_max_index2\
    \ = 0;\n    let mut paren_level_depth_max_index3 = 0;\n    let mut paren_level_depth_max_index4\
    \ = 0;\n    let mut paren_level_depth_max_index5 = 0;\n    let mut paren_level_depth_max_index6\
    \ = 0;\n    let mut paren_level_depth_max_index7 = 0;\n    let mut paren_level_depth_max_index8\
    \ = 0;\n    let mut paren_level_depth_max_index9 = 0;\n    let mut paren_level_depth_max_index10\
    \ = 0;\n    let mut paren_level_depth_max_index11 = 0;\n    let mut paren_level_depth_max_index12\
    \ = 0;\n    let mut paren_level_depth_max_index13 = 0;\n    let mut paren_level_depth_max_index14\
    \ = 0;\n    let mut paren_level_depth_max_index15 = 0;\n    let mut paren_level_depth_max_index16\
    \ = 0;\n    let mut paren_level_depth_max_index17 = 0;\n    let mut paren_level_depth_max_index18\
    \ = 0;\n    let mut paren_level_depth_max_index19 = 0;\n    let mut paren_level_depth_max_index20\
    \ = 0;\n    let mut paren_level_depth_max_index21 = 0;\n    let mut paren_level_depth_max_index22\
    \ = 0;\n    let mut paren_level_depth_max_index23 = 0;\n    let mut paren_level_depth_max_index24\
    \ = 0;\n    let mut paren_level_depth_max_index25 = 0;\n    let mut paren_level_depth_max_index26\
    \ = 0;\n    let mut paren_level_depth_max_index27 = 0;\n    let mut paren_level_depth_max_index28\
    \ = 0;\n    let mut paren_level_depth_max_index29 = 0;\n    let mut paren_level_depth_max_index30\
    \ = 0;\n    let mut paren_level_depth_max_index31 = 0;\n    let mut paren_level_depth_max_index32\
    \ = 0;\n    let mut paren_level_depth_max_index33 = 0;\n    let mut paren_level_depth_max_index34\
    \ = 0;\n    let mut paren_level_depth_max_index35 = 0;\n    let mut \n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpc8ns17zy.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvweo9_99.rs:41:18\n   |\n\
    41 |     let mut paren\n   |                  ^ help: add `;` here\n42 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvweo9_99.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr98hrsnt.rs:35:27\n   |\n\
    35 |     let mut paren_nesting_\n   |                           ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpr98hrsnt.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().rev();\n \
    \   let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq2dwuhvd.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9yhn3spe.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9yhn3spe.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5o4jl_vd.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5o4jl_vd.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpaob4li6b.rs:38:1\n  \
    \ |\n38 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels =\
    \ Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_size\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwc1qmfnp.rs:29:111\n   |\n\
    29 |     let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    \   |                                                                        \
    \                                       ^ help: add `;` here\n30 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwc1qmfnp.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_indexes: Vec<isize>\
    \ = vec![0];\n    let mut paren_level_indexes_len = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_indexes = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_indexe\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_indexes_len_index = 0;\n    let mut paren_level_indexes_len_index\
    \ = 0;\n    let mut paren_level_index\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbvs02z4h.rs:49:30\n   |\n\
    49 |     let mut paren_level_index\n   |                              ^ help:\
    \ add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpbvs02z4h.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7exhj8u3.rs:37:32\n   |\n\
    37 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp7exhj8u3.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = vec![];\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_char.len();\n    let mut paren_level_char_pos = 0;\n    let mut\
    \ paren_level_char_len = paren_level_char.len();\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n    let mut\
    \ paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpuoaorrnq.rs:49:1\n  \
    \ |\n49 | }\n   | ^ expected pattern\n\nerror[E0689]: can't call method `len`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpuoaorrnq.rs:14:53\n   |\n\
    14 |     let mut paren_level_char_len = paren_level_char.len();\n   |        \
    \                                             ^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpuoaorrnq.rs:16:53\n\
    \   |\n16 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpuoaorrnq.rs:18:53\n\
    \   |\n18 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpuoaorrnq.rs:20:53\n\
    \   |\n20 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpuoaorrnq.rs:22:53\n\
    \   |\n22 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_levels_len = paren_string.len();\n\
    \    let mut paren_levels_index = 0;\n    let mut paren_levels_index2 = 0;\n \
    \   let mut paren_levels_index3 = 0;\n    let mut paren_levels_index4 = 0;\n \
    \   let mut paren_levels_index5 = 0;\n    let mut paren_levels_index6 = 0;\n \
    \   let mut paren_levels_index7 = 0;\n    let mut paren_levels_index8 = 0;\n \
    \   let mut paren_levels_index9 = 0;\n    let mut paren_levels_index10 = 0;\n\
    \    let mut paren_levels_index11 = 0;\n    let mut paren_levels_index12 = 0;\n\
    \    let mut paren_levels_index13 = 0;\n    let mut paren_levels_index14 = 0;\n\
    \    let mut paren_levels_index15 = 0;\n    let mut paren_levels_index16 = 0;\n\
    \    let mut paren_levels_index17 = 0;\n    let mut paren_levels_index18 = 0;\n\
    \    let mut paren_levels_index19 = 0;\n    let mut paren_levels_index20 = 0;\n\
    \    let mut paren_levels_index21 = 0;\n    let mut paren_levels_index22 = 0;\n\
    \    let mut paren_levels_index23 = 0;\n    let mut paren_levels_index24 = 0;\n\
    \    let mut paren_levels_index25 = 0;\n    let mut paren_levels_index26 = 0;\n\
    \    let mut paren_levels_index27 = 0;\n    let mut paren_levels_index28 = 0;\n\
    \    let mut paren_levels_index29 = 0;\n    let mut paren_levels_index30 = 0;\n\
    \    let mut paren_levels_index31 = 0;\n    let mut paren_levels_index32 = 0;\n\
    \    let mut paren_levels_index33 = 0;\n    let mut paren_levels_index34 = 0;\n\
    \    let mut paren_levels_index35 = 0;\n    let mut paren_levels_index36 = 0;\n\
    \    let mut paren_levels_index37 = 0;\n    let mut paren_levels_index38 = 0;\n\
    \    let mut paren_levels_index39 = 0;\n    let mut paren_levels_index40 = 0;\n\
    \    let mut paren_levels_index41 = 0;\n    let mut paren_levels_index42 = 0;\n\
    \    let mut paren_levels_index43 = 0;\n    let mut paren\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_npkehyx.rs:54:18\n   |\n\
    54 |     let mut paren\n   |                  ^ help: add `;` here\n55 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_npkehyx.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo94cdj3d.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpo94cdj3d.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().filter_map(|i|\
    \ {\n        if paren_level == 0 {\n            paren_level += 1;\n          \
    \  Some(paren_level)\n        } else {\n            paren_level -= 1;\n      \
    \      None\n        }\n    });\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n    let\
    \ mut paren_levels_stack_iter = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n    let\
    \ mut paren_levels_stack_iter = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n    let\
    \ mut paren_levels_stack_iter = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n    let\
    \ mut paren_levels_stack_iter = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n    let\
    \ mut paren_levels_stack_iter = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_stack_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_stack_iter = paren\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaw0y3zgx.rs:42:44\n   |\n\
    42 |     let mut paren_levels_stack_iter = paren\n   |                       \
    \                     ^ help: add `;` here\n43 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `paren` in this scope\n  --> /tmp/tmpaw0y3zgx.rs:42:39\n\
    \   |\n42 |     let mut paren_levels_stack_iter = paren\n   |                \
    \                       ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpaw0y3zgx.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels =\
    \ Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr = Vec::new();\n    let mut paren_levels_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp122mq8s3.rs:30:112\n   |\n\
    30 |     let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new\n   |                                                           \
    \                                                     ^ help: add `;` here\n31\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp122mq8s3.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0vugtwr4.rs:37:26\n   |\n\
    37 |     let mut paren_levels_\n   |                          ^ help: add `;`\
    \ here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp0vugtwr4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_stack = vec![];\n\
    \    let mut paren_level_stack_len = paren_level_stack.len();\n    let mut paren_level_stack_top\
    \ = paren_level_stack.len();\n    let mut paren_level_stack_bottom = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack.len();\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack.len();\n    let mut paren_level_stack_top = paren_level_stack.len();\n\
    \    let mut paren_level_stack_bottom = paren_level_stack.len();\n    let mut\
    \ paren_level_stack_top = paren_level_stack.len();\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack.len();\n    let mut paren_level_stack_top = paren_level_stack.len();\n\
    \    let mut paren_level_stack_bottom = paren_level_stack.len();\n    let mut\
    \ paren_level_stack_top = paren_level_stack.len();\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack.len();\n    let mut paren_level_stack_top = paren_level_stack.len();\n\
    \    let mut paren_level_stack_bottom = paren_level_stack.len();\n    let mut\
    \ paren_level_stack_top = paren_level_stack.len();\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack.len();\n    let mut paren_level_stack_top = paren_level_stack.len();\n\
    \    let mut paren_level_stack_bottom = paren_level_stack.len();\n    let mut\
    \ paren_level_stack_top = paren_level_stack.len();\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack.len();\n    let mut paren_level_stack_top = paren_level_stack.len();\n\
    \    let mut paren_level_stack_bottom = paren_level_stack.len();\n    let mut\
    \ paren_level_stack_top = paren_level_stack.len();\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack.len();\n    let mut paren_level_stack_top = paren_level_stack.len();\n\
    \    let mut paren_level_stack_bottom = paren_level_stack.len();\n    let mut\
    \ paren_level_stack_top = paren_level_stack.len();\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack.len();\n    let mut paren_level_stack_top = paren_level_stack.len();\n\
    \    let mut paren_level_stack_bottom\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvhz2pm__.rs:41:37\n   |\n\
    41 |     let mut paren_level_stack_bottom\n   |                              \
    \       ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpvhz2pm__.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = vec![];\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_count = 0;\n    let mut paren_level_char_pos_char_count\
    \ = 0;\n    let mut paren_level_char_pos_chars = vec![];\n    let mut paren_level_char_pos_char_pos\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_count = 0;\n    let mut paren_level_char_pos_char_pos_char_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_chars = vec![];\n    let mut\
    \ paren_level_char_pos_char_pos_char_pos = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_count = 0;\n \
    \   let mut paren_level_char_pos_char_pos_char_pos_char_pos = 0;\n    let mut\
    \ paren_level_char_pos_char_pos_char_pos_char_pos_count = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos =\
    \ 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_count\
    \ = 0;\n    let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpep87uv66.rs:36:124\n   |\n\
    36 |     let mut paren_level_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_char_pos_\n\
    \   |                                                                        \
    \                                                    ^ help: add `;` here\n37\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpep87uv66.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmptjrfye8a.rs:31:1\n  \
    \ |\n31 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_len = 0;\n    let mut paren_levels_lens = Vec::new();\n\
    \    let mut paren_levels_lens_len = 0;\n    let mut paren_levels_lens_len2 =\
    \ 0;\n    let mut paren_levels_lens_len3 = 0;\n    let mut paren_levels_lens_len4\
    \ = 0;\n    let mut paren_levels_lens_len5 = 0;\n    let mut paren_levels_lens_len6\
    \ = 0;\n    let mut paren_levels_lens_len7 = 0;\n    let mut paren_levels_lens_len8\
    \ = 0;\n    let mut paren_levels_lens_len9 = 0;\n    let mut paren_levels_lens_len10\
    \ = 0;\n    let mut paren_levels_lens_len11 = 0;\n    let mut paren_levels_lens_len12\
    \ = 0;\n    let mut paren_levels_lens_len13 = 0;\n    let mut paren_levels_lens_len14\
    \ = 0;\n    let mut paren_levels_lens_len15 = 0;\n    let mut paren_levels_lens_len16\
    \ = 0;\n    let mut paren_levels_lens_len17 = 0;\n    let mut paren_levels_lens_len18\
    \ = 0;\n    let mut paren_levels_lens_len19 = 0;\n    let mut paren_levels_lens_len20\
    \ = 0;\n    let mut paren_levels_lens_len21 = 0;\n    let mut paren_levels_lens_len22\
    \ = 0;\n    let mut paren_levels_lens_len23 = 0;\n    let mut paren_levels_lens_len24\
    \ = 0;\n    let mut paren_levels_lens_len25 = 0;\n    let mut paren_levels_lens_len26\
    \ = 0;\n    let mut paren_levels_lens_len27 = 0;\n    let mut paren_levels_lens_len28\
    \ = 0;\n    let mut paren_levels_lens_len29 = 0;\n    let mut paren_levels_lens_len30\
    \ = 0;\n    let mut paren_levels_lens_len31 = 0;\n    let mut paren_levels_lens_len32\
    \ = 0;\n    let mut paren_levels_lens_len33 = 0;\n    let mut paren_levels_lens_len34\
    \ = 0;\n    let mut paren_levels_lens_len35 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4j3jqcz1.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_nesting_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_nesting_levels_stack\
    \ = Vec::new();\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n\
    \    let mut paren_nesting_levels_stack_size = paren_nesting_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_nesting_levels_stack_pos\
    \ = paren_nesting_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_nesting_levels_stack_top = paren_nesting_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_nesting_levels_stack_bottom = paren_nesting_levels_stack.len();\n    let\
    \ mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut paren_nesting_levels_stack_bottom\
    \ = paren_nesting_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_nesting_levels_stack_top = paren_nesting_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_nesting_levels_stack_bottom = paren_nesting_levels_stack.len();\n    let\
    \ mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut paren_nesting_levels_stack_bottom\
    \ = paren_nesting_levels_stack.len();\n    let mut paren_levels_stack_bottom =\
    \ paren_levels_stack.len();\n    let mut paren_nesting_levels_stack_bottom = paren_nesting_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_nesting_levels_stack_top\
    \ = paren_nesting_levels_stack.len();\n    let mut paren_levels_stack_bottom =\
    \ paren_levels_stack.len();\n    let mut paren_nesting_levels_stack_bottom = paren_nesting_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpye8p84qz.rs:35:38\n   |\n\
    35 |     let mut paren_levels_stack_bottom\n   |                             \
    \         ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpye8p84qz.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7exhj8u3.rs:37:32\n   |\n\
    37 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp7exhj8u3.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().rev();\n \
    \   let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = \n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpijk6m9re.rs:37:1\n\
    \   |\n37 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().filter_map(|(_,\
    \ index)| {\n        if paren_level == 0 {\n            paren_level += 1;\n  \
    \          paren_levels.push(paren_level);\n            Some(index)\n        }\
    \ else {\n            Some(index)\n        }\n    });\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp60811eck.rs:43:19\n   |\n\
    43 |     let mut paren_\n   |                   ^ help: add `;` here\n44 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp60811eck.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo94cdj3d.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpo94cdj3d.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n\
    \    let mut paren_level_max_count: isize = 0;\n    let mut paren_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_count: isize = 0;\n    let mut\
    \ paren_level_max_level_max_count: isize = 0;\n    let mut paren_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_count: isize = 0;\n\
    \    let mut paren_level_max_level_max_level_max_level: isize = 0;\n    let mut\
    \ paren_level_max_level_max_level_max_level_count: isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level:\
    \ isize = 0;\n    let mut paren_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_max_level_count:\
    \ isize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7oxf3g5c.rs:32:11\n   |\n\
    32 |     let mu\n   |           ^ help: add `;` here\n33 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7oxf3g5c.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr98hrsnt.rs:35:27\n   |\n\
    35 |     let mut paren_nesting_\n   |                           ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpr98hrsnt.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            paren_level += 1;\n            paren_level_count\
    \ += 1;\n        } else if paren == ')' {\n            paren_level -= 1;\n   \
    \         paren_level_count += 1;\n            if paren_level == 0 {\n       \
    \         paren_levels.push(paren_level_count);\n            }\n        }\n  \
    \  }\n    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 12, 14, 24]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpoetda3gr.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n\
    \    for paren in paren_string.chars() {\n        if paren == '(' {\n        \
    \    paren_stack.push(paren_level);\n            paren_level_count = 1;\n    \
    \    } else if paren == ')' {\n            paren_level_count = paren_stack.pop();\n\
    \            if paren_level_count == 0 {\n                paren_level_count =\
    \ 1;\n            }\n            paren_level += paren_level_count;\n        }\n\
    \    }\n    paren_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3zw22mha.rs:15:33\n   |\n\
    15 |             paren_level_count = paren_stack.pop();\n   |                \
    \                 ^^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n  \
    \ |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3zw22mha.rs:22:5\n   |\n6  | fn\
    \ parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |            \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n22 |     paren_level\n   |     ^^^^^^^^^^^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_start\
    \ = paren_string.chars().nth(paren_level).unwrap();\n    let mut paren_level_end\
    \ = paren_level_start;\n    let mut paren_level_char = paren_level_start.chars().nth(0).unwrap();\n\
    \    let mut paren_level_char_next = paren_level_char;\n    let mut paren_level_char_prev\
    \ = paren_level_char;\n    let mut paren_level_char_next_next = paren_level_char;\n\
    \    let mut paren_level_char_next_prev = paren_level_char;\n    let mut paren_level_char_prev_next\
    \ = paren_level_char;\n    let mut paren_level_char_prev_prev = paren_level_char;\n\
    \    let mut paren_level_char_next_next_next = paren_level_char;\n    let mut\
    \ paren_level_char_next_next_prev = paren_level_char;\n    let mut paren_level_char_next_prev_next\
    \ = paren_level_char;\n    let mut paren_level_char_next_prev_prev = paren_level_char;\n\
    \    let mut paren_level_char_prev_next_next = paren_level_char;\n    let mut\
    \ paren_level_char_prev_next_prev = paren_level_char;\n    let mut paren_level_char_prev_prev_next\
    \ = paren_level_char;\n    let mut paren_level_char_prev_prev_prev = paren_level_char;\n\
    \    let mut paren_level_char_next_next_next_next = paren_level_char;\n    let\
    \ mut paren_level_char_next_next_next_prev = paren_level_char;\n    let mut paren_level_char_next_next_prev_next\
    \ = paren_level_char;\n    let mut paren_level_char_next_next_prev_prev = paren_level_char;\n\
    \    let mut paren_level_char_next_prev_next_next = paren_level_char;\n    let\
    \ mut paren_level_char_next_prev_next_prev = paren_level_char;\n    let mut paren_level_char_prev_next_next_next\
    \ = paren_level_char;\n    let mut paren_level_char_prev_next_next_prev = paren_level_char;\n\
    \    let mut paren_level_char_prev_next_prev_next = paren_level_char;\n    let\
    \ mut paren_level_char_prev_next_prev_prev = paren_level_char;\n    let mut paren_level_char_prev_prev_next_next\
    \ = paren_level_char;\n    let mut paren_level_char_prev_prev_next_prev = paren_level_char;\n\
    \    let mut paren_level_char_prev_prev_prev_next = paren\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsw2abner.rs:39:57\n   |\n\
    39 |     let mut paren_level_char_prev_prev_prev_next = paren\n   |          \
    \                                               ^ help: add `;` here\n40 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `paren` in this scope\n\
    \  --> /tmp/tmpsw2abner.rs:39:52\n   |\n39 |     let mut paren_level_char_prev_prev_prev_next\
    \ = paren\n   |                                                    ^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `chars` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpsw2abner.rs:12:50\n   |\n12 |     let mut\
    \ paren_level_char = paren_level_start.chars().nth(0).unwrap();\n   |        \
    \                                          ^^^^^ method not found in `char`\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpsw2abner.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos_end\
    \ = 0;\n    let mut paren_level_char_pos_start = 0;\n    let mut paren_level_char_pos_start_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end = 0;\n    let mut paren_level_char_pos_start_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end = 0;\n    let mut\
    \ paren_level_char_pos_start_end_end_end_end_end = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end = 0;\n\
    \    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end = 0;\n\
    \    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end =\
    \ 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = 0;\n    let mut paren_level_char_pos_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyxdqdljn.rs:36:34\n   |\n\
    36 |     let mut paren_level_char_pos_\n   |                                 \
    \ ^ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpyxdqdljn.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_nesting_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_nesting_levels_stack\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = paren_levels_stack.as_mut_ptr();\n\
    \    let mut paren_nesting_levels_stack_ptr = paren_nesting_levels_stack.as_mut_ptr();\n\
    \    let mut paren_levels_stack_ptr_next = paren_levels_stack_ptr.offset(1);\n\
    \    let mut paren_nesting_levels_stack_ptr_next = paren_nesting_levels_stack_ptr.offset(1);\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_nesting_levels_stack_ptr_end = paren_nesting_levels_stack_ptr.offset(paren_nesting_levels_stack.len());\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_nesting_levels_stack_ptr_end = paren_nesting_levels_stack_ptr.offset(paren_nesting_levels_stack.len());\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_nesting_levels_stack_ptr_end = paren_nesting_levels_stack_ptr.offset(paren_nesting_levels_stack.len());\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_nesting_levels_stack_ptr_end = paren_nesting_levels_stack_ptr.offset(paren_nesting_levels_stack.len());\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_nesting_levels_stack_ptr_end = paren_nesting_levels_stack_ptr.offset(paren_nesting_levels_stack.len());\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack.len());\n\
    \    let mut paren_nesting_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpe5ysxqlj.rs:28:27\n   |\n\
    28 |     let mut paren_nesting_\n   |                           ^ help: add `;`\
    \ here\n29 | }\n   | - unexpected token\n\nwarning: type annotations needed\n\
    \  --> /tmp/tmpe5ysxqlj.rs:15:66\n   |\n15 |     let mut paren_levels_stack_ptr_next\
    \ = paren_levels_stack_ptr.offset(1);\n   |                                  \
    \                                ^^^^^^\n   |\n   = note: `#[warn(tyvar_behind_raw_pointer)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2018!\n   = note: for more information, see issue\
    \ #46906 <https://github.com/rust-lang/rust/issues/46906>\n\nwarning: type annotations\
    \ needed\n  --> /tmp/tmpe5ysxqlj.rs:16:82\n   |\n16 |     let mut paren_nesting_levels_stack_ptr_next\
    \ = paren_nesting_levels_stack_ptr.offset(1);\n   |                          \
    \                                                        ^^^^^^\n   |\n   = warning:\
    \ this is accepted in the current edition (Rust 2015) but is a hard error in Rust\
    \ 2018!\n   = note: for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n\
    \nwarning: type annotations needed\n  --> /tmp/tmpe5ysxqlj.rs:17:65\n   |\n17\
    \ |     let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack.len());\n\
    \   |                                                                 ^^^^^^\n\
    \   |\n   = warning: this is accepted in the current edition (Rust 2015) but is\
    \ a hard error in Rust 2018!\n   = note: for more information, see issue #46906\
    \ <https://github.com/rust-lang/rust/issues/46906>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe5ysxqlj.rs:17:72\n   |\n17 |     let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack.len());\n   |           \
    \                                                             ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |     let mut\
    \ paren_levels_stack_ptr_end = "
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_curr = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_curr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_curr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_curr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_curr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_curr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_curr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_curr = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_curr = paren_levels_stack.len();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1conzc2_.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr98hrsnt.rs:35:27\n   |\n\
    35 |     let mut paren_nesting_\n   |                           ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpr98hrsnt.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbyflqwxn.rs:29:71\n   |\n\
    29 |     let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    \   |                                                                       ^\
    \ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpbyflqwxn.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n\
    \    let mut paren_levels: Vec<isize> = Vec::new();\n    let mut paren_levels_stack:\
    \ Vec<isize> = Vec::new();\n    let mut paren_levels_stack_pointer = 0;\n    let\
    \ mut paren_levels_stack_pointer_max = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_pointer_max_index = 0;\n    let mut paren_levels_stack_pointer_max_value\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pointer_max_value_index\
    \ = 0;\n    let mut paren_levels_stack_pointer_max_value_len = 0;\n    let mut\
    \ paren_levels_stack_pointer_max_value_len_index = 0;\n    let mut paren_levels_stack_pointer_max_value_len_value\
    \ = 0;\n    let mut paren_levels_stack_pointer_max_value_len_value_index = 0;\n\
    \    let mut paren_levels_stack_pointer_max_value_len_value_value = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_index = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_value = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_index = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_value = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_index = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_value = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_index = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_value = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_index = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_value = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_index = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_value = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_index = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_value = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_index = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_len_value_value_value = 0;\n    let\
    \ mut paren_levels_stack_pointer_max_value_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsnp6oq5_.rs:37:50\n   |\n\
    37 |     let mut paren_levels_stack_pointer_max_value_\n   |                 \
    \                                 ^ help: add `;` here\n38 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsnp6oq5_.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmprn4sdvnv.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_levels_stack = vec![];\n\
    \    let mut paren_levels_stack_count = 0;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack_count;\n    let mut paren_levels_stack_bottom = paren_levels_stack_count;\n\
    \    let mut paren_levels_stack_top = paren_levels_stack_count;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_count;\n    let mut paren_levels_stack_top = paren_levels_stack_count;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_count;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_count;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_count;\n    let mut paren_levels_stack_top = paren_levels_stack_count;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_count;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_count;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_count;\n    let mut paren_levels_stack_top = paren_levels_stack_count;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_count;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_count;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_count;\n    let mut paren_levels_stack_top = paren_levels_stack_count;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_count;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_count;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_count;\n    let mut paren_levels_stack_top = paren_levels_stack_count;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_count;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_count;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_count;\n    let mut paren_levels_stack_top = paren_levels_stack_count;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_count;\n    let mut\
    \ paren_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpe2w6e1wf.rs:38:19\n   |\n\
    38 |     let mut paren_\n   |                   ^ help: add `;` here\n39 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpe2w6e1wf.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr98hrsnt.rs:35:27\n   |\n\
    35 |     let mut paren_nesting_\n   |                           ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpr98hrsnt.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nest\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprachjfko.rs:41:31\n   |\n\
    41 |     let mut paren_nesting_nest\n   |                               ^ help:\
    \ add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmprachjfko.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_pos = 0;\n\
    \    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_pos = 0;\n\
    \    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_pos = 0;\n\
    \    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_pos = 0;\n\
    \    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_pos = 0;\n    let\
    \ mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_pos = 0;\n\
    \    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6ipq7q8k.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nest\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprachjfko.rs:41:31\n   |\n\
    41 |     let mut paren_nesting_nest\n   |                               ^ help:\
    \ add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmprachjfko.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvweo9_99.rs:41:18\n   |\n\
    41 |     let mut paren\n   |                  ^ help: add `;` here\n42 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvweo9_99.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_level = 0;\n    let mut paren_level_depth\
    \ = Vec::new();\n    let mut paren_level_stack = Vec::new();\n    let mut paren_level_level\
    \ = 0;\n    let mut paren_level_level_depth = Vec::new();\n    let mut paren_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_stack = Vec::new();\n   \
    \ let mut paren_level_level_level_level_stack = Vec::new();\n    let mut paren_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_stack =\
    \ Vec::new();\n    let mut paren_level_level_level_level_level_level_stack = Vec::new();\n\
    \    let mut paren_level_level_level_level_level_level_level_stack = Vec::new();\n\
    \    let mut paren_level_level_level_level_level_level_level_level_stack = Vec::new();\n\
    \    let mut paren_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_level_stack\
    \ = Vec::new();\n    let mut paren_level_level_level_level_level_level_level_level_level_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpy2ty5aee.rs:33:73\n   |\n\
    33 |     let mut paren_level_level_level_level_level_level_level_level_level_\n\
    \   |                                                                        \
    \ ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpy2ty5aee.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7exhj8u3.rs:37:32\n   |\n\
    37 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp7exhj8u3.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut paren_depth\
    \ = 0;\n    for paren in paren_string.chars() {\n        if paren == '(' {\n \
    \           paren_depth += 1;\n            paren_stack.push(paren_depth);\n  \
    \      } else if paren == ')' {\n            paren_depth -= 1;\n            if\
    \ paren_depth == 0 {\n                paren_stack.push(paren_depth);\n       \
    \     }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2, 0, 1, 2, 3, 0, 1, 0, 1, 2, 3, 2, 2, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmps1vbr2vb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n\
    \    let mut paren_levels_stack_size = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaupw3asa.rs:31:19\n   |\n\
    31 |     let mut paren_\n   |                   ^ help: add `;` here\n32 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpaupw3asa.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2rj21ub7.rs:37:32\n   |\n\
    37 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp2rj21ub7.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_chars.len();\n    let mut paren_level_char_pos = 0;\n    let mut\
    \ paren_level_char_len = paren_level_chars.len();\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n    let mut\
    \ paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf83tr90v.rs:47:30\n   |\n\
    47 |     let mut paren_level_char_\n   |                              ^ help:\
    \ add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpf83tr90v.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let mut paren_levels_stack_pos\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_pos = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_pos = paren_levels_stack.len();\n    let \n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpz3c7qxky.rs:39:1\n  \
    \ |\n39 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_nesting_levels\
    \ = Vec::new();\n    let mut paren_levels_iter = paren_string.char_indices().rev();\n\
    \    let mut paren_nesting_levels_iter = paren_string.char_indices().rev();\n\
    \    let mut paren_levels_mut_iter = paren_levels_iter.clone();\n    let mut paren_nesting_levels_mut_iter\
    \ = paren_nesting_levels_iter.clone();\n    let mut paren_levels_mut_iter_mut\
    \ = paren_levels_mut_iter.clone();\n    let mut paren_nesting_levels_mut_iter_mut\
    \ = paren_nesting_levels_mut_iter.clone();\n    let mut paren_levels_mut_iter_mut2\
    \ = paren_levels_mut_iter.clone();\n    let mut paren_nesting_levels_mut_iter_mut2\
    \ = paren_nesting_levels_mut_iter.clone();\n    let mut paren_levels_mut_iter_mut3\
    \ = paren_levels_mut_iter.clone();\n    let mut paren_nesting_levels_mut_iter_mut3\
    \ = paren_nesting_levels_mut_iter.clone();\n    let mut paren_levels_mut_iter_mut4\
    \ = paren_levels_mut_iter.clone();\n    let mut paren_nesting_levels_mut_iter_mut4\
    \ = paren_nesting_levels_mut_iter.clone();\n    let mut paren_levels_mut_iter_mut5\
    \ = paren_levels_mut_iter.clone();\n    let mut paren_nesting_levels_mut_iter_mut5\
    \ = paren_nesting_levels_mut_iter.clone();\n    let mut paren_levels_mut_iter_mut6\
    \ = paren_levels_mut_iter.clone();\n    let mut paren_nesting_levels_mut_iter_mut6\
    \ = paren_nesting_levels_mut_iter.clone();\n    let mut paren_levels_mut_iter_mut7\
    \ = paren_levels_mut_iter.clone();\n    let mut paren_nesting_levels_mut_iter_mut7\
    \ = paren_nesting_levels_mut_iter.clone();\n    let mut paren_levels_mut_iter_mut8\
    \ = paren_levels_mut_iter.clone();\n    let mut paren_nesting_levels_mut_iter_mut8\
    \ = paren_nesting_levels_mut_iter.clone();\n    let mut paren_levels_mut_iter_m\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2fum9bmi.rs:31:36\n   |\n\
    31 |     let mut paren_levels_mut_iter_m\n   |                               \
    \     ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp2fum9bmi.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = vec![];\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_char.len();\n    let mut paren_level_char_pos = 0;\n    let mut\
    \ paren_level_char_len = paren_level_char.len();\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n    let mut\
    \ paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_char.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpuoaorrnq.rs:49:1\n  \
    \ |\n49 | }\n   | ^ expected pattern\n\nerror[E0689]: can't call method `len`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpuoaorrnq.rs:14:53\n   |\n\
    14 |     let mut paren_level_char_len = paren_level_char.len();\n   |        \
    \                                             ^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpuoaorrnq.rs:16:53\n\
    \   |\n16 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpuoaorrnq.rs:18:53\n\
    \   |\n18 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpuoaorrnq.rs:20:53\n\
    \   |\n20 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call\
    \ method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpuoaorrnq.rs:22:53\n\
    \   |\n22 |     let mut paren_level_char_len = paren_level_char.len();\n   | \
    \                                                    ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n12 |     let mut paren_level_char:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().rev();\n \
    \   let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq2dwuhvd.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_stack = vec![0];\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom_index = 0;\n\
    \    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n    let mut paren_level_stack_bottom_index\
    \ = 0;\n    let mut paren_level_stack_top_index = 0;\n\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpg8z_imm3.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_size;\n    let mut paren_levels_stack_top = paren_levels_stack_size;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_size;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_size;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvy87k78n.rs:37:59\n   |\n\
    37 |     let mut paren_levels_stack_bottom = paren_levels_stack\n   |        \
    \                                                   ^ help: add `;` here\n38 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvy87k78n.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbyflqwxn.rs:29:71\n   |\n\
    29 |     let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    \   |                                                                       ^\
    \ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpbyflqwxn.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices();\n    let\
    \ mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mu\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9k4639b3.rs:38:11\n   |\n\
    38 |     let mu\n   |           ^ help: add `;` here\n39 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9k4639b3.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    let mut paren_level_count: usize = 0;\n\
    \    let mut paren_level_string: String = String::new();\n    let mut paren_level_string_len:\
    \ usize = 0;\n    let mut paren_level_char: char = '(';\n    for c in paren_string.chars()\
    \ {\n        if paren_level_char == c {\n            paren_level_char = '(';\n\
    \            paren_level += 1;\n            paren_level_count += 1;\n        \
    \    paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += &c.to_string();\n       \
    \     paren_level_string += &c.to_string();\n            paren_level_string +=\
    \ &c.to_string();\n            paren_level_string += \n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp09_w2hsw.rs:61:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n13 |     for c in paren_string.chars() {\n   |                          \
    \         - unclosed delimiter\n14 |         if paren_level_char == c {\n   |\
    \                                  - this delimiter might not be properly closed...\n\
    ...\n54 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    61 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmp09_w2hsw.rs:54:1\n\
    \   |\n54 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp09_w2hsw.rs:13:5\n   |\n6  |   fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \     ---------- expected `Vec<isize>` because of return type\n...\n13 | /   \
    \  for c in paren_string.chars() {\n14 | |         if paren_level_char == c {\n\
    15 | |             paren_level_char = '(';\n16 | |             paren_level +=\
    \ 1;\n...  |\n60 | |     assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n61 | | }\n   | |__^ expected struct `Vec`, found `()`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_level = 0;\n    let mut paren_level_stack\
    \ = Vec::new();\n    let mut paren_level_stack_size = paren_level_stack.len();\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = paren_level_stack_size\
    \ - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let\
    \ mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos\
    \ = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size\
    \ - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let\
    \ mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos\
    \ = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size\
    \ - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let\
    \ mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos\
    \ = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size\
    \ - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let\
    \ mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos\
    \ = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size\
    \ - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let\
    \ mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos\
    \ = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size\
    \ - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let\
    \ mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos\
    \ = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size\
    \ - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let\
    \ mut paren_level_stack_pos = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos\
    \ = paren_level_stack_size - 1;\n    let mut paren_level_stack_pos = paren_level_stack_size\
    \ - 1;\n    let mut paren_level_stack_pos = paren_level_stack_\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps5xk9xsn.rs:42:55\n   |\n\
    42 |     let mut paren_level_stack_pos = paren_level_stack_\n   |            \
    \                                           ^ help: add `;` here\n43 | }\n   |\
    \ - unexpected token\n\nerror[E0425]: cannot find value `paren_level_stack_` in\
    \ this scope\n  --> /tmp/tmps5xk9xsn.rs:42:37\n   |\n42 |     let mut paren_level_stack_pos\
    \ = paren_level_stack_\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_level_stack`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmps5xk9xsn.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nest\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprachjfko.rs:41:31\n   |\n\
    41 |     let mut paren_nesting_nest\n   |                               ^ help:\
    \ add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmprachjfko.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr = Vec::new();\n    let mut paren_levels_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end = Vec::new();\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_end_ptr_end_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqj_6w9c6.rs:28:69\n   |\n\
    28 |     let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\n  \
    \ |                                                                     ^ help:\
    \ add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpqj_6w9c6.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = Vec::new();\n    let mut paren_level_char = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = Vec::new();\n    let mut paren_level_char = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = Vec::new();\n    let mut paren_level_char = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = Vec::new();\n    let mut paren_level_char = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = Vec::new();\n    let mut paren_level_char = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = Vec::new();\n    let mut paren_level_char = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = Vec::new();\n    let mut paren_level_char = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpro8eco1_.rs:56:1\n\
    \   |\n56 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = vec![0];\n    let mut paren_level_char\
    \ = 0;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_chars.len();\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_pos = 0;\n\
    \    let mut paren_level_char_pos = 0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp94e0o6fg.rs:58:1\n  \
    \ |\n58 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_size\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqrvca5aq.rs:30:31\n   |\n\
    30 |     let mut paren_levels_stack\n   |                               ^ help:\
    \ add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpqrvca5aq.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels =\
    \ vec![];\n    let mut paren_level = 0;\n    let mut paren_level_count = 0;\n\
    \    let mut paren_level_char_count = 0;\n    let mut paren_level_chars = vec![];\n\
    \    let mut paren_level_char = 0;\n    let mut paren_level_char_pos = 0;\n  \
    \  let mut paren_level_char_len = paren_level_char.len();\n    let mut paren_level_char_len\
    \ = paren_level_char_len.saturating_sub(1);\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \    let mut paren_level_char_pos = paren_level_char_pos.satur\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpve6_4_2d.rs:39:62\n   |\n\
    39 |     let mut paren_level_char_pos = paren_level_char_pos.satur\n   |     \
    \                                                         ^ help: add `;` here\n\
    40 | }\n   | - unexpected token\n\nerror[E0689]: can't call method `len` on ambiguous\
    \ numeric type `{integer}`\n  --> /tmp/tmpve6_4_2d.rs:15:53\n   |\n15 |     let\
    \ mut paren_level_char_len = paren_level_char.len();\n   |                   \
    \                                  ^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `i32`\n   |\n13 |     let mut paren_level_char: i32 = 0;\n\
    \   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `saturating_sub`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmpve6_4_2d.rs:18:57\n   |\n\
    18 |     let mut paren_level_char_pos = paren_level_char_pos.saturating_sub(1);\n\
    \   |                                                         ^^^^^^^^^^^^^^\n\
    \   |\nhelp: you must specify a type for this binding, like `i32`\n   |\n17 |\
    \     let mut paren_level_char_pos: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpve6_4_2d.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0689.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_max\
    \ = 0;\n    let mut paren_level_max_count = 0;\n    let mut paren_level_max_index\
    \ = 0;\n    let mut paren_level_max_index2 = 0;\n    let mut paren_level_max_index3\
    \ = 0;\n    let mut paren_level_max_index4 = 0;\n    let mut paren_level_max_index5\
    \ = 0;\n    let mut paren_level_max_index6 = 0;\n    let mut paren_level_max_index7\
    \ = 0;\n    let mut paren_level_max_index8 = 0;\n    let mut paren_level_max_index9\
    \ = 0;\n    let mut paren_level_max_index10 = 0;\n    let mut paren_level_max_index11\
    \ = 0;\n    let mut paren_level_max_index12 = 0;\n    let mut paren_level_max_index13\
    \ = 0;\n    let mut paren_level_max_index14 = 0;\n    let mut paren_level_max_index15\
    \ = 0;\n    let mut paren_level_max_index16 = 0;\n    let mut paren_level_max_index17\
    \ = 0;\n    let mut paren_level_max_index18 = 0;\n    let mut paren_level_max_index19\
    \ = 0;\n    let mut paren_level_max_index20 = 0;\n    let mut paren_level_max_index21\
    \ = 0;\n    let mut paren_level_max_index22 = 0;\n    let mut paren_level_max_index23\
    \ = 0;\n    let mut paren_level_max_index24 = 0;\n    let mut paren_level_max_index25\
    \ = 0;\n    let mut paren_level_max_index26 = 0;\n    let mut paren_level_max_index27\
    \ = 0;\n    let mut paren_level_max_index28 = 0;\n    let mut paren_level_max_index29\
    \ = 0;\n    let mut paren_level_max_index30 = 0;\n    let mut paren_level_max_index31\
    \ = 0;\n    let mut paren_level_max_index32 = 0;\n    let mut paren_level_max_index33\
    \ = 0;\n    let mut paren_level_max_index34 = 0;\n    let mut paren_level_max_index35\
    \ = 0;\n    let mut paren_level_max_index36 = 0;\n    let mut paren_level_max_index37\
    \ = 0;\n    let mut paren_level_max_index38 = 0;\n    let mut paren_level_max_index39\
    \ = 0;\n    let mut paren_level_max_index40 = 0;\n    let mut paren_level_max_index41\
    \ = 0;\n    let mut paren_level_max_index42 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpcpbcpdbd.rs:55:1\n\
    \   |\n55 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_string = paren_string;\n\
    \    let mut paren_level_string = paren_string;\n    while paren_level_count <\
    \ paren_level {\n        paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren_string.split_whitespace().collect();\n\
    \        let mut paren_level_string = paren\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3ruz2ggc.rs:47:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n12 |     while paren_level_count < paren_level {\n   |                  \
    \                         - this delimiter might not be properly closed...\n...\n\
    40 | }\n   | - ...as it matches this but it has different indentation\n...\n47\
    \ | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp3ruz2ggc.rs:39:43\n\
    \   |\n39 |         let mut paren_level_string = paren\n   |                 \
    \                          ^ help: add `;` here\n40 | }\n   | - unexpected token\n\
    \nerror[E0425]: cannot find value `paren` in this scope\n  --> /tmp/tmp3ruz2ggc.rs:39:38\n\
    \   |\n39 |         let mut paren_level_string = paren\n   |                 \
    \                     ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp3ruz2ggc.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut \n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2r6felf0.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_chars = vec![0];\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_char_count =\
    \ 0;\n    let mut paren_level_chars = paren_string.chars();\n    let mut paren_level_char_index\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = paren_string.chars();\n    let mut paren_level_char_index = 0;\n    let mut\
    \ paren_level_char_count = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_char_count =\
    \ 0;\n    let mut paren_level_chars = paren_string.chars();\n    let mut paren_level_char_index\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = paren_string.chars();\n    let mut paren_level_char_index = 0;\n    let mut\
    \ paren_level_char_count = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_char_count =\
    \ 0;\n    let mut paren_level_chars = paren_string.chars();\n    let mut paren_level_char_index\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = paren_string.chars();\n    let mut paren_level_char_index = 0;\n    let mut\
    \ paren_level_char_count = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_char_count =\
    \ 0;\n    let mut paren_level_chars = paren_string.chars();\n    let mut paren_level_char_index\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = paren_string.chars();\n    let mut paren_level_char_index = 0;\n    let mut\
    \ paren_level_char_count = 0;\n    let mut paren_level_chars = paren_string.chars();\n\
    \    let mut paren_level_char_index = 0;\n    let mut paren_level_char_count =\
    \ 0;\n    let mut paren_level_chars = paren_string.chars();\n    let mut paren_level_char_index\
    \ = 0;\n    let mut paren_level_char_count = 0;\n    let mut paren_level_chars\
    \ = paren_string\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpha97o2ef.rs:52:45\n   |\n\
    52 |     let mut paren_level_chars = paren_string\n   |                      \
    \                       ^ help: add `;` here\n53 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpha97o2ef.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfx2as2qe.rs:37:32\n   |\n\
    37 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpfx2as2qe.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7exhj8u3.rs:37:32\n   |\n\
    37 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp7exhj8u3.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = vec![];\n    let mut paren_level_count_index\
    \ = -1;\n    let mut paren_level_count_index2 = 0;\n    let mut paren_level_count_index3\
    \ = 0;\n    let mut paren_level_count_index4 = 0;\n    let mut paren_level_count_index5\
    \ = 0;\n    let mut paren_level_count_index6 = 0;\n    let mut paren_level_count_index7\
    \ = 0;\n    let mut paren_level_count_index8 = 0;\n    let mut paren_level_count_index9\
    \ = 0;\n    let mut paren_level_count_index10 = 0;\n    let mut paren_level_count_index11\
    \ = 0;\n    let mut paren_level_count_index12 = 0;\n    let mut paren_level_count_index13\
    \ = 0;\n    let mut paren_level_count_index14 = 0;\n    let mut paren_level_count_index15\
    \ = 0;\n    let mut paren_level_count_index16 = 0;\n    let mut paren_level_count_index17\
    \ = 0;\n    let mut paren_level_count_index18 = 0;\n    let mut paren_level_count_index19\
    \ = 0;\n    let mut paren_level_count_index20 = 0;\n    let mut paren_level_count_index21\
    \ = 0;\n    let mut paren_level_count_index22 = 0;\n    let mut paren_level_count_index23\
    \ = 0;\n    let mut paren_level_count_index24 = 0;\n    let mut paren_level_count_index25\
    \ = 0;\n    let mut paren_level_count_index26 = 0;\n    let mut paren_level_count_index27\
    \ = 0;\n    let mut paren_level_count_index28 = 0;\n    let mut paren_level_count_index29\
    \ = 0;\n    let mut paren_level_count_index30 = 0;\n    let mut paren_level_count_index31\
    \ = 0;\n    let mut paren_level_count_index32 = 0;\n    let mut paren_level_count_index33\
    \ = 0;\n    let mut paren_level_count_index34 = 0;\n    let mut paren_level_count_index35\
    \ = 0;\n    let mut paren_level_count_index36 = 0;\n    let mut paren_level_count_index37\
    \ = 0;\n    let mut paren_level_count_index38 = 0;\n    let mut paren_level_count_index39\
    \ = 0;\n    let mut paren_level_count_index40 = 0;\n    let mut paren_level_count_index41\
    \ = 0;\n    let mut paren_level_count_index42 = 0;\n    let mut paren_level_count_index43\
    \ = 0;\n    let mut paren_level_count_index44 = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpod5egdp7.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpod5egdp7.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo94cdj3d.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpo94cdj3d.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_string\
    \ = paren_string;\n    let mut paren_level_string = paren_string;\n    let mut\
    \ paren_level_string = paren_string;\n    while paren_level_count < paren_level\
    \ {\n        paren_level_count += 1;\n        let mut paren_level_string = paren_string;\n\
    \        let mut paren_level_string = paren_string;\n        let mut paren_level_string\
    \ = paren_string;\n        while paren_level_count < paren_level {\n         \
    \   paren_level_count += 1;\n            let mut paren_level_string = paren_string;\n\
    \            let mut paren_level_string = paren_string;\n            let mut paren_level_string\
    \ = paren_string;\n        }\n    }\n    paren_levels\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `paren_level_string`\n  --> /tmp/tmpfkyet4ro.rs:10:13\n\
    \   |\n10 |     let mut paren_level_string = paren_string;\n   |             ^^^^^^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_paren_level_string`\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused\
    \ variable: `paren_level_string`\n  --> /tmp/tmpfkyet4ro.rs:11:13\n   |\n11 |\
    \     let mut paren_level_string = paren_string;\n   |             ^^^^^^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_paren_level_string`\n\
    \nwarning: unused variable: `paren_level_string`\n  --> /tmp/tmpfkyet4ro.rs:12:13\n\
    \   |\n12 |     let mut paren_level_string = paren_string;\n   |             ^^^^^^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_paren_level_string`\n\
    \nwarning: unused variable: `paren_level_string`\n  --> /tmp/tmpfkyet4ro.rs:15:17\n\
    \   |\n15 |         let mut paren_level_string = paren_string;\n   |         \
    \        ^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore:\
    \ `_paren_level_string`\n\nwarning: unused variable: `paren_level_string`\n  -->\
    \ /tmp/tmpfkyet4ro.rs:16:17\n   |\n16 |         let mut paren_level_string = paren_string;\n\
    \   |                 ^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix\
    \ it with an underscore: `_paren_level_string`\n\nwarning: unused variable: `paren_level_string`\n\
    \  --> /tmp/tmpfkyet4ro.rs:17:17\n   |\n17 |         let mut paren_level_string\
    \ = paren_string;\n   |                 ^^^^^^^^^^^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_paren_level_string`\n\nwarning: unused variable:\
    \ `paren_level_string`\n  --> /tmp/tmpfkyet4ro.rs:20:21\n   |\n20 |          \
    \   let mut paren_level_string = paren_string;\n   |                     ^^^^^^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_paren_level_string`\n\
    \nwarning: unused variable: `paren_level_string`\n  --> /tmp/tmpfkyet4ro.rs:21:21\n\
    \   |\n21 |             let mut paren_level_string = paren_string;\n   |     \
    \            "
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2rj21ub7.rs:37:32\n   |\n\
    37 |     let mut paren_levels_stack_\n   |                                ^ help:\
    \ add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp2rj21ub7.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_nestings = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_nestings_stack\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len();\n\
    \    let mut paren_nestings_stack_ptr = paren_nestings_stack.len();\n    let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack.len();\n    let mut paren_nestings_stack_ptr_end\
    \ = paren_nestings_stack.len();\n    let mut paren_levels_stack_ptr_end_ptr =\
    \ paren_levels_stack.len();\n    let mut paren_nestings_stack_ptr_end_ptr = paren_nestings_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_nestings_stack_ptr_end_ptr_end = paren_nestings_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr = paren_levels_stack.len();\n\
    \    let mut paren_nestings_stack_ptr_end_ptr_end_ptr = paren_nestings_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_nestings_stack_ptr_end_ptr_end_ptr_end = paren_nestings_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr = paren_levels_stack.len();\n\
    \    let mut paren_nestings_stack_ptr_end_ptr_end_ptr_end_ptr = paren_nestings_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_nestings_stack_ptr_end_ptr_end_ptr_end_ptr_end = paren_nestings_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr = paren_levels_stack.len();\n\
    \    let mut paren_nestings_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr = paren_nesting\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkz2e0bjs.rs:30:85\n   |\n\
    30 |     let mut paren_nestings_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr = paren_nesting\n\
    \   |                                                                        \
    \             ^ help: add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpkz2e0bjs.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = vec![];\n    let mut paren_level_char:\
    \ char;\n    for paren_level_char in paren_string.chars() {\n        if paren_level_char\
    \ == '(' {\n            paren_level += 1;\n            paren_level_char_count\
    \ += 1;\n            paren_level_chars.push(paren_level_char);\n        } else\
    \ if paren_level_char == ')' {\n            paren_level -= 1;\n            paren_level_char_count\
    \ += 1;\n            paren_level_chars.push(paren_level_char);\n            if\
    \ paren_level == 0 {\n                paren_levels.push(paren_level_count);\n\
    \            }\n        } else {\n            paren_level_char_count += 1;\n \
    \           paren_level_chars.push(paren_level_char);\n        }\n    }\n    paren_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpsxdw5ed4.rs:35:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_level = 0;\n    let mut paren_level_depth\
    \ = Vec::new();\n    let mut paren_level_depth_stack = Vec::new();\n    let mut\
    \ paren_level_depth_stack_len = paren_level_depth_stack.len();\n    let mut paren_level_depth_stack_pos\
    \ = 0;\n    let mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n\
    \    let mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let\
    \ mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let mut\
    \ paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let mut paren_level_depth_stack_pos\
    \ = paren_level_depth_stack_pos;\n    let mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n\
    \    let mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let\
    \ mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let mut\
    \ paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let mut paren_level_depth_stack_pos\
    \ = paren_level_depth_stack_pos;\n    let mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n\
    \    let mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let\
    \ mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let mut\
    \ paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let mut paren_level_depth_stack_pos\
    \ = paren_level_depth_stack_pos;\n    let mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n\
    \    let mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let\
    \ mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let mut\
    \ paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let mut paren_level_depth_stack_pos\
    \ = paren_level_depth_stack_pos;\n    let mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n\
    \    let mut paren_level_depth_stack_pos = paren_level_depth_stack_pos;\n    let\
    \ mut paren_level_depth_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf69vmy6r.rs:36:31\n   |\n\
    36 |     let mut paren_level_depth_\n   |                               ^ help:\
    \ add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpf69vmy6r.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut paren_depth\
    \ = 0;\n    let mut paren_level = 0;\n    let mut paren_nesting = 0;\n    let\
    \ mut paren_levels = vec![];\n    let mut paren_levels_len = paren_levels_len();\n\
    \    let mut paren_levels_len_ptr = paren_levels_len_ptr();\n    let mut paren_levels_ptr\
    \ = paren_levels_ptr();\n    let mut paren_levels_ptr_len = paren_levels_ptr_len();\n\
    \    let mut paren_levels_ptr_len_next = paren_levels_ptr_len_next();\n    let\
    \ mut paren_levels_ptr_len_next_ptr = paren_levels_ptr_len_next_ptr();\n    let\
    \ mut paren_levels_ptr_len_next_ptr_next = paren_levels_ptr_len_next_ptr_next();\n\
    \    let mut paren_levels_ptr_len_next_ptr_next_ptr = paren_levels_ptr_len_next_ptr_next_ptr();\n\
    \    let mut paren_levels_ptr_len_next_ptr_next_ptr_next = paren_levels_ptr_len_next_ptr_next_ptr_next();\n\
    \    let mut paren_levels_ptr_len_next_ptr_next_ptr_next_ptr = paren_levels_ptr_len_next_ptr_next_ptr_next_ptr();\n\
    \    let mut paren_levels_ptr_len_next_ptr_next_ptr_next_ptr_next = paren_levels_ptr_len_next_ptr_next_ptr_next_ptr_next();\n\
    \    let mut paren_levels_ptr_len_next_ptr_next_ptr_next_ptr_next_ptr = paren_levels_ptr_len_next_ptr_next_ptr_next_ptr_next_ptr();\n\
    \    let mut paren_levels_ptr_len_next_ptr_next_ptr_next_ptr_next_ptr_next = paren_levels_ptr_len_next_ptr_next_ptr_next_ptr_next_ptr_next();\n\
    \    let mut paren_levels_ptr_len_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr\
    \ = paren_levels_ptr_len_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr();\n   \
    \ let mut paren_levels_ptr_len_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next\
    \ = paren_levels_ptr_len_next_ptr_next_ptr_next_ptr_next_ptr_next_ptr_next();\n\
    \    let mut paren_levels_ptr_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuaa34ksx.rs:27:30\n   |\n\
    27 |     let mut paren_levels_ptr_\n   |                              ^ help:\
    \ add `;` here\n28 | }\n   | - unexpected token\n\nerror[E0425]: cannot find function\
    \ `paren_levels_len` in this scope\n  --> /tmp/tmpuaa34ksx.rs:12:32\n   |\n12\
    \ |     let mut paren_levels_len = paren_levels_len();\n   |                 \
    \               ^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `paren_levels`\n\nerror[E0425]: cannot find function `paren_levels_len_ptr`\
    \ in this scope\n  --> /tmp/tmpuaa34ksx.rs:13:36\n   |\n13 |     let mut paren_levels_len_ptr\
    \ = paren_levels_len_ptr();\n   |                                    ^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_len`\n\nerror[E0425]:\
    \ cannot find function `paren_levels_ptr` in this scope\n  --> /tmp/tmpuaa34ksx.rs:14:32\n\
    \   |\n14 |     let mut paren_levels_ptr = paren_levels_ptr();\n   |         \
    \                       ^^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `paren_levels_len`\n\nerror[E0425]: cannot find function `paren_levels_ptr_len`\
    \ in this scope\n  --> /tmp/tmpuaa34ksx.rs:15:36\n   |\n15 |     let mut paren_levels_ptr_len\
    \ = paren_levels_ptr_len();\n   |                                    ^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_len`\n\nerror[E0425]:\
    \ cannot find function `paren_levels_ptr_len_next` in this scope\n  --> /tmp/tmpuaa34ksx.rs:16:41\n\
    \   |\n16 |     let mut paren_levels_ptr_len_next = paren_levels_ptr_len_next();\n\
    \   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `paren_levels_ptr_len`\n\nerror[E0425]:\
    \ cannot find function `paren_levels_ptr_len_next_ptr` in this scope\n  --> /tmp/tmpuaa34ksx.rs:17:45\n\
    \   |\n17 |     let mut paren_levels_ptr_len_next_ptr = paren_levels_ptr_len_next_ptr();\n\
    \   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_ptr_"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_max = paren_levels_stack.len();\n    let mut paren_levels_stack_max_pos\
    \ = 0;\n    let mut paren_levels_stack_max_len = paren_levels_stack.len();\n \
    \   let mut paren_levels_stack_max_value = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_max_value_pos = 0;\n    let mut paren_levels_stack_max_value_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_value_pos =\
    \ 0;\n    let mut paren_levels_stack_max_value_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_value_pos = 0;\n    let mut paren_levels_stack_max_value_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_value_pos =\
    \ 0;\n    let mut paren_levels_stack_max_value_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_value_pos = 0;\n    let mut paren_levels_stack_max_value_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_value_pos =\
    \ 0;\n    let mut paren_levels_stack_max_value_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_value_pos = 0;\n    let mut paren_levels_stack_max_value_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_value_pos =\
    \ 0;\n    let mut paren_levels_stack_max_value_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_value_pos = 0;\n    let mut paren_levels_stack_max_value_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_value_pos =\
    \ 0;\n    let mut paren_levels_stack_max_value_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_max_value_pos = 0;\n    let mut paren_levels_stack_max_value_len\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_max_value_pos =\
    \ 0;\n    let mut paren_levels_stack_max_value_len = paren_levels_stack.len();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpm7ndik_3.rs:41:1\n\
    \   |\n41 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().filter_map(|i|\
    \ {\n        if paren_level == 0 {\n            paren_level += 1;\n          \
    \  Some(paren_level)\n        } else {\n            paren_level -= 1;\n      \
    \      None\n        }\n    });\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_level\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr9c28qhx.rs:43:44\n   |\n\
    43 |     let mut paren_levels_iter = paren_level\n   |                       \
    \                     ^ help: add `;` here\n44 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpr9c28qhx.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5o4jl_vd.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5o4jl_vd.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting = 0;\n\
    \    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr98hrsnt.rs:35:27\n   |\n\
    35 |     let mut paren_nesting_\n   |                           ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpr98hrsnt.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut paren_stack_len = paren_string.len();\n    let mut paren_stack_pos\
    \ = 0;\n    let mut paren_stack_char = paren_string[paren_stack_pos];\n    let\
    \ mut paren_stack_char_pos = 0;\n    let mut paren_stack_char_len = paren_string.chars().count();\n\
    \    while paren_stack_pos < paren_stack_char_len {\n        if paren_stack_char\
    \ == ')' {\n            paren_stack.pop();\n            paren_stack_pos += 1;\n\
    \            paren_stack_char = paren_string[paren_stack_pos];\n            paren_stack_char_pos\
    \ = 0;\n            paren_stack_char_len = paren_string.chars().count();\n   \
    \     }\n        if paren_stack_char == '(' {\n            paren_stack.push(level);\n\
    \            paren_stack_pos += 1;\n            paren_stack_char = paren_string[paren_stack_pos];\n\
    \            paren_stack_char_pos = 0;\n            paren_stack_char_len = paren_string.chars().count();\n\
    \            level += 1;\n        }\n        if paren_stack_char == ')' {\n  \
    \          level -= 1;\n        }\n        if paren_stack_char == ')' {\n    \
    \        paren_stack_pos += 1;\n            paren_stack_char = paren_string[paren_stack_pos];\n\
    \            paren_stack_char_pos = 0;\n            paren_stack_char_len = paren_string.chars().count();\n\
    \        }\n        if paren_stack_char == '(' {\n            level += 1;\n  \
    \      }\n        paren_stack_pos += 1;\n        paren_stack_char = paren_string[paren_stack_pos];\n\
    \        paren_stack_char_pos = 0;\n        paren_stack_char_len = paren_string.chars().count();\n\
    \    }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpg1gyygbm.rs:11:32\n   |\n11 |     let mut paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpg1gyygbm.rs:18:32\n   |\n18 |             paren_stack_char\
    \ = paren_string[paren_stack_pos];\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpg1gyygbm.rs:25:32\n   |\n25 |            \
    \ paren_stack_char = paren_string[paren_stack_pos];\n   |                    \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg1gyygbm.rs:35:32\n\
    \   |\n35 |             paren_stack_char = paren_string[paren_stack_pos];\n  \
    \ |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpg1gyygbm.rs:43:28\n   |\n43 |         paren_stack_char = paren_string[paren_stack_pos];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n\
    \    let mut paren_levels_len: usize = 0;\n    let mut paren_levels_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_len: usize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_len: usize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<usize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens: Vec<usize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7sdc7gx6.rs:28:56\n   |\n\
    28 |     let mut paren_levels_lens_lens_lens_lens_lens_lens_\n   |           \
    \                                             ^ help: add `;` here\n29 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7sdc7gx6.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices();\n    let\
    \ mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mu\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9k4639b3.rs:38:11\n   |\n\
    38 |     let mu\n   |           ^ help: add `;` here\n39 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9k4639b3.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n\
    \    let mut paren_levels = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n\
    \    let mut paren_levels_stack_size = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let\
    \ mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr =\
    \ Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaupw3asa.rs:31:19\n   |\n\
    31 |     let mut paren_\n   |                   ^ help: add `;` here\n32 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpaupw3asa.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9yhn3spe.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9yhn3spe.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_chars = Vec::new();\n    let mut paren_level_char:\
    \ char;\n    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len\
    \ = paren_level_chars.len();\n    let mut paren_level_char_pos = 0;\n    let mut\
    \ paren_level_char_len = paren_level_chars.len();\n    let mut paren_level_char_pos\
    \ = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n    let mut\
    \ paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_pos = 0;\n    let mut paren_level_char_len = paren_level_chars.len();\n\
    \    let mut paren_level_char_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf83tr90v.rs:47:30\n   |\n\
    47 |     let mut paren_level_char_\n   |                              ^ help:\
    \ add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpf83tr90v.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_nesting = 0;\n    let mut paren_levels =\
    \ Vec::new();\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_levels_len\
    \ = paren_stack.len();\n    let mut paren_nesting_levels_len = paren_nesting_levels.len();\n\
    \    let mut paren_levels_len_ptr = paren_levels_len;\n    let mut paren_nesting_levels_len_ptr\
    \ = paren_nesting_levels_len;\n    let mut paren_levels_ptr = paren_levels;\n\
    \    let mut paren_nesting_levels_ptr = paren_nesting_levels;\n    let mut paren_levels_ptr_end\
    \ = paren_levels_ptr.end();\n    let mut paren_nesting_levels_ptr_end = paren_nesting_levels_ptr.end();\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.end();\n    let mut paren_nesting_levels_ptr_end\
    \ = paren_nesting_levels_ptr.end();\n    let mut paren_levels_ptr_end = paren_levels_ptr.end();\n\
    \    let mut paren_nesting_levels_ptr_end = paren_nesting_levels_ptr.end();\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.end();\n    let mut paren_nesting_levels_ptr_end\
    \ = paren_nesting_levels_ptr.end();\n    let mut paren_levels_ptr_end = paren_levels_ptr.end();\n\
    \    let mut paren_nesting_levels_ptr_end = paren_nesting_levels_ptr.end();\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.end();\n    let mut paren_nesting_levels_ptr_end\
    \ = paren_nesting_levels_ptr.end();\n    let mut paren_levels_ptr_end = paren_levels_ptr.end();\n\
    \    let mut paren_nesting_levels_ptr_end = paren_nesting_levels_ptr.end();\n\
    \    let mut paren_levels_ptr_end = paren_levels_ptr.end();\n    let mut paren_nesting_levels_ptr_end\
    \ = paren_nesting_levels_ptr.end();\n    let mut paren_levels_ptr_end = paren_levels_ptr.end();\n\
    \    let mut paren_nesting_levels_ptr_end = paren_nesting_levels_ptr\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp98qw8cnv.rs:35:68\n   |\n\
    35 |     let mut paren_nesting_levels_ptr_end = paren_nesting_levels_ptr\n   |\
    \                                                                    ^ help: add\
    \ `;` here\n36 | }\n   | - unexpected token\n\nerror[E0599]: no method named `end`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp98qw8cnv.rs:18:53\n\
    \   |\n18 |     let mut paren_levels_ptr_end = paren_levels_ptr.end();\n   | \
    \                                                    ^^^ method not found in `Vec<_>`\n\
    \nerror[E0599]: no method named `end` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmp98qw8cnv.rs:19:69\n   |\n19 |     let mut paren_nesting_levels_ptr_end\
    \ = paren_nesting_levels_ptr.end();\n   |                                    \
    \                                 ^^^ method not found in `Vec<_>`\n\nerror[E0599]:\
    \ no method named `end` found for struct `Vec<_>` in the current scope\n  -->\
    \ /tmp/tmp98qw8cnv.rs:20:53\n   |\n20 |     let mut paren_levels_ptr_end = paren_levels_ptr.end();\n\
    \   |                                                     ^^^ method not found\
    \ in `Vec<_>`\n\nerror[E0599]: no method named `end` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmp98qw8cnv.rs:21:69\n   |\n21 |     let mut\
    \ paren_nesting_levels_ptr_end = paren_nesting_levels_ptr.end();\n   |       \
    \                                                              ^^^ method not\
    \ found in `Vec<_>`\n\nerror[E0599]: no method named `end` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmp98qw8cnv.rs:22:53\n   |\n22 |     let mut\
    \ paren_levels_ptr_end = paren_levels_ptr.end();\n   |                       \
    \                              ^^^ method not found in `Vec<_>`\n\nerror[E0599]:\
    \ no method named `end` found for struct `Vec<_>` in the current scope\n  -->\
    \ /tmp/tmp98qw8cnv.rs:23:69\n   |\n23 |     let mut paren_nesting_levels_ptr_end\
    \ = paren_nesting_levels_ptr.end();\n   |                                    \
    \                                 ^^^ method not found in `Vec<_>`\n\nerror[E0599]:\
    \ no method named `end` "
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_len = paren_stack.len();\n    let mut paren_levels_len_ptr\
    \ = paren_levels_len as *const isize;\n    let mut paren_levels_ptr = paren_levels_len_ptr\
    \ as *const Vec<isize>;\n    let mut paren_levels_ptr_end = paren_levels_ptr +\
    \ paren_levels_len;\n    let mut paren_levels_ptr_end_ptr = paren_levels_ptr_end\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end = paren_levels_ptr_end_ptr\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_ptr = paren_levels_ptr_end_ptr_end\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end = paren_levels_ptr_end_ptr_end_ptr\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr = paren_levels_ptr_end_ptr_end_ptr_end\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end =\
    \ paren_levels_ptr_end_ptr_end_ptr_end_ptr as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr_end_ptr_end_ptr_end_ptr_end as *const isize;\n    let mut\
    \ paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end as *const isize;\n  \
    \  let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ as *const isize;\n    let mut paren_levels_ptr_end_ptr_end_\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu80s7ikk.rs:25:42\n   |\n\
    25 |     let mut paren_levels_ptr_end_ptr_end_\n   |                         \
    \                 ^ help: add `;` here\n26 | }\n   | - unexpected token\n\nerror[E0369]:\
    \ cannot add `usize` to `*const Vec<isize>`\n  --> /tmp/tmpu80s7ikk.rs:14:53\n\
    \   |\n14 |     let mut paren_levels_ptr_end = paren_levels_ptr + paren_levels_len;\n\
    \   |                                    ---------------- ^ ---------------- usize\n\
    \   |                                    |\n   |                             \
    \       *const Vec<isize>\n\nerror[E0308]: mismatched types\n --> /tmp/tmpu80s7ikk.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_char_count\
    \ = 0;\n    let mut paren_level_char = 0;\n    let mut paren_level_char_pos =\
    \ 0;\n    let mut paren_level_char_len = paren_string.chars().count();\n    let\
    \ mut paren_level_char_len = paren_level_char_len as usize;\n    let mut paren_level_char_pos\
    \ = paren_level_char_len as usize;\n    let mut paren_level_char_pos = paren_level_char_pos\
    \ as usize;\n    let mut paren_level_char_pos = paren_level_char_pos as usize;\n\
    \    let mut paren_level_char_pos = paren_level_char_pos as usize;\n    let mut\
    \ paren_level_char_pos = paren_level_char_pos as usize;\n    let mut paren_level_char_pos\
    \ = paren_level_char_pos as usize;\n    let mut paren_level_char_pos = paren_level_char_pos\
    \ as usize;\n    let mut paren_level_char_pos = paren_level_char_pos as usize;\n\
    \    let mut paren_level_char_pos = paren_level_char_pos as usize;\n    let mut\
    \ paren_level_char_pos = paren_level_char_pos as usize;\n    let mut paren_level_char_pos\
    \ = paren_level_char_pos as usize;\n    let mut paren_level_char_pos = paren_level_char_pos\
    \ as usize;\n    let mut paren_level_char_pos = paren_level_char_pos as usize;\n\
    \    let mut paren_level_char_pos = paren_level_char_pos as usize;\n    let mut\
    \ paren_level_char_pos = paren_level_char_pos as usize;\n    let mut paren_level_char_pos\
    \ = paren_level_char_pos as usize;\n    let mut paren_level_char_pos = paren_level_char_pos\
    \ as usize;\n    let mut paren_level_char_pos = paren_level_char_pos as usize;\n\
    \    let mut paren_level_char_pos = paren_level_char_pos as usize;\n    let mut\
    \ paren_level_char_pos = paren_level_char_pos as usize;\n    let mut paren_level_char_pos\
    \ = paren_level_char_pos as usize;\n    let mut paren_level_char_pos = paren_level_char_pos\
    \ as usize;\n    let mut paren_level_char_pos = paren_level_char_pos as usize;\n\
    \    let mut paren_level_char_pos = paren_level_char_pos as usize;\n    let mut\
    \ paren_level_char_pos = paren_level_char_pos as \n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmp_jaapl58.rs:40:1\n   |\n\
    40 | }\n   | ^ expected type\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo94cdj3d.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpo94cdj3d.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_len = paren_stack.len();\n    let mut paren_levels_len2\
    \ = paren_levels_len * 2;\n    let mut paren_levels_len3 = paren_levels_len *\
    \ 3;\n    let mut paren_levels_len4 = paren_levels_len * 4;\n    let mut paren_levels_len5\
    \ = paren_levels_len * 5;\n    let mut paren_levels_len6 = paren_levels_len *\
    \ 6;\n    let mut paren_levels_len7 = paren_levels_len * 7;\n    let mut paren_levels_len8\
    \ = paren_levels_len * 8;\n    let mut paren_levels_len9 = paren_levels_len *\
    \ 9;\n    let mut paren_levels_len10 = paren_levels_len * 10;\n    let mut paren_levels_len11\
    \ = paren_levels_len * 11;\n    let mut paren_levels_len12 = paren_levels_len\
    \ * 12;\n    let mut paren_levels_len13 = paren_levels_len * 13;\n    let mut\
    \ paren_levels_len14 = paren_levels_len * 14;\n    let mut paren_levels_len15\
    \ = paren_levels_len * 15;\n    let mut paren_levels_len16 = paren_levels_len\
    \ * 16;\n    let mut paren_levels_len17 = paren_levels_len * 17;\n    let mut\
    \ paren_levels_len18 = paren_levels_len * 18;\n    let mut paren_levels_len19\
    \ = paren_levels_len * 19;\n    let mut paren_levels_len20 = paren_levels_len\
    \ * 20;\n    let mut paren_levels_len21 = paren_levels_len * 21;\n    let mut\
    \ paren_levels_len22 = paren_levels_len * 22;\n    let mut paren_levels_len23\
    \ = paren_levels_len * 23;\n    let mut paren_levels_len24 = paren_levels_len\
    \ * 24;\n    let mut paren_levels_len25 = paren_levels_len * 25;\n    let mut\
    \ paren_levels_len26 = paren_levels_len * 26;\n    let mut paren_levels_len27\
    \ = paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq7h4o7y4.rs:37:39\n   |\n\
    37 |     let mut paren_levels_len27 = paren\n   |                            \
    \           ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `paren` in this scope\n  --> /tmp/tmpq7h4o7y4.rs:37:34\n \
    \  |\n37 |     let mut paren_levels_len27 = paren\n   |                      \
    \            ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpq7h4o7y4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_stack = vec![0];\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_len = paren_level_stack.len();\n\
    \    let mut paren_level_stack_top = paren_level_stack_len;\n    let mut paren_level_stack_bottom\
    \ = paren_level_stack_len;\n    let mut paren_level_stack_bottom_index = 0;\n\
    \    let mut paren_level_stack_bottom_pos = 0;\n    let mut paren_level_stack_bottom_len\
    \ = paren_level_stack_bottom.len();\n    let mut paren_level_stack_bottom_top\
    \ = paren_level_stack_bottom_len;\n    let mut paren_level_stack_bottom_bottom\
    \ = paren_level_stack_bottom_len;\n    let mut paren_level_stack_bottom_bottom_index\
    \ = 0;\n    let mut paren_level_stack_bottom_bottom_pos = 0;\n    let mut paren_level_stack_bottom_bottom_len\
    \ = paren_level_stack_bottom_bottom.len();\n    let mut paren_level_stack_bottom_bottom_top\
    \ = paren_level_stack_bottom_bottom_len;\n    let mut paren_level_stack_bottom_bottom_bottom\
    \ = paren_level_stack_bottom_bottom_len;\n    let mut paren_level_stack_bottom_bottom_bottom_index\
    \ = 0;\n    let mut paren_level_stack_bottom_bottom_bottom_pos = 0;\n    let mut\
    \ paren_level_stack_bottom_bottom_bottom_len = paren_level_stack_bottom_bottom_bottom.len();\n\
    \    let mut paren_level_stack_bottom_bottom_bottom_top = paren_level_stack_bottom_bottom_bottom_len;\n\
    \    let mut paren_level_stack_bottom_bottom_bottom_bottom = paren_level_stack_bottom_bottom_bottom_len;\n\
    \    let mut paren_level_stack_bottom_bottom_bottom_bottom_index = 0;\n    let\
    \ mut paren_level_stack_bottom_bottom_bottom_bottom_pos = 0;\n    let mut paren_level_stack_bottom_bottom_bottom_bottom_len\
    \ = paren_level_stack_bottom_bottom_bottom_bottom.len();\n    let mut paren_level_stack_bottom_bottom_bottom_bottom_top\
    \ = paren_level_stack_bottom_bottom_bottom_bottom_len;\n    let mut paren_level_stack_bottom_bottom_bottom_bottom_bottom\
    \ = paren_level_stack_bottom_bottom_bottom_bottom_len;\n    let mut paren_level_stack_bottom_bottom_bottom_bottom_bottom_index\
    \ = 0;\n    let mut paren_level_stack_bottom_bottom_bottom_bottom_bottom_pos =\
    \ 0;\n    let mut paren_level_stack_bottom_bottom_bottom_bottom_bottom_len = paren_level_stack_bottom_bottom_bottom_bottom_bottom.len();\n\
    \    let mut paren_level_stack_bottom_bottom_bottom_bottom_bottom_top = paren_level_stack_bottom_bottom_bottom_bottom_bottom_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptofg32ed.rs:38:125\n   |\n\
    38 |     let mut paren_level_stack_bottom_bottom_bottom_bottom_bottom_top = paren_level_stack_bottom_bottom_bottom_bottom_bottom_\n\
    \   |                                                                        \
    \                                                     ^ help: add `;` here\n39\
    \ | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `paren_level_stack_bottom_bottom_bottom_bottom_bottom_`\
    \ in this scope\n  --> /tmp/tmptofg32ed.rs:38:72\n   |\n38 |     let mut paren_level_stack_bottom_bottom_bottom_bottom_bottom_top\
    \ = paren_level_stack_bottom_bottom_bottom_bottom_bottom_\n   |              \
    \                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_level_stack_bottom_bottom_bottom_bottom_bottom`\n\
    \nerror[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmptofg32ed.rs:17:69\n   |\n17 |     let mut paren_level_stack_bottom_len\
    \ = paren_level_stack_bottom.len();\n   |                                    \
    \                                 ^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmptofg32ed.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_max_count\
    \ = 0;\n    let mut paren_level_max_count_index = 0;\n    let mut paren_level_max_count_index2\
    \ = 0;\n    let mut paren_level_max_count_index3 = 0;\n    let mut paren_level_max_count_index4\
    \ = 0;\n    let mut paren_level_max_count_index5 = 0;\n    let mut paren_level_max_count_index6\
    \ = 0;\n    let mut paren_level_max_count_index7 = 0;\n    let mut paren_level_max_count_index8\
    \ = 0;\n    let mut paren_level_max_count_index9 = 0;\n    let mut paren_level_max_count_index10\
    \ = 0;\n    let mut paren_level_max_count_index11 = 0;\n    let mut paren_level_max_count_index12\
    \ = 0;\n    let mut paren_level_max_count_index13 = 0;\n    let mut paren_level_max_count_index14\
    \ = 0;\n    let mut paren_level_max_count_index15 = 0;\n    let mut paren_level_max_count_index16\
    \ = 0;\n    let mut paren_level_max_count_index17 = 0;\n    let mut paren_level_max_count_index18\
    \ = 0;\n    let mut paren_level_max_count_index19 = 0;\n    let mut paren_level_max_count_index20\
    \ = 0;\n    let mut paren_level_max_count_index21 = 0;\n    let mut paren_level_max_count_index22\
    \ = 0;\n    let mut paren_level_max_count_index23 = 0;\n    let mut paren_level_max_count_index24\
    \ = 0;\n    let mut paren_level_max_count_index25 = 0;\n    let mut paren_level_max_count_index26\
    \ = 0;\n    let mut paren_level_max_count_index27 = 0;\n    let mut paren_level_max_count_index28\
    \ = 0;\n    let mut paren_level_max_count_index29 = 0;\n    let mut paren_level_max_count_index30\
    \ = 0;\n    let mut paren_level_max_count_index31 = 0;\n    let mut paren_level_max_count_index32\
    \ = 0;\n    let mut paren_level_max_count_index33 = 0;\n    let mut paren_level_max_count_index34\
    \ = 0;\n    let mut paren_level_max_count_index35 = 0;\n    let mut paren_level_max_count_index36\
    \ = 0;\n    let mut paren_level_max_count_index37 = 0;\n    let mut paren_level_max_count_index38\
    \ = 0;\n    let mut paren_level_max_count_index39 = 0;\n    let mut paren_level_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoqn1iapo.rs:50:25\n   |\n\
    50 |     let mut paren_level_\n   |                         ^ help: add `;` here\n\
    51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpoqn1iapo.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpuc750knm.rs:38:1\n   |\n38\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpuc750knm.rs:37:60\n\
    \   |\n37 |     let mut paren_levels_stack_bottom = paren_levels_stack.\n   |\
    \                                                            ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpuc750knm.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices();\n    let\
    \ mut paren_levels_iter = paren_levels_iter.filter_map(|(_, c)| {\n        if\
    \ c.is_whitespace() {\n            paren_level += 1;\n            Some(paren_level)\n\
    \        } else {\n            None\n        }\n    });\n    let mut paren_levels_iter\
    \ = paren_levels_iter.filter_map(|(_, c)| {\n        if c.is_whitespace() {\n\
    \            paren_level -= 1;\n            Some(paren_level)\n        } else\
    \ {\n            None\n        }\n    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|(_,\
    \ c)| {\n        if c.is_whitespace() {\n            Some(paren_level)\n     \
    \   } else {\n            None\n        }\n    });\n    let mut paren_levels_iter\
    \ = paren_levels_iter.filter_map(|(_, c)| {\n        if c.is_whitespace() {\n\
    \            Some(paren_level)\n        } else {\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|(_, c)|\
    \ {\n        if c.is_whitespace() {\n            Some(paren_level)\n        }\
    \ else {\n            None\n        }\n    });\n    let mut paren_levels_iter\
    \ = paren_levels_iter.filter_map(|(_, c)| {\n        if c.is_whitespace() {\n\
    \            Some(paren_level)\n        } else {\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|(_, c)|\
    \ {\n        if c.is_whitespace() {\n            Some(paren_level)\n        }\
    \ else {\n            None\n        }\n    });\n    let mut paren_levels_iter\
    \ = paren_levels_iter.filter_map(|(_, c)| {\n        if c.is_whitespace() {\n\
    \            Some(paren_level)\n        } else {\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|(_, c)|\
    \ {\n        if c.is_whitespace() {\n            Some(paren_level)\n        }\
    \ else {\n            None\n        }\n    });\n    let mut paren_levels_iter\
    \ = paren_levels_iter.filter_map(|(_, c)| {\n        if c.is_whitespace() {\n\
    \            Some(paren_level)\n        } else {\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|(_, c)|\
    \ {\n        if c.is_whitespace() {\n            Some(paren_level)\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmphg4252t2.rs:92:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n82 |     let mut paren_levels_iter = paren_levels_iter.filter_map(|(_, c)|\
    \ {\n   |                                                             -      \
    \   - unclosed delimiter\n   |                                               \
    \              |\n   |                                                       \
    \      unclosed delimiter\n83 |         if c.is_whitespace() {\n   |         \
    \                     - this delimiter might not be properly closed...\n84 | \
    \            Some(paren_level)\n85 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n92 | }\n   |   ^\n\nerror: expected one of `.`,\
    \ `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmphg4252t2.rs:92:3\n\
    \   |\n92 | }\n   |   ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphg4252t2.rs:18:63\n   |\n18 |\
    \     let mut paren_levels_iter = paren_levels_iter.filter_map(|(_, c)| {\n  \
    \ |                                                               ^^^^^-\n   |\
    \                                                               |    |\n   | \
    \                                                              |    expected due\
    \ to this\n   |                                                              \
    \ expected integer, found tuple\n   |\n   = note: expected type `{integer}`\n\
    \             found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphg4252t2.rs:26:63\n\
    \   |\n26 |     let mut paren_levels_iter = paren_levels_iter.filter_map(|(_,\
    \ c)| {\n   |                                                               ^^^^^-\n\
    \   |                                                               |    |\n \
    \  |                                                               |    expected\
    \ due to this\n   |                                                          \
    \     expected integer, found tuple\n   |\n   = note: exp"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level = 0;\n    let mut paren_level_count = vec![];\n    let mut\
    \ paren_level_count_stack: Vec<isize> = vec![];\n    let mut paren_level_count_stack_count\
    \ = vec![];\n    let mut paren_level_count_stack_count2 = vec![];\n    let mut\
    \ paren_level_count_stack_count3 = vec![];\n    let mut paren_level_count_stack_count4\
    \ = vec![];\n    let mut paren_level_count_stack_count5 = vec![];\n    let mut\
    \ paren_level_count_stack_count6 = vec![];\n    let mut paren_level_count_stack_count7\
    \ = vec![];\n    let mut paren_level_count_stack_count8 = vec![];\n    let mut\
    \ paren_level_count_stack_count9 = vec![];\n    let mut paren_level_count_stack_count10\
    \ = vec![];\n    let mut paren_level_count_stack_count11 = vec![];\n    let mut\
    \ paren_level_count_stack_count12 = vec![];\n    let mut paren_level_count_stack_count13\
    \ = vec![];\n    let mut paren_level_count_stack_count14 = vec![];\n    let mut\
    \ paren_level_count_stack_count15 = vec![];\n    let mut paren_level_count_stack_count16\
    \ = vec![];\n    let mut paren_level_count_stack_count17 = vec![];\n    let mut\
    \ paren_level_count_stack_count18 = vec![];\n    let mut paren_level_count_stack_count19\
    \ = vec![];\n    let mut paren_level_count_stack_count20 = vec![];\n    let mut\
    \ paren_level_count_stack_count21 = vec![];\n    let mut paren_level_count_stack_count22\
    \ = vec![];\n    let mut paren_level_count_stack_count23 = vec![];\n    let mut\
    \ paren_level_count_stack_count24 = vec![];\n    let mut paren_level_count_stack_count25\
    \ = vec![];\n    let mut paren_level_count_stack_count26 = vec![];\n    let mut\
    \ paren_level_count_stack_count27 = vec![];\n    let mut paren_level_count_stack_count28\
    \ = vec![];\n    let mut paren_level_count_stack_count29 = vec![];\n    let mut\
    \ paren_level_count_stack_count30 = vec![];\n    let mut paren_level_count_stack_count31\
    \ = vec![];\n    let mut \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpjfrksxly.rs:43:1\n\
    \   |\n43 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_stack\
    \ = vec![];\n    for paren in paren_string.chars() {\n        if paren == '('\
    \ {\n            paren_stack.push(paren_level);\n            paren_level += 1;\n\
    \        } else if paren == ')' {\n            paren_level -= 1;\n           \
    \ if paren_level == 0 {\n                paren_stack.push(paren_level);\n    \
    \        }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpz4n5kb1t.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_size\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt67mx2yh.rs:30:71\n   |\n\
    30 |     let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    \   |                                                                       ^\
    \ help: add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpt67mx2yh.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    for paren in paren_string.chars() {\n        if paren\
    \ == '(' {\n            paren_stack.push(paren_depth);\n            paren_depth\
    \ += 1;\n        } else if paren == ')' {\n            paren_depth -= 1;\n   \
    \         if paren_depth == 0 {\n                paren_stack.push(paren_depth);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpc_e_z3f7.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_string\
    \ = \"\";\n    let mut paren_level_string_count = 0;\n    let mut paren_level_string_index\
    \ = 0;\n    let mut paren_level_strings = Vec::new();\n    let mut paren_level_strings_index\
    \ = 0;\n    let mut paren_level_strings_count = 0;\n    let mut paren_level_strings_string\
    \ = \"\";\n    let mut paren_level_strings_string_index = 0;\n    let mut paren_level_strings_string_count\
    \ = 0;\n    let mut paren_level_strings_strings = Vec::new();\n    let mut paren_level_strings_strings_index\
    \ = 0;\n    let mut paren_level_strings_strings_count = 0;\n    let mut paren_level_strings_strings_string\
    \ = \"\";\n    let mut paren_level_strings_strings_string_index = 0;\n    let\
    \ mut paren_level_strings_strings_string_count = 0;\n    let mut paren_level_strings_strings_strings\
    \ = Vec::new();\n    let mut paren_level_strings_strings_strings_index = 0;\n\
    \    let mut paren_level_strings_strings_strings_count = 0;\n    let mut paren_level_strings_strings_strings_string\
    \ = \"\";\n    let mut paren_level_strings_strings_strings_string_index = 0;\n\
    \    let mut paren_level_strings_strings_strings_string_count = 0;\n    let mut\
    \ paren_level_strings_strings_strings_strings = Vec::new();\n    let mut paren_level_strings_strings_strings_strings_index\
    \ = 0;\n    let mut paren_level_strings_strings_strings_strings_count = 0;\n \
    \   let mut paren_level_strings_strings_strings_strings_string = \"\";\n    let\
    \ mut paren_level_strings_strings_strings_strings_string_index = 0;\n    let mut\
    \ paren_level_strings_strings_strings_strings_string_count = 0;\n    let mut paren_level_strings_strings_strings_strings_strings\
    \ = Vec::new();\n    let mut paren_level_strings_strings_strings_strings_strings_index\
    \ = 0;\n    let mut paren_level_strings_strings_strings_strings_strings_count\
    \ = 0;\n    let mut paren_level_strings_strings_strings_strings_strings_string\
    \ = \"\";\n    let mut paren_level_strings_strings_strings_strings_strings_string_index\
    \ = 0;\n    let mut paren_level_strings_string\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp11a6kbyz.rs:42:39\n   |\n\
    42 |     let mut paren_level_strings_string\n   |                            \
    \           ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp11a6kbyz.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5o4jl_vd.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5o4jl_vd.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr = Vec::new();\n    let mut paren_levels_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_ptr\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpel890u7c.rs:30:33\n   |\n\
    30 |     let mut paren_levels_ptr_ptr\n   |                                 ^\
    \ help: add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpel890u7c.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            paren_stack.push(paren_level);\n \
    \           paren_level += 1;\n            paren_nesting += 1;\n        } else\
    \ if paren == ')' {\n            paren_level -= 1;\n            paren_nesting\
    \ -= 1;\n            if paren_nesting == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpiukk2gbm.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    let mut paren_level_count: isize = 0;\n\
    \    for paren in paren_string.chars() {\n        if paren == '(' {\n        \
    \    paren_stack.push(paren_level);\n            paren_level_count = 1;\n    \
    \    } else if paren == ')' {\n            paren_level_count = paren_stack.pop();\n\
    \            if paren_level_count == 0 {\n                paren_level_count =\
    \ paren_level;\n            }\n            paren_level += paren_level_count;\n\
    \        }\n    }\n    paren_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw1uv7at8.rs:15:33\n   |\n\
    15 |             paren_level_count = paren_stack.pop();\n   |                \
    \                 ^^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n  \
    \ |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw1uv7at8.rs:22:5\n   |\n6  | fn\
    \ parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |            \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n22 |     paren_level\n   |     ^^^^^^^^^^^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices().filter_map(|i|\
    \ {\n        if paren_level == 0 {\n            paren_level += 1;\n          \
    \  Some(paren_level)\n        } else {\n            paren_level -= 1;\n      \
    \      None\n        }\n    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|i|\
    \ {\n        if i.is_some() {\n            paren_level += 1;\n            Some(paren_level)\n\
    \        } else {\n            paren_level -= 1;\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|i| {\n\
    \        if i.is_some() {\n            paren_level += 1;\n            Some(paren_level)\n\
    \        } else {\n            paren_level -= 1;\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|i| {\n\
    \        if i.is_some() {\n            paren_level += 1;\n            Some(paren_level)\n\
    \        } else {\n            paren_level -= 1;\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|i| {\n\
    \        if i.is_some() {\n            paren_level += 1;\n            Some(paren_level)\n\
    \        } else {\n            paren_level -= 1;\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|i| {\n\
    \        if i.is_some() {\n            paren_level += 1;\n            Some(paren_level)\n\
    \        } else {\n            paren_level -= 1;\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|i| {\n\
    \        if i.is_some() {\n            paren_level += 1;\n            Some(paren_level)\n\
    \        } else {\n            paren_level -= 1;\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|i| {\n\
    \        if i.is_some() {\n            paren_level += 1;\n            Some(paren_level)\n\
    \        } else {\n            paren_level -= 1;\n            None\n        }\n\
    \    });\n    let mut paren_levels_iter = paren_levels_iter.filter_map(|i| {\n\
    \        if i.is_some() {\n            paren_level += 1;\n            Some(paren_level)\n\
    \        } else {\n            paren_level -= 1;\n            None\n\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvd_sy3uw.rs:96:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n81 |     let mut paren_levels_iter = paren_levels_iter.filter_map(|i| {\n\
    \   |                                                             -    - unclosed\
    \ delimiter\n   |                                                            \
    \ |\n   |                                                             unclosed\
    \ delimiter\n...\n85 |         } else {\n   |                - this delimiter\
    \ might not be properly closed...\n...\n89 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n96 | }\n   |   ^\n\nerror: expected one of\
    \ `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpvd_sy3uw.rs:96:3\n\
    \   |\n96 | }\n   |   ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\
    \nerror[E0599]: no method named `is_some` found for type `{integer}` in the current\
    \ scope\n  --> /tmp/tmpvd_sy3uw.rs:19:14\n   |\n19 |         if i.is_some() {\n\
    \   |              ^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no\
    \ method named `is_some` found for type `{integer}` in the current scope\n  -->\
    \ /tmp/tmpvd_sy3uw.rs:28:14\n   |\n28 |         if i.is_some() {\n   |       \
    \       ^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method named\
    \ `is_some` found for type `{integer}` in the current scope\n  --> /tmp/tmpvd_sy3uw.rs:37:14\n\
    \   |\n37 |         if i.is_some() {\n   |              ^^^^^^^ method not found\
    \ in `{integer}`\n\nerror[E0599]: no method named `is_some` found for type `{integer}`\
    \ in the current scope\n  --> /tmp/tmpvd_sy3uw.rs:46:14\n   |\n46 |         if\
    \ i.is_some() {\n   |              ^^^^^^^ method not found in `{integer}`\n\n\
    error[E0599]: no method named `is_some` found for type `{integer}` in the current\
    \ scope\n  --> /tmp/tmpvd_sy3uw.rs:55:14\n   |\n55 |         if i.is_some() {\n\
    \   |              ^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no\
    \ method named `is_some` found for type `{"
  stdout: ''
  timestamp: 1659748334
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level = 0;\n    for paren in paren_string.chars() {\n        if\
    \ paren == '(' {\n            paren_stack.push(paren_level);\n            paren_level\
    \ += 1;\n        } else if paren == ')' {\n            paren_level -= 1;\n   \
    \         if paren_level == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpx7rqhlka.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_nestings = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_nestings_stack\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = 0;\n    let mut paren_nestings_stack_ptr\
    \ = 0;\n    let mut paren_levels_ptr = 0;\n    let mut paren_nestings_ptr = 0;\n\
    \    let mut paren_levels_ptr_next = 0;\n    let mut paren_nestings_ptr_next =\
    \ 0;\n    let mut paren_levels_ptr_next2 = 0;\n    let mut paren_nestings_ptr_next2\
    \ = 0;\n    let mut paren_levels_ptr_next3 = 0;\n    let mut paren_nestings_ptr_next3\
    \ = 0;\n    let mut paren_levels_ptr_next4 = 0;\n    let mut paren_nestings_ptr_next4\
    \ = 0;\n    let mut paren_levels_ptr_next5 = 0;\n    let mut paren_nestings_ptr_next5\
    \ = 0;\n    let mut paren_levels_ptr_next6 = 0;\n    let mut paren_nestings_ptr_next6\
    \ = 0;\n    let mut paren_levels_ptr_next7 = 0;\n    let mut paren_nestings_ptr_next7\
    \ = 0;\n    let mut paren_levels_ptr_next8 = 0;\n    let mut paren_nestings_ptr_next8\
    \ = 0;\n    let mut paren_levels_ptr_next9 = 0;\n    let mut paren_nestings_ptr_next9\
    \ = 0;\n    let mut paren_levels_ptr_next10 = 0;\n    let mut paren_nestings_ptr_next10\
    \ = 0;\n    let mut paren_levels_ptr_next11 = 0;\n    let mut paren_nestings_ptr_next11\
    \ = 0;\n    let mut paren_levels_ptr_next12 = 0;\n    let mut paren_nestings_ptr_next12\
    \ = 0;\n    let mut paren_levels_ptr_next13 = 0;\n    let mut paren_nestings_ptr_next13\
    \ = 0;\n    let mut paren_levels_ptr_next14 = 0;\n    let mut paren_nestings_ptr_next14\
    \ = 0;\n    let mut paren_levels_ptr_next15 = 0;\n    let mut paren_nestings_ptr_next15\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptgcbz7fn.rs:47:11\n   |\n\
    47 |     let mu\n   |           ^ help: add `;` here\n48 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmptgcbz7fn.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_size\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr = Vec::new();\n\
    \    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp17ilnehk.rs:29:75\n   |\n\
    29 |     let mut paren_levels_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\n\
    \   |                                                                        \
    \   ^ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp17ilnehk.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut \n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2r6felf0.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_depth = 0;\n    let mut paren_level = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_levels_len = 0;\n    let mut paren_levels_lens = Vec::new();\n\
    \    let mut paren_levels_lens_len = 0;\n    let mut paren_levels_lens_len2 =\
    \ 0;\n    let mut paren_levels_lens_len3 = 0;\n    let mut paren_levels_lens_len4\
    \ = 0;\n    let mut paren_levels_lens_len5 = 0;\n    let mut paren_levels_lens_len6\
    \ = 0;\n    let mut paren_levels_lens_len7 = 0;\n    let mut paren_levels_lens_len8\
    \ = 0;\n    let mut paren_levels_lens_len9 = 0;\n    let mut paren_levels_lens_len10\
    \ = 0;\n    let mut paren_levels_lens_len11 = 0;\n    let mut paren_levels_lens_len12\
    \ = 0;\n    let mut paren_levels_lens_len13 = 0;\n    let mut paren_levels_lens_len14\
    \ = 0;\n    let mut paren_levels_lens_len15 = 0;\n    let mut paren_levels_lens_len16\
    \ = 0;\n    let mut paren_levels_lens_len17 = 0;\n    let mut paren_levels_lens_len18\
    \ = 0;\n    let mut paren_levels_lens_len19 = 0;\n    let mut paren_levels_lens_len20\
    \ = 0;\n    let mut paren_levels_lens_len21 = 0;\n    let mut paren_levels_lens_len22\
    \ = 0;\n    let mut paren_levels_lens_len23 = 0;\n    let mut paren_levels_lens_len24\
    \ = 0;\n    let mut paren_levels_lens_len25 = 0;\n    let mut paren_levels_lens_len26\
    \ = 0;\n    let mut paren_levels_lens_len27 = 0;\n    let mut paren_levels_lens_len28\
    \ = 0;\n    let mut paren_levels_lens_len29 = 0;\n    let mut paren_levels_lens_len30\
    \ = 0;\n    let mut paren_levels_lens_len31 = 0;\n    let mut paren_levels_lens_len32\
    \ = 0;\n    let mut paren_levels_lens_len33 = 0;\n    let mut paren_levels_lens_len34\
    \ = 0;\n    let mut paren_levels_lens_len35 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4j3jqcz1.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_iter = paren_string.char_indices();\n    let\
    \ mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mut paren_levels_iter\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter = paren_levels_iter.peekable();\n    let mu\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9k4639b3.rs:38:11\n   |\n\
    38 |     let mu\n   |           ^ help: add `;` here\n39 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9k4639b3.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_nesting = 0;\n    let mut paren_levels =\
    \ Vec::new();\n    for paren in paren_string.chars() {\n        if paren == '('\
    \ {\n            paren_stack.push(paren_nesting);\n            paren_nesting +=\
    \ 1;\n        } else if paren == ')' {\n            paren_nesting -= paren_stack.pop();\n\
    \            if paren_nesting == 0 {\n                paren_levels.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_levels\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract-assign `Option<{integer}>` from `{integer}`\n\
    \  --> /tmp/tmpkf63a7o1.rs:16:27\n   |\n16 |             paren_nesting -= paren_stack.pop();\n\
    \   |                           ^^ no implementation for `{integer} -= Option<{integer}>`\n\
    \   |\n   = help: the trait `SubAssign<Option<{integer}>>` is not implemented\
    \ for `{integer}`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_nesting_level = 0;\n    let mut paren_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvweo9_99.rs:41:18\n   |\n\
    41 |     let mut paren\n   |                  ^ help: add `;` here\n42 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvweo9_99.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9yhn3spe.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9yhn3spe.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n\
    \    let mut paren_levels_len: isize = 0;\n    let mut paren_levels_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_len: isize = 0;\n    let mut paren_levels_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_len: isize = 0;\n \
    \   let mut paren_levels_lens_lens_lens: Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_len:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens: Vec<isize> = vec![];\n\
    \    let mut paren_levels_lens_lens_lens_lens_len: isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_len:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_len: isize\
    \ = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens: Vec<isize>\
    \ = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_len:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ isize = 0;\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcp4kjzwj.rs:28:61\n   |\n\
    28 |     let mut paren_levels_lens_lens_lens_lens_lens_lens_lens_\n   |      \
    \                                                       ^ help: add `;` here\n\
    29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcp4kjzwj.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack.len();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprgpk09rz.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmprgpk09rz.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9yhn3spe.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9yhn3spe.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels:\
    \ Vec<isize> = vec![];\n    let mut paren_levels_stack: Vec<isize> = vec![];\n\
    \    let mut paren_levels_stack_len: usize = 0;\n    let mut paren_levels_stack_ptr:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end: usize = 0;\n    let mut\
    \ paren_levels_stack_ptr_end_ptr: usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr: usize = 0;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end: usize = 0;\n    let mut\
    \ paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr: usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end:\
    \ usize = 0;\n    let mut paren_levels_stack_ptr_end_ptr_\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpykvmdc88.rs:28:44\n   |\n\
    28 |     let mut paren_levels_stack_ptr_end_ptr_\n   |                       \
    \                     ^ help: add `;` here\n29 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpykvmdc88.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len()\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack.len() - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len()\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack.len() - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len()\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack.len() - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len()\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack.len() - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len()\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack.len() - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len()\
    \ - 1;\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack.len() - 1;\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_ptr = paren_levels_stack.len()\
    \ - 1;\n    let mut paren_levels_stack_top = paren_level\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa4dmsq7x.rs:36:49\n   |\n\
    36 |     let mut paren_levels_stack_top = paren_level\n   |                  \
    \                               ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpa4dmsq7x.rs:6:49\n  |\n\
    6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_ptr = 0;\n    let mut paren_levels_stack_ptr_end = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_ptr_end_ptr = paren_levels_stack_ptr_end;\n  \
    \  let mut paren_levels_stack_ptr_end_ptr_end = paren_levels_stack_ptr_end_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr = paren_levels_stack_ptr_end_ptr_end;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end = paren_levels_stack_ptr_end_ptr_end_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr = paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr = paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr =\
    \ paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr;\n    let mut\
    \ paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end = paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr;\n\
    \    let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdci9xzbl.rs:23:103\n   |\n\
    23 |     let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = paren_levels_\n   |                                                      \
    \                                                 ^ help: add `;` here\n24 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr`\
    \ in this scope\n  --> /tmp/tmpdci9xzbl.rs:16:62\n   |\n16 |     let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr;\n   |                    \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_stack_ptr_end_ptr_end_ptr_end`\n\
    \nerror[E0425]: cannot find value `paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr`\
    \ in this scope\n  --> /tmp/tmpdci9xzbl.rs:18:70\n   |\n18 |     let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr;\n   |            \
    \                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end`\n\
    \nerror[E0425]: cannot find value `paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr`\
    \ in this scope\n  --> /tmp/tmpdci9xzbl.rs:20:78\n   |\n20 |     let mut paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr;\n   |    \
    \                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end`\n\
    \nerror[E0425]: cannot find value `paren_levels_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr`\
    \ in this scope\n  --> /tmp/tmpdci9xzbl.rs:22:86\n   |\n22 | ...nd_ptr_end_ptr_end_ptr\
    \ = paren_leve"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplklc17zu.rs:36:44\n   |\n\
    36 |     let mut paren_levels_stack_cur = paren_\n   |                       \
    \                     ^ help: add `;` here\n37 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `paren_` in this scope\n  --> /tmp/tmplklc17zu.rs:36:38\n\
    \   |\n36 |     let mut paren_levels_stack_cur = paren_\n   |                \
    \                      ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmplklc17zu.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_levels_stack_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr = Vec::new();\n    let mut paren_levels_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end = Vec::new();\n\
    \    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr = Vec::new();\n    let mut\
    \ paren_levels_ptr_end_ptr_end_ptr_end_ptr_end = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = Vec::new();\n    let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqj_6w9c6.rs:28:69\n   |\n\
    28 |     let mut paren_levels_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\n  \
    \ |                                                                     ^ help:\
    \ add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpqj_6w9c6.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_level_count = 0;\n    let mut paren_level_start = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren_level_end = paren_level;\n\
    \    let mut paren_level_end = paren_level;\n    let mut paren\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0o1l48px.rs:50:18\n   |\n\
    50 |     let mut paren\n   |                  ^ help: add `;` here\n51 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp0o1l48px.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level = 0;\n    let mut paren_level_count = vec![];\n    let mut\
    \ paren_level_count_stack: Vec<isize> = vec![];\n    let mut paren_level_count_level\
    \ = 0;\n    let mut paren_level_count_level_count = vec![];\n    let mut paren_level_count_level_count_stack:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_level_count_level = 0;\n\
    \    let mut paren_level_count_level_count_level_count_stack: Vec<isize> = vec![];\n\
    \    let mut paren_level_count_level_count_level_count_level_count = 0;\n    let\
    \ mut paren_level_count_level_count_level_count_level_count_stack: Vec<isize>\
    \ = vec![];\n    let mut paren_level_count_level_count_level_count_level_count_level_count\
    \ = 0;\n    let mut paren_level_count_level_count_level_count_level_count_level_count_stack:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_level_count_level_count_level_count_level_count_level_count\
    \ = 0;\n    let mut paren_level_count_level_count_level_count_level_count_level_count_level_count_stack:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_level_count_level_count_level_count_level_count_level_count_level_count\
    \ = 0;\n    let mut paren_level_count_level_count_level_count_level_count_level_count_level_count_level_count_stack:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count\
    \ = 0;\n    let mut paren_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_stack:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count\
    \ = 0;\n    let mut paren_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_stack:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count\
    \ = 0;\n    let mut paren_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_level_count_stack:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_level_count_level_count_level_\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppqun8vq8.rs:30:61\n   |\n\
    30 |     let mut paren_level_count_level_count_level_count_level_\n   |      \
    \                                                       ^ help: add `;` here\n\
    31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmppqun8vq8.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: usize = 0;\n    let mut paren_levels: Vec<isize> = vec![];\n\
    \    for paren in paren_string.chars() {\n        if paren == '(' {\n        \
    \    paren_stack.push(paren_level);\n            paren_level += 1;\n         \
    \   paren_levels.push(paren_level);\n        } else if paren == ')' {\n      \
    \      paren_level -= 1;\n            if paren_stack.pop() == paren_level {\n\
    \                paren_levels.push(paren_level);\n            }\n        }\n \
    \   }\n    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9oi3deh.rs:12:30\n   |\n\
    12 |             paren_stack.push(paren_level);\n   |                        \
    \      ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    12 |             paren_stack.push(paren_level.try_into().unwrap());\n   |    \
    \                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb9oi3deh.rs:14:31\n   |\n14 |             paren_levels.push(paren_level);\n\
    \   |                               ^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |             paren_levels.push(paren_level.try_into().unwrap());\n\
    \   |                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb9oi3deh.rs:17:37\n   |\n17 |             if\
    \ paren_stack.pop() == paren_level {\n   |                                   \
    \  ^^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found type `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb9oi3deh.rs:18:35\n   |\n18 |                 paren_levels.push(paren_level);\n\
    \   |                                   ^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |                 paren_levels.push(paren_level.try_into().unwrap());\n\
    \   |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    for paren in paren_string.chars() {\n \
    \       if paren == '(' {\n            paren_stack.push(paren_level);\n      \
    \      paren_level += 1;\n        } else if paren == ')' {\n            paren_level\
    \ -= 1;\n            if paren_level == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpifgr9nrv.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string\
    \ = paren_string;\n    while paren_level_index < paren_string.len() {\n      \
    \  if paren_level_index == paren_string.len() - 1 {\n            paren_levels.push(paren_level);\n\
    \            paren_level_string = paren_level_string.trim_end().to_string();\n\
    \            paren_level_index += 1;\n            paren_level += 1;\n        \
    \    continue;\n        }\n        let mut paren_level_char = paren_level_string[paren_level_index];\n\
    \        if paren_level_char == ')' {\n            paren_level_index += 1;\n \
    \           paren_level -= 1;\n            continue;\n        }\n        if paren_level_char\
    \ == '(' {\n            paren_level += 1;\n            paren_level_index += 1;\n\
    \            paren_levels.push(paren_level);\n            paren_level_string =\
    \ paren_level_string.trim_end().to_string();\n            paren_level_index +=\
    \ 1;\n            paren_level += 1;\n            continue;\n        }\n      \
    \  if paren_level_char == ' ' {\n            paren_level_index += 1;\n       \
    \     paren_level -= 1;\n            continue;\n        }\n        if paren_level_char\
    \ == ')' || paren_level_char == ')(' {\n            paren_level_string = paren_level_string.trim_end().to_string();\n\
    \            paren_level_index += 1;\n            paren_level += 1;\n        \
    \    continue;\n        }\n        if paren_level_char == ')(' {\n           \
    \ paren_level_string = paren_level_string.trim_end().to_string();\n          \
    \  paren_level_index += 1;\n            paren_level += 1;\n            continue;\n\
    \        }\n        if paren_level_char == ')' || paren_level_char == ')' || paren_level_char\
    \ == ')(' {\n            paren_level_string = paren_level_string.trim_end().to_string();\n\
    \            paren_level_index += 1;\n            paren_level += 1;\n        \
    \    continue;\n        }\n        if paren_level_char == ')(' {\n           \
    \ paren_level_string = paren_level_string.trim_end().to_string();\n          \
    \  paren_level_index += 1;\n            paren_level += 1;\n            continue;\n\
    \        }\n        if paren_level_char == ')' || paren_level_char == ')' || paren_level_char\
    \ == ')(' {\n            paren_level_string = paren_level_string.trim_end().to_string();\n\
    \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmprhvcjj7_.rs:39:59\n\
    \   |\n39 |         if paren_level_char == ')' || paren_level_char == ')(' {\n\
    \   |                                                           ^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n39 |       \
    \  if paren_level_char == ')' || paren_level_char == \")(\" {\n   |          \
    \                                                 ~~~~\n\nerror: character literal\
    \ may only contain one codepoint\n  --> /tmp/tmprhvcjj7_.rs:45:32\n   |\n45 |\
    \         if paren_level_char == ')(' {\n   |                                ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    45 |         if paren_level_char == \")(\" {\n   |                           \
    \     ~~~~\n\nerror: character literal may only contain one codepoint\n  --> /tmp/tmprhvcjj7_.rs:51:86\n\
    \   |\n51 |         if paren_level_char == ')' || paren_level_char == ')' || paren_level_char\
    \ == ')(' {\n   |                                                            \
    \                          ^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n51 |         if paren_level_char == ')' || paren_level_char\
    \ == ')' || paren_level_char == \")(\" {\n   |                               \
    \                                                       ~~~~\n\nerror: character\
    \ literal may only contain one codepoint\n  --> /tmp/tmprhvcjj7_.rs:57:32\n  \
    \ |\n57 |         if paren_level_char == ')(' {\n   |                        \
    \        ^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n57 |         if paren_level_char == \")(\" {\n   |                    \
    \            ~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmprhvcjj7_.rs:63:86\n   |\n63 |         if paren_level_char == ')'\
    \ || paren_level_char == ')' || paren_level_char == ')(' {\n   |             \
    \                                                                         ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    63 |         if paren_leve"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_nesting = 0;\n    let mut paren_levels =\
    \ Vec::new();\n    let mut paren_nesting_levels = Vec::new();\n    let mut paren_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels_len = paren_nesting_levels.len();\n \
    \   let mut paren_nesting_levels_len2 = paren_nesting_levels_len;\n    let mut\
    \ paren_nesting_levels_len3 = paren_nesting_levels_len;\n    let mut paren_nesting_levels_len4\
    \ = paren_nesting_levels_len;\n    let mut paren_nesting_levels_len5 = paren_nesting_levels_len;\n\
    \    let mut paren_nesting_levels_len6 = paren_nesting_levels_len;\n    let mut\
    \ paren_nesting_levels_len7 = paren_nesting_levels_len;\n    let mut paren_nesting_levels_len8\
    \ = paren_nesting_levels_len;\n    let mut paren_nesting_levels_len9 = paren_nesting_levels_len;\n\
    \    let mut paren_nesting_levels_len10 = paren_nesting_levels_len;\n    let mut\
    \ paren_nesting_levels_len11 = paren_nesting_levels_len;\n    let mut paren_nesting_levels_len12\
    \ = paren_nesting_levels_len;\n    let mut paren_nesting_levels_len13 = paren_nesting_levels_len;\n\
    \    let mut paren_nesting_levels_len14 = paren_nesting_levels_len;\n    let mut\
    \ paren_nesting_levels_len15 = paren_nesting_levels_len;\n    let mut paren_nesting_levels_len16\
    \ = paren_nesting_levels_len;\n    let mut paren_nesting_levels_len17 = paren_nesting_levels_len;\n\
    \    let mut paren_nesting_levels_len18 = paren_nesting_levels_len;\n    let mut\
    \ paren_nesting_levels_len19 = paren_nesting_levels_len;\n    let mut paren_nesting_levels_len20\
    \ = paren_nesting_levels_len;\n    let mut paren_nesting_levels_len21 = paren_nesting_levels_len;\n\
    \    let mut paren_nesting_levels_len22 = paren_nesting_levels_len;\n    let mut\
    \ paren_nesting_levels_len23 = paren_nesting_levels_len;\n\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2z4__i2w.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level: isize = 0;\n    for paren in paren_string.chars() {\n \
    \       if paren == '(' {\n            paren_stack.push(paren_level);\n      \
    \      paren_level += 1;\n        } else if paren == ')' {\n            paren_level\
    \ -= 1;\n            if paren_level == 0 {\n                paren_stack.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmpifgr9nrv.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_pos = 0;\n    let mut paren_levels_stack_len = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_levels_stack_bottom = paren_levels_stack_len;\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack_len;\n    let mut paren_levels_stack_bottom\
    \ = paren_levels_stack_len;\n    let mut paren_levels_stack_top = paren_levels_stack_len;\n\
    \    let mut paren_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuykbvdhe.rs:39:19\n   |\n\
    39 |     let mut paren_\n   |                   ^ help: add `;` here\n40 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpuykbvdhe.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level = 0;\n    let mut paren_level_count: Vec<isize> = vec![];\n\
    \    let mut paren_level_count_stack: Vec<isize> = vec![];\n    let mut paren_level_count_stack_count:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_stack_count1: Vec<isize>\
    \ = vec![];\n    let mut paren_level_count_stack_count2: Vec<isize> = vec![];\n\
    \    let mut paren_level_count_stack_count3: Vec<isize> = vec![];\n    let mut\
    \ paren_level_count_stack_count4: Vec<isize> = vec![];\n    let mut paren_level_count_stack_count5:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_stack_count6: Vec<isize>\
    \ = vec![];\n    let mut paren_level_count_stack_count7: Vec<isize> = vec![];\n\
    \    let mut paren_level_count_stack_count8: Vec<isize> = vec![];\n    let mut\
    \ paren_level_count_stack_count9: Vec<isize> = vec![];\n    let mut paren_level_count_stack_count10:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_stack_count11: Vec<isize>\
    \ = vec![];\n    let mut paren_level_count_stack_count12: Vec<isize> = vec![];\n\
    \    let mut paren_level_count_stack_count13: Vec<isize> = vec![];\n    let mut\
    \ paren_level_count_stack_count14: Vec<isize> = vec![];\n    let mut paren_level_count_stack_count15:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_stack_count16: Vec<isize>\
    \ = vec![];\n    let mut paren_level_count_stack_count17: Vec<isize> = vec![];\n\
    \    let mut paren_level_count_stack_count18: Vec<isize> = vec![];\n    let mut\
    \ paren_level_count_stack_count19: Vec<isize> = vec![];\n    let mut paren_level_count_stack_count20:\
    \ Vec<isize> = vec![];\n    let mut paren_level_count_stack_count21: Vec<isize\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `+`, `,`, `::`, `:`, `<`, `=`, or `>`,\
    \ found `}`\n  --> /tmp/tmppuirueb7.rs:33:1\n   |\n32 |     let mut paren_level_count_stack_count21:\
    \ Vec<isize\n   |         ------------------------------------          - expected\
    \ one of 9 possible tokens\n   |         |                                  |\n\
    \   |         |                                  help: use `=` if you meant to\
    \ assign\n   |         while parsing the type for `mut paren_level_count_stack_count21`\n\
    33 | }\n   | ^ unexpected token\n\nerror: expected `;`, found `}`\n  --> /tmp/tmppuirueb7.rs:32:55\n\
    \   |\n32 |     let mut paren_level_count_stack_count21: Vec<isize\n   |     \
    \                                                  ^ help: add `;` here\n33 |\
    \ }\n   | - unexpected token\n\nerror[E0423]: expected value, found struct `Vec`\n\
    \   --> /tmp/tmppuirueb7.rs:32:46\n    |\n32  |       let mut paren_level_count_stack_count21:\
    \ Vec<isize\n    |                                                ^^^ help: use\
    \ struct literal syntax instead: `Vec { buf: val, len: val }`\n\nerror[E0423]:\
    \ expected value, found builtin type `isize`\n  --> /tmp/tmppuirueb7.rs:32:50\n\
    \   |\n32 |     let mut paren_level_count_stack_count21: Vec<isize\n   |     \
    \                                             ^^^^^ not a value\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppuirueb7.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level = 0;\n    let mut paren_level_count = 0;\n    for paren\
    \ in paren_string.chars() {\n        if paren == '(' {\n            paren_stack.push(paren_level);\n\
    \            paren_level_count = 1;\n        } else if paren == ')' {\n      \
    \      paren_level_count = paren_stack.pop();\n            if paren_level_count\
    \ == 0 {\n                paren_level_count = paren_level;\n            }\n  \
    \      }\n        paren_level += paren_level_count;\n    }\n    paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmznlpkad.rs:15:33\n   |\n\
    15 |             paren_level_count = paren_stack.pop();\n   |                \
    \                 ^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n  \
    \ |\n   = note: expected type `{integer}`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmznlpkad.rs:22:5\n   |\n6  | fn\
    \ parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |            \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n22 |     paren_level\n   |     ^^^^^^^^^^^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_nestings = Vec::new();\n\
    \    let mut paren_levels_stack = Vec::new();\n    let mut paren_nestings_stack\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = paren_levels_stack.as_mut_ptr();\n\
    \    let mut paren_nestings_stack_ptr = paren_nestings_stack.as_mut_ptr();\n \
    \   let mut paren_levels_stack_ptr_end = paren_levels_stack.end();\n    let mut\
    \ paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.end();\n    let mut paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.end();\n    let mut\
    \ paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.end();\n    let mut paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.end();\n    let mut\
    \ paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.end();\n    let mut paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.end();\n    let mut\
    \ paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.end();\n    let mut paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.end();\n    let mut\
    \ paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.end();\n    let mut paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n\
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.end();\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `end` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmp7dwiq23c.rs:15:61\n   |\n15 |     let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.end();\n   |                                          \
    \                   ^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method\
    \ named `end` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp7dwiq23c.rs:16:65\n\
    \   |\n16 |     let mut paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n\
    \   |                                                                 ^^^ method\
    \ not found in `Vec<_>`\n\nerror[E0599]: no method named `end` found for struct\
    \ `Vec<_>` in the current scope\n  --> /tmp/tmp7dwiq23c.rs:17:61\n   |\n17 | \
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.end();\n   |    \
    \                                                         ^^^ method not found\
    \ in `Vec<_>`\n\nerror[E0599]: no method named `end` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmp7dwiq23c.rs:18:65\n   |\n18 |     let mut\
    \ paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n   |           \
    \                                                      ^^^ method not found in\
    \ `Vec<_>`\n\nerror[E0599]: no method named `end` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmp7dwiq23c.rs:19:61\n   |\n19 |     let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack.end();\n   |                                          \
    \                   ^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method\
    \ named `end` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp7dwiq23c.rs:20:65\n\
    \   |\n20 |     let mut paren_nestings_stack_ptr_end = paren_nestings_stack.end();\n\
    \   |                                                                 ^^^ method\
    \ not found in `Vec<_>`\n\nerror[E0599]: no method named `end` found for struct\
    \ `Vec<_>` in the current scope\n  --> /tmp/tmp7dwiq23c.rs:21:61\n   |\n21 | \
    \    let mut paren_levels_stack_ptr_end = paren_levels_stack.end();\n   |    \
    \                                                         ^^^ method not found "
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_pos = 0;\n    let mut paren_level_stack = Vec::new();\n \
    \   let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_size = paren_level_stack.len();\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n    let mut paren_level_stack_pos = 0;\n\
    \    let mut paren_level_stack_pos = 0;\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9w4ieu8o.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_stack = vec![];\n\
    \    for paren in paren_string.chars() {\n        if paren == ')' {\n        \
    \    paren_stack.pop();\n            level += 1;\n        } else if paren == '('\
    \ {\n            paren_stack.push(level);\n            level += 1;\n        }\n\
    \    }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmppnqhhwug.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels_stack = vec![0];\n    let mut paren_levels_stack_pos\
    \ = 0;\n    let mut paren_levels_stack_size = paren_levels_stack.len();\n    let\
    \ mut paren_levels_stack_ptr = paren_levels_stack.as_mut_ptr();\n    let mut paren_levels_stack_ptr_pos\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n    let mut paren_levels_stack_ptr_end\
    \ = \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpdmj3j30m.rs:29:1\n\
    \   |\n29 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdmj3j30m.rs:13:72\n   |\n13 |     let mut paren_levels_stack_ptr_pos\
    \ = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n   |            \
    \                                                            ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n13 |     let mut\
    \ paren_levels_stack_ptr_pos = paren_levels_stack_ptr.offset(paren_levels_stack_size.try_into().unwrap());\n\
    \   |                                                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdmj3j30m.rs:14:72\n   |\n14 |\
    \     let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n\
    \   |                                                                        ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |     let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack_size.try_into().unwrap());\n\
    \   |                                                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdmj3j30m.rs:15:72\n   |\n15 |\
    \     let mut paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack_size);\n\
    \   |                                                                        ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |     let mut\
    \ paren_levels_stack_ptr_end = paren_levels_stack_ptr.offset(paren_levels_stack_size.try_into().unwrap());\n\
    \   |                                                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \ne"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels = vec![];\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            paren_stack.push(paren_level);\n \
    \           paren_level += 1;\n            paren_levels.push(paren_level);\n \
    \       } else if paren == ')' {\n            paren_level -= 1;\n            if\
    \ paren_stack.pop() == paren_level {\n                paren_levels.push(paren_level);\n\
    \            }\n        }\n    }\n    paren_levels\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2jjstanq.rs:17:37\n   |\n\
    17 |             if paren_stack.pop() == paren_level {\n   |                 \
    \                    ^^^^^^^^^^^\n   |                                     |\n\
    \   |                                     expected enum `Option`, found integer\n\
    \   |                                     help: try using a variant of the expected\
    \ enum: `Some(paren_level)`\n   |\n   = note: expected enum `Option<{integer}>`\n\
    \              found type `{integer}`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = vec![0];\n    let mut paren_level\
    \ = 0;\n    let mut paren_nesting = 0;\n    let mut paren_nesting_level = 0;\n\
    \    let mut paren_nesting_nesting = 0;\n    let mut paren_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let\
    \ mut paren_nesting_nesting_nesting_nesting_level = 0;\n    let mut paren_nesting_nesting_nesting_nesting_level\
    \ = 0;\n    let mut paren_nesting_nesting_\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo94cdj3d.rs:41:35\n   |\n\
    41 |     let mut paren_nesting_nesting_\n   |                                \
    \   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpo94cdj3d.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ let mut paren_level = 0;\n    let mut paren_level_count: Vec<isize> = vec![];\n\
    \    let mut paren_level_count_idx = 0;\n    let mut paren_level_count_idx2 =\
    \ 0;\n    let mut paren_level_count_idx3 = 0;\n    let mut paren_level_count_idx4\
    \ = 0;\n    let mut paren_level_count_idx5 = 0;\n    let mut paren_level_count_idx6\
    \ = 0;\n    let mut paren_level_count_idx7 = 0;\n    let mut paren_level_count_idx8\
    \ = 0;\n    let mut paren_level_count_idx9 = 0;\n    let mut paren_level_count_idx10\
    \ = 0;\n    let mut paren_level_count_idx11 = 0;\n    let mut paren_level_count_idx12\
    \ = 0;\n    let mut paren_level_count_idx13 = 0;\n    let mut paren_level_count_idx14\
    \ = 0;\n    let mut paren_level_count_idx15 = 0;\n    let mut paren_level_count_idx16\
    \ = 0;\n    let mut paren_level_count_idx17 = 0;\n    let mut paren_level_count_idx18\
    \ = 0;\n    let mut paren_level_count_idx19 = 0;\n    let mut paren_level_count_idx20\
    \ = 0;\n    let mut paren_level_count_idx21 = 0;\n    let mut paren_level_count_idx22\
    \ = 0;\n    let mut paren_level_count_idx23 = 0;\n    let mut paren_level_count_idx24\
    \ = 0;\n    let mut paren_level_count_idx25 = 0;\n    let mut paren_level_count_idx26\
    \ = 0;\n    let mut paren_level_count_idx27 = 0;\n    let mut paren_level_count_idx28\
    \ = 0;\n    let mut paren_level_count_idx29 = 0;\n    let mut paren_level_count_idx30\
    \ = 0;\n    let mut paren_level_count_idx31 = 0;\n    let mut paren_level_count_idx32\
    \ = 0;\n    let mut paren_level_count_idx33 = 0;\n    let mut paren_level_count_idx34\
    \ = 0;\n    let mut paren_level_count_idx35 = 0;\n    let mut paren_level_count_idx36\
    \ = 0;\n    let mut paren_level_count_idx37 = 0;\n    let mut paren_level_count_idx38\
    \ = 0;\n    let mut paren_level_count_idx39 = 0;\n    let mut paren_level_count_idx40\
    \ = 0;\n    let mut paren_level_count_idx41 = 0;\n    let mut paren_level_count_idx42\
    \ = 0;\n    let mut paren_level_count_idx43 = 0;\n    let \n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpkngzs66x.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_nesting\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_nesting_levels\
    \ = Vec::new();\n    let mut paren_levels_stack = Vec::new();\n    let mut paren_nesting_levels_stack\
    \ = Vec::new();\n    let mut paren_levels_stack_ptr = paren_levels_stack.as_mut_ptr();\n\
    \    let mut paren_nesting_levels_stack_ptr = paren_nesting_levels_stack.as_mut_ptr();\n\
    \    let mut paren_levels_ptr = paren_levels.as_mut_ptr();\n    let mut paren_nesting_levels_ptr\
    \ = paren_nesting_levels.as_mut_ptr();\n    let mut paren_levels_ptr_next = paren_levels_ptr;\n\
    \    let mut paren_nesting_levels_ptr_next = paren_nesting_levels_ptr;\n    let\
    \ mut paren_levels_ptr_end = paren_levels_ptr;\n    let mut paren_nesting_levels_ptr_end\
    \ = paren_nesting_levels_ptr;\n    let mut paren_levels_ptr_end = paren_levels_ptr;\n\
    \    let mut paren_nesting_levels_ptr_end = paren_nesting_levels_ptr;\n    let\
    \ mut paren_levels_ptr_end = paren_levels_ptr;\n    let mut paren_nesting_levels_ptr_end\
    \ = paren_nesting_levels_ptr;\n    let mut paren_levels_ptr_end = paren_levels_ptr;\n\
    \    let mut paren_nesting_levels_ptr_end = paren_nesting_levels_ptr;\n    let\
    \ mut paren_levels_ptr_end = paren_levels_ptr;\n    let mut paren_nesting_levels_ptr_end\
    \ = paren_nesting_levels_ptr;\n    let mut paren_levels_ptr_end = paren_levels_ptr;\n\
    \    let mut paren_nesting_levels_ptr_end = paren_nesting_levels_ptr;\n    let\
    \ mut paren_levels_ptr_end = paren_levels_ptr;\n    let mut paren_nesting_levels_ptr_end\
    \ = paren_nesting_levels_ptr;\n    let mut paren_levels_ptr_end = paren_levels_ptr;\n\
    \    let mut paren_nesting_levels_ptr_end = paren_nesting_levels_ptr;\n    let\
    \ mut paren_levels_ptr_end = paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg68gbdqz.rs:35:41\n   |\n\
    35 |     let mut paren_levels_ptr_end = paren\n   |                          \
    \               ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `paren` in this scope\n  --> /tmp/tmpg68gbdqz.rs:35:36\n \
    \  |\n35 |     let mut paren_levels_ptr_end = paren\n   |                    \
    \                ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpg68gbdqz.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels = Vec::new();\n    let mut paren_levels_iter\
    \ = paren_string.char_indices();\n    let mut paren_levels_iter = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut\
    \ paren_levels_iter_next = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next\
    \ = paren_levels_iter.peekable();\n    let mut paren_levels_iter_next = paren_levels_iter.peekable();\n\
    \    let mut paren_levels_iter_next = paren_levels_iter.peekable\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdomga0x7.rs:36:64\n   |\n\
    36 |     let mut paren_levels_iter_next = paren_levels_iter.peekable\n   |   \
    \                                                             ^ help: add `;`\
    \ here\n37 | }\n   | - unexpected token\n\nerror[E0615]: attempted to take value\
    \ of method `peekable` on type `Peekable<CharIndices<'_>>`\n  --> /tmp/tmpdomga0x7.rs:36:56\n\
    \   |\n36 |     let mut paren_levels_iter_next = paren_levels_iter.peekable\n\
    \   |                                                        ^^^^^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n36 |    \
    \ let mut paren_levels_iter_next = paren_levels_iter.peekable()\n   |        \
    \                                                        ++\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpdomga0x7.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0615.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748334
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_levels_stack = Vec::new();\n    let mut\
    \ paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_cur = paren_levels_stack.len();\n    let mut paren_levels_stack_top\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_cur = paren_levels_stack.len();\n\
    \    let mut paren_levels_stack_top = paren_levels_stack.len();\n    let mut paren_levels_stack_cur\
    \ = paren_levels_stack.len();\n    let mut paren_levels_stack_top = paren_levels_stack.len();\n\
    \    let mut paren_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9yhn3spe.rs:37:24\n   |\n\
    37 |     let mut paren_level\n   |                        ^ help: add `;` here\n\
    38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9yhn3spe.rs:6:49\n\
    \  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |  \
    \  -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748333
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_level = 0;\n    let mut paren_level_index = 0;\n    let mut paren_level_string\
    \ = paren_string;\n    while paren_level_index < paren_string.len() {\n      \
    \  let mut paren_level_string = paren_string;\n        let mut paren_level = 0;\n\
    \        while paren_level_index < paren_string.len() {\n            let mut paren_level_string\
    \ = paren_string;\n            let mut paren_level = 0;\n            while paren_level_index\
    \ < paren_string.len() {\n                let mut paren_level_string = paren_string;\n\
    \                let mut paren_level = 0;\n                while paren_level_index\
    \ < paren_string.len() {\n                    let mut paren_level_string = paren_string;\n\
    \                    let mut paren_level = 0;\n                    while paren_level_index\
    \ < paren_string.len() {\n                        let mut paren_level_string =\
    \ paren_string;\n                        let mut paren_level = 0;\n          \
    \              while paren_level_index < paren_string.len() {\n              \
    \              let mut paren_level_string = paren_string;\n                  \
    \          let mut paren_level = 0;\n                            while paren_level_index\
    \ < paren_string.len() {\n                                let mut paren_level_string\
    \ = paren_string;\n                                let mut paren_level = 0;\n\
    \                                while paren_level_index < paren_string.len()\
    \ {\n                                    let mut paren_level_string = paren_string;\n\
    \                                    let mut paren_level = 0;\n              \
    \                      while paren_level_index < paren_string.len() {\n      \
    \                                  let mut paren_level_string = paren_string;\n\
    \                                        let mut paren_level = 0;\n          \
    \                              while paren_level_index < paren_string.len() {\n\
    \                                            let mut paren_level_string = paren_string;\n\
    \                                            let mut paren_level = 0;\n      \
    \                                      while paren_level_index < paren_string.len()\
    \ {\n                                                let mut paren_level_string\
    \ = paren_string;\n                                                let mut paren_level\
    \ = 0;\n                                            }\n                      \
    \                  }\n                                    }\n                \
    \                }\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n        paren_levels.push(paren_level);\n\
    \        paren_level_index += 1;\n    }\n    paren_levels\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `paren_level`\n --> /tmp/tmpl617b9q5.rs:8:13\n\
    \  |\n8 |     let mut paren_level = 0;\n  |             ^^^^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_paren_level`\n  |\n  = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `paren_level_string`\n\
    \  --> /tmp/tmpl617b9q5.rs:10:13\n   |\n10 |     let mut paren_level_string =\
    \ paren_string;\n   |             ^^^^^^^^^^^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_paren_level_string`\n\nwarning: unused variable:\
    \ `paren_level_string`\n  --> /tmp/tmpl617b9q5.rs:12:17\n   |\n12 |         let\
    \ mut paren_level_string = paren_string;\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_paren_level_string`\n\
    \nwarning: unused variable: `paren_level_string`\n  --> /tmp/tmpl617b9q5.rs:15:21\n\
    \   |\n15 |             let mut paren_level_string = paren_string;\n   |     \
    \                ^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with\
    \ an underscore: `_paren_level_string`\n\nwarning: unused variable: `paren_level`\n\
    \  --> /tmp/tmpl617b9q5.rs:16:21\n   |\n16 |             let mut paren_level =\
    \ 0;\n   |                     ^^^^^^^^^^^ help: if this is intentional, prefix\
    \ it with an underscore: `_paren_level`\n\nwarning: unused variable: `paren_level_string`\n\
    \  --> /tmp/tmpl617b9q5.rs:18:25\n   |\n18 |                 let mut paren_level_string\
    \ = paren_string;\n   |                         ^^^^^^^^^^^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_paren_level_string`\n\nwarning:\
    \ unused variable: `paren_level`\n  --> /tmp/tmpl617b9q5.rs:19:25\n   |\n19 |\
    \                 let mut paren_level = 0;\n   |                         ^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_paren_level`\n\
    \nwarning: unused variable: `paren_level_string`\n  --> /tmp/tmpl617b9q5.rs:21:29\n\
    \   |\n21 |                     let mut paren_level_string = paren_string;\n \
    \  |                             ^^^^^^^^^^^^^^^^^^ help: if this is intentional,\
    \ prefix "
  stdout: ''
  timestamp: 1659748334
