name: HumanEval_100_make_a_pile
language: rs
prompt: "/// Given a positive integer n, you have to make a pile of n levels of stones.\n\
  /// The first level has n stones.\n/// The number of stones in the next level is:\n\
  /// - the next odd number if n is odd.\n/// - the next even number if n is even.\n\
  /// Return the number of stones in each level in a vector, where element at index\n\
  /// i represents the number of stones in the level (i+1).\n/// Examples:\n/// >>>\
  \ make_a_pile(3)\n/// vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
  \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
  \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
  \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
completions: ["    let mut pile = vec![0; n + 1];\n    pile[0] += n;\n    if n % 2\
    \ == 0 {\n        pile[1] += n / 2;\n    } else {\n        pile[2] += n / 2;\n\
    \    }\n    pile", "    let mut pile = vec![];\n    if n % 2 == 0 {\n        pile.push(n\
    \ - 1);\n    } else {\n        pile.push(n - 1);\n        pile.push(n - 2);\n\
    \    }\n    for i in 0..n {\n        pile.push(i + 1);\n    }\n    pile", "  \
    \  let mut pile = vec![0; n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n  \
    \      if i % 2 == 0 {\n            pile[i] = pile[i - 1] + 1;\n        } else\
    \ {\n            pile[i] = pile[i - 1];\n        }\n    }\n    pile", "    let\
    \ mut pile = vec![n];\n    if n % 2 == 0 {\n        pile[0] += 1;\n    } else\
    \ {\n        pile[0] += 2;\n    }\n    for i in 1..pile.len() {\n        pile[i]\
    \ += pile[i - 1];\n    }\n    pile", "    let mut stones = Vec::new();\n    if\
    \ n % 2 == 0 {\n        stones.push(n % 2);\n    } else {\n        stones.push(n\
    \ - stones.last().unwrap());\n    }\n    for i in 1..n {\n        stones.push(stones.last().unwrap());\n\
    \    }\n    stones", "    let mut pile = vec![n];\n    if n % 2 == 1 {\n     \
    \   pile.push(n - 1);\n    }\n    for i in 2..=n {\n        if i % 2 == 0 {\n\
    \            pile.push(i);\n        }\n    }\n    pile", "    let mut pile = Vec::new();\n\
    \    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            pile.push(n\
    \ % 2);\n            n /= 2;\n        } else {\n            pile.push(n / 2);\n\
    \            n /= 2;\n        }\n    }\n    pile", "    let mut pile = vec![];\n\
    \    pile.push(n);\n    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else\
    \ {\n        pile.push((n - 1) + (n - 2) / 2);\n    }\n    pile", "    let mut\
    \ pile = Vec::new();\n    let mut next_odd_level = 0;\n    let mut next_even_level\
    \ = 0;\n    for _ in 0..n {\n        if n % 2 == 0 {\n            pile.push(next_even_level);\n\
    \            next_even_level += 1;\n        } else {\n            pile.push(next_odd_level);\n\
    \            next_odd_level += 1;\n        }\n    }\n    pile", "    let mut pile\
    \ = vec![0; n + 1];\n    pile[0] = n;\n    for i in 1..=n {\n        if i % 2\
    \ == 0 {\n            pile[i] = pile[i - 1] + 1;\n        } else {\n         \
    \   pile[i] = pile[i - 1];\n        }\n    }\n    pile", "    let mut pile = vec![];\n\
    \    if n % 2 == 0 {\n        pile.push(n - 1);\n    } else {\n        pile.push(n\
    \ - 1);\n        pile.push(n - 1);\n    }\n    for i in 0..n {\n        pile.push(i\
    \ + 1);\n    }\n    pile", "    let mut stones = Vec::new();\n    if n % 2 ==\
    \ 0 {\n        stones.push(n / 2);\n    } else {\n        let mut odd_stones =\
    \ n / 2;\n        let mut even_stones = n - odd_stones;\n        while even_stones\
    \ > 0 {\n            stones.push(even_stones);\n            even_stones -= 2;\n\
    \        }\n        while odd_stones > 0 {\n            stones.push(odd_stones);\n\
    \            odd_stones -= 2;\n        }\n    }\n    stones", "    let mut stones\
    \ = Vec::new();\n    let mut next_odd = 1;\n    let mut next_even = 1;\n\n   \
    \ while stones.len() < n {\n        if n % 2 == 0 {\n            next_even *=\
    \ 2;\n        } else {\n            next_odd *= 2;\n        }\n        stones.push(next_odd);\n\
    \        stones.push(next_even);\n        n -= 1;\n    }\n\n    stones", "   \
    \ let mut pile = vec![];\n    if n % 2 == 0 {\n        for _ in 0..n {\n     \
    \       pile.push(n - 1);\n        }\n    } else {\n        for _ in 0..n {\n\
    \            pile.push((n - 1) / 2);\n        }\n    }\n    pile", "    let mut\
    \ stones = Vec::new();\n    if n % 2 == 0 {\n        stones.push(n - 1);\n   \
    \ } else {\n        stones.push(n - 1);\n        stones.push(n - 2);\n    }\n\
    \    stones", "    let mut stones = Vec::new();\n    let mut level = 0;\n    while\
    \ stones.len() < n {\n        if n % 2 == 0 {\n            stones.push(stones.last().unwrap()\
    \ + 1);\n        } else {\n            stones.push(stones.last().unwrap());\n\
    \        }\n        level += 1;\n        n = n / 2;\n    }\n    stones", "   \
    \ let mut stones = Vec::new();\n    if n % 2 == 0 {\n        for _ in 0..n {\n\
    \            stones.push(stones.last().unwrap() + 1);\n        }\n    } else {\n\
    \        for _ in 0..n {\n            stones.push(stones.last().unwrap());\n \
    \       }\n    }\n    stones", "    let mut stones = Vec::new();\n    let mut\
    \ next_odd_stones = if n % 2 == 1 {\n        n / 2\n    } else {\n        n /\
    \ 2 + 1\n    };\n    let mut next_even_stones = if n % 2 == 0 {\n        n / 2\n\
    \    } else {\n        n / 2 + 1\n    };\n    for i in 0..n {\n        if i %\
    \ 2 == 0 {\n            stones.push(next_even_stones);\n            next_even_stones\
    \ += 2;\n        } else {\n            stones.push(next_odd_stones);\n       \
    \     next_odd_stones += 2;\n        }\n    }\n    stones", "    let mut pile\
    \ = vec![0; n + 1];\n    pile[0] += n;\n    if n % 2 == 0 {\n        pile[1] +=\
    \ n / 2;\n    } else {\n        pile[1] += n / 2;\n        pile[2] += n / 2;\n\
    \    }\n    pile", "    let mut pile = vec![];\n    if n % 2 == 0 {\n        pile.push(n\
    \ / 2);\n    }\n    for i in 1..n / 2 {\n        pile.push((i + 1) * 2);\n   \
    \ }\n    pile"]
stop_tokens:
- "\n}"
