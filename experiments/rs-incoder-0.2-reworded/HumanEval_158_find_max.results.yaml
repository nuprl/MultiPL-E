name: HumanEval_158_find_max
language: rs
results:
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy9bpfmi5.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpe2f6k1ru.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in &words {\n        let count = word.chars().count();\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2bqlovxc.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9oxz9n1q.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    let mut max_word = words.iter().find(|word|\
    \ word.chars().count() == max_count).unwrap();\n    for word in words.iter() {\n\
    \        let count = word.chars().count();\n        if count == max_count {\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfmbukrk5.rs:21:5\n   |\n\
    11 | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n21 |     max_word\n\
    \   |     ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \     |\n   |     expected struct `String`, found `&String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().rev() {\n        let count = word.chars().count();\n       \
    \ if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpczfdvrna.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        if word.chars().count() > max_count {\n \
    \           max_count = word.chars().count();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqfjakml.rs:17:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n17 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for (i, word) in\
    \ words.iter().enumerate() {\n        if word.chars().count() > max_count {\n\
    \            max_count = word.chars().count();\n            max_word = word;\n\
    \            max_index = i;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaqcpuofq.rs:18:24\n   |\n\
    13 |     let mut max_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n18 |             max_word = word;\n   |   \
    \                     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpaqcpuofq.rs:14:25\n   |\n14 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for (i, word) in\
    \ words.iter().enumerate() {\n        if word.chars().count() > max_count {\n\
    \            max_count = word.chars().count();\n            max_word = word;\n\
    \            max_index = i;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8wg11zx.rs:18:24\n   |\n\
    13 |     let mut max_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n18 |             max_word = word;\n   |   \
    \                     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpd8wg11zx.rs:14:25\n   |\n14 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp6sqbms2w.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp2lil4sec.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashMap::new();\n    let mut max_chars = String::new();\n    for word in words\
    \ {\n        for char in word.chars() {\n            if !unique_chars.contains_key(&char)\
    \ {\n                unique_chars.insert(char, 0);\n            }\n          \
    \  unique_chars.entry(char).or_insert(0) += 1;\n        }\n        if unique_chars.values().iter().max().is_some()\
    \ {\n            max_chars = word;\n        }\n    }\n    max_chars\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpifzoj58l.rs:12:28\n   |\n12 |     let mut unique_chars = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpifzoj58l.rs:19:51\n\
    \   |\n19 |             unique_chars.entry(char).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counter.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = String::new();\n    for (_,\
    \ value) in counter.iter() {\n        if *value > max_value.len() {\n        \
    \    max_value = value;\n            max_key = String::new();\n        }\n   \
    \     max_key.push_str(&*max_value);\n    }\n    max_key\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpn3rl8cd5.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpn3rl8cd5.rs:15:43\n   |\n\
    15 |             counter.entry(c).or_insert(0) += 1;\n   |             -----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for c in counters.keys() {\n        if *max_counters.entry(c).or_insert(0)\
    \ > *max_counters.entry(c).or_insert(1) {\n            max_counters.entry(c).or_insert(0)\
    \ = *max_counters.entry(c).or_insert(1);\n            max_word = word;\n     \
    \   }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpdkphk8zw.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmpdkphk8zw.rs:23:24\n  \
    \ |\n23 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpdkphk8zw.rs:15:44\n   |\n15 |  \
    \           counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpdkphk8zw.rs:22:48\n\
    \   |\n22 |             max_counters.entry(c).or_insert(0) = *max_counters.entry(c).or_insert(1);\n\
    \   |             ---------------------------------- ^\n   |             |\n \
    \  |             cannot assign to this expression\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0067, E0070, E0425,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for index in 0..words.len()\
    \ {\n        if words[index].chars().count() > max_count {\n            max_count\
    \ = words[index].chars().count();\n            max_word = words[index];\n    \
    \        max_index = index;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpkzatdyy9.rs:14:25\n\
    \   |\n14 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpgm_e42x5.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashMap::new();\n    let mut max_chars = String::new();\n    for word in words\
    \ {\n        for c in word.chars() {\n            if !unique_chars.contains_key(&c)\
    \ {\n                unique_chars.insert(c, 0);\n            }\n            unique_chars.entry(c).or_insert(0)\
    \ += 1;\n        }\n        if unique_chars.values().iter().max().is_some() {\n\
    \            max_chars = word;\n        }\n    }\n    if unique_chars.values().iter().max().is_some()\
    \ {\n        max_chars\n    } else {\n        String::from(\"No words have maximum\
    \ number of unique characters.\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpnk6yj4c2.rs:12:28\n   |\n12 |     let mut unique_chars = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpnk6yj4c2.rs:19:48\n\
    \   |\n19 |             unique_chars.entry(c).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        counter.insert(word.chars().count(),\
    \ 1);\n    }\n    let mut max_count = counter.iter().max().unwrap();\n    let\
    \ mut max_word = String::new();\n    for word in words {\n        if counter.contains_key(word.chars().count())\
    \ {\n            if counter[word.chars().count()] > max_count {\n            \
    \    max_count = counter[word.chars().count()];\n                max_word = word;\n\
    \            }\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpvijpwsrr.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
