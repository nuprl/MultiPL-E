language: rs
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy9bpfmi5.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpe2f6k1ru.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in &words {\n        let count = word.chars().count();\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2bqlovxc.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9oxz9n1q.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    let mut max_word = words.iter().find(|word|\
    \ word.chars().count() == max_count).unwrap();\n    for word in words.iter() {\n\
    \        let count = word.chars().count();\n        if count == max_count {\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfmbukrk5.rs:21:5\n   |\n\
    11 | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n21 |     max_word\n\
    \   |     ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \     |\n   |     expected struct `String`, found `&String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().rev() {\n        let count = word.chars().count();\n       \
    \ if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpczfdvrna.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        if word.chars().count() > max_count {\n \
    \           max_count = word.chars().count();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqfjakml.rs:17:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n17 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for (i, word) in\
    \ words.iter().enumerate() {\n        if word.chars().count() > max_count {\n\
    \            max_count = word.chars().count();\n            max_word = word;\n\
    \            max_index = i;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaqcpuofq.rs:18:24\n   |\n\
    13 |     let mut max_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n18 |             max_word = word;\n   |   \
    \                     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpaqcpuofq.rs:14:25\n   |\n14 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for (i, word) in\
    \ words.iter().enumerate() {\n        if word.chars().count() > max_count {\n\
    \            max_count = word.chars().count();\n            max_word = word;\n\
    \            max_index = i;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8wg11zx.rs:18:24\n   |\n\
    13 |     let mut max_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n18 |             max_word = word;\n   |   \
    \                     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpd8wg11zx.rs:14:25\n   |\n14 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp6sqbms2w.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp2lil4sec.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashMap::new();\n    let mut max_chars = String::new();\n    for word in words\
    \ {\n        for char in word.chars() {\n            if !unique_chars.contains_key(&char)\
    \ {\n                unique_chars.insert(char, 0);\n            }\n          \
    \  unique_chars.entry(char).or_insert(0) += 1;\n        }\n        if unique_chars.values().iter().max().is_some()\
    \ {\n            max_chars = word;\n        }\n    }\n    max_chars\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpifzoj58l.rs:12:28\n   |\n12 |     let mut unique_chars = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpifzoj58l.rs:19:51\n\
    \   |\n19 |             unique_chars.entry(char).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counter.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = String::new();\n    for (_,\
    \ value) in counter.iter() {\n        if *value > max_value.len() {\n        \
    \    max_value = value;\n            max_key = String::new();\n        }\n   \
    \     max_key.push_str(&*max_value);\n    }\n    max_key\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpn3rl8cd5.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpn3rl8cd5.rs:15:43\n   |\n\
    15 |             counter.entry(c).or_insert(0) += 1;\n   |             -----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for c in counters.keys() {\n        if *max_counters.entry(c).or_insert(0)\
    \ > *max_counters.entry(c).or_insert(1) {\n            max_counters.entry(c).or_insert(0)\
    \ = *max_counters.entry(c).or_insert(1);\n            max_word = word;\n     \
    \   }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpdkphk8zw.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmpdkphk8zw.rs:23:24\n  \
    \ |\n23 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpdkphk8zw.rs:15:44\n   |\n15 |  \
    \           counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpdkphk8zw.rs:22:48\n\
    \   |\n22 |             max_counters.entry(c).or_insert(0) = *max_counters.entry(c).or_insert(1);\n\
    \   |             ---------------------------------- ^\n   |             |\n \
    \  |             cannot assign to this expression\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0067, E0070, E0425,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for index in 0..words.len()\
    \ {\n        if words[index].chars().count() > max_count {\n            max_count\
    \ = words[index].chars().count();\n            max_word = words[index];\n    \
    \        max_index = index;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpkzatdyy9.rs:14:25\n\
    \   |\n14 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpgm_e42x5.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashMap::new();\n    let mut max_chars = String::new();\n    for word in words\
    \ {\n        for c in word.chars() {\n            if !unique_chars.contains_key(&c)\
    \ {\n                unique_chars.insert(c, 0);\n            }\n            unique_chars.entry(c).or_insert(0)\
    \ += 1;\n        }\n        if unique_chars.values().iter().max().is_some() {\n\
    \            max_chars = word;\n        }\n    }\n    if unique_chars.values().iter().max().is_some()\
    \ {\n        max_chars\n    } else {\n        String::from(\"No words have maximum\
    \ number of unique characters.\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpnk6yj4c2.rs:12:28\n   |\n12 |     let mut unique_chars = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpnk6yj4c2.rs:19:48\n\
    \   |\n19 |             unique_chars.entry(c).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        counter.insert(word.chars().count(),\
    \ 1);\n    }\n    let mut max_count = counter.iter().max().unwrap();\n    let\
    \ mut max_word = String::new();\n    for word in words {\n        if counter.contains_key(word.chars().count())\
    \ {\n            if counter[word.chars().count()] > max_count {\n            \
    \    max_count = counter[word.chars().count()];\n                max_word = word;\n\
    \            }\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpvijpwsrr.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpa0s5yq5k.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  let mut max_key = String::new();\n    for (key, val) in counters.iter().cloned().max_by_key(|&(_,\
    \ count)| count) {\n        if val > max_counters.get(&key).unwrap() {\n     \
    \       max_counters.insert(key, val);\n            max_word = key;\n        \
    \    max_key = key;\n        }\n    }\n    max_key\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp0rzkzm9o.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp0rzkzm9o.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for c in max_counters.keys() {\n        if max_counters[c] > max_counters.entry(c).or_insert(0)\
    \ {\n            max_counters.entry(c).or_insert(0) = max_counters[c];\n     \
    \       max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpa8521sed.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmpa8521sed.rs:23:24\n  \
    \ |\n23 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpa8521sed.rs:15:44\n   |\n15 |  \
    \           counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpa8521sed.rs:22:48\n\
    \   |\n22 |             max_counters.entry(c).or_insert(0) = max_counters[c];\n\
    \   |             ---------------------------------- ^\n   |             |\n \
    \  |             cannot assign to this expression\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0067, E0070, E0425,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = 0;\n        for c in word.chars() {\n           \
    \ if *c != c.to_ascii_lowercase() {\n                count += 1;\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count;\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpe2zwjxd5.rs:17:16\n\
    \   |\n17 |             if *c != c.to_ascii_lowercase() {\n   |              \
    \  ^^\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counter.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = String::new();\n    for (key,\
    \ value) in counter.iter() {\n        if *value > max_value.len() {\n        \
    \    max_value = key;\n            max_key = key;\n        }\n    }\n    max_key\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpzn11z2__.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpzn11z2__.rs:15:43\n   |\n\
    15 |             counter.entry(c).or_insert(0) += 1;\n   |             -----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  let mut max_key = String::new();\n    for (_, count) in max_counters.iter()\
    \ {\n        if count > max_counters.len() {\n            max_counters = HashMap::new();\n\
    \            max_word = String::new();\n            max_key = String::new();\n\
    \        }\n        if count == max_counters.len() {\n            max_counters.entry(max_key.clone()).or_insert(0)\
    \ += 1;\n        }\n    }\n    max_key\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6m155zos.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp6m155zos.rs:23:28\n\
    \   |\n23 |             max_counters = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmp6m155zos.rs:15:44\n   |\n15 |  \
    \           counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp6m155zos.rs:28:62\n\
    \   |\n28 |             max_counters.entry(max_key.clone()).or_insert(0) += 1;\n\
    \   |             ------------------------------------------------ ^^\n   |  \
    \           |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0433.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = String::new();\n    for (_,\
    \ count) in counters.iter() {\n        if *count > max_value.len() {\n       \
    \     max_value = *count;\n            max_key = String::new();\n        }\n \
    \       max_key.push_str(&*count);\n    }\n    max_key\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpeebzrawe.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpeebzrawe.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        if word.chars().count() > max_count {\n \
    \           max_count = word.chars().count();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqfjakml.rs:17:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n17 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter() {\n        let count = word.chars().count();\n        if count\
    \ > max_count {\n            max_count = count;\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptjex95xl.rs:18:24\n   |\n\
    18 |             max_word = word;\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().rev() {\n        let count = word.chars().count();\n       \
    \ if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpczfdvrna.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = counters.iter().max().unwrap();\n\
    \    for c in counters.keys() {\n        if counters[c] == max_value {\n     \
    \       max_key = c;\n        }\n    }\n    max_key\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpr025mqw3.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpr025mqw3.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  let mut max_key = String::new();\n    for (key, val) in counters.iter().cloned().max_by_key(|&(_,\
    \ count)| count) {\n        if *val > max_counters.get(&key).unwrap() {\n    \
    \        max_counters.insert(key, *val);\n            max_word = key;\n      \
    \      max_key = key;\n        }\n    }\n    max_key\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpbjik3r_f.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpbjik3r_f.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter() {\n        if word.chars().count() > max_count {\n         \
    \   max_count = word.chars().count();\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp931ol4_p.rs:17:24\n   |\n\
    17 |             max_word = word;\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  let mut max_word_len = 0;\n    for c in counters.keys() {\n        if counters[c]\
    \ > max_counters[c] {\n            max_counters[c] = counters[c];\n          \
    \  max_word = word;\n            max_word_len = c;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpqh5y2bzr.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmpqh5y2bzr.rs:24:24\n  \
    \ |\n24 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpqh5y2bzr.rs:15:44\n   |\n15 |  \
    \           counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::cmp::Ordering::Greater;\n    let mut max_word = String::new();\n    for\
    \ word in words {\n        let mut count = std::cmp::Ordering::Greater;\n    \
    \    for c in word.chars() {\n            if *c != c.to_ascii_lowercase() {\n\
    \                count = std::cmp::Ordering::Less;\n                break;\n \
    \           }\n        }\n        if count > max_count {\n            max_count\
    \ = count;\n            max_word = word;\n        }\n    }\n    max_word\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp45o_u8zz.rs:17:16\n\
    \   |\n17 |             if *c != c.to_ascii_lowercase() {\n   |              \
    \  ^^\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_word_len = words.iter().map(|word|\
    \ word.chars().count()).max().unwrap();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n            max_word_len = word.chars().count();\n        }\n    }\n\
    \    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable `max_word_len` is assigned to, but never used\n  -->\
    \ /tmp/tmpb_c3tcdd.rs:14:13\n   |\n14 |     let mut max_word_len = words.iter().map(|word|\
    \ word.chars().count()).max().unwrap();\n   |             ^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using\
    \ `_max_word_len` instead\n\nwarning: value assigned to `max_word_len` is never\
    \ read\n  --> /tmp/tmpb_c3tcdd.rs:19:13\n   |\n19 |             max_word_len =\
    \ word.chars().count();\n   |             ^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0382]:\
    \ borrow of moved value: `word`\n    --> /tmp/tmpb_c3tcdd.rs:19:28\n     |\n15\
    \   |     for word in words {\n     |         ---- move occurs because `word`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n18   |  \
    \           max_word = word;\n     |                        ---- value moved here\n\
    19   |             max_word_len = word.chars().count();\n     |              \
    \              ^^^^^^^^^^^^ value borrowed here after move\n     |\n     = note:\
    \ borrow occurs due to deref coercion to `str`\nnote: deref defined here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashSet::new();\n    let mut max_word = String::new();\n\
    \n    for word in words {\n        let mut count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert((c, 1));\n        }\n\
    \        for (c, count) in count.iter().cloned().max_by_key(|(_, count)| count)\
    \ {\n            if *count > max_count.get(&c) {\n                max_count.insert(c,\
    \ *count);\n                max_word = word;\n            }\n        }\n    }\n\
    \n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp7jh3x0uh.rs:21:16\n\
    \   |\n21 |             if *count > max_count.get(&c) {\n   |                ^^^^^^\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmp7jh3x0uh.rs:22:27\n    |\n22  |                 max_count.insert(c,\
    \ *count);\n    |                           ^^^^^^ -  ------ supplied 2 arguments\n\
    \    |                           |\n    |                           expected 1\
    \ argument\n    |\nnote: associated function defined here\n\nerror[E0614]: type\
    \ `{integer}` cannot be dereferenced\n  --> /tmp/tmp7jh3x0uh.rs:22:37\n   |\n\
    22 |                 max_count.insert(c, *count);\n   |                      \
    \               ^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::cmp::Ordering::Equal;\n    let mut max_word = String::new();\n    for\
    \ word in words {\n        let mut count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert((c, 1));\n        }\n\
    \        if count.len() > max_count {\n            max_count = count.len();\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4cc702ok.rs:19:26\n   |\n\
    19 |         if count.len() > max_count {\n   |                          ^^^^^^^^^\
    \ expected `usize`, found enum `std::cmp::Ordering`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4cc702ok.rs:20:25\n   |\n20 |             max_count = count.len();\n\
    \   |                         ^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for index in 0..words.len()\
    \ {\n        let count = words.iter().map(|word| word.chars().count()).nth(index).unwrap();\n\
    \        if count > max_count {\n            max_count = count;\n            max_word\
    \ = words[index];\n            max_index = index;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp9gu9gpxz.rs:14:25\n\
    \   |\n14 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = std::i32::MAX;\n        for c in word.chars() {\n\
    \            count += 1;\n        }\n        if count > max_count {\n        \
    \    max_count = count;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to add with overflow'', /tmp/tmpqpje3r90.rs:17:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpa0s5yq5k.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for (i, word) in\
    \ words.iter().enumerate() {\n        if word.chars().count() == max_count {\n\
    \            max_word = word;\n            max_index = i;\n        }\n    }\n\
    \    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwawxcts5.rs:17:24\n   |\n\
    17 |             max_word = word;\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpwawxcts5.rs:14:25\n\
    \   |\n14 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = 0;\n        for c in word.chars() {\n           \
    \ count += 1;\n        }\n        if count > max_count {\n            max_count\
    \ = count;\n            max_word = word;\n        }\n    }\n    max_word\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmplohh5u8s.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for c in counters.keys() {\n        if counters[c] > max_counters[c] {\n  \
    \          max_counters[c] = counters[c];\n            max_word = word;\n    \
    \    }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5dr1qs4u.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmp5dr1qs4u.rs:23:24\n  \
    \ |\n23 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmp5dr1qs4u.rs:15:44\n   |\n15 |  \
    \           counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_key = String::new();\n   \
    \ for (key, val) in counters.iter() {\n        if val > max_counters.get(&key).unwrap()\
    \ {\n            max_counters.insert(key, val);\n            max_key = key;\n\
    \        }\n    }\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpgn3quiuu.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpgn3quiuu.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for c in counters.keys() {\n        if counters[c] > max_counters[c] {\n  \
    \          max_counters = counters.clone();\n            max_word = String::new();\n\
    \        }\n        max_word += c;\n    }\n    max_word\n}\n\nfn main() {\n  \
    \  let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpaxv4fkwo.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpaxv4fkwo.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_count = counters.iter().max().unwrap();\n    let mut max_word = String::new();\n\
    \    for c in counters.iter() {\n        if *c > max_count {\n            max_count\
    \ = *c;\n            max_word = words[counters.iter().position(|&(_, count)| count\
    \ > max_count).unwrap()];\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpulganm7b.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpulganm7b.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for (counter, word) in counters.iter().cloned().sort_by_key(|&(_, count)| {\n\
    \        count.cmp(&max_counters.get(&c).unwrap())\n    }) {\n        if max_counters.get(&c).unwrap()\
    \ > max_counters.get(&max_word).unwrap() {\n            max_counters = counters.clone();\n\
    \            max_word = word.clone();\n        }\n    }\n    max_word\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpn5qdww1v.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `c` in this scope\n  --> /tmp/tmpn5qdww1v.rs:21:38\n   |\n\
    21 |         count.cmp(&max_counters.get(&c).unwrap())\n   |                 \
    \                     ^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `c` in this scope\n  --> /tmp/tmpn5qdww1v.rs:23:30\n   |\n23 |         if max_counters.get(&c).unwrap()\
    \ > max_counters.get(&max_word).unwrap() {\n   |                             \
    \ ^ not found in this scope\n\nerror[E0067]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpn5qdww1v.rs:15:44\n   |\n15 |             counters.entry(c).or_insert(0)\
    \ += 1;\n   |             ------------------------------ ^^\n   |            \
    \ |\n   |             cannot assign to this expression\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0425,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        if let Some(count) = counters.get(&word)\
    \ {\n            if count > 1 {\n                counters.insert(word, count -\
    \ 1);\n            } else {\n                return word;\n            }\n   \
    \     } else {\n            counters.insert(word, 1);\n        }\n    }\n    words[0]\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp8qlpl7h0.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|w| w.chars().count()).max().unwrap();\n    let mut max_word\
    \ = String::from(\"\");\n    for word in words {\n        let count = word.chars().count();\n\
    \        if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpw9zlfk08.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for c in counters.keys() {\n        if *max_counters.entry(c).or_insert(0)\
    \ >= *counters.entry(c).or_insert(0) {\n            max_counters.entry(c).or_insert(0)\
    \ = *counters.entry(c).or_insert(0);\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpkwc3shv7.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmpkwc3shv7.rs:23:24\n  \
    \ |\n23 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpkwc3shv7.rs:15:44\n   |\n15 |  \
    \           counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpkwc3shv7.rs:22:48\n\
    \   |\n22 |             max_counters.entry(c).or_insert(0) = *counters.entry(c).or_insert(0);\n\
    \   |             ---------------------------------- ^\n   |             |\n \
    \  |             cannot assign to this expression\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0067, E0070, E0425,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpa0s5yq5k.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpa0s5yq5k.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashMap::new();\n    let mut max_chars = String::new();\n    for word in words\
    \ {\n        for c in word.chars() {\n            if !unique_chars.contains_key(&c)\
    \ {\n                unique_chars.insert(c, 0);\n            }\n            unique_chars.entry(c).or_insert(0)\
    \ += 1;\n        }\n        if unique_chars.len() > max_chars.len() {\n      \
    \      max_chars = word;\n        }\n    }\n    max_chars\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmprmz7x3pz.rs:12:28\n   |\n12 |     let mut unique_chars = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprmz7x3pz.rs:19:48\n\
    \   |\n19 |             unique_chars.entry(c).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counter = counters.iter().max().unwrap();\n    let mut max_word = String::new();\n\
    \    for c in counters.keys() {\n        if counters[c] == max_counter {\n   \
    \         max_word = words[counters[c]];\n        }\n    }\n    max_word\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpnp7fc42l.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpnp7fc42l.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for c in max_counters.keys() {\n        if max_counters[c] > max_counters.entry(c).or_insert(0)\
    \ {\n            max_counters.entry(c).or_insert(0) = max_counters[c];\n     \
    \       max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpa8521sed.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmpa8521sed.rs:23:24\n  \
    \ |\n23 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpa8521sed.rs:15:44\n   |\n15 |  \
    \           counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpa8521sed.rs:22:48\n\
    \   |\n22 |             max_counters.entry(c).or_insert(0) = max_counters[c];\n\
    \   |             ---------------------------------- ^\n   |             |\n \
    \  |             cannot assign to this expression\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0067, E0070, E0425,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashSet::new();\n    let mut max_word = String::new();\n\
    \    for word in words {\n        let mut count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert((c, 1));\n        }\n\
    \        if count.len() > max_count.len() {\n            max_count = count;\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpy9lnu5qt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut i = 0;\n    while i < words.len() {\n\
    \        let word = words[i];\n        let count = word.chars().count();\n   \
    \     if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n        i += 1;\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpca2t6jm6.rs:16:20\n\
    \   |\n16 |         let word = words[i];\n   |                    ^^^^^^^^\n \
    \  |                    |\n   |                    move occurs because value has\
    \ type `String`, which does not implement the `Copy` trait\n   |             \
    \       help: consider borrowing here: `&words[i]`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpa0s5yq5k.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashSet::new();\n    let mut max_word = String::new();\n\
    \    for word in words {\n        let mut count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert((c, 1));\n        }\n\
    \        if count.len() > max_count.len() {\n            max_count = count;\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpy9lnu5qt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut i = 0;\n    for word in words {\n   \
    \     if word.chars().count() > max_count {\n            max_count = word.chars().count();\n\
    \            max_word = word;\n        }\n        i += 1;\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpwyukr7b6.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for c in max_counters.keys() {\n        if max_counters[c] > max_counters.len()\
    \ {\n            max_counters = HashMap::new();\n            max_word = String::new();\n\
    \        }\n        if c == max_counters.keys().nth(0) {\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpxtou05o3.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpxtou05o3.rs:22:28\n\
    \   |\n22 |             max_counters = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]: cannot\
    \ find value `word` in this scope\n  --> /tmp/tmpxtou05o3.rs:26:24\n   |\n26 |\
    \             max_word = word;\n   |                        ^^^^ help: a local\
    \ variable with a similar name exists: `words`\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmpxtou05o3.rs:15:44\n   |\n15 |            \
    \ counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashSet::new();\n    let mut max_word = String::new();\n\
    \    for word in words {\n        let mut count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert((*c).to_ascii_lowercase());\n\
    \        }\n        if count.len() > max_count.len() {\n            max_count\
    \ = count;\n            max_word = word;\n        }\n    }\n    max_word\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmphmapbi06.rs:17:26\n\
    \   |\n17 |             count.insert((*c).to_ascii_lowercase());\n   |       \
    \                   ^^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter() {\n        if word.chars().count() > max_count {\n         \
    \   max_count = word.chars().count();\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp931ol4_p.rs:17:24\n   |\n\
    17 |             max_word = word;\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let count = word.chars().filter(|c| !c.is_whitespace()).count();\n\
    \        if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpix9jp44n.rs:16:20\n   |\n\
    16 |         if count > max_count {\n   |                    ^^^^^^^^^ expected\
    \ `usize`, found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if count > max_count.try_into().unwrap()\
    \ {\n   |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpix9jp44n.rs:17:25\n   |\n17 |             max_count = count;\n\
    \   |                         ^^^^^ expected `i32`, found `usize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_key = String::new();\n   \
    \ for (_, count) in max_counters.iter_mut().take(1) {\n        if *count > max_counters.len()\
    \ {\n            max_counters = count;\n            max_key = String::new();\n\
    \        }\n    }\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpogv9qyir.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpogv9qyir.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counter.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = -1;\n    for (_, value) in\
    \ counter.iter() {\n        if value > max_value {\n            max_value = value;\n\
    \            max_key = String::new();\n        }\n        max_key.push_str(&*key);\n\
    \    }\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp8qho_f27.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `key` in this scope\n  --> /tmp/tmp8qho_f27.rs:25:28\n   |\n\
    25 |         max_key.push_str(&*key);\n   |                            ^^^ not\
    \ found in this scope\n\nerror[E0067]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmp8qho_f27.rs:15:43\n   |\n15 |             counter.entry(c).or_insert(0)\
    \ += 1;\n   |             ----------------------------- ^^\n   |             |\n\
    \   |             cannot assign to this expression\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0067, E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counter.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = String::new();\n    for ((key,\
    \ value), &mut counter) in counter.iter_mut().zip(words.iter()) {\n        if\
    \ *counter > max_value.len() {\n            max_value = key;\n            max_key\
    \ = key;\n        }\n        *counter -= 1;\n    }\n    max_key\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpkmytlkxp.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpkmytlkxp.rs:15:43\n   |\n\
    15 |             counter.entry(c).or_insert(0) += 1;\n   |             -----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = std::i32::MAX;\n        for c in word.chars() {\n\
    \            if *c != c.to_ascii_lowercase() {\n                count += 1;\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count;\n            max_word = word;\n        }\n    }\n    max_word\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpib7j_qel.rs:17:16\n\
    \   |\n17 |             if *c != c.to_ascii_lowercase() {\n   |              \
    \  ^^\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|w| w.chars().count()).max().unwrap();\n    let mut max_word\
    \ = String::new();\n    for w in words {\n        if w.chars().count() > max_count\
    \ {\n            max_count = w.chars().count();\n            max_word = w;\n \
    \       }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpr16q7fr2.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counter = 0;\n    let mut max_word = String::new();\n    for c in counters.keys()\
    \ {\n        if counters[c] > max_counter {\n            max_counter = counters[c];\n\
    \            max_word = c;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpea4l33up.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpea4l33up.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counter.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = -1;\n    for (key, value)\
    \ in counter.iter() {\n        if value > max_value {\n            max_value =\
    \ value;\n            max_key = key;\n        }\n    }\n    max_key\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpsjewtb67.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpsjewtb67.rs:15:43\n   |\n\
    15 |             counter.entry(c).or_insert(0) += 1;\n   |             -----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        if let Some(count) = counters.get(&word)\
    \ {\n            *count += 1;\n        } else {\n            counters.insert(word.clone(),\
    \ 1);\n        }\n    }\n    let mut max_count = counters.iter().max().unwrap();\n\
    \    let mut max_word = String::new();\n    for (_, count) in counters {\n   \
    \     if *count > max_count {\n            max_count = *count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp9mi9nfya.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmp9mi9nfya.rs:25:24\n  \
    \ |\n25 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_word_index = -1;\n    for (i, word)\
    \ in words.iter().enumerate() {\n        if word.chars().count() > max_count {\n\
    \            max_count = word.chars().count();\n            max_word = word;\n\
    \            max_word_index = i;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkbxqdhp5.rs:18:24\n   |\n\
    18 |             max_word = word;\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpkbxqdhp5.rs:14:30\n\
    \   |\n14 |     let mut max_word_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        counter.insert(word.chars().count(),\
    \ 1);\n    }\n    let mut max_count = counter.iter().max().unwrap();\n    let\
    \ mut max_word = String::new();\n    for word in words {\n        if counter[word.chars().count()]\
    \ == max_count {\n            max_count = counter[word.chars().count()];\n   \
    \         max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpb2vsuxi1.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = String::new();\n    for (_,\
    \ value) in counters.iter() {\n        if value > max_value.len() {\n        \
    \    max_value = value;\n            max_key = String::new();\n        }\n   \
    \     if value == max_value.len() {\n            max_key.push_str(&word);\n  \
    \      }\n    }\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmps6cpmqza.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmps6cpmqza.rs:26:31\n  \
    \ |\n26 |             max_key.push_str(&word);\n   |                         \
    \      ^^^^ help: a local variable with a similar name exists: `words`\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmps6cpmqza.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0277]: can't compare `String` with `usize`\n  --> /tmp/tmps6cpmqza.rs:21:18\n\
    \   |\n21 |         if value > max_value.len() {\n   |                  ^ no implementation\
    \ for `String < usize` and `String > usize`\n   |\n   = help: the trait `PartialOrd<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: can't compare `String` with\
    \ `usize`\n  --> /tmp/tmps6cpmqza.rs:25:18\n   |\n25 |         if value == max_value.len()\
    \ {\n   |                  ^^ no implementation for `String == usize`\n   |\n\
    \   = help: the trait `PartialEq<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0277, E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  let mut max_key = String::new();\n    for (_, v) in max_counters.iter() {\n\
    \        if v > max_counters.get(&max_key).unwrap().cloned() {\n            max_counters.insert(max_key,\
    \ v);\n            max_word = max_key;\n            max_key = String::new();\n\
    \        }\n    }\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpd47gr_2p.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpd47gr_2p.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashSet::new();\n    let mut max_word = String::new();\n\
    \    for word in words {\n        let count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert(c);\n        }\n  \
    \      if count.len() > max_count.len() {\n            max_count = count;\n  \
    \          max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `count` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmptkbu7n9c.rs:17:13\n   |\n15 |         let count = std::collections::HashSet::new();\n\
    \   |             ----- help: consider changing this to be mutable: `mut count`\n\
    16 |         for c in word.chars() {\n17 |             count.insert(c);\n   |\
    \             ^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashMap::new();\n    let mut max_word = String::new();\n\
    \    for word in words {\n        let mut count = std::collections::HashMap::new();\n\
    \        for c in word.chars() {\n            count.insert(c, count.entry(c).or_insert(0)\
    \ as usize);\n        }\n        if count.len() > max_count.len() {\n        \
    \    max_count = count;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&mut usize` as `usize` is invalid\n  --> /tmp/tmp15xmx8ra.rs:17:29\n\
    \   |\n17 |             count.insert(c, count.entry(c).or_insert(0) as usize);\n\
    \   |                             ---------------------------^^^^^^^^^\n   | \
    \                            |\n   |                             cannot cast `&mut\
    \ usize` as `usize`\n   |                             help: dereference the expression:\
    \ `*count.entry(c).or_insert(0)`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counter.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = String::new();\n    for (_,\
    \ value) in counter.iter() {\n        if value > max_value.len() {\n         \
    \   max_value = value;\n            max_key = String::new();\n        }\n    \
    \    if value == max_value.len() {\n            max_key.push_str(&word);\n   \
    \     }\n    }\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpk5943xw9.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmpk5943xw9.rs:26:31\n  \
    \ |\n26 |             max_key.push_str(&word);\n   |                         \
    \      ^^^^ help: a local variable with a similar name exists: `words`\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpk5943xw9.rs:15:43\n   |\n\
    15 |             counter.entry(c).or_insert(0) += 1;\n   |             -----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0277]: can't compare `String` with `usize`\n  --> /tmp/tmpk5943xw9.rs:21:18\n\
    \   |\n21 |         if value > max_value.len() {\n   |                  ^ no implementation\
    \ for `String < usize` and `String > usize`\n   |\n   = help: the trait `PartialOrd<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: can't compare `String` with\
    \ `usize`\n  --> /tmp/tmpk5943xw9.rs:25:18\n   |\n25 |         if value == max_value.len()\
    \ {\n   |                  ^^ no implementation for `String == usize`\n   |\n\
    \   = help: the trait `PartialEq<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0277, E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_count = counters.iter().max().unwrap();\n    let mut max_word = String::new();\n\
    \    for c in counters.keys() {\n        if counters[c] == max_count {\n     \
    \       max_word = words[counters[c]];\n            break;\n        }\n    }\n\
    \    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpfazgf2rh.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpfazgf2rh.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = std::i32::MAX;\n        for c in word.chars() {\n\
    \            count += c.chars().count();\n        }\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp2m9xkl__.rs:17:24\n   |\n17 |             count += c.chars().count();\n\
    \   |                        ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for (i, word) in\
    \ words.iter().enumerate() {\n        if word.chars().count() > max_count {\n\
    \            max_count = word.chars().count();\n            max_word = word;\n\
    \            max_index = i;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8wg11zx.rs:18:24\n   |\n\
    13 |     let mut max_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n18 |             max_word = word;\n   |   \
    \                     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpd8wg11zx.rs:14:25\n   |\n14 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpa0s5yq5k.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        if let Some(count) = counters.get(&word)\
    \ {\n            counters.insert(word, count + 1);\n        } else {\n       \
    \     counters.insert(word, 1);\n        }\n    }\n    let mut max_count = counters.iter().max().unwrap();\n\
    \    let mut max_word = String::new();\n    for (word, count) in counters {\n\
    \        if count == max_count {\n            max_word = word;\n        }\n  \
    \  }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpsp2o4xc8.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = std::i32::MAX;\n        for c in word.chars() {\n\
    \            count += c.chars().count();\n        }\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp2m9xkl__.rs:17:24\n   |\n17 |             count += c.chars().count();\n\
    \   |                        ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = 0;\n        for c in word.chars() {\n           \
    \ count += 1;\n        }\n        if count > max_count {\n            max_count\
    \ = count;\n            max_word = word;\n        }\n    }\n    max_word\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmplohh5u8s.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for (counter, word) in counters.iter().take_while(|(_, count)| count > max_counters.len()\
    \ as u64) {\n        max_counters = max_counters.clone();\n        max_word =\
    \ word;\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpm9alky2v.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpm9alky2v.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpa0s5yq5k.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpa0s5yq5k.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::cmp::Ordering::Equal;\n    let mut max_word = String::new();\n    for\
    \ word in words {\n        let mut count = std::cmp::Ordering::Equal;\n      \
    \  for c in word.chars() {\n            count += c.chars().count();\n        }\n\
    \        if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp88mxlpnz.rs:17:24\n   |\n17 |             count += c.chars().count();\n\
    \   |                        ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            if !unique_chars.contains_key(&c) {\n                unique_chars.insert(c,\
    \ 1);\n            } else {\n                unique_chars.entry(c).or_insert(0)\
    \ += 1;\n            }\n        }\n    }\n    let mut max_chars = unique_chars.iter().max_by_key(|&(_,\
    \ count)| count).unwrap();\n    let mut max_word = String::new();\n    let mut\
    \ max_count = 0;\n    for (c, count) in unique_chars.iter() {\n        if count\
    \ == max_count {\n            max_word.push_str(&c);\n        }\n        if count\
    \ > max_count {\n            max_count = count;\n            max_word = String::new();\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpmpdzrf99.rs:12:28\n   |\n12 |     let mut unique_chars = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmpdzrf99.rs:18:52\n\
    \   |\n18 |                 unique_chars.entry(c).or_insert(0) += 1;\n   |   \
    \              ---------------------------------- ^^\n   |                 |\n\
    \   |                 cannot assign to this expression\n\nerror[E0277]: the size\
    \ for values of type `str` cannot be known at compilation time\n  --> /tmp/tmpmpdzrf99.rs:25:10\n\
    \   |\n25 |     for (c, count) in unique_chars.iter() {\n   |          ^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpmpdzrf99.rs:25:23\n   |\n25 |     for (c, count) in unique_chars.iter()\
    \ {\n   |                       ^^^^^^^^^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: only the last element of a tuple may have a dynamically sized type\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0277, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|w| w.chars().count()).max().unwrap();\n    let mut max_word\
    \ = String::new();\n    for w in words {\n        if w.chars().count() > max_count\
    \ {\n            max_count = w.chars().count();\n            max_word = w;\n \
    \       }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpr16q7fr2.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for (i, word) in\
    \ words.iter().enumerate() {\n        if word.chars().count() > max_count {\n\
    \            max_count = word.chars().count();\n            max_word = word;\n\
    \            max_index = i;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8wg11zx.rs:18:24\n   |\n\
    13 |     let mut max_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n18 |             max_word = word;\n   |   \
    \                     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpd8wg11zx.rs:14:25\n   |\n14 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        counter.insert(word.chars().count(),\
    \ 1);\n    }\n    let mut max_key = counter.keys().max().unwrap();\n    let mut\
    \ max_value = counter.values().max().unwrap();\n    let mut max_word = String::new();\n\
    \    for &(k, v) in &counter {\n        if v == max_value {\n            max_word\
    \ = words[max_key.index()];\n            break;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpwyum35s2.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::from(\"\");\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpa0s5yq5k.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for (i, word) in\
    \ words.iter().enumerate() {\n        if word.chars().count() > max_count {\n\
    \            max_count = word.chars().count();\n            max_word = word;\n\
    \            max_index = i;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8wg11zx.rs:18:24\n   |\n\
    13 |     let mut max_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n18 |             max_word = word;\n   |   \
    \                     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpd8wg11zx.rs:14:25\n   |\n14 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in &words {\n        let count = word.chars().count();\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2bqlovxc.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = std::i32::MAX;\n        for c in word.chars() {\n\
    \            count += 1;\n        }\n        if count > max_count {\n        \
    \    max_count = count;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to add with overflow'', /tmp/tmpqpje3r90.rs:17:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for word in words\
    \ {\n        let count = word.chars().count();\n        if count > max_count {\n\
    \            max_count = count;\n            max_word = word;\n            max_index\
    \ = words.iter().position(|&word| word == &max_word).unwrap();\n        }\n  \
    \  }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpusmhl6k1.rs:20:60\n\
    \   |\n20 |             max_index = words.iter().position(|&word| word == &max_word).unwrap();\n\
    \   |                                                            ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n\nerror[E0277]: the trait bound `usize: Neg` is\
    \ not satisfied\n  --> /tmp/tmpusmhl6k1.rs:14:25\n   |\n14 |     let mut max_index\
    \ = -1;\n   |                         ^^ the trait `Neg` is not implemented for\
    \ `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in &words {\n        let count = word.chars().count();\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2bqlovxc.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashSet::new();\n    let mut max_word = String::new();\n\
    \    for word in words {\n        let mut count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert(c);\n        }\n  \
    \      if count.len() > max_count.len() {\n            max_count = count;\n  \
    \          max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpwarrngd2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748540
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        if word.chars().count() > max_count {\n \
    \           max_count = word.chars().count();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqfjakml.rs:17:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n17 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        if word.chars().count() > max_count {\n \
    \           max_count = word.chars().count();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqfjakml.rs:17:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n17 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_word_index = -1;\n    for word in\
    \ words {\n        if word.chars().count() > max_count {\n            max_count\
    \ = word.chars().count();\n            max_word = word;\n            max_word_index\
    \ = words.iter().position(|&word| word == max_word).unwrap();\n        }\n   \
    \ }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpb309rr1u.rs:14:30\n\
    \   |\n14 |     let mut max_word_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = std::i32::MAX;\n        for c in word.chars() {\n\
    \            count += 1;\n        }\n        if count > max_count {\n        \
    \    max_count = count;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to add with overflow'', /tmp/tmpqpje3r90.rs:17:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashSet::new();\n    let mut max_word = String::new();\n\
    \    for word in words {\n        let mut count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert((c, 1));\n        }\n\
    \        if count.len() > max_count.len() {\n            max_count = count;\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpy9lnu5qt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for c in max_counters.keys() {\n        if max_counters[c] > max_counters.iter().rev().next().unwrap()\
    \ {\n            max_counters.entry(c).or_insert(0) += 1;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5wyroiia.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmp5wyroiia.rs:23:24\n  \
    \ |\n23 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmp5wyroiia.rs:15:44\n   |\n15 |  \
    \           counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp5wyroiia.rs:22:48\n\
    \   |\n22 |             max_counters.entry(c).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for index in 0..words.len()\
    \ {\n        let count = words[index].chars().count();\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = words[index];\n  \
    \          max_index = index;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpf0j734of.rs:14:25\n\
    \   |\n14 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for index in 0..words.len()\
    \ {\n        let count = words[index].chars().count();\n        if count == max_count\
    \ {\n            max_word = words[index];\n            max_index = index;\n  \
    \      }\n        if count > max_count {\n            max_count = count;\n   \
    \         max_word = words[index];\n            max_index = index;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpbkszs9xc.rs:14:25\n\
    \   |\n14 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counter.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_key = String::new();\n    let mut max_value = String::new();\n    for (_,\
    \ value) in counter.iter() {\n        if value > max_value.len() {\n         \
    \   max_value = value;\n            max_key = String::new();\n        }\n    \
    \    if value == max_value.len() {\n            max_key.push_str(&*max_key);\n\
    \        }\n    }\n    if max_key.len() == 0 {\n        String::new()\n    } else\
    \ {\n        max_key.push_str(&*max_key);\n        max_value\n    }\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp7sh5_bdm.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp7sh5_bdm.rs:15:43\n   |\n\
    15 |             counter.entry(c).or_insert(0) += 1;\n   |             -----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0277]: can't compare `String` with `usize`\n  --> /tmp/tmp7sh5_bdm.rs:21:18\n\
    \   |\n21 |         if value > max_value.len() {\n   |                  ^ no implementation\
    \ for `String < usize` and `String > usize`\n   |\n   = help: the trait `PartialOrd<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: can't compare `String` with\
    \ `usize`\n  --> /tmp/tmp7sh5_bdm.rs:25:18\n   |\n25 |         if value == max_value.len()\
    \ {\n   |                  ^^ no implementation for `String == usize`\n   |\n\
    \   = help: the trait `PartialEq<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0277, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        counters.entry(word.chars().count()).or_insert(0)\
    \ += 1;\n    }\n    let mut max_counters = counters.clone();\n    let mut max_word\
    \ = String::new();\n    for (counter, word) in counters.iter().cloned().sorted()\
    \ {\n        if *counter > max_counters.entry(word).or_insert(0) {\n         \
    \   max_counters = max_counters.entry(word).or_insert(0);\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp4i5y4d21.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp4i5y4d21.rs:14:59\n   |\n\
    14 |         counters.entry(word.chars().count()).or_insert(0) += 1;\n   |   \
    \      ------------------------------------------------- ^^\n   |         |\n\
    \   |         cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        if let Some(count) = counters.get(&word)\
    \ {\n            if count > 1 {\n                return word;\n            }\n\
    \            counters.insert(word, 1);\n        } else {\n            counters.insert(word,\
    \ 1);\n        }\n    }\n    let mut max_word = String::new();\n    let mut max_count\
    \ = counters.iter().max().unwrap();\n    for (_, count) in counters {\n      \
    \  if count == max_count {\n            max_word = word;\n        }\n    }\n \
    \   max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp3oylm69e.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmp3oylm69e.rs:27:24\n  \
    \ |\n27 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_key = String::new();\n   \
    \ for (_, v) in max_counters.iter_mut().enumerate() {\n        if v > max_counters.value_for(*v).unwrap()\
    \ {\n            max_counters.insert(*v, v);\n            max_key = words[*v];\n\
    \        }\n    }\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpjtvqhln9.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpjtvqhln9.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        if word.chars().count() > max_count {\n \
    \           max_count = word.chars().count();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqfjakml.rs:17:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n17 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = 0;\n        for c in word.chars() {\n           \
    \ count += 1;\n            if count > max_count {\n                max_count =\
    \ count;\n                max_word = word;\n            }\n        }\n    }\n\
    \    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused variable: `c`\n  --> /tmp/tmp3x660bif.rs:16:13\n   |\n\
    16 |         for c in word.chars() {\n   |             ^ help: if this is intentional,\
    \ prefix it with an underscore: `_c`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0505]: cannot move out of `word` because it is borrowed\n\
    \  --> /tmp/tmp3x660bif.rs:20:28\n   |\n16 |         for c in word.chars() {\n\
    \   |                  ---- borrow of `word` occurs here\n...\n20 |          \
    \       max_word = word;\n   |                            ^^^^ move out of `word`\
    \ occurs here\n\nerror[E0382]: use of moved value: `word`\n  --> /tmp/tmp3x660bif.rs:20:28\n\
    \   |\n14 |     for word in words {\n   |         ----    ----- this reinitialization\
    \ might get skipped\n   |         |\n   |         move occurs because `word` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n20 |        \
    \         max_word = word;\n   |                            ^^^^ value moved here,\
    \ in previous iteration of loop\n\nerror: aborting due to 2 previous errors; 1\
    \ warning emitted\n\nSome errors have detailed explanations: E0382, E0505.\nFor\
    \ more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashSet::new();\n    let mut max_word = String::new();\n\
    \    for word in words {\n        let mut count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert((c, 1));\n        }\n\
    \        if count.len() > max_count.len() {\n            max_count = count;\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpy9lnu5qt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashSet::new();\n    let mut max_word = String::new();\n\
    \    for word in words {\n        let mut count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert((c, 1));\n        }\n\
    \        if count.len() > max_count.len() {\n            max_count = count;\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpy9lnu5qt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counter.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_count = counter.iter().max().unwrap();\n    let mut max_word = String::new();\n\
    \    for c in max_count.keys().cloned() {\n        if counter[c] > max_count {\n\
    \            max_count = counter[c];\n            max_word = c.to_string();\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphnbizeyl.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmphnbizeyl.rs:15:43\n   |\n\
    15 |             counter.entry(c).or_insert(0) += 1;\n   |             -----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::cmp::Ordering::Greater;\n    let mut max_word = String::new();\n    for\
    \ word in words {\n        let mut count = std::cmp::Ordering::Equal;\n      \
    \  for c in word.chars() {\n            if *c != c.to_ascii_lowercase() {\n  \
    \              count = std::cmp::Ordering::Less;\n                break;\n   \
    \         }\n        }\n        if count > max_count {\n            max_count\
    \ = count;\n            max_word = word;\n        }\n    }\n    max_word\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpsxgqcuaw.rs:17:16\n\
    \   |\n17 |             if *c != c.to_ascii_lowercase() {\n   |              \
    \  ^^\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        if let Some(count) = counters.get(&word)\
    \ {\n            if count > 1 {\n                counters.insert(word, count +\
    \ 1);\n            } else {\n                counters.insert(word, 1);\n     \
    \       }\n        } else {\n            counters.insert(word, 1);\n        }\n\
    \    }\n    let mut max_count = counters.iter().max().unwrap();\n    let mut max_word\
    \ = String::new();\n    for (_, count) in counters {\n        if count == max_count\
    \ {\n            max_word = word;\n            break;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp435988k2.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmp435988k2.rs:28:24\n  \
    \ |\n28 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for (i, word) in\
    \ words.iter().enumerate() {\n        if word.chars().count() > max_count {\n\
    \            max_count = word.chars().count();\n            max_word = word;\n\
    \            max_index = i;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8wg11zx.rs:18:24\n   |\n\
    13 |     let mut max_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n18 |             max_word = word;\n   |   \
    \                     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpd8wg11zx.rs:14:25\n   |\n14 |     let mut max_index = -1;\n   |\
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in &words {\n        let count = word.chars().count();\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2bqlovxc.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words {\n        let count = word.chars().count();\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpgl81y37m.rs:13:24\n\
    \   |\n13 |     let mut max_word = words[0];\n   |                        ^^^^^^^^\n\
    \   |                        |\n   |                        move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n   |   \
    \                     help: consider borrowing here: `&words[0]`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = std::i32::MAX;\n        for c in word.chars() {\n\
    \            count += 1;\n        }\n        if count > max_count {\n        \
    \    max_count = count;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to add with overflow'', /tmp/tmpqpje3r90.rs:17:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = std::i32::MAX;\n        for c in word.chars() {\n\
    \            count += c.chars().count();\n        }\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp2m9xkl__.rs:17:24\n   |\n17 |             count += c.chars().count();\n\
    \   |                        ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    let mut max_index = -1;\n    for (i, word) in\
    \ words.iter().enumerate() {\n        let count = word.chars().count();\n    \
    \    if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n            max_index = i;\n        }\n    }\n    max_word\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuiihur3.rs:19:24\n   |\n\
    19 |             max_word = word;\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpnuiihur3.rs:14:25\n\
    \   |\n14 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748540
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words {\n        let count = word.chars().count();\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpgl81y37m.rs:13:24\n\
    \   |\n13 |     let mut max_word = words[0];\n   |                        ^^^^^^^^\n\
    \   |                        |\n   |                        move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n   |   \
    \                     help: consider borrowing here: `&words[0]`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        if word.chars().count() > max_count {\n \
    \           max_count = word.chars().count();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqfjakml.rs:17:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n17 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        if word.chars().count() > max_count {\n \
    \           max_count = word.chars().count();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqfjakml.rs:17:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n17 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in &words {\n        let count = word.chars().count();\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2bqlovxc.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_word = String::new();\n  \
    \  for c in counters.keys().cloned() {\n        if counters[c] > max_counters[c]\
    \ {\n            max_counters[c] = counters[c];\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpujenvigi.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `word` in this scope\n  --> /tmp/tmpujenvigi.rs:23:24\n  \
    \ |\n23 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpujenvigi.rs:15:44\n   |\n15 |  \
    \           counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_key = String::new();\n   \
    \ for (_, count) in max_counters.iter_mut().take(1) {\n        if *count > max_counters.len()\
    \ {\n            max_counters = count;\n            max_key = String::new();\n\
    \        }\n    }\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpogv9qyir.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpogv9qyir.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748539
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        if word.chars().count() > max_count {\n \
    \           max_count = word.chars().count();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmqfjakml.rs:17:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n17 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashMap::new();\n    let mut max_chars = String::new();\n    let mut max_word\
    \ = String::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            if !unique_chars.contains_key(&c) {\n                unique_chars.insert(c,\
    \ 1);\n            } else {\n                unique_chars.entry(c).or_insert(0)\
    \ += 1;\n            }\n        }\n        if unique_chars.values().iter().max().is_some()\
    \ {\n            max_chars = max_chars.clone();\n            max_word = word.clone();\n\
    \        }\n    }\n    if max_chars.len() > max_word.len() {\n        max_chars\n\
    \    } else {\n        max_word\n    }\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpq46j75wg.rs:12:28\n   |\n12 |     let mut unique_chars = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpq46j75wg.rs:20:52\n\
    \   |\n20 |                 unique_chars.entry(c).or_insert(0) += 1;\n   |   \
    \              ---------------------------------- ^^\n   |                 |\n\
    \   |                 cannot assign to this expression\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0433.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748540
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    let mut\
    \ max_counters = counters.clone();\n    let mut max_key = String::new();\n   \
    \ for (_, v) in max_counters.iter_mut().enumerate() {\n        if v > max_counters.iter().filter(|(_,\
    \ v)| v == v).next().unwrap().1 {\n            max_counters.entry(v).or_insert(0)\
    \ -= 1;\n            max_key = v;\n        }\n    }\n    max_key\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp0ias82ge.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp0ias82ge.rs:15:44\n   |\n\
    15 |             counters.entry(c).or_insert(0) += 1;\n   |             ------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp0ias82ge.rs:22:48\n\
    \   |\n22 |             max_counters.entry(v).or_insert(0) -= 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659748540
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words[0].chars().count();\n    let mut max_word = words[0];\n    for word\
    \ in words.iter().skip(1) {\n        let count = word.chars().count();\n     \
    \   if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dwo1hus.rs:18:24\n   |\n\
    13 |     let mut max_word = words[0];\n   |                        -------- expected\
    \ due to this value\n...\n18 |             max_word = word;\n   |            \
    \            ^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                       |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp3dnydedm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
