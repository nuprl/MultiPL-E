language: cpp
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    int cap_extension = 0;\n    int sm_extension = 0;\n    for (auto &extension\
    \ : extensions) {\n        auto cap_letters = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {\n            return std::isupper(c);\n       \
    \ });\n        auto sm_letters = std::count_if(extension.begin(), extension.end(),\
    \ [](char c) {\n            return std::islower(c);\n        });\n        cap_extension\
    \ += cap_letters;\n        sm_extension += sm_letters;\n    }\n    float strength\
    \ = cap_extension - sm_extension;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    if (strength > 1) {\n    \
    \    auto it = std::min_element(extensions.begin(), extensions.end(), \n     \
    \       [](std::string a, std::string b) {\n                return std::stoi(a)\
    \ < std::stoi(b);\n            });\n        strongest_extension = class_name +\
    \ \".\" + it->to_string();\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpaay5bph1.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpaay5bph1.cpp:41:54:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018to_string\u2019\n   41 |         strongest_extension = class_name + \"\
    .\" + it->to_string();\n      |                                              \
    \        ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660123319
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap_num = 0, sm_num = 0;\n    for (auto &ext : extensions) {\n        cap_num\
    \ += ext.length();\n        sm_num += ext.length() - 1;\n    }\n    int strength\
    \ = cap_num - sm_num;\n    if (strength > 0) {\n        return class_name + \"\
    .\" + extensions[0];\n    }\n    return class_name;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpjbig3daj: /tmp/tmpjbig3daj.cpp:33: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (int i = 0; i < extensions.size(); i++) {\n        if (class_name[cap_counter]\
    \ == extensions[i][0]) {\n            cap_counter++;\n        }\n        if (class_name[sm_counter]\
    \ == extensions[i][1]) {\n            sm_counter++;\n        }\n    }\n    double\
    \ strength = cap_counter - sm_counter;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (strength == extensions[i].size()) {\n            strongest_extension\
    \ = class_name + \".\" + extensions[i];\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp_42d68g6: /tmp/tmp_42d68g6.cpp:44: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = class_name.size();\n    int sm =\
    \ class_name.size();\n    for (int i = 0; i < extensions.size(); i++) {\n    \
    \    cap = cap - extensions[i].size();\n        sm = sm - extensions[i].size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (strength > 0) {\n            strongest_extension = class_name\
    \ + \".\" + extensions[i];\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpv6ilbjee: /tmp/tmpv6ilbjee.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap_num = 0, sm_num = 0;\n    for (auto &ext : extensions) {\n        cap_num\
    \ += ext.size();\n        sm_num += ext.size();\n    }\n    int cap = cap_num\
    \ / cap_num;\n    int sm = sm_num / cap_num;\n    if (cap - sm > 0) return class_name\
    \ + extensions[0];\n    else return class_name + extensions[extensions.size()\
    \ - 1];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp_z42oan_: /tmp/tmp_z42oan_.cpp:32: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(int i = 0; i < extensions.size();\
    \ i++){\n        std::string extension = extensions[i];\n        \n        for(int\
    \ j = 0; j < extension.size(); j++){\n            char c = extension[j];\n   \
    \         \n            if(c == toupper(extension[j])){\n                strongest_extension\
    \ += c;\n            }\n        }\n    }\n    \n    return class_name + \".\"\
    \ + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpvkkv3xsa: /tmp/tmpvkkv3xsa.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto &extension : extensions) {\n        if (extension == class_name.substr(cap_counter,\
    \ cap_counter + sm_counter)) {\n            strongest_extension = class_name +\
    \ \".\" + extension;\n            cap_counter += CAP;\n            sm_counter\
    \ += SM;\n        }\n    }\n    if (cap_counter > sm_counter) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmppv15wcta.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmppv15wcta.cpp:26:28:\
    \ error: \u2018CAP\u2019 was not declared in this scope\n   26 |             cap_counter\
    \ += CAP;\n      |                            ^~~\n/tmp/tmppv15wcta.cpp:27:27:\
    \ error: \u2018SM\u2019 was not declared in this scope\n   27 |             sm_counter\
    \ += SM;\n      |                           ^~\n"
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for\
    \ (auto &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ += \".\";\n    }\n    strongest_extension += extensions[0];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpb_uogn2c: /tmp/tmpb_uogn2c.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap = class_name.size();\n    int sm = extensions.size();\n    double strength\
    \ = cap - sm;\n    double max = 0;\n    std::string maxStr = \"\";\n    for (auto\
    \ ext : extensions) {\n        if (ext.size() == cap) {\n            double x\
    \ = ext.size() - cap;\n            double y = cap - ext.size();\n            double\
    \ z = cap - ext.size() + cap;\n            double a = x / y;\n            double\
    \ b = x / z;\n            double c = y / z;\n            double d = cap - a;\n\
    \            double e = cap - b;\n            double f = cap - c;\n          \
    \  double g = cap - d;\n            double h = cap - e;\n            double i\
    \ = cap - f;\n            double j = cap - g;\n            double k = cap - h;\n\
    \            double l = cap - i;\n            double m = cap - j;\n          \
    \  double n = cap - k;\n            double o = cap - l;\n            double p\
    \ = cap - m;\n            double q = cap - n;\n            double r = cap - o;\n\
    \            double s = cap - p;\n            double t = cap - q;\n          \
    \  double u = cap - r;\n            double v = cap - s;\n            double w\
    \ = cap - t;\n            double x = cap - u;\n            double y = cap - v;\n\
    \            double z = cap - w;\n            double a = x / y;\n            double\
    \ b = x / z;\n            double c = y / z;\n            double d = cap - a;\n\
    \            double e = cap - b;\n            double f = cap - c;\n          \
    \  double g = cap - d;\n            double h = cap - e;\n            double i\
    \ = cap - f;\n            double j = cap - g;\n            double k = cap - h;\n\
    \            double l = cap - i;\n            double m = cap - j;\n          \
    \  double n = cap - k;\n            double o = cap - l;\n            double p\
    \ = cap - m;\n            double q = cap - n;\n            double r = cap - o;\n\
    \            double s = cap - p;\n            double t = cap - q;\n          \
    \  double u = cap - r;\n            double v = cap - s;\n            double w\
    \ = cap - t;\n            double x = cap - u;\n            double y = cap - v;\n\
    \            double z = cap - w;\n            double a = x / y;\n            double\
    \ b = x / z;\n            double c = y / z;\n            double d = cap - a;\n\
    \            double e = cap - b;\n            double f = cap - c;\n          \
    \  double g = cap - d;\n            double h = cap - e;\n            double i\
    \ = \n}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpuui5uov7.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpuui5uov7.cpp:53:20:\
    \ error: redeclaration of \u2018double x\u2019\n   53 |             double x =\
    \ cap - u;\n      |                    ^\n/tmp/tmpuui5uov7.cpp:27:20: note: \u2018\
    double x\u2019 previously declared here\n   27 |             double x = ext.size()\
    \ - cap;\n      |                    ^\n/tmp/tmpuui5uov7.cpp:54:20: error: redeclaration\
    \ of \u2018double y\u2019\n   54 |             double y = cap - v;\n      |  \
    \                  ^\n/tmp/tmpuui5uov7.cpp:28:20: note: \u2018double y\u2019 previously\
    \ declared here\n   28 |             double y = cap - ext.size();\n      |   \
    \                 ^\n/tmp/tmpuui5uov7.cpp:55:20: error: redeclaration of \u2018\
    double z\u2019\n   55 |             double z = cap - w;\n      |             \
    \       ^\n/tmp/tmpuui5uov7.cpp:29:20: note: \u2018double z\u2019 previously declared\
    \ here\n   29 |             double z = cap - ext.size() + cap;\n      |      \
    \              ^\n/tmp/tmpuui5uov7.cpp:56:20: error: redeclaration of \u2018double\
    \ a\u2019\n   56 |             double a = x / y;\n      |                    ^\n\
    /tmp/tmpuui5uov7.cpp:30:20: note: \u2018double a\u2019 previously declared here\n\
    \   30 |             double a = x / y;\n      |                    ^\n/tmp/tmpuui5uov7.cpp:57:20:\
    \ error: redeclaration of \u2018double b\u2019\n   57 |             double b =\
    \ x / z;\n      |                    ^\n/tmp/tmpuui5uov7.cpp:31:20: note: \u2018\
    double b\u2019 previously declared here\n   31 |             double b = x / z;\n\
    \      |                    ^\n/tmp/tmpuui5uov7.cpp:58:20: error: redeclaration\
    \ of \u2018double c\u2019\n   58 |             double c = y / z;\n      |    \
    \                ^\n/tmp/tmpuui5uov7.cpp:32:20: note: \u2018double c\u2019 previously\
    \ declared here\n   32 |             double c = y / z;\n      |              \
    \      ^\n/tmp/tmpuui5uov7.cpp:59:20: error: redeclaration of \u2018double d\u2019\
    \n   59 |             double d = cap - a;\n      |                    ^\n/tmp/tmpuui5uov7.cpp:33:20:\
    \ note: \u2018double d\u2019 previously declared here\n   33 |  "
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        cap += extension.at(0) - 'A';\n        sm\
    \ += extension.at(1) - 'a';\n    }\n    float strength = cap - sm;\n    if (strength\
    \ > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    if (strength == 1) {\n        strongest_extension = class_name + \"\
    .\" + extensions[0];\n    }\n    if (strength > 1) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpvt5mr9qo: /tmp/tmpvt5mr9qo.cpp:41: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == strongest_extension.length()) {\n           \
    \ if (ext.length() < strongest_extension.length()) {\n                strongest_extension\
    \ = class_name + \".\" + ext;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp95wlwua_: /tmp/tmp95wlwua_.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for\
    \ (auto &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        std::sort(extensions.begin(),\
    \ extensions.end());\n        for (auto &ext : extensions) {\n            if (ext.length()\
    \ == strength) {\n                strongest_extension += \".\" + ext;\n      \
    \      }\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp7kya6fud: /tmp/tmp7kya6fud.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    int cap = cap_num / CAP;\n    int sm\
    \ = sm_num / SM;\n    if (cap > sm) {\n        return class_name + extensions[0];\n\
    \    }\n    return class_name + extensions[extensions.size() - 1];\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp0035je15.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp0035je15.cpp:24:25:\
    \ error: \u2018CAP\u2019 was not declared in this scope\n   24 |     int cap =\
    \ cap_num / CAP;\n      |                         ^~~\n/tmp/tmp0035je15.cpp:25:23:\
    \ error: \u2018SM\u2019 was not declared in this scope\n   25 |     int sm = sm_num\
    \ / SM;\n      |                       ^~\n"
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    cap = cap - sm;\n    if (cap > 0) {\n        strongest_extension =\
    \ class_name + extensions[0];\n    }\n    else {\n        for (auto &ext : extensions)\
    \ {\n            if (cap < ext.length()) {\n                strongest_extension\
    \ = class_name + ext;\n                break;\n            }\n        }\n    }\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp9suvk8vi: /tmp/tmp9suvk8vi.cpp:43: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension;\n    \n    for(int i = 0; i < extensions.size();\
    \ i++){\n        std::string extension = extensions[i];\n        int cap = extension.find_first_of('A');\n\
    \        int sm = extension.find_first_of('l');\n        int strength = cap -\
    \ sm;\n        if(strength > 0){\n            strongest_extension = class_name\
    \ + extension;\n            break;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp_um4zuqo: /tmp/tmp_um4zuqo.cpp:37: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    int cap_counter = 0;\n    int sml_counter = 0;\n    for (auto &extension\
    \ : extensions) {\n        if (extension == class_name) {\n            strongest_extension\
    \ = class_name;\n            break;\n        }\n        if (std::toupper(extension[0])\
    \ == std::toupper(class_name[0])) {\n            cap_counter++;\n        }\n \
    \       if (std::tolower(extension[0]) == std::tolower(class_name[0])) {\n   \
    \         sml_counter++;\n        }\n    }\n    if (cap_counter > sml_counter)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpguph4126: /tmp/tmpguph4126.cpp:41: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap = 0;\n    int sm = 0;\n\
    \    for (auto &ext : extensions) {\n        cap += ext.length();\n        sm\
    \ += ext.length();\n    }\n    double strength = cap - sm;\n    double max_strength\
    \ = -1;\n    for (auto &ext : extensions) {\n        double cur_strength = ext.length();\n\
    \        if (cur_strength > max_strength) {\n            max_strength = cur_strength;\n\
    \        }\n    }\n    if (max_strength == -1) {\n        return class_name;\n\
    \    }\n    std::string res = class_name + \".\";\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == max_strength) {\n            res += ext;\n  \
    \      }\n    }\n    return res;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpxtdksc_5: /tmp/tmpxtdksc_5.cpp:48: int main(): Assertion `candidate(("__YESIMHERE"),
    (std::vector<std::string>({"t", "eMptY", "nothing", "zeR00", "NuLl__", "123NoooneB321"})))
    == ("__YESIMHERE.NuLl__")'' failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - ext.find_first_of('A');\n    }\n    double strength\
    \ = cap_num - sm_num;\n    int max_strength = -1;\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() > max_strength) {\n            max_strength = ext.length();\n\
    \        }\n    }\n    if (max_strength == -1) {\n        return class_name;\n\
    \    }\n    int max_index = -1;\n    for (auto &ext : extensions) {\n        if\
    \ (ext.length() == max_strength) {\n            max_index = extensions.find(ext);\n\
    \        }\n    }\n    if (max_index == -1) {\n        return class_name;\n  \
    \  }\n    std::string new_name = class_name + \".\" + extensions[max_index];\n\
    \    return new_name;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp349_97j9.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp349_97j9.cpp:37:36:\
    \ error: \u2018class std::vector<std::__cxx11::basic_string<char> >\u2019 has\
    \ no member named \u2018find\u2019\n   37 |             max_index = extensions.find(ext);\n\
    \      |                                    ^~~~\n"
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = class_name.size();\n    int\
    \ sm = class_name.size();\n    for (auto &ext : extensions) {\n        cap = cap\
    \ - ext.size();\n        sm = sm - ext.size();\n    }\n    if (cap > sm) {\n \
    \       strongest_extension = class_name + extensions[0];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp08hhm37q: /tmp/tmp08hhm37q.cpp:34: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    for(auto &ext : extensions) {\n        cap += ext.length();\n        sm +=\
    \ ext.length();\n    }\n    \n    int strength = cap - sm;\n    \n    for(auto\
    \ &ext : extensions) {\n        if(ext.length() == strength) {\n            strongest_extension\
    \ = class_name + ext;\n            break;\n        }\n    }\n    \n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp11n6_sy4: /tmp/tmp11n6_sy4.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_num = 0, sm_num = 0;\n    for (auto &ext :\
    \ extensions) {\n        cap_num += ext.size();\n        sm_num += ext.size();\n\
    \    }\n    float strength = cap_num - sm_num;\n    if (strength > 0) {\n    \
    \    strongest_extension = class_name + \".\" + extensions[0];\n    }\n    for\
    \ (auto &ext : extensions) {\n        if (ext.size() == strength) {\n        \
    \    strongest_extension = class_name + \".\" + ext;\n        }\n    }\n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp4_2h3bum: /tmp/tmp4_2h3bum.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions){\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    for(auto &ext : extensions){\n   \
    \     if(ext.size() == cap){\n            strongest_extension = class_name + ext;\n\
    \            break;\n        }\n    }\n    if(strongest_extension == \"\"){\n\
    \        for(auto &ext : extensions){\n            if(ext.size() == sm){\n   \
    \             strongest_extension = class_name + ext;\n                break;\n\
    \            }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp9x18ttk4: /tmp/tmp9x18ttk4.cpp:46: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length()\
    \ - ext.find_first_not_of(ext.begin(), ext.end());\n    }\n    float strength\
    \ = cap - sm;\n    for (auto &ext : extensions) {\n        if (ext.length() ==\
    \ strongest_extension.length()) {\n            if (ext.length() < strongest_extension.length())\
    \ {\n                strongest_extension = ext;\n            }\n        } else\
    \ if (ext.length() > strongest_extension.length()) {\n            if (ext.length()\
    \ == strongest_extension.length()) {\n                if (ext.length() < strongest_extension.length())\
    \ {\n                    strongest_extension = ext;\n                }\n     \
    \       }\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpilvesm1f.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpilvesm1f.cpp:25:74:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::find_first_not_of(std::__cxx11::basic_string<char>::iterator,\
    \ std::__cxx11::basic_string<char>::iterator)\u2019\n   25 |         sm += ext.length()\
    \ - ext.find_first_not_of(ext.begin(), ext.end());\n      |                  \
    \                                                        ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpilvesm1f.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2673:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) const [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 2673 |       find_first_not_of(const basic_string&\
    \ __str, size_type __pos = 0) const\n      |       ^~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2673:45:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019} to \u2018const std::__cxx11::basic_string<char>&\u2019\n 2673 |   \
    \    find_first_not_of(const basic_string& __str, size_type _"
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap = class_name.size();\n    int sm = class_name.size();\n    for(auto &ext\
    \ : extensions){\n        cap = cap - ext.size();\n        sm = sm - ext.size();\n\
    \    }\n    return class_name + \".\" + extensions[cap - sm];\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp977mplbh: /tmp/tmp977mplbh.cpp:30: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap_num = 0, sm_num = 0;\n    for (auto &ext : extensions) {\n        if (ext.size()\
    \ >= cap_num && ext.size() <= sm_num) {\n            cap_num = ext.size();\n \
    \           sm_num = ext.size();\n        }\n        else if (ext.size() > sm_num)\
    \ {\n            sm_num = ext.size();\n        }\n    }\n    double strength =\
    \ cap_num - sm_num;\n    std::string result = class_name;\n    for (auto &ext\
    \ : extensions) {\n        if (ext.size() == cap_num) {\n            result +=\
    \ \".\" + ext;\n        }\n        else if (ext.size() == sm_num) {\n        \
    \    result += \".\" + ext;\n        }\n        else if (ext.size() > cap_num\
    \ && ext.size() < sm_num) {\n            result += \".\" + ext;\n        }\n \
    \       else if (ext.size() > sm_num) {\n            result += \".\" + ext;\n\
    \        }\n    }\n    result += \".\" + std::to_string(strength);\n    return\
    \ result;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpo1kdjnf5: /tmp/tmpo1kdjnf5.cpp:51: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto e : extensions)\
    \ {\n        cap += e.size();\n        sm += std::count(e.begin(), e.end(), 'a');\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    } else {\n        for (auto e : extensions)\
    \ {\n            if (e.size() == strongest_extension.size()) {\n             \
    \   strongest_extension = class_name + \".\" + e;\n                break;\n  \
    \          }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpyc9wxuvc: /tmp/tmpyc9wxuvc.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    for(auto &ext : extensions){\n        cap += ext.length();\n        sm +=\
    \ ext.length()-1;\n    }\n    float strength = cap - sm;\n    \n    for(auto &ext\
    \ : extensions){\n        if(ext.length() == strongest_extension.length()){\n\
    \            if(strength > ext.length()-1){\n                strongest_extension\
    \ = ext;\n            }\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpsef6bj4d: /tmp/tmpsef6bj4d.cpp:41: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    double strength = cap_num - sm_num;\n\
    \    int strongest_ext = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n\
    \        if (extensions[i].length() == cap_num - sm_num) {\n            strongest_ext\
    \ = i;\n            break;\n        }\n    }\n    return class_name + \".\" +\
    \ extensions[strongest_ext];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp7rqxip5k: /tmp/tmp7rqxip5k.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    for(auto ext : extensions) {\n   \
    \     if(ext.length() == strongest_extension.length()) {\n            if(ext.compare(0,\
    \ strongest_extension.length(), strongest_extension) == 0) {\n               \
    \ strongest_extension = ext;\n            }\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp_2or1b_5: /tmp/tmp_2or1b_5.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_extensions = 0;\n    int sm_extensions\
    \ = 0;\n    for(auto &extension : extensions) {\n        if(std::toupper(extension[0])\
    \ == extension[0]) {\n            cap_extensions++;\n        }\n        if(std::tolower(extension[0])\
    \ == extension[0]) {\n            sm_extensions++;\n        }\n    }\n    float\
    \ strength = cap_extensions - sm_extensions;\n    if(cap_extensions > sm_extensions)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        strongest_extension = class_name + \".\" + extensions[sm_extensions];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpccf5t3pu: /tmp/tmpccf5t3pu.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for (auto &extension :\
    \ extensions) {\n        int cap = std::count_if(extension.begin(), extension.end(),\
    \ [](char c) {return std::toupper(c) == c;});\n        int sm = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {return std::tolower(c) == c;});\n        float\
    \ strength = cap - sm;\n        if (strength > 0) {\n            strongest_extension\
    \ = class_name + \".\" + extension;\n            break;\n        }\n    }\n  \
    \  return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp3i1jhsvw: /tmp/tmp3i1jhsvw.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = class_name;\n    int cap_num = 0, sml_num = 0;\n    for (auto &ext : extensions)\
    \ {\n        cap_num += ext.length();\n        sml_num += ext.length() - 1;\n\
    \    }\n    double strength = cap_num - sml_num;\n    if (strength > 0) {\n  \
    \      std::sort(extensions.begin(), extensions.end());\n        for (auto &ext\
    \ : extensions) {\n            if (ext.length() == strength) {\n             \
    \   strongest_extension += \".\" + ext;\n                break;\n            }\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmp901ixibn: /tmp/tmp901ixibn.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    \n    for(int\
    \ i = 0; i < extensions.size(); i++) {\n        if(extensions[i].size() > 0) {\n\
    \            cap = cap + extensions[i].at(0);\n            sm = sm + extensions[i].at(0);\n\
    \        }\n    }\n    \n    float strength = cap - sm;\n    \n    for(int i =\
    \ 0; i < extensions.size(); i++) {\n        if(extensions[i].size() > 0) {\n \
    \           cap = cap - extensions[i].at(0);\n            sm = sm - extensions[i].at(0);\n\
    \        }\n    }\n    \n    float strength2 = cap - sm;\n    \n    if(strength\
    \ > strength2) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    else if(strength == strength2) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    else {\n        strongest_extension = class_name\
    \ + \".\" + extensions[1];\n    }\n    \n    return strongest_extension;\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp9ynv6l2r: /tmp/tmp9ynv6l2r.cpp:57: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n   \
    \ }\n    cap = cap / extensions.size();\n    sm = sm / extensions.size();\n  \
    \  if (cap - sm > 0)\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    else\n        strongest_extension = class_name + \".\" + extensions[extensions.size()-1];\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpdumpk44_: /tmp/tmpdumpk44_.cpp:38: int main(): Assertion `candidate(("Boku123"),
    (std::vector<std::string>({"nani", "NazeDa", "YEs.WeCaNe", "32145tggg"}))) ==
    ("Boku123.YEs.WeCaNe")'' failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    for (auto &ext : extensions) {\n        cap += ext.size();\n        sm +=\
    \ ext.size();\n    }\n    cap = cap / extensions.size();\n    sm = sm / extensions.size();\n\
    \    if (cap - sm > 0)\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    else\n        strongest_extension = class_name + \".\" + extensions[extensions.size()-1];\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpjhzzndor: /tmp/tmpjhzzndor.cpp:39: int main(): Assertion `candidate(("Boku123"),
    (std::vector<std::string>({"nani", "NazeDa", "YEs.WeCaNe", "32145tggg"}))) ==
    ("Boku123.YEs.WeCaNe")'' failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    cap = cap / 2;\n    sm = sm / 2;\n    if (cap - sm > 0) strongest_extension\
    \ = class_name + extensions[0];\n    else if (sm - cap > 0) strongest_extension\
    \ = class_name + extensions[1];\n    else strongest_extension = class_name + extensions[2];\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpxh_baamy: /tmp/tmpxh_baamy.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    for(auto &ext : extensions) {\n  \
    \      if(ext.length() == strongest_extension.length()) {\n            strongest_extension\
    \ = class_name + ext;\n        }\n    }\n    return strongest_extension;\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpony039e8: /tmp/tmpony039e8.cpp:37: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    for (auto &ext : extensions) {\n \
    \       if (ext.length() == cap - sm) {\n            strongest_extension += class_name\
    \ + \".\" + ext;\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpj22vusdi: /tmp/tmpj22vusdi.cpp:37: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(int\
    \ i = 0; i < extensions.size(); i++) {\n        if(extensions[i].size() > cap)\
    \ {\n            cap = extensions[i].size();\n        }\n        if(extensions[i].size()\
    \ < sm) {\n            sm = extensions[i].size();\n        }\n    }\n    float\
    \ strength = cap - sm;\n    for(int i = 0; i < extensions.size(); i++) {\n   \
    \     if(extensions[i].size() == cap) {\n            if(extensions[i].compare(class_name.substr(0,\
    \ extensions[i].size())) == 0) {\n                strongest_extension = class_name\
    \ + \".\" + extensions[i];\n                break;\n            }\n        }\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmp3isofgjo: /tmp/tmp3isofgjo.cpp:44: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = class_name.size();\n    int sm =\
    \ class_name.size();\n    for (auto &ext : extensions) {\n        cap = cap -\
    \ ext.size();\n        sm = sm - ext.size();\n    }\n    if (cap == sm) {\n  \
    \      strongest_extension = class_name + \".\" + extensions[0];\n    }\n    for\
    \ (int i = 1; i < extensions.size(); i++) {\n        if (extensions[i].size()\
    \ == cap) {\n            strongest_extension = class_name + \".\" + extensions[i];\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpsuu2f2rw: /tmp/tmpsuu2f2rw.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for(auto extension : extensions) {\n        if(extension == class_name[0])\
    \ {\n            cap_counter++;\n        }\n        if(extension == class_name[class_name.size()-1])\
    \ {\n            sm_counter++;\n        }\n    }\n    float strength = cap_counter\
    \ - sm_counter;\n    if(strength > 0) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    else if(strength < 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[extensions.size()-1];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmphhffi0ol.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmphhffi0ol.cpp:24:22:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |         if(extension == class_name[0]) {\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmphhffi0ol.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmphhffi0ol.cpp:24:37:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   24 |         if(extension ==\
    \ class_name[0]) {\n      |                                     ^\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmphhffi0ol.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmphhffi0ol.cpp:24:37: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}"
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = class_name;\n    \n    for (int i = 0;\
    \ i < extensions.size(); i++) {\n        std::string extension = extensions[i];\n\
    \        int cap = extension.find_first_of('A');\n        int sm = extension.find_first_of('z');\n\
    \        int strength = cap - sm;\n        if (strength > 0) {\n            strongest_extension\
    \ += \".\" + extension;\n        }\n    }\n    return strongest_extension;\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpf8i_n0xp: /tmp/tmpf8i_n0xp.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap = class_name.size();\n \
    \   int sm = class_name.size();\n    for (auto ext : extensions) {\n        cap\
    \ = cap - ext.size();\n        sm = sm - ext.size();\n    }\n    return class_name\
    \ + \".\" + extensions[cap - sm];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp7lc8fzi0: /tmp/tmp7lc8fzi0.cpp:29: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_num = 0, sml_num = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap_num += ext.length();\n        sml_num += ext.length()\
    \ - cap_num;\n    }\n    float strength = cap_num - sml_num;\n    for (auto &ext\
    \ : extensions) {\n        if (ext.length() == cap_num) {\n            if (ext.compare(class_name.substr(0,\
    \ ext.length())) == 0) {\n                strongest_extension = class_name + ext;\n\
    \            }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpgm6nkg0b: /tmp/tmpgm6nkg0b.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    \n    // Write your code here\n\
    \    \n    std::string strongest_extension = \"\";\n    int cap = 0;\n    int\
    \ sm = 0;\n    \n    for(auto &ext : extensions) {\n        cap += ext.length();\n\
    \        sm += ext.length() - cap;\n    }\n    \n    cap = cap - sm;\n    \n \
    \   for(auto &ext : extensions) {\n        if(ext.length() == cap) {\n       \
    \     strongest_extension = class_name + ext;\n            break;\n        }\n\
    \    }\n    \n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmp8p2o0vko: /tmp/tmp8p2o0vko.cpp:44: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length()\
    \ - cap;\n    }\n    cap = cap / 2;\n    sm = sm / 2;\n    if (cap > sm) {\n \
    \       strongest_extension = class_name + extensions[0];\n    } else {\n    \
    \    strongest_extension = class_name + extensions[1];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp6rofghye: /tmp/tmp6rofghye.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = class_name;\n    int cap = 0;\n    int\
    \ sm = 0;\n    \n    for (auto &ext : extensions) {\n        cap += ext.length();\n\
    \        sm += ext.length();\n    }\n    \n    float strength = cap - sm;\n  \
    \  \n    for (auto &ext : extensions) {\n        if (ext.length() == strongest_extension.length())\
    \ {\n            if (ext.length() < strongest_extension.length()) {\n        \
    \        strongest_extension = ext;\n            }\n        }\n    }\n    \n \
    \   return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpvf8kmssf: /tmp/tmpvf8kmssf.cpp:44: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123322
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (int\
    \ i = 0; i < extensions.size(); i++) {\n        if (extensions[i].size() > cap)\
    \ {\n            cap = extensions[i].size();\n        }\n        if (extensions[i].size()\
    \ < sm) {\n            sm = extensions[i].size();\n        }\n    }\n    int strength\
    \ = cap - sm;\n    for (int i = 0; i < extensions.size(); i++) {\n        if (extensions[i].size()\
    \ == strength) {\n            strongest_extension += class_name + \".\" + extensions[i];\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpnxo63bzd: /tmp/tmpnxo63bzd.cpp:43: int main(): Assertion `candidate(("__YESIMHERE"),
    (std::vector<std::string>({"t", "eMptY", "nothing", "zeR00", "NuLl__", "123NoooneB321"})))
    == ("__YESIMHERE.NuLl__")'' failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    \n    for(auto extension : extensions) {\n\
    \        auto cap = std::count_if(extension.begin(), extension.end(), [](char\
    \ c) {return std::toupper(c) == c;});\n        auto sm = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {return std::tolower(c) == c;});\n        auto strength\
    \ = cap - sm;\n        \n        if(strength > 0) {\n            strongest_extension\
    \ += class_name + \".\" + extension;\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmprsf1gq4u: /tmp/tmprsf1gq4u.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &i : extensions) {\n        if (i == class_name[0]) {\n            cap++;\n\
    \        }\n        if (i == class_name[class_name.size() - 1]) {\n          \
    \  sm++;\n        }\n    }\n    if (cap - sm > 1) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp17xv4o7k.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp17xv4o7k.cpp:24:15:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |         if (i == class_name[0]) {\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp17xv4o7k.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp17xv4o7k.cpp:24:30:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   24 |         if (i == class_name[0])\
    \ {\n      |                              ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp17xv4o7k.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp17xv4o7k.cpp:24:30: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |         if ("
  stdout: ''
  timestamp: 1660123322
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &extension : extensions){\n        cap += extension.size()/2;\n        sm +=\
    \ extension.size();\n    }\n    float strength = cap - sm;\n    for(auto &extension\
    \ : extensions){\n        if(extension == class_name){\n            return class_name;\n\
    \        }\n        if(strength > 0){\n            strength -= extension.size();\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpfpl0q0_7: /tmp/tmpfpl0q0_7.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto &extension : extensions) {\n        cap_counter += extension.find_first_of('A');\n\
    \        sm_counter += extension.find_first_of('a', 'z');\n    }\n    int strength\
    \ = cap_counter - sm_counter;\n    if (strength == 0) {\n        return class_name;\n\
    \    }\n    if (strength > 0) {\n        strongest_extension = class_name + \"\
    .\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size(); i++) {\n\
    \        if (strength > 0) {\n            strongest_extension = class_name + \"\
    .\" + extensions[i];\n        }\n        strength -= extensions[i].find_first_of('a',\
    \ 'z');\n        if (strength == 0) {\n            break;\n        }\n    }\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpu9nbykd2: /tmp/tmpu9nbykd2.cpp:47: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap = 0;\n    int sm = 0;\n    for(auto &ext : extensions){\n        cap +=\
    \ ext.size();\n        sm += ext.size();\n    }\n    float strength = cap - sm;\n\
    \    for(auto &ext : extensions){\n        if(ext.size() == cap){\n          \
    \  strength = -1;\n            break;\n        }\n    }\n    std::string strongest_ext\
    \ = class_name + \".\" + extensions[0];\n    for(auto &ext : extensions){\n  \
    \      if(ext.size() > strongest_ext.size()){\n            strongest_ext = class_name\
    \ + \".\" + ext;\n        }\n    }\n    return strongest_ext;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp26tibfej: /tmp/tmp26tibfej.cpp:43: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    for (auto &ext : extensions) {\n \
    \       if (ext.size() == cap - sm) {\n            strongest_extension = class_name\
    \ + ext;\n            break;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp023_4am4: /tmp/tmp023_4am4.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        if (ext.size() > cap) {\n            cap = ext.size();\n\
    \        }\n        if (ext.size() < sm) {\n            sm = ext.size();\n   \
    \     }\n    }\n    float strength = cap - sm;\n    if (strength > 0) {\n    \
    \    strongest_extension = class_name + \".\" + extensions[0];\n    }\n    for\
    \ (int i = 1; i < extensions.size(); i++) {\n        if (strength > 0) {\n   \
    \         strongest_extension = class_name + \".\" + extensions[i];\n        }\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmp83lfqtqn: /tmp/tmp83lfqtqn.cpp:45: int main(): Assertion `candidate(("Boku123"),
    (std::vector<std::string>({"nani", "NazeDa", "YEs.WeCaNe", "32145tggg"}))) ==
    ("Boku123.YEs.WeCaNe")'' failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ e : extensions) {\n        cap += e.size();\n        sm += e.size();\n    }\n\
    \    float strength = cap - sm;\n    if (strength > 0) {\n        for (auto e\
    \ : extensions) {\n            if (e.size() == strength) {\n                strongest_extension\
    \ = class_name + e;\n                break;\n            }\n        }\n    }\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpzsqmizps: /tmp/tmpzsqmizps.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = class_name;\n    int cap = 0;\n    int\
    \ sm = 0;\n    \n    for (auto &extension : extensions) {\n        cap += (std::toupper(extension[0])\
    \ - std::toupper(extension[1]));\n        sm += (std::tolower(extension[0]) -\
    \ std::tolower(extension[1]));\n    }\n    \n    float strength = cap - sm;\n\
    \    \n    if (strength > 0) {\n        strongest_extension += \".\";\n    }\n\
    \    \n    for (auto &extension : extensions) {\n        if (std::toupper(extension[0])\
    \ == std::toupper(extension[1])) {\n            strongest_extension += extension[0];\n\
    \        }\n    }\n    \n    return strongest_extension;\n}\nint main() {\n  \
    \  auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"),\
    \ (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp0oyd_4d8: /tmp/tmp0oyd_4d8.cpp:46: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto &extension : extensions) {\n        cap_counter += std::toupper(extension[0])\
    \ - 'A';\n        sm_counter += std::tolower(extension[0]) - 'a';\n    }\n   \
    \ if (cap_counter > sm_counter) {\n        strongest_extension = class_name +\
    \ extensions[0];\n    }\n    else {\n        strongest_extension = class_name\
    \ + extensions[1];\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpcyoo9dbh: /tmp/tmpcyoo9dbh.cpp:37: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_num = 0, sm_num = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap_num += ext.size();\n        sm_num += ext.size();\n\
    \    }\n    float strength = cap_num - sm_num;\n    if (strength > 0) {\n    \
    \    strongest_extension = class_name + \".\" + extensions[0];\n    }\n    for\
    \ (auto &ext : extensions) {\n        if (ext.size() == strength) {\n        \
    \    strongest_extension = class_name + \".\" + ext;\n        }\n    }\n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpxujkw36n: /tmp/tmpxujkw36n.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = class_name;\n    int cap_counter = 0;\n\
    \    int sm_counter = 0;\n    for(auto &extension : extensions) {\n        if(std::toupper(extension[0])\
    \ == extension[0]) {\n            cap_counter++;\n        }\n        if(std::tolower(extension[0])\
    \ == extension[0]) {\n            sm_counter++;\n        }\n    }\n    \n    float\
    \ strength = cap_counter - sm_counter;\n    \n    if(strength > 0) {\n       \
    \ for(auto &extension : extensions) {\n            if(std::toupper(extension[0])\
    \ == extension[0]) {\n                cap_counter--;\n            }\n        \
    \    if(std::tolower(extension[0]) == extension[0]) {\n                sm_counter--;\n\
    \            }\n        }\n        strength = cap_counter - sm_counter;\n    }\n\
    \    \n    if(strength > 0) {\n        strongest_extension = class_name + extensions[0];\n\
    \    }\n    \n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmp_zpkg_5b: /tmp/tmp_zpkg_5b.cpp:55: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    int cap =\
    \ class_name.size();\n    int sm = extensions.size();\n    int strength = 0;\n\
    \    for (int i = 0; i < cap; i++) {\n        for (int j = 0; j < sm; j++) {\n\
    \            if (class_name[i] == extensions[j][0] && class_name[i] == extensions[j][1])\
    \ {\n                strength = cap - sm;\n            }\n        }\n    }\n \
    \   if (strength > 0) {\n        return class_name + \".\" + extensions[strength][0];\n\
    \    }\n    else {\n        return class_name;\n    }\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmp4sjfl692: /tmp/tmp4sjfl692.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(auto &extension :\
    \ extensions) {\n        auto cap = std::count_if(extension.begin(), extension.end(),\
    \ [](char ch) {\n            return std::isupper(ch);\n        });\n        auto\
    \ sm = std::count_if(extension.begin(), extension.end(), [](char ch) {\n     \
    \       return std::islower(ch);\n        });\n        auto strength = cap - sm;\n\
    \        if(strength > 0) {\n            strongest_extension = class_name + \"\
    .\" + extension;\n            break;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpslkebfts: /tmp/tmpslkebfts.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &i : extensions) {\n        cap += i[0]-'A';\n        sm += i[1]-'a';\n    }\n\
    \    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &i : extensions)\
    \ {\n        if (i[0] == i[1]) {\n            continue;\n        }\n        if\
    \ (i[0] < i[1]) {\n            strongest_extension = class_name + \".\" + i;\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpfyriv4wu: /tmp/tmpfyriv4wu.cpp:43: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    \n    int cap_num = 0, sm_num = 0;\n    for\
    \ (auto &ext : extensions) {\n        cap_num += ext.length();\n        sm_num\
    \ += ext.length() - cap_num;\n    }\n    \n    int strength = cap_num - sm_num;\n\
    \    \n    for (auto &ext : extensions) {\n        if (ext.length() == cap_num)\
    \ {\n            if (ext.compare(extensions[0]) == 0) {\n                strongest_extension\
    \ = class_name + ext;\n                break;\n            }\n        }\n    }\n\
    \    \n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpfiexi8e4: /tmp/tmpfiexi8e4.cpp:43: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    double strongest_strength = 0;\n    for (auto\
    \ &extension : extensions) {\n        double extension_strength = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {\n            return std::toupper(c) >= 'A' &&\
    \ std::toupper(c) <= 'Z';\n        }) / extension.size();\n        if (extension_strength\
    \ > strongest_strength) {\n            strongest_strength = extension_strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp9w477g0z: /tmp/tmp9w477g0z.cpp:35: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_counter = 0;\n    int sml_counter = 0;\n \
    \   for (auto &extension : extensions) {\n        if (std::toupper(extension[0])\
    \ == extension[0]) {\n            cap_counter++;\n        }\n        if (std::tolower(extension[0])\
    \ == extension[0]) {\n            sml_counter++;\n        }\n    }\n    float\
    \ strength = cap_counter - sml_counter;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    if (strength == 1) {\n   \
    \     strongest_extension = class_name + \".\" + extensions[0];\n    }\n    if\
    \ (strength > 1) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpcg11j981: /tmp/tmpcg11j981.cpp:45: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == strongest_extension.length()) {\n           \
    \ if (ext.compare(0, strongest_extension.length(), strongest_extension) == 0)\
    \ {\n                strongest_extension = class_name + \".\" + ext;\n       \
    \     }\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpblojg137: /tmp/tmpblojg137.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    cap = cap - sm;\n    if (cap > 0) {\n        strongest_extension =\
    \ class_name + extensions[0];\n    }\n    for (auto &ext : extensions) {\n   \
    \     if (ext.size() == cap) {\n            strongest_extension = class_name +\
    \ ext;\n            break;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp713qev07: /tmp/tmp713qev07.cpp:41: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    int strength = cap_num - sm_num;\n \
    \   if (strength == 0) return class_name;\n    int index = 0;\n    for (auto &ext\
    \ : extensions) {\n        if (ext.length() == strength) {\n            return\
    \ class_name + \".\" + ext;\n        }\n        index++;\n    }\n    return class_name;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpuf3stjjh: /tmp/tmpuf3stjjh.cpp:37: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &i : extensions) {\n        cap += i[0]-'A';\n        sm += i[1]-'a';\n    }\n\
    \    float strength = cap - sm;\n    for (auto &i : extensions) {\n        if\
    \ (cap - i[0] < sm) {\n            strongest_extension = class_name + i;\n   \
    \         break;\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpp9wdq01e: /tmp/tmpp9wdq01e.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto &extension : extensions) {\n        if (extension.at(0) ==\
    \ class_name.at(0)) {\n            cap_counter++;\n        }\n        if (extension.at(1)\
    \ == class_name.at(0)) {\n            sm_counter++;\n        }\n    }\n    if\
    \ (cap_counter > sm_counter) {\n        strongest_extension = class_name + \"\
    .\" + extensions[0];\n    }\n    else {\n        strongest_extension = class_name\
    \ + \".\" + extensions[1];\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpf2cpyr44: /tmp/tmpf2cpyr44.cpp:41: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions) {\n        if(ext.size() >= cap) {\n            cap = ext.size();\n\
    \        }\n        if(ext.size() >= sm) {\n            sm = ext.size();\n   \
    \     }\n    }\n    float strength = cap - sm;\n    for(auto &ext : extensions)\
    \ {\n        if(ext.size() == cap) {\n            strongest_extension = class_name\
    \ + ext;\n            break;\n        }\n        if(ext.size() == sm) {\n    \
    \        strongest_extension = class_name + ext;\n            break;\n       \
    \ }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmp9m8uyewv: /tmp/tmp9m8uyewv.cpp:46: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    int max_strength = -1;\n    for (auto\
    \ &ext : extensions) {\n        if (ext.size() > max_strength) {\n           \
    \ max_strength = ext.size();\n        }\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.size() == max_strength) {\n            if (cap - ext.size()\
    \ > sm) {\n                strongest_extension = class_name + \".\" + ext;\n \
    \           }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpxkdfefw5: /tmp/tmpxkdfefw5.cpp:45: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension;\n    \n    for(auto extension : extensions) {\n       \
    \ auto cap = extension.find_first_of('A');\n        auto sm = extension.find_first_of('l');\n\
    \        auto strength = cap - sm;\n        \n        if(strength > 0) {\n   \
    \         strongest_extension = class_name + extension;\n            break;\n\
    \        }\n    }\n    \n    return strongest_extension;\n}\nint main() {\n  \
    \  auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"),\
    \ (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpgi_x8z61: /tmp/tmpgi_x8z61.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length()\
    \ - cap;\n    }\n    cap = cap / 2;\n    sm = sm / 2;\n    if (cap - sm > 0) strongest_extension\
    \ = class_name + extensions[0];\n    else if (sm - cap > 0) strongest_extension\
    \ = class_name + extensions[1];\n    else strongest_extension = class_name + extensions[2];\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpqpbkdevw: /tmp/tmpqpbkdevw.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (strength > 0) {\n            strongest_extension = class_name\
    \ + \".\" + extensions[i];\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp80n8ajis: /tmp/tmp80n8ajis.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = class_name;\n    int cap = 0;\n    int\
    \ sm = 0;\n    \n    for (auto &ext : extensions) {\n        cap += ext.size();\n\
    \        sm += ext.size();\n    }\n    \n    if (cap - sm > 0)\n        strongest_extension\
    \ += \".\";\n    \n    for (auto &ext : extensions) {\n        if (cap - sm ==\
    \ 0) {\n            strongest_extension += ext;\n            break;\n        }\n\
    \        \n        if (ext.size() < cap - sm) {\n            strongest_extension\
    \ += ext;\n            break;\n        }\n        \n        if (ext.size() > cap\
    \ - sm) {\n            strongest_extension += ext.substr(0, cap - sm);\n     \
    \       break;\n        }\n    }\n    \n    return strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmprqwmy323: /tmp/tmprqwmy323.cpp:54: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(int i = 0; i < extensions.size();\
    \ i++){\n        std::string extension = extensions[i];\n        \n        for(int\
    \ j = 0; j < extension.size(); j++){\n            char c = extension[j];\n   \
    \         \n            if(c == toupper(extension[j])){\n                strongest_extension\
    \ += c;\n            }\n        }\n    }\n    \n    return class_name + \".\"\
    \ + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpvkkv3xsa: /tmp/tmpvkkv3xsa.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        cap += ext.length();\n        sm += ext.length() -\
    \ cap;\n    }\n    cap = cap - sm;\n    int strength = cap - cap;\n    if (strength\
    \ > 0) {\n        strongest_extension = class_name + extensions[0];\n    }\n \
    \   for (int i = 1; i < extensions.size(); i++) {\n        if (strength > 0) {\n\
    \            strongest_extension = class_name + extensions[i];\n        }\n  \
    \      strength -= extensions[i].length();\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp2u_icivd: /tmp/tmp2u_icivd.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension = \"\";\n\
    \    int cap = 0;\n    int sm = 0;\n    for (auto &ext : extensions) {\n     \
    \   cap += ext.length();\n        sm += ext.length();\n    }\n    cap = cap /\
    \ 2;\n    sm = sm / 2;\n    if (cap - sm > 0)\n        extension = class_name\
    \ + extensions[0];\n    else if (cap - sm == 0)\n        extension = class_name\
    \ + extensions[1];\n    else\n        extension = class_name + extensions[2];\n\
    \    return extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpx9mtmzhz: /tmp/tmpx9mtmzhz.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = class_name;\n    int cap = class_name.size();\n\
    \    int sm = class_name.size();\n    \n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        cap = cap - extensions[i].size();\n        sm = sm - extensions[i].size();\n\
    \    }\n    \n    if (cap > sm) {\n        strongest_extension = class_name +\
    \ extensions[0];\n    }\n    \n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpmtcgulws: /tmp/tmpmtcgulws.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ it=extensions.begin(); it!=extensions.end(); ++it) {\n        cap += std::toupper(*it).size();\n\
    \        sm += std::tolower(*it).size();\n    }\n    float strength = cap - sm;\n\
    \    if(strength > 0) {\n        for(auto it=extensions.begin(); it!=extensions.end();\
    \ ++it) {\n            if(std::toupper(*it) == std::toupper(class_name)) {\n \
    \               strongest_extension = class_name + \".\" + std::toupper(*it);\n\
    \                break;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpolj1haup.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpolj1haup.cpp:24:32:\
    \ error: no matching function for call to \u2018toupper(std::__cxx11::basic_string<char>&)\u2019\
    \n   24 |         cap += std::toupper(*it).size();\n      |                  \
    \              ^\nIn file included from /usr/include/c++/9/cctype:42,\n      \
    \           from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n     \
    \            from /tmp/tmpolj1haup.cpp:2:\n/usr/include/ctype.h:125:12: note:\
    \ candidate: \u2018int toupper(int)\u2019\n  125 | extern int toupper (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:125:25: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018int\u2019\n  125 | extern int toupper (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpolj1haup.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2643:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::toupper(_CharT, const std::locale&)\u2019\
    \n 2643 |     toupper(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2643:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpolj1haup.cpp:24:32: note:   candidate expects 2 arguments,\
    \ 1 provided\n   24 |         cap += std::toupper(*it).size();\n      |      \
    \                          ^\n/tmp/tmpolj1haup.cpp:25:31: error: no matching function\
    \ for call to \u2018tolower(std::__cxx11::basic_string<char>&)\u2019\n   25 |\
    \         sm += std::tolower(*it).size();\n      |                           \
    \    ^\nIn file included from /usr/include/c++/9/"
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    \n    for\
    \ (auto &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    \n    cap = cap / extensions.size();\n    sm = sm / extensions.size();\n\
    \    \n    if (cap - sm > 0)\n        strongest_extension = class_name + extensions[cap\
    \ - sm];\n    else\n        strongest_extension = class_name;\n    \n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpte54q8ja: /tmp/tmpte54q8ja.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &extension\
    \ : extensions) {\n        cap_counter += std::count_if(extension.begin(), extension.end(),\
    \ [](char c) {\n            return std::toupper(c) == c;\n        });\n      \
    \  sm_counter += std::count_if(extension.begin(), extension.end(), [](char c)\
    \ {\n            return std::tolower(c) == c;\n        });\n    }\n    double\
    \ strength = cap_counter - sm_counter;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &extension : extensions)\
    \ {\n        if (strength > 0) {\n            double extension_strength = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {\n                return std::toupper(c) == c;\n\
    \            });\n            if (extension_strength > strength) {\n         \
    \       strongest_extension = class_name + \".\" + extension;\n            }\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpl_k456y1: /tmp/tmpl_k456y1.cpp:49: int main(): Assertion `candidate(("Boku123"),
    (std::vector<std::string>({"nani", "NazeDa", "YEs.WeCaNe", "32145tggg"}))) ==
    ("Boku123.YEs.WeCaNe")'' failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap_counter = 0;\n    int\
    \ sm_counter = 0;\n    \n    for (auto extension : extensions) {\n        cap_counter\
    \ += std::count_if(extension.begin(), extension.end(), [](char c) {\n        \
    \    return std::toupper(c) == c;\n        });\n        sm_counter += std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {\n            return std::tolower(c) == c;\n  \
    \      });\n    }\n    \n    int strength = cap_counter - sm_counter;\n    \n\
    \    if (strength > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    \n    for (auto extension : extensions) {\n        if (strength >\
    \ 0) {\n            if (std::tolower(extension) == std::tolower(extensions[0]))\
    \ {\n                strongest_extension = class_name + \".\" + extension;\n \
    \               break;\n            }\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpv9wsz8as.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpv9wsz8as.cpp:42:39:\
    \ error: no matching function for call to \u2018tolower(std::__cxx11::basic_string<char>&)\u2019\
    \n   42 |             if (std::tolower(extension) == std::tolower(extensions[0]))\
    \ {\n      |                                       ^\nIn file included from /usr/include/c++/9/cctype:42,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpv9wsz8as.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpv9wsz8as.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpv9wsz8as.cpp:42:39: note:   candidate expects 2 arguments,\
    \ 1 provided\n   42 |             if (std::tolower(extension) == std::tolower(extensions[0]))\
    \ {\n      |                                       ^\n/tmp/tmpv9wsz8as.cpp:42:70:\
    \ error: no matching function for call to \u2018tolower(__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx"
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension;\n    \n    int cap = 0;\n    int sm = 0;\n\
    \    \n    for (auto &ext : extensions) {\n        cap += ext.length();\n    \
    \    sm += ext.length();\n    }\n    \n    float strength = cap - sm;\n    \n\
    \    for (auto &ext : extensions) {\n        if (ext.length() == strongest_extension.length())\
    \ {\n            if (ext.length() > strongest_extension.length()) {\n        \
    \        strongest_extension = ext;\n            }\n        }\n    }\n    \n \
    \   return class_name + \".\" + strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpy7u46t2v: /tmp/tmpy7u46t2v.cpp:45: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = class_name;\n    int cap = 0;\n    int sm = 0;\n    for(auto &ext : extensions)\
    \ {\n        cap += ext.length();\n        sm += ext.length() - cap;\n    }\n\
    \    cap = cap - sm;\n    for(auto &ext : extensions) {\n        if(ext.length()\
    \ == cap) {\n            strongest_extension += ext;\n        }\n    }\n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpitzomq3m: /tmp/tmpitzomq3m.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.size() > strongest_extension.size()) {\n            strongest_extension\
    \ = class_name + \".\" + ext;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpfy1rwr9b: /tmp/tmpfy1rwr9b.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length();\n    }\n    double strength = cap_num - sm_num;\n  \
    \  double max_strength = -1;\n    for (auto &ext : extensions) {\n        double\
    \ ext_strength = ext.length();\n        if (ext_strength > max_strength) {\n \
    \           max_strength = ext_strength;\n        }\n    }\n    if (max_strength\
    \ == -1) {\n        return class_name;\n    }\n    double strength_diff = strength\
    \ / max_strength;\n    double max_diff = -1;\n    for (auto &ext : extensions)\
    \ {\n        double ext_diff = ext.length() / max_strength;\n        if (ext_diff\
    \ > max_diff) {\n            max_diff = ext_diff;\n        }\n    }\n    if (max_diff\
    \ == -1) {\n        return class_name;\n    }\n    double diff_diff = strength_diff\
    \ / max_diff;\n    double max_diff_diff = -1;\n    for (auto &ext : extensions)\
    \ {\n        double ext_diff_diff = ext.length() / max_diff;\n        if (ext_diff_diff\
    \ > max_diff_diff) {\n            max_diff_diff = ext_diff_diff;\n        }\n\
    \    }\n    if (max_diff_diff == -1) {\n        return class_name;\n    }\n  \
    \  std::string strongest_ext;\n    for (auto &ext : extensions) {\n        if\
    \ (ext.length() == max_diff_diff) {\n            strongest_ext = class_name +\
    \ \".\" + ext;\n        }\n    }\n    return strongest_ext;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpgkrwjyig: /tmp/tmpgkrwjyig.cpp:69: int main(): Assertion `candidate(("__YESIMHERE"),
    (std::vector<std::string>({"t", "eMptY", "nothing", "zeR00", "NuLl__", "123NoooneB321"})))
    == ("__YESIMHERE.NuLl__")'' failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_num = 0, sm_num = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap_num += ext.length();\n        sm_num += ext.length();\n\
    \    }\n    double strength = cap_num - sm_num;\n    if (strength > 0) {\n   \
    \     strongest_extension = class_name + \".\" + extensions[0];\n    }\n    for\
    \ (auto &ext : extensions) {\n        if (ext.length() == strength) {\n      \
    \      strongest_extension = class_name + \".\" + ext;\n        }\n    }\n   \
    \ return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp813f50zx: /tmp/tmp813f50zx.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.size() == strongest_extension.size()) {\n            if (strength\
    \ > 0) {\n                strongest_extension = class_name + \".\" + ext;\n  \
    \          }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpr328fvvy: /tmp/tmpr328fvvy.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_counter = 0;\n    int sml_counter = 0;\n \
    \   for (auto &ext : extensions) {\n        if (ext.size() == cap_counter) {\n\
    \            strongest_extension = class_name + ext;\n            break;\n   \
    \     }\n        if (ext.size() == sml_counter) {\n            strongest_extension\
    \ = class_name + ext;\n            break;\n        }\n        cap_counter++;\n\
    \        sml_counter++;\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpwr2o6smk: /tmp/tmpwr2o6smk.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions){\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    for(auto &ext : extensions){\n   \
    \     if(ext.size() == cap){\n            strongest_extension = class_name + ext;\n\
    \            break;\n        }\n    }\n    if(strongest_extension.empty()){\n\
    \        for(auto &ext : extensions){\n            if(ext.size() < cap){\n   \
    \             strongest_extension = class_name + ext;\n                break;\n\
    \            }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp4xdcfb3w: /tmp/tmp4xdcfb3w.cpp:46: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123325
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length();\n    }\n    int cap = cap_num / class_name.size();\n\
    \    int sm = sm_num / class_name.size();\n    if (cap > sm) {\n        return\
    \ class_name + \".\" + extensions[0];\n    }\n    return class_name + \".\" +\
    \ extensions[extensions.size() - 1];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpu7g_yh6q: /tmp/tmpu7g_yh6q.cpp:34: int main(): Assertion `candidate(("Boku123"),
    (std::vector<std::string>({"nani", "NazeDa", "YEs.WeCaNe", "32145tggg"}))) ==
    ("Boku123.YEs.WeCaNe")'' failed.

    '
  stdout: ''
  timestamp: 1660123325
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    std::string extension = \"\";\n    int cap\
    \ = 0;\n    int sm = 0;\n    for (auto &i : extensions) {\n        cap += i[0]-'A';\n\
    \        sm += i[1]-'a';\n    }\n    float strength = cap - sm;\n    if (strength\
    \ > 0) {\n        strongest_extension = class_name + extensions[0];\n    }\n \
    \   for (auto &i : extensions) {\n        if (i[0] == i[1]) {\n            continue;\n\
    \        }\n        if (i[0] < i[1]) {\n            strongest_extension = class_name\
    \ + extensions[0];\n            break;\n        }\n        if (i[0] > i[1]) {\n\
    \            strongest_extension = class_name + extensions[1];\n            break;\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpmbgtinou: /tmp/tmpmbgtinou.cpp:49: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123325
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    double strength = cap_num - sm_num;\n\
    \    int strongest_ext = 0;\n    for (auto &ext : extensions) {\n        if (ext.length()\
    \ == strength) {\n            strongest_ext = ext.length();\n        }\n    }\n\
    \    return class_name + \".\" + extensions[strongest_ext];\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp3o5vg6zt: /tmp/tmp3o5vg6zt.cpp:35: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    double strength = cap_num - sm_num;\n\
    \    int max_strength = -1;\n    for (auto &ext : extensions) {\n        if (ext.length()\
    \ > max_strength) {\n            max_strength = ext.length();\n        }\n   \
    \ }\n    if (max_strength == -1) {\n        return class_name;\n    }\n    std::string\
    \ strongest_ext;\n    for (auto &ext : extensions) {\n        if (ext.length()\
    \ == max_strength) {\n            strongest_ext = class_name + \".\" + ext;\n\
    \            break;\n        }\n    }\n    return strongest_ext;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp5dyn7tj2: /tmp/tmp5dyn7tj2.cpp:45: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    \n    for(auto &extension : extensions){\n\
    \        int cap = extension.size()-1;\n        int sm = extension.size()-cap;\n\
    \        float strength = (float)cap-(float)sm;\n        if(strength > 0){\n \
    \           strongest_extension = class_name + \".\" + extension;\n          \
    \  break;\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp72hzvzd7: /tmp/tmp72hzvzd7.cpp:35: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_counter = 0;\n    int sm_counter = 0;\n  \
    \  for (auto &extension : extensions) {\n        if (extension == class_name[0])\
    \ {\n            cap_counter++;\n        }\n        if (extension == class_name[class_name.length()\
    \ - 1]) {\n            sm_counter++;\n        }\n    }\n    double strength =\
    \ cap_counter - sm_counter;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    if (strength < 0) {\n    \
    \    strongest_extension = class_name + \".\" + extensions[extensions.size() -\
    \ 1];\n    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9aszdtl9.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp9aszdtl9.cpp:24:23:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |         if (extension == class_name[0]) {\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9aszdtl9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9aszdtl9.cpp:24:38:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   24 |         if (extension ==\
    \ class_name[0]) {\n      |                                      ^\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9aszdtl9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9aszdtl9.cpp:24:38: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char"
  stdout: ''
  timestamp: 1660123325
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for\
    \ (auto &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        for (auto\
    \ &ext : extensions) {\n            if (ext.length() == strength) {\n        \
    \        strongest_extension = class_name + ext;\n                break;\n   \
    \         }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpjr0nkow1: /tmp/tmpjr0nkow1.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    int index = std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end(), [&](std::string a, std::string\
    \ b) { return a.length() < b.length(); }));\n    strongest_extension = class_name\
    \ + extensions[index];\n    return strongest_extension;\n}\nint main() {\n   \
    \ auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpjco5maba: /tmp/tmpjco5maba.cpp:34: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &extension : extensions){\n        cap += extension.at(0) - 'A';\n        sm\
    \ += extension.at(1) - 'a';\n    }\n    float strength = cap - sm;\n    for(auto\
    \ &extension : extensions){\n        if(extension.at(0) - 'A' == cap && extension.at(1)\
    \ - 'a' == sm){\n            strongest_extension = class_name + \".\" + extension;\n\
    \            break;\n        }\n    }\n    return strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp8dctfj_7: /tmp/tmp8dctfj_7.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    cap = cap / 2;\n    sm = sm / 2;\n    if (cap - sm > 0)\n        strongest_extension\
    \ = class_name + extensions[0];\n    else if (cap - sm == 0)\n        strongest_extension\
    \ = class_name + extensions[1];\n    else\n        strongest_extension = class_name\
    \ + extensions[2];\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmp45lzcrnl: /tmp/tmp45lzcrnl.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    std::string strongest_extension_strength =\
    \ \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for(auto &extension\
    \ : extensions) {\n        if(extension == class_name[0]) {\n            cap_counter++;\n\
    \        }\n        if(extension == class_name[class_name.length() - 1]) {\n \
    \           sm_counter++;\n        }\n    }\n    double strength = cap_counter\
    \ - sm_counter;\n    if(strength > 0) {\n        strongest_extension_strength\
    \ = class_name + \".\" + extensions[0];\n    }\n    else if(strength < 0) {\n\
    \        strongest_extension_strength = class_name + \".\" + extensions[extensions.size()\
    \ - 1];\n    }\n    else if(strength == 0) {\n        strongest_extension_strength\
    \ = class_name;\n    }\n    else {\n        strongest_extension_strength = class_name\
    \ + \".\" + extensions[0];\n    }\n    return strongest_extension_strength;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpuzxwv364.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpuzxwv364.cpp:25:22:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   25 |         if(extension == class_name[0]) {\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuzxwv364.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpuzxwv364.cpp:25:37:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   25 |         if(extension ==\
    \ class_name[0]) {\n      |                                     ^\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuzxwv364.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpuzxwv364.cpp:25:37: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}"
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = class_name;\n    int cap = 0;\n    int\
    \ sm = 0;\n    for (auto &ext : extensions) {\n        cap += ext.size();\n  \
    \      sm += ext.size();\n    }\n    \n    if (cap - sm > 0) {\n        float\
    \ strength = (float)cap - sm;\n        std::sort(extensions.begin(), extensions.end(),\
    \ [&](std::string &a, std::string &b) -> bool {\n            return a.size() >\
    \ b.size() ? true : a.size() < b.size();\n        });\n        for (auto &ext\
    \ : extensions) {\n            if (ext.size() == strongest_extension.size()) {\n\
    \                if (ext.size() < strongest_extension.size()) {\n            \
    \        strongest_extension = class_name + ext;\n                }\n        \
    \    }\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n \
    \   auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"),\
    \ (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpeg6g_jcf: /tmp/tmpeg6g_jcf.cpp:46: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &e : extensions) {\n        if (e.size() > cap) {\n            cap = e.size();\n\
    \        }\n        if (e.size() < sm) {\n            sm = e.size();\n       \
    \ }\n    }\n    float strength = cap - sm;\n    if (strength == 0) {\n       \
    \ return class_name;\n    }\n    for (auto &e : extensions) {\n        if (e.size()\
    \ == cap) {\n            strongest_extension += e;\n        }\n    }\n    return\
    \ class_name + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpx1fjro17: /tmp/tmpx1fjro17.cpp:46: int main(): Assertion `candidate(("__YESIMHERE"),
    (std::vector<std::string>({"t", "eMptY", "nothing", "zeR00", "NuLl__", "123NoooneB321"})))
    == ("__YESIMHERE.NuLl__")'' failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    cap = cap - sm;\n    if (cap > 0) {\n        strongest_extension =\
    \ class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.size() == cap) {\n            strongest_extension = class_name\
    \ + \".\" + ext;\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmph9jckqa3: /tmp/tmph9jckqa3.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.size();\n        sm_num\
    \ += ext.size();\n    }\n    float strength = cap_num - sm_num;\n    std::string\
    \ strongest_ext;\n    for (auto &ext : extensions) {\n        if (ext.size() ==\
    \ strength) {\n            strongest_ext = class_name + \".\" + ext;\n       \
    \     break;\n        }\n    }\n    return strongest_ext;\n}\nint main() {\n \
    \   auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"),\
    \ (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp4hd0_z43: /tmp/tmp4hd0_z43.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap = class_name.size();\n \
    \   int sm = class_name.size();\n    for (auto ext : extensions) {\n        cap\
    \ = cap - ext.size();\n        sm = sm - ext.size();\n    }\n    float strength\
    \ = cap - sm;\n    if (strength > 0) {\n        return class_name + \".\" + extensions[0];\n\
    \    }\n    else if (strength == 0){\n        return class_name;\n    }\n    else\
    \ {\n        return class_name + \".\" + extensions[extensions.size()-1];\n  \
    \  }\n}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp_y9m8qls: /tmp/tmp_y9m8qls.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sml_counter =\
    \ 0;\n    for (auto &ext : extensions) {\n        if (ext.length() == 0) {\n \
    \           continue;\n        }\n        if (ext.at(0) == class_name.at(0)) {\n\
    \            cap_counter++;\n        }\n        if (ext.at(0) >= class_name.at(0))\
    \ {\n            sml_counter++;\n        }\n    }\n    if (cap_counter > sml_counter)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        strongest_extension = class_name + \".\" + extensions[sml_counter];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpvbcebcyq: /tmp/tmpvbcebcyq.cpp:44: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    for(auto &ext : extensions){\n        if(ext.size() > cap){\n           \
    \ cap = ext.size();\n        }\n        if(ext.size() < sm){\n            sm =\
    \ ext.size();\n        }\n    }\n    float strength = cap - sm;\n    \n    for(auto\
    \ &ext : extensions){\n        if(ext.size() == cap){\n            if(ext.compare(class_name.substr(0,\
    \ ext.size())) == 0){\n                strongest_extension = class_name + ext;\n\
    \            }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpgvx_am4u: /tmp/tmpgvx_am4u.cpp:45: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap = class_name.size();\n    int sm = class_name.size();\n    for(int i = 0;\
    \ i < extensions.size(); i++){\n        cap = cap - extensions[i].size();\n  \
    \      sm = sm - extensions[i].size();\n    }\n    float strength = cap - sm;\n\
    \    std::string strongest_extension = \"\";\n    for(int i = 0; i < extensions.size();\
    \ i++){\n        if(strength > 0){\n            strongest_extension = strongest_extension\
    \ + class_name + \".\" + extensions[i];\n            strength = strength - 1;\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpgvr7k5_4: /tmp/tmpgvr7k5_4.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_num = 0, sm_num = 0;\n    for (auto\
    \ &ext : extensions) {\n        if (ext.size() > cap_num) {\n            cap_num\
    \ = ext.size();\n        }\n        if (ext.size() < sm_num) {\n            sm_num\
    \ = ext.size();\n        }\n    }\n    float cap_frac = cap_num - sm_num;\n  \
    \  if (cap_frac > 1) {\n        cap_frac = cap_frac / 2;\n    }\n    cap_num -=\
    \ cap_frac;\n    for (auto &ext : extensions) {\n        if (ext.size() > cap_num)\
    \ {\n            cap_num = ext.size();\n        }\n    }\n    for (auto &ext :\
    \ extensions) {\n        if (ext.size() < sm_num) {\n            sm_num = ext.size();\n\
    \        }\n    }\n    float sm_frac = sm_num - cap_num;\n    if (sm_frac > 1)\
    \ {\n        sm_frac = sm_frac / 2;\n    }\n    sm_num -= sm_frac;\n    for (auto\
    \ &ext : extensions) {\n        if (ext.size() > cap_num) {\n            cap_num\
    \ = ext.size();\n        }\n        if (ext.size() < sm_num) {\n            sm_num\
    \ = ext.size();\n        }\n    }\n    cap_num -= sm_num;\n    for (auto &ext\
    \ : extensions) {\n        if (ext.size() > cap_num) {\n            cap_num =\
    \ ext.size();\n        }\n    }\n    for (auto &ext : extensions) {\n        if\
    \ (ext.size() < sm_num) {\n            sm_num = ext.size();\n        }\n    }\n\
    \    cap_num -= sm_num;\n    for (auto &ext : extensions) {\n        if (ext.size()\
    \ > cap_num) {\n            cap_num = ext.size();\n        }\n    }\n    for (auto\
    \ &ext : extensions) {\n        if (ext.size() < sm_num) {\n            sm_num\
    \ = ext.size();\n        }\n    }\n    cap_num -= sm_num;\n    for (auto &ext\
    \ : extensions) {\n        if (ext.size() > cap_num) {\n            cap_num =\
    \ ext.size();\n        }\n    }\n    for (auto &ext : extensions) {\n        if\
    \ (ext.size() < sm_num) {\n            sm_num = ext.size();\n        }\n    }\n\
    \    cap_num -= sm_num;\n    for (auto &ext : extensions) {\n        if (ext.size()\
    \ > cap_num) {\n            cap_num = ext.size();\n        }\n    }\n    for (auto\
    \ &ext : extensions) {\n        if (ext.size() < sm_num) {\n            sm_num\
    \ = ext.size();\n        }\n    }\n    cap_num -= sm_num;\n    for (auto \n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp9zn0hpjw.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp9zn0hpjw.cpp:104:1:\
    \ error: expected unqualified-id before \u2018}\u2019 token\n  104 | }\n     \
    \ | ^\n/tmp/tmp9zn0hpjw.cpp:103:14: error: expected \u2018;\u2019 before \u2018\
    }\u2019 token\n  103 |     for (auto\n      |              ^\n      |        \
    \      ;\n  104 | }\n      | ~             \n/tmp/tmp9zn0hpjw.cpp:104:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n  104 | }\n      | ^\n\
    /tmp/tmp9zn0hpjw.cpp:103:14: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n  103 |     for (auto\n      |              ^\n      |              ;\n\
    \  104 | }\n      | ~             \n/tmp/tmp9zn0hpjw.cpp:104:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n  104 | }\n      | ^\n/tmp/tmp9zn0hpjw.cpp:103:14:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n  103 |     for (auto\n\
    \      |         ~    ^\n      |              )\n  104 | }\n      | ~        \
    \     \n/tmp/tmp9zn0hpjw.cpp:104:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n  104 | }\n      | ^\n/tmp/tmp9zn0hpjw.cpp:104:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660123325
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for\
    \ (int i = 0; i < extensions.size(); i++) {\n        cap += (extensions[i].size()\
    \ - extensions[i].find_first_of('A'));\n        sm += (extensions[i].size() -\
    \ extensions[i].find_first_of('a')) + 1;\n    }\n    if (cap - sm > 0) strongest_extension\
    \ += \".\";\n    for (int i = 0; i < extensions.size(); i++) {\n        if (extensions[i].size()\
    \ == cap - sm) {\n            strongest_extension += extensions[i];\n        }\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmps903pbca: /tmp/tmps903pbca.cpp:37: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = class_name.size();\n    int\
    \ sm = extensions.size();\n    int strength = cap - sm;\n    for (int i = 0; i\
    \ < extensions.size(); i++) {\n        if (extensions[i] == strongest_extension)\
    \ {\n            strength = i;\n        }\n    }\n    if (strength != -1) {\n\
    \        strongest_extension = class_name + extensions[strength];\n    }\n   \
    \ return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmplw9uz658: /tmp/tmplw9uz658.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap = class_name.size();\n \
    \   int sm = class_name.size();\n    for (auto ext : extensions) {\n        cap\
    \ = cap - ext.size();\n        sm = sm - ext.size();\n    }\n    return class_name\
    \ + \".\" + extensions[cap - sm];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp7lc8fzi0: /tmp/tmp7lc8fzi0.cpp:29: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123321
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension;\n    int cap = 0;\n    int sm = 0;\n   \
    \ for(auto &extension : extensions){\n        cap += extension.size()-1;\n   \
    \     sm += extension.size()-1;\n    }\n    \n    float strength = cap - sm;\n\
    \    \n    for(auto &extension : extensions){\n        if(extension == class_name){\n\
    \            strongest_extension = class_name;\n            break;\n        }\n\
    \        if(strength > 0){\n            if(extension.find(class_name) != std::string::npos){\n\
    \                strongest_extension = class_name + extension;\n             \
    \   break;\n            }\n        }\n        else{\n            if(extension.find(class_name)\
    \ != std::string::npos){\n                strongest_extension = class_name + extension;\n\
    \                break;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp4of3pxn8: /tmp/tmp4of3pxn8.cpp:53: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        cap += (extension.size()-1);\n        sm\
    \ += (extension.size()-1);\n    }\n    float strength = cap - sm;\n    if (strength\
    \ > 0) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    for (int i = 1; i < extensions.size(); i++) {\n        if (strength\
    \ > 0) {\n            strongest_extension = class_name + \".\" + extensions[i];\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpatxm_mfo: /tmp/tmpatxm_mfo.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    std::string extension_strength = \"\";\n  \
    \  int cap = 0;\n    int sm = 0;\n    for(auto &extension : extensions){\n   \
    \     cap += extension.size()-1;\n        sm += extension.size()-1;\n    }\n \
    \   extension_strength = cap - sm;\n    for(auto &extension : extensions){\n \
    \       if(extension_strength == extension.size()-1){\n            strongest_extension\
    \ = class_name + extension;\n            break;\n        }\n    }\n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpvc749_1o.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpvc749_1o.cpp:30:31:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019})\n   30 |         if(extension_strength\
    \ == extension.size()-1){\n      |            ~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~~~\n\
    \      |            |                                     |\n      |         \
    \   |                                     std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned int}\n      |            std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvc749_1o.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvc749_1o.cpp:30:51:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   30\
    \ |         if(extension_strength == extension.size()-1){\n      |           \
    \                                        ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvc749_1o.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 109"
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n   \
    \ }\n    cap = cap - sm;\n    if (cap > 0) {\n        strongest_extension = class_name\
    \ + extensions[0];\n    }\n    for (auto &ext : extensions) {\n        if (ext.size()\
    \ == cap) {\n            strongest_extension = class_name + ext;\n        }\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpeu73vck4: /tmp/tmpeu73vck4.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    double strength = cap_num - sm_num;\n\
    \    double max_strength = -1;\n    for (auto &ext : extensions) {\n        double\
    \ cur_strength = ext.length() - 1;\n        if (cur_strength > max_strength) {\n\
    \            max_strength = cur_strength;\n        }\n    }\n    if (max_strength\
    \ == -1) {\n        return class_name;\n    }\n    std::string res = class_name\
    \ + \".\";\n    for (auto &ext : extensions) {\n        if (ext.length() == max_strength)\
    \ {\n            res += ext;\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpflkfc41n: /tmp/tmpflkfc41n.cpp:45: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = class_name;\n    int cap = class_name.size();\n\
    \    int sm = class_name.size();\n    \n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        cap = cap - extensions[i].size();\n        sm = sm - extensions[i].size();\n\
    \    }\n    \n    if (cap == sm) {\n        for (int i = 0; i < extensions.size();\
    \ i++) {\n            if (cap > sm) {\n                strongest_extension = strongest_extension\
    \ + extensions[i] + \".\";\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp527_2pyk: /tmp/tmp527_2pyk.cpp:41: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    cap = cap / 2;\n    sm = sm / 2;\n    if (cap - sm > 0)\n        strongest_extension\
    \ = class_name + extensions[0];\n    else if (sm - cap > 0)\n        strongest_extension\
    \ = class_name + extensions[1];\n    else\n        strongest_extension = class_name\
    \ + extensions[2];\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmph6ahtzzp: /tmp/tmph6ahtzzp.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap_num = 0, sm_num = 0;\n    for (auto &ext : extensions) {\n        if (ext.size()\
    \ >= cap_num && ext.size() <= sm_num) {\n            cap_num = ext.size();\n \
    \           sm_num = ext.size();\n        }\n    }\n    double strength = cap_num\
    \ - sm_num;\n    if (strength == 0)\n        return class_name;\n    double max_strength\
    \ = -1;\n    for (auto &ext : extensions) {\n        if (ext.size() >= cap_num\
    \ && ext.size() <= sm_num) {\n            if (strength > max_strength) {\n   \
    \             max_strength = strength;\n            }\n        }\n    }\n    return\
    \ class_name + \".\" + extensions[max_strength];\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpq76he54p: /tmp/tmpq76he54p.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    for(auto e : extensions){\n        cap += e.size();\n        sm += e.size();\n\
    \    }\n    float strength = cap - sm;\n    \n    for(auto e : extensions){\n\
    \        if(e.size() == cap){\n            strongest_extension += class_name +\
    \ e;\n        }\n        else if(e.size() == sm){\n            strongest_extension\
    \ += class_name + e;\n        }\n        else if(e.size() > cap && e.size() >\
    \ sm){\n            strongest_extension += class_name + e;\n        }\n      \
    \  else if(e.size() < cap && e.size() < sm){\n            strongest_extension\
    \ += e;\n        }\n        else if(e.size() == cap && e.size() == sm){\n    \
    \        strongest_extension += e;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpn7d_9hvg: /tmp/tmpn7d_9hvg.cpp:51: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap = class_name.size();\n    int sm = class_name.size();\n\
    \    for(int i = 0; i < extensions.size(); i++){\n        cap = cap - extensions[i].size();\n\
    \        sm = sm - extensions[i].size();\n    }\n    float strength = cap - sm;\n\
    \    for(int i = 0; i < extensions.size(); i++){\n        if(strength > 0){\n\
    \            strength = strength - extensions[i].size();\n        }\n    }\n \
    \   strongest_extension = class_name + extensions[extensions.size()-1];\n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpho8ctlcy: /tmp/tmpho8ctlcy.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (strength > 0) {\n            strongest_extension = class_name\
    \ + \".\" + extensions[i];\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp80n8ajis: /tmp/tmp80n8ajis.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    std::string extension_strength = \"\";\n  \
    \  std::string extension_class = \"\";\n    for (auto &extension : extensions)\
    \ {\n        extension_class = extension;\n        extension_strength = extension_class.substr(0,\
    \ extension_class.find_first_of('.'));\n        if (extension_strength.find_first_of('a')\
    \ == std::string::npos) {\n            strongest_extension = class_name + \".\"\
    \ + extension;\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp5mtoqk4e: /tmp/tmp5mtoqk4e.cpp:35: int main(): Assertion `candidate(("Boku123"),
    (std::vector<std::string>({"nani", "NazeDa", "YEs.WeCaNe", "32145tggg"}))) ==
    ("Boku123.YEs.WeCaNe")'' failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = class_name;\n    int cap_counter = 0;\n    int sml_counter = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap_counter += ext.size();\n        sml_counter\
    \ += ext.size();\n    }\n    double strength = cap_counter - sml_counter;\n  \
    \  if (strength > 0) {\n        auto it = std::min_element(extensions.begin(),\
    \ extensions.end(), \n            [&](const std::string &a, const std::string\
    \ &b) { return a.size() < b.size(); });\n        strongest_extension = class_name\
    \ + \".\" + extensions[it->size()];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpa64kqap6: /tmp/tmpa64kqap6.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(int i = 0; i < extensions.size();\
    \ i++){\n        if(extensions[i].size() == 0){\n            continue;\n     \
    \   }\n        \n        std::string extension = extensions[i];\n        \n  \
    \      for(int j = 0; j < extension.size(); j++){\n            if(extension[j]\
    \ >= 'A' && extension[j] <= 'Z'){\n                extension[j] -= 'A';\n    \
    \        }\n            else if(extension[j] >= 'a' && extension[j] <= 'z'){\n\
    \                extension[j] -= 'a';\n            }\n        }\n        \n  \
    \      std::string extension_str = extension;\n        \n        for(int j = 0;\
    \ j < extension_str.size(); j++){\n            if(extension_str[j] >= 'A' && extension_str[j]\
    \ <= 'Z'){\n                extension_str[j] -= 'A';\n            }\n        \
    \    else if(extension_str[j] >= 'a' && extension_str[j] <= 'z'){\n          \
    \      extension_str[j] -= 'a';\n            }\n        }\n        \n        if(extension_str\
    \ == extension){\n            strongest_extension = class_name + \".\" + extension;\n\
    \            break;\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpygu60b76: /tmp/tmpygu60b76.cpp:60: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        if (ext.size() > cap_num) {\n    \
    \        cap_num = ext.size();\n        }\n        if (ext.size() > sm_num) {\n\
    \            sm_num = ext.size();\n        }\n    }\n    int cap_strength = cap_num\
    \ - sm_num;\n    if (cap_strength == 0) {\n        return class_name;\n    }\n\
    \    int sm_strength = sm_num - cap_num;\n    if (sm_strength == 0) {\n      \
    \  return class_name;\n    }\n    int strength = cap_strength - sm_strength;\n\
    \    if (strength == 0) {\n        return class_name;\n    }\n    int index =\
    \ -1;\n    for (int i = 0; i < extensions.size(); i++) {\n        if (extensions[i].size()\
    \ == cap_num) {\n            index = i;\n            break;\n        }\n    }\n\
    \    if (index == -1) {\n        return class_name;\n    }\n    return class_name\
    \ + \".\" + extensions[index];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpkup298hx: /tmp/tmpkup298hx.cpp:54: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    cap = cap / extensions.size();\n    sm = sm / extensions.size();\n\
    \    if (cap - sm > 0) strongest_extension = class_name + extensions[0];\n   \
    \ else if (sm - cap > 0) strongest_extension = class_name + extensions[1];\n \
    \   else strongest_extension = class_name + extensions[2];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpr62or3m2: /tmp/tmpr62or3m2.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext : extensions)\
    \ {\n        cap += ext.size();\n        sm += ext.size();\n    }\n    cap = cap\
    \ / extensions.size();\n    sm = sm / extensions.size();\n    if (cap - sm > 0)\
    \ strongest_extension = class_name + \".\" + extensions[0];\n    for (int i =\
    \ 1; i < extensions.size(); i++) {\n        if (cap - sm > 0) strongest_extension\
    \ = class_name + \".\" + extensions[i];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpcv_ve4ke: /tmp/tmpcv_ve4ke.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.size() == strongest_extension.size()) {\n            if (strength\
    \ > 0) {\n                strongest_extension = class_name + \".\" + ext;\n  \
    \          }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpr328fvvy: /tmp/tmpr328fvvy.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123324
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    for(auto &ext : extensions) {\n  \
    \      if(ext.size() == cap) {\n            strongest_extension = class_name +\
    \ ext;\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n \
    \   auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"),\
    \ (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpgh_zrujl: /tmp/tmpgh_zrujl.cpp:37: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    cap = cap / 2;\n    sm = sm / 2;\n    if (cap - sm > 0)\n        strongest_extension\
    \ = class_name + extensions[0];\n    else\n        strongest_extension = class_name\
    \ + extensions[1];\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpkbnq50_n: /tmp/tmpkbnq50_n.cpp:37: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123326
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (int\
    \ i = 0; i < extensions.size(); i++) {\n        if (extensions[i].at(0) == class_name[0])\
    \ {\n            cap = cap + 1;\n        }\n        if (extensions[i].at(1) ==\
    \ class_name[0]) {\n            sm = sm + 1;\n        }\n    }\n    if (cap -\
    \ sm > 1) {\n        for (int i = 0; i < extensions.size(); i++) {\n         \
    \   if (extensions[i].at(0) == class_name[0]) {\n                cap = cap - 1;\n\
    \            }\n            if (extensions[i].at(1) == class_name[0]) {\n    \
    \            sm = sm - 1;\n            }\n        }\n    }\n    strongest_extension\
    \ = class_name + \".\" + extensions[cap - sm];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp7ds8a20w: /tmp/tmp7ds8a20w.cpp:46: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    for(auto &ext : extensions){\n        cap += ext.length();\n        sm +=\
    \ ext.length()-1;\n    }\n    \n    float strength = cap - sm;\n    \n    for(auto\
    \ &ext : extensions){\n        if(ext.length() == cap){\n            strongest_extension\
    \ = class_name + ext;\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp5oefn1sa: /tmp/tmp5oefn1sa.cpp:41: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sml_num = 0;\n\
    \    for (auto &ext : extensions) {\n        if (ext.size() > cap_num) cap_num\
    \ = ext.size();\n        if (ext.size() < sml_num) sml_num = ext.size();\n   \
    \ }\n    double strength = cap_num - sml_num;\n    if (strength == 0) return class_name;\n\
    \    else return class_name + \".\" + extensions[extensions.size() - 1];\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmph4x5g75k: /tmp/tmph4x5g75k.cpp:31: int main(): Assertion `candidate(("Boku123"),
    (std::vector<std::string>({"nani", "NazeDa", "YEs.WeCaNe", "32145tggg"}))) ==
    ("Boku123.YEs.WeCaNe")'' failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == strongest_extension.length()) {\n           \
    \ if (ext.compare(strongest_extension) == 0) {\n                strongest_extension\
    \ = class_name + \".\" + ext;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpor99vklo: /tmp/tmpor99vklo.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    for(auto &ext : extensions) {\n  \
    \      if(ext.length() == strongest_extension.length()) {\n            if(strength\
    \ > ext.length()) {\n                strongest_extension = ext;\n            }\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpm26tn5y4: /tmp/tmpm26tn5y4.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123327
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &ext\
    \ : extensions) {\n        if (ext.length() > cap_counter) {\n            cap_counter\
    \ = ext.length();\n        }\n        if (ext.length() > sm_counter) {\n     \
    \       sm_counter = ext.length();\n        }\n    }\n    int strength = cap_counter\
    \ - sm_counter;\n    for (auto &ext : extensions) {\n        if (ext.length()\
    \ == cap_counter) {\n            if (ext.compare(0, cap_counter, class_name.cbegin(),\
    \ cap_counter) == 0) {\n                strongest_extension = class_name + ext;\n\
    \                break;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpeci2vecg.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpeci2vecg.cpp:33:77:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::compare(int,\
    \ int&, std::__cxx11::basic_string<char>::const_iterator, int&)\u2019\n   33 |\
    \             if (ext.compare(0, cap_counter, class_name.cbegin(), cap_counter)\
    \ == 0) {\n      |                                                           \
    \                  ^\nIn file included from /usr/include/c++/9/string:55,\n  \
    \               from /usr/include/c++/9/bits/locale_classes.h:40,\n          \
    \       from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpeci2vecg.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note: candidate: \u2018int std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::compare(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) const [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2857\
    \ |       compare(const basic_string& __str) const\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2857:7:\
    \ note:   candidate expects 1 argument, 4 provided\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note: candidate: \u2018template<class _Tp> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::_If_sv<_Tp, int> std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::compare(const _Tp&) const [with _Tp = _Tp; _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\n 2877 |  compare(const\
    \ _Tp& __svt) const\n      |  ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2877:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpeci2vecg.cpp:33:77:\
    \ n"
  stdout: ''
  timestamp: 1660123327
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for(auto extension : extensions) {\n        cap_counter++;\n       \
    \ for(auto c : extension) {\n            sm_counter++;\n        }\n    }\n   \
    \ float strength = cap_counter - sm_counter;\n    for(auto extension : extensions)\
    \ {\n        if(strength > 0) {\n            if(extension == class_name) {\n \
    \               strongest_extension = class_name;\n                break;\n  \
    \          }\n            if(extension.find(class_name) != std::string::npos)\
    \ {\n                strongest_extension = class_name + \".\" + extension;\n \
    \               break;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpvg_euy58: /tmp/tmpvg_euy58.cpp:46: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123328
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (int\
    \ i = 0; i < extensions.size(); i++) {\n        if (extensions[i].size() > 0)\
    \ {\n            cap += (extensions[i].at(0) - 'A');\n            sm += (extensions[i].at(1)\
    \ - 'a');\n        }\n    }\n    if (cap - sm > 0)\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    else if (cap - sm == 0)\n       \
    \ strongest_extension = class_name + \".\" + extensions[0];\n    else\n      \
    \  strongest_extension = class_name + \".\" + extensions[1];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp2r8wr4by: /tmp/tmp2r8wr4by.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123328
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    std::string extension_strength = \"\";\n  \
    \  int cap = 0;\n    int sm = 0;\n    for (auto &extension : extensions) {\n \
    \       cap += extension.at(0) - 'A';\n        sm += extension.at(1) - 'a';\n\
    \    }\n    extension_strength = cap - sm;\n    if (extension_strength == 0) return\
    \ class_name;\n    if (extension_strength == 1) return class_name + extensions[0];\n\
    \    if (extension_strength == 2) return class_name + extensions[0];\n    if (extension_strength\
    \ == 3) return class_name + extensions[0];\n    if (extension_strength == 4) return\
    \ class_name + extensions[0];\n    if (extension_strength == 5) return class_name\
    \ + extensions[0];\n    if (extension_strength == 6) return class_name + extensions[0];\n\
    \    if (extension_strength == 7) return class_name + extensions[0];\n    if (extension_strength\
    \ == 8) return class_name + extensions[0];\n    if (extension_strength == 9) return\
    \ class_name + extensions[0];\n    if (extension_strength == 10) return class_name\
    \ + extensions[0];\n    if (extension_strength == 11) return class_name + extensions[0];\n\
    \    if (extension_strength == 12) return class_name + extensions[0];\n    if\
    \ (extension_strength == 13) return class_name + extensions[0];\n    if (extension_strength\
    \ == 14) return class_name + extensions[0];\n    if (extension_strength == 15)\
    \ return class_name + extensions[0];\n    if (extension_strength == 16) return\
    \ class_name + extensions[0];\n    if (extension_strength == 17) return class_name\
    \ + extensions[0];\n    if (extension_strength == 18) return class_name + extensions[0];\n\
    \    if (extension_strength == 19) return class_name + extensions[0];\n    if\
    \ (extension_strength == 20) return class_name + extensions[0];\n    if (extension_strength\
    \ == 21) return class_name + extensions[0];\n    if (extension_strength == 22)\
    \ return class_name + extensions[0];\n    if (extension_strength == 23) return\
    \ class_name + extensions[0];\n    if (extension_strength == 24) return class_name\
    \ + extensions[0];\n    if (extension_strength == 25) return class_name + extensions[0];\n\
    \    if (extension_strength == 26) return class_name + extensions[0];\n    if\
    \ (extension_strength == 27) return class_name + extensions[0];\n    if (extension_strength\
    \ == 28) return class_name + extensions[0];\n    if (extension_strength == 29)\
    \ return class_name + extensions[0];\n    if (extension_strength == 30) return\
    \ class_name + extensions[0];\n    if (extension_strength == 31) return class_name\
    \ + extensions[0];\n    if (extension_strength == 32) return class_name + extensions[0];\n\
    \    if (extension_strength == 33) return class_name + extensions[0];\n    if\
    \ (extension_strength == 34) return class_name + extensions[0];\n    if (extension_strength\
    \ == 35) return class_name + extensions[0];\n    if (extension_strength == 36)\
    \ return class_name + extensions[0];\n    if (extension_strength == 37) return\
    \ class_name + extensions[0];\n    if (extension\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpur3jwy3b.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpur3jwy3b.cpp:29:28:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} and \u2018int\u2019)\n  \
    \ 29 |     if (extension_strength == 0) return class_name;\n      |         ~~~~~~~~~~~~~~~~~~\
    \ ^~ ~\n      |         |                     |\n      |         |           \
    \          int\n      |         std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpur3jwy3b.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpur3jwy3b.cpp:29:31:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   29\
    \ |     if (extension_strength == 0) return class_name;\n      |             \
    \                  ^\nIn file included from /usr/include/c++/9/regex:62,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n \
    \                from /tmp/tmpur3jwy3b.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpur3jwy3b"
  stdout: ''
  timestamp: 1660123328
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    double strongest_extension_strength = -1;\n    for\
    \ (auto extension : extensions) {\n        double extension_strength = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {\n            return std::toupper(c) - std::tolower(c)\
    \ == 0;\n        }) / extension.size();\n        if (extension_strength > strongest_extension_strength)\
    \ {\n            strongest_extension_strength = extension_strength;\n        \
    \    strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpyfqdahzf: /tmp/tmpyfqdahzf.cpp:35: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123328
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for\
    \ (auto &extension : extensions) {\n        cap += std::toupper(extension[0])\
    \ - std::toupper(extension[1]);\n        sm += std::tolower(extension[0]) - std::tolower(extension[1]);\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ += \".\";\n    }\n    strongest_extension += extensions[0];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpe9s23j5l: /tmp/tmpe9s23j5l.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ e : extensions) {\n        if (e == class_name[0]) {\n            cap++;\n \
    \       }\n        if (e == class_name[class_name.size() - 1]) {\n           \
    \ sm++;\n        }\n    }\n    if (cap - sm > 0)\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    else if (cap - sm == 0)\n       \
    \ strongest_extension = class_name + \".\" + extensions[0];\n    else\n      \
    \  strongest_extension = class_name + \".\" + extensions[1];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpalxt2tfl.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpalxt2tfl.cpp:24:15:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |         if (e == class_name[0]) {\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpalxt2tfl.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpalxt2tfl.cpp:24:30:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   24 |         if (e == class_name[0])\
    \ {\n      |                              ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpalxt2tfl.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpalxt2tfl.cpp:24:30: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |         if ("
  stdout: ''
  timestamp: 1660123328
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == strongest_extension.length()) {\n           \
    \ if (ext.compare(0, strongest_extension.length(), strongest_extension) == 0)\
    \ {\n                strongest_extension = class_name + \".\" + ext;\n       \
    \     }\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpblojg137: /tmp/tmpblojg137.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123323
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension;\n    int cap = 0;\n    int sm = 0;\n   \
    \ \n    for (auto ext : extensions) {\n        cap += ext.length();\n        sm\
    \ += ext.length();\n    }\n    \n    if (cap - sm == 0) {\n        strongest_extension\
    \ = class_name;\n    }\n    else {\n        float strength = cap - sm;\n     \
    \   \n        for (auto ext : extensions) {\n            float ext_cap = ext.length();\n\
    \            float ext_sm = ext.length();\n            \n            if (ext_cap\
    \ - ext_sm == 0) {\n                strongest_extension = class_name + \".\" +\
    \ ext;\n                break;\n            }\n            \n            ext_cap\
    \ -= ext_sm;\n            ext_sm -= ext_cap;\n            \n            if (ext_cap\
    \ > ext_sm) {\n                strongest_extension = class_name + \".\" + ext;\n\
    \                break;\n            }\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpf7wnswjd: /tmp/tmpf7wnswjd.cpp:59: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    std::string extension_str;\n    int extension_strength_counter = 0;\n   \
    \ int extension_counter_counter = 0;\n    for (auto &extension : extensions) {\n\
    \        if (extension_strength_counter == 0) {\n            extension_strength\
    \ = extension;\n            extension_strength_counter = 1;\n        }\n     \
    \   else if (extension_strength_counter == 1) {\n            if (extension_strength_counter\
    \ > extension_strength_counter) {\n                extension_strength = extension;\n\
    \                extension_strength_counter = 1;\n            }\n            else\
    \ {\n                extension_strength = extension;\n                extension_strength_counter++;\n\
    \            }\n        }\n        else if (extension_strength_counter == 2) {\n\
    \            if (extension_strength_counter > extension_strength_counter) {\n\
    \                extension_strength = extension;\n                extension_strength_counter\
    \ = 1;\n            }\n            else {\n                extension_strength\
    \ = extension;\n                extension_strength_counter++;\n            }\n\
    \        }\n        else if (extension_strength_counter == 3) {\n            if\
    \ (extension_strength_counter > extension_strength_counter) {\n              \
    \  extension_strength = extension;\n                extension_strength_counter\
    \ = 1;\n            }\n            else {\n                extension_strength\
    \ = extension;\n                extension_strength_counter++;\n            }\n\
    \        }\n        else if (extension_strength_counter == 4) {\n            if\
    \ (extension_strength_counter > extension_strength_counter) {\n              \
    \  extension_strength = extension;\n                extension_strength_counter\
    \ = 1;\n            }\n            else {\n                extension_strength\
    \ = extension;\n                extension_strength_counter++;\n            }\n\
    \        }\n        else if (extension_strength_counter == 5) {\n            if\
    \ (extension_strength_counter > extension_strength_counter) {\n              \
    \  extension_strength = extension;\n                extension_strength_counter\
    \ = 1;\n            }\n            else {\n                extension_strength\
    \ = extension;\n                extension_strength_counter++;\n            }\n\
    \        }\n        else if (extension_strength_counter == 6) {\n            if\
    \ (extension_strength_counter > extension_strength_counter) {\n              \
    \  extension_strength = extension;\n                extension_strength_counter\
    \ = 1;\n            }\n            else {\n                extension_strength\
    \ = extension;\n                extension_strength_counter++;\n            }\n\
    \        }\n        else if (extension_strength_counter == 7) {\n            if\
    \ (extension_strength_counter > extension_strength_counter) {\n              \
    \  extension_strength = extension;\n                extension_strength_counter\
    \ = 1;\n            }\n            else {\n                extension_strength\
    \ = extension;\n                extension_strength_counter++;\n            }\n\
    \        }\n        else if (extension_strength_counter == 8) {\n\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpsfzwnixn.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpsfzwnixn.cpp:101:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  101 | int main() {\n      |            ^\n/tmp/tmpsfzwnixn.cpp:112:1: error:\
    \ expected \u2018}\u2019 at end of input\n  112 | }\n      | ^\n/tmp/tmpsfzwnixn.cpp:23:40:\
    \ note: to match this \u2018{\u2019\n   23 |     for (auto &extension : extensions)\
    \ {\n      |                                        ^\n/tmp/tmpsfzwnixn.cpp:112:1:\
    \ error: expected \u2018}\u2019 at end of input\n  112 | }\n      | ^\n/tmp/tmpsfzwnixn.cpp:18:94:\
    \ note: to match this \u2018{\u2019\n   18 | std::string Strongest_Extension(std::string\
    \ class_name, std::vector<std::string> extensions) {\n      |                \
    \                                                                            \
    \  ^\n/tmp/tmpsfzwnixn.cpp:112:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  112 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660123328
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    \n    for\
    \ (auto &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    \n    float strength = cap - sm;\n    \n    if (strength > 0) {\n\
    \        for (auto &ext : extensions) {\n            if (ext.size() == strength)\
    \ {\n                strongest_extension = class_name + ext;\n               \
    \ break;\n            }\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp2y3ic1jo: /tmp/tmp2y3ic1jo.cpp:45: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for\
    \ (auto &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ += \".\";\n    }\n    strongest_extension += extensions[0];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpo5lqel3j: /tmp/tmpo5lqel3j.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for\
    \ (auto &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ += \".\";\n    }\n    strongest_extension += extensions[0];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpb_uogn2c: /tmp/tmpb_uogn2c.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123320
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for(auto &extension : extensions) {\n        if(extension == class_name[0])\
    \ {\n            cap_counter++;\n        }\n        if(extension == class_name[class_name.length()-1])\
    \ {\n            sm_counter++;\n        }\n    }\n    float strength = cap_counter\
    \ - sm_counter;\n    \n    if(strength > 0) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    else if(strength < 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[extensions.size()-1];\n    }\n    else {\n\
    \        strongest_extension = class_name;\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpontx6g_p.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpontx6g_p.cpp:24:22:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |         if(extension == class_name[0]) {\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpontx6g_p.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpontx6g_p.cpp:24:37:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   24 |         if(extension ==\
    \ class_name[0]) {\n      |                                     ^\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpontx6g_p.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpontx6g_p.cpp:24:37: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}"
  stdout: ''
  timestamp: 1660123328
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for\
    \ (int i = 0; i < extensions.size(); i++) {\n        if (extensions[i].size()\
    \ > cap) {\n            cap = extensions[i].size();\n        }\n        if (extensions[i].size()\
    \ < sm) {\n            sm = extensions[i].size();\n        }\n    }\n    float\
    \ strength = cap - sm;\n    for (int i = 0; i < extensions.size(); i++) {\n  \
    \      if (extensions[i].size() == cap) {\n            strongest_extension +=\
    \ \".\" + extensions[i];\n        }\n        if (extensions[i].size() == sm) {\n\
    \            strongest_extension += \".\" + extensions[i];\n        }\n    }\n\
    \    if (strongest_extension.find(\".\")!= std::string::npos) {\n        strongest_extension\
    \ = strongest_extension.substr(0, strongest_extension.find(\".\"));\n    }\n \
    \   return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp7v04bvqe: /tmp/tmp7v04bvqe.cpp:47: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    for(auto &ext : extensions) {\n  \
    \      if(ext.length() == strongest_extension.length()) {\n            if(ext.length()\
    \ < strongest_extension.length()) {\n                strongest_extension = ext;\n\
    \            }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmprss5vi4m: /tmp/tmprss5vi4m.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = 0;\n    int sm = 0;\n    for\
    \ (auto &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        for (auto\
    \ &ext : extensions) {\n            if (ext.size() == strength) {\n          \
    \      strongest_extension += \".\" + ext;\n            }\n        }\n    }\n\
    \    return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp3hbd5xue: /tmp/tmp3hbd5xue.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap_num = 0, sm_num = 0;\n    for (auto &ext : extensions) {\n        cap_num\
    \ += ext.length();\n        sm_num += ext.length() - 1;\n    }\n    double strength\
    \ = cap_num - sm_num;\n    double max_strength = -1;\n    for (auto &ext : extensions)\
    \ {\n        double ext_strength = ext.length();\n        if (ext_strength > max_strength)\
    \ {\n            max_strength = ext_strength;\n        }\n    }\n    std::string\
    \ result = class_name;\n    for (auto &ext : extensions) {\n        if (ext.length()\
    \ == max_strength) {\n            result += ext;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpn2tnjfmh: /tmp/tmpn2tnjfmh.cpp:43: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension;\n    \n    int cap_counter = 0;\n    int\
    \ sm_counter = 0;\n    \n    for (auto &extension : extensions) {\n        cap_counter\
    \ += std::toupper(extension[0]) - std::toupper(extension[1]);\n        sm_counter\
    \ += std::tolower(extension[0]) - std::tolower(extension[1]);\n    }\n    \n \
    \   if (cap_counter > sm_counter) {\n        strongest_extension = class_name\
    \ + extensions[0];\n    }\n    else {\n        strongest_extension = class_name\
    \ + extensions[1];\n    }\n    \n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpoh2z8i6f: /tmp/tmpoh2z8i6f.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        cap += std::toupper(extension[0]) - std::toupper(extension[1]);\n\
    \        sm += std::tolower(extension[0]) - std::tolower(extension[1]);\n    }\n\
    \    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &extension : extensions)\
    \ {\n        if (strength > 0) {\n            if (strength == std::toupper(extension[0])\
    \ - std::toupper(extension[1])) {\n                strongest_extension = class_name\
    \ + \".\" + extension;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp9rm19egp: /tmp/tmp9rm19egp.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    for (auto &ext : extensions) {\n \
    \       if (ext.length() == strongest_extension.length()) {\n            if (ext.length()\
    \ < strongest_extension.length()) {\n                strongest_extension = ext;\n\
    \            }\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpbkm1nqxm: /tmp/tmpbkm1nqxm.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap = 0;\n    int sm = 0;\n    for (auto &ext : extensions) {\n        cap +=\
    \ ext.size();\n        sm += ext.size();\n    }\n    float strength = cap - sm;\n\
    \    int index = std::distance(extensions.begin(), std::min_element(extensions.begin(),\
    \ extensions.end(), [&](const std::string &a, const std::string &b) { return a.size()\
    \ < b.size(); }));\n    return class_name + \".\" + extensions[index];\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpl8eqwb_y: /tmp/tmpl8eqwb_y.cpp:32: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(int\
    \ i = 0; i < extensions.size(); i++){\n        if(extensions[i].at(0) == class_name[0]){\n\
    \            cap = cap + 1;\n        }\n        if(extensions[i].at(1) == class_name[1]){\n\
    \            sm = sm + 1;\n        }\n    }\n    float strength = cap - sm;\n\
    \    for(int i = 0; i < extensions.size(); i++){\n        if(extensions[i].at(0)\
    \ == class_name[0]){\n            cap = cap - 1;\n        }\n        if(extensions[i].at(1)\
    \ == class_name[1]){\n            sm = sm - 1;\n        }\n    }\n    strength\
    \ = cap - sm;\n    if(strength > 0){\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    else if(strength < 0){\n        strongest_extension\
    \ = class_name + \".\" + extensions[extensions.size() - 1];\n    }\n    else if(strength\
    \ == 0){\n        strongest_extension = class_name;\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpv0xxexho: /tmp/tmpv0xxexho.cpp:54: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() > cap_counter) {\n            cap_counter = ext.length();\n\
    \        }\n        if (ext.length() > sm_counter) {\n            sm_counter =\
    \ ext.length();\n        }\n    }\n    float strength = cap_counter - sm_counter;\n\
    \    if (strength > 0) {\n        extension_strength = class_name + \".\" + extensions[0];\n\
    \    }\n    for (int i = 1; i < extensions.size(); i++) {\n        if (extensions[i].length()\
    \ > cap_counter) {\n            cap_counter = extensions[i].length();\n      \
    \  }\n        if (extensions[i].length() > sm_counter) {\n            sm_counter\
    \ = extensions[i].length();\n        }\n    }\n    float strength_2 = cap_counter\
    \ - sm_counter;\n    if (strength_2 > 0) {\n        extension_strength = class_name\
    \ + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (extensions[i].length() > cap_counter) {\n            cap_counter\
    \ = extensions[i].length();\n        }\n        if (extensions[i].length() > sm_counter)\
    \ {\n            sm_counter = extensions[i].length();\n        }\n    }\n    float\
    \ strength_3 = cap_counter - sm_counter;\n    if (strength_3 > 0) {\n        extension_strength\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (extensions[i].length() > cap_counter) {\n            cap_counter\
    \ = extensions[i].length();\n        }\n        if (extensions[i].length() > sm_counter)\
    \ {\n            sm_counter = extensions[i].length();\n        }\n    }\n    float\
    \ strength_4 = cap_counter - sm_counter;\n    if (strength_4 > 0) {\n        extension_strength\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (extensions[i].length() > cap_counter) {\n            cap_counter\
    \ = extensions[i].length();\n        }\n        if (extensions[i].length() > sm_counter)\
    \ {\n            sm_counter = extensions[i].length();\n        }\n    }\n    float\
    \ strength_5 = cap_counter - sm_counter;\n    if (strength_5 > 0) {\n        extension_strength\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (extensions[i].length() > cap_counter) {\n            cap_counter\
    \ = extensions[i].length();\n        }\n        if (extensions[i].length() > sm_counter)\
    \ {\n            sm_counter = extensions[i].length();\n        }\n    }\n    float\
    \ strength_6 = cap_counter - sm_counter;\n    if (strength_6 > 0) {\n        extension\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpi9vpoq82.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpi9vpoq82.cpp:92:9:\
    \ error: \u2018extension\u2019 was not declared in this scope; did you mean \u2018\
    extensions\u2019?\n   92 |         extension\n      |         ^~~~~~~~~\n    \
    \  |         extensions\n/tmp/tmpi9vpoq82.cpp:94:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   94 | int main() {\n     \
    \ |            ^\n/tmp/tmpi9vpoq82.cpp:105:1: error: expected \u2018}\u2019 at\
    \ end of input\n  105 | }\n      | ^\n/tmp/tmpi9vpoq82.cpp:18:94: note: to match\
    \ this \u2018{\u2019\n   18 | std::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n      |                            \
    \                                                                  ^\n/tmp/tmpi9vpoq82.cpp:105:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  105 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660123328
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &extension :\
    \ extensions) {\n        if (extension.at(0) == class_name[0]) {\n           \
    \ cap_counter++;\n        }\n        if (extension.at(1) == class_name[0]) {\n\
    \            sm_counter++;\n        }\n    }\n    if (cap_counter > sm_counter)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\
    \ else if (cap_counter < sm_counter) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[1];\n    } else {\n        strongest_extension = class_name\
    \ + \".\" + extensions[2];\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::at: __n (which is 1) >= this->size() (which is 1)\n"
  stdout: ''
  timestamp: 1660123329
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap_num = 0, sm_num = 0;\n    for (auto &ext : extensions) {\n        cap_num\
    \ += ext.length();\n        sm_num += ext.length() - 1;\n    }\n    float strength\
    \ = cap_num - sm_num;\n    if (strength == 0) return class_name;\n    else return\
    \ class_name + \".\" + extensions[std::find(extensions.begin(), extensions.end(),\
    \ extensions[std::find(extensions.begin(), extensions.end(), strength)].length())];\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpxw6mniml.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpxw6mniml.cpp:27:105:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019)\n   27 |     else return\
    \ class_name + \".\" + extensions[std::find(extensions.begin(), extensions.end(),\
    \ extensions[std::find(extensions.begin(), extensions.end(), strength)].length())];\n\
    \      |                                                                     \
    \                                    ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxw6mniml.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1040:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::reference = std::__cxx11::basic_string<char>&; std::vector<_Tp, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1040 |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1040:28: note: \
    \  no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::size_type\u2019 {aka \u2018long unsigned int\u2019}\n 1040 |       operator[](size_type\
    \ __n) _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1058:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::cons"
  stdout: ''
  timestamp: 1660123328
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_num = 0, sml_num = 0;\n    for (auto\
    \ &ext : extensions) {\n        if (ext.length() > cap_num) {\n            cap_num\
    \ = ext.length();\n        }\n        if (ext.length() > sml_num) {\n        \
    \    sml_num = ext.length();\n        }\n    }\n    float strength = cap_num -\
    \ sml_num;\n    if (strength > 0) {\n        strongest_extension = class_name\
    \ + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (strength > 0) {\n            strongest_extension = class_name\
    \ + \".\" + extensions[i];\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp8bazxd8g: /tmp/tmp8bazxd8g.cpp:43: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for(auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    cap = cap - sm;\n    for(auto &ext : extensions) {\n        if(ext.length()\
    \ == cap) {\n            strongest_extension = class_name + ext;\n           \
    \ break;\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpr62_ao19: /tmp/tmpr62_ao19.cpp:38: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    int\
    \ cap = class_name.size();\n    int sm = extensions.size();\n    int strength\
    \ = cap - sm;\n    int max = 0;\n    int index = 0;\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        if (extensions[i].size() == cap) {\n            int count =\
    \ 0;\n            for (int j = 0; j < extensions[i].size(); j++) {\n         \
    \       if (extensions[i][j] == class_name[i]) {\n                    count++;\n\
    \                }\n            }\n            if (count > max) {\n          \
    \      max = count;\n                index = i;\n            }\n        }\n  \
    \  }\n    if (max > 1) {\n        for (int i = 0; i < extensions.size(); i++)\
    \ {\n            if (extensions[i].size() == cap) {\n                int count\
    \ = 0;\n                for (int j = 0; j < extensions[i].size(); j++) {\n   \
    \                 if (extensions[i][j] == class_name[i]) {\n                 \
    \       count++;\n                    }\n                }\n                if\
    \ (count > max) {\n                    max = count;\n                    index\
    \ = i;\n                }\n            }\n        }\n    }\n    return class_name\
    \ + \".\" + extensions[index];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpkryvz2qp: /tmp/tmpkryvz2qp.cpp:59: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    cap = cap - sm;\n    if (cap > 0) {\n        strongest_extension =\
    \ class_name + \".\" + extensions[0];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpl5ssatsh: /tmp/tmpl5ssatsh.cpp:35: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    float strength = cap_num - sm_num;\n\
    \    int strongest_ext = 0;\n    for (auto &ext : extensions) {\n        if (ext.length()\
    \ == strength) {\n            strongest_ext = ext.length();\n            break;\n\
    \        }\n    }\n    return class_name + \".\" + extensions[strongest_ext];\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp4n6vwp5_: /tmp/tmp4n6vwp5_.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    for(auto &ext : extensions){\n        cap += ext.length();\n        sm +=\
    \ ext.length();\n    }\n    \n    float strength = cap - sm;\n    \n    for(auto\
    \ &ext : extensions){\n        if(ext.length() == cap){\n            strongest_extension\
    \ = class_name + ext;\n            break;\n        }\n    }\n    \n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpbkq8y84n: /tmp/tmpbkq8y84n.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string extension_strength;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto &ext : extensions)\
    \ {\n        if (ext.size() > cap_counter) {\n            cap_counter = ext.size();\n\
    \        }\n        if (ext.size() > sm_counter) {\n            sm_counter = ext.size();\n\
    \        }\n    }\n    extension_strength = class_name + \".\";\n    for (int\
    \ i = 0; i < cap_counter; i++) {\n        extension_strength += extensions[i].substr(0,\
    \ 1).toUpperCase() + extensions[i].substr(1, extensions[i].size() - 1);\n    }\n\
    \    for (int i = 0; i < sm_counter; i++) {\n        extension_strength += extensions[i].substr(0,\
    \ 1).toLowerCase() + extensions[i].substr(1, extensions[i].size() - 1);\n    }\n\
    \    return extension_strength;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmphiyhnegn.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmphiyhnegn.cpp:32:58:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toUpperCase\u2019\n   32 |         extension_strength += extensions[i].substr(0,\
    \ 1).toUpperCase() + extensions[i].substr(1, extensions[i].size() - 1);\n    \
    \  |                                                          ^~~~~~~~~~~\n/tmp/tmphiyhnegn.cpp:35:58:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toLowerCase\u2019\n   35 |         extension_strength += extensions[i].substr(0,\
    \ 1).toLowerCase() + extensions[i].substr(1, extensions[i].size() - 1);\n    \
    \  |                                                          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    \n    // Write your code here\n\
    \    \n    std::string strongest_extension = \"\";\n    \n    for(auto &extension\
    \ : extensions) {\n        \n        int cap = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {\n            return std::toupper(c) == c;\n  \
    \      });\n        int sm = std::count_if(extension.begin(), extension.end(),\
    \ [](char c) {\n            return std::tolower(c) == c;\n        });\n      \
    \  \n        int strength = cap - sm;\n        \n        if(strength > 0) {\n\
    \            strongest_extension = class_name + \".\" + extension;\n        }\n\
    \    }\n    \n    return strongest_extension;\n}\nint main() {\n    auto candidate\
    \ = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmp26ol4ml1: /tmp/tmp26ol4ml1.cpp:46: int main(): Assertion `candidate(("__YESIMHERE"),
    (std::vector<std::string>({"t", "eMptY", "nothing", "zeR00", "NuLl__", "123NoooneB321"})))
    == ("__YESIMHERE.NuLl__")'' failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length()\
    \ - cap;\n    }\n    cap = cap / 2;\n    sm = sm / 2;\n    if (cap - sm > 0)\n\
    \        strongest_extension = class_name + extensions[0];\n    else if (sm -\
    \ cap > 0)\n        strongest_extension = class_name + extensions[1];\n    else\n\
    \        strongest_extension = class_name + extensions[2];\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpgeat7fi7: /tmp/tmpgeat7fi7.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n  \
    \  }\n    int cap = cap_num / CAP;\n    int sm = sm_num / SM;\n    if (cap ==\
    \ sm) {\n        return class_name + extensions[0];\n    }\n    if (cap > sm)\
    \ {\n        return class_name + extensions[cap - 1];\n    }\n    return class_name\
    \ + extensions[sm - 1];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpx6hkff3x.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmpx6hkff3x.cpp:22:78:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::find_first_not_of(std::__cxx11::basic_string<char>::iterator,\
    \ std::__cxx11::basic_string<char>::iterator)\u2019\n   22 |         sm_num +=\
    \ ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n      |     \
    \                                                                         ^\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx6hkff3x.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2673:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) const [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 2673 |       find_first_not_of(const basic_string&\
    \ __str, size_type __pos = 0) const\n      |       ^~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2673:45:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019} to \u2018const std::__cxx11::basic_string<char>&\u2019\n 2673 |   \
    \    find_first_not_of(const basic_string& __str, siz"
  stdout: ''
  timestamp: 1660123329
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    int cap_counter = 0;\n\
    \    int sm_counter = 0;\n    \n    for (auto &extension : extensions) {\n   \
    \     if (extension == class_name[0]) {\n            cap_counter++;\n        }\n\
    \        if (extension == class_name[class_name.length() - 1]) {\n           \
    \ sm_counter++;\n        }\n    }\n    \n    if (cap_counter > sm_counter) {\n\
    \        strongest_extension = class_name + \".\" + extensions[0];\n    }\n  \
    \  else {\n        strongest_extension = class_name + \".\" + extensions[extensions.size()\
    \ - 1];\n    }\n    \n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3fcqvy_v.cpp: In function \u2018std::string Strongest_Extension(std::string,\
    \ std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp3fcqvy_v.cpp:27:23:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   27 |         if (extension == class_name[0]) {\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3fcqvy_v.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp3fcqvy_v.cpp:27:38:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   27 |         if (extension ==\
    \ class_name[0]) {\n      |                                      ^\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3fcqvy_v.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp3fcqvy_v.cpp:27:38: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char"
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    std::string extension;\n    int cap = 0;\n    int\
    \ sm = 0;\n    for(auto &e : extensions){\n        cap += e.size();\n        sm\
    \ += e.size();\n    }\n    float strength = cap - sm;\n    for(auto &e : extensions){\n\
    \        if(e.size() == cap){\n            strongest_extension = class_name +\
    \ e;\n        }\n        if(e.size() == sm){\n            strongest_extension\
    \ = class_name + e;\n        }\n    }\n    return strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpj1g8pil9: /tmp/tmpj1g8pil9.cpp:41: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension;\n    int cap_counter = 0;\n    int sm_counter\
    \ = 0;\n    for(auto &extension : extensions) {\n        if(extension.at(0) ==\
    \ class_name[0]) {\n            cap_counter++;\n        }\n        if(extension.at(1)\
    \ == class_name[0]) {\n            sm_counter++;\n        }\n    }\n    \n   \
    \ double strength = cap_counter - sm_counter;\n    \n    if(strength > 0) {\n\
    \        strongest_extension = class_name + \".\" + extensions[0];\n    }\n  \
    \  else if(strength < 0) {\n        strongest_extension = class_name + \".\" +\
    \ extensions[extensions.size()-1];\n    }\n    else {\n        strongest_extension\
    \ = class_name;\n    }\n    \n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp94fee1_5: /tmp/tmp94fee1_5.cpp:49: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    int index = std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end(), [&](std::string a, std::string\
    \ b) { return a.length() < b.length(); }));\n    if (strength > 0) {\n       \
    \ strongest_extension = class_name + extensions[index];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpqx_63drp: /tmp/tmpqx_63drp.cpp:36: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(int i = 0; i < extensions.size();\
    \ i++){\n        for(int j = 0; j < extensions[i].size(); j++){\n            if(extensions[i][j]\
    \ == class_name[j]){\n                strongest_extension += class_name[j];\n\
    \            }\n        }\n    }\n    \n    return strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpfrgx6pyv: /tmp/tmpfrgx6pyv.cpp:35: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = class_name;\n    int cap = 0;\n    int\
    \ sm = 0;\n    \n    for(int i = 0; i < extensions.size(); i++){\n        if(extensions[i][0]\
    \ >= 'A' && extensions[i][0] <= 'Z'){\n            cap++;\n        }\n       \
    \ if(extensions[i][0] >= 'a' && extensions[i][0] <= 'z'){\n            sm++;\n\
    \        }\n    }\n    \n    float strength = cap - sm;\n    \n    for(int i =\
    \ 0; i < extensions.size(); i++){\n        if(extensions[i][0] >= 'A' && extensions[i][0]\
    \ <= 'Z'){\n            cap--;\n        }\n        if(extensions[i][0] >= 'a'\
    \ && extensions[i][0] <= 'z'){\n            sm--;\n        }\n    }\n    \n  \
    \  if(strength > 0){\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    \n    for(int i = 1; i < extensions.size(); i++){\n        if(strength\
    \ > extensions[i].length()){\n            strongest_extension = class_name + \"\
    .\" + extensions[i];\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpbcpjw0vm: /tmp/tmpbcpjw0vm.cpp:59: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(auto &extension :\
    \ extensions) {\n        \n        auto cap = extension.find_first_of('A');\n\
    \        auto sm = extension.find_first_of('z');\n        \n        auto strength\
    \ = cap - sm;\n        \n        if(strength == 0)\n            strongest_extension\
    \ = extension;\n        else if(strength > 0)\n            strongest_extension\
    \ = class_name + \".\" + extension;\n        else if(strength < 0)\n         \
    \   strongest_extension = class_name + \".\" + extension;\n    }\n    \n    return\
    \ strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpqawr7c3z: /tmp/tmpqawr7c3z.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123329
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(int i = 0; i < extensions.size();\
    \ i++) {\n        std::string extension = extensions[i];\n        \n        int\
    \ cap = extension.find_first_of('A');\n        int sm = extension.find_first_of('z');\n\
    \        \n        int strength = cap - sm;\n        \n        if(strength > 0)\
    \ {\n            strongest_extension += class_name + \".\" + extension;\n    \
    \    }\n    }\n    \n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmp8fzl8i__: /tmp/tmp8fzl8i__.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.size() == strongest_extension.size()) {\n            strongest_extension\
    \ = class_name + \".\" + ext;\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpjg785q7i: /tmp/tmpjg785q7i.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.size();\n        sm += ext.size();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.size() == strongest_extension.size()) {\n            if (ext.size()\
    \ < strongest_extension.size()) {\n                strongest_extension = class_name\
    \ + \".\" + ext;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpsfdud6m5: /tmp/tmpsfdud6m5.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = class_name.size();\n    int sm =\
    \ class_name.size();\n    for (int i = 0; i < extensions.size(); i++) {\n    \
    \    cap = cap - extensions[i].size();\n        sm = sm - extensions[i].size();\n\
    \        if (cap > sm) {\n            strongest_extension = class_name + extensions[i];\n\
    \        }\n    }\n    return strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"\
    K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) ==\
    \ (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
    Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
    YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\"\
    , \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"\
    }))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
    Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
    671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
  status: Exception
  stderr: 'tmpxw9oqz0n: /tmp/tmpxw9oqz0n.cpp:34: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap = class_name.size();\n    int sm = class_name.size();\n\
    \    for (auto &ext : extensions) {\n        cap = cap - ext.size();\n       \
    \ sm = sm - ext.size();\n    }\n    if (cap > sm) {\n        strongest_extension\
    \ = class_name + extensions[0];\n    }\n    else {\n        strongest_extension\
    \ = class_name + extensions[1];\n    }\n    return strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp4ufmw83_: /tmp/tmp4ufmw83_.cpp:37: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_counter = 0;\n    int sm_counter = 0;\n  \
    \  for (auto &extension : extensions) {\n        if (extension.at(0) == class_name.at(0))\
    \ {\n            cap_counter++;\n        }\n        if (extension.at(1) == class_name.at(1)){\n\
    \            sm_counter++;\n        }\n    }\n    float strength = cap_counter\
    \ - sm_counter;\n    if (strength > 0){\n        strongest_extension = class_name\
    \ + extensions[0];\n    }\n    else if (strength < 0){\n        strongest_extension\
    \ = class_name + extensions[extensions.size()-1];\n    }\n    else{\n        strongest_extension\
    \ = class_name + extensions[0];\n    }\n    return strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpbgssygdh: /tmp/tmpbgssygdh.cpp:45: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(auto &extension :\
    \ extensions) {\n        auto cap = std::count_if(extension.begin(), extension.end(),\
    \ [](char c) {\n            return std::toupper(c) == c;\n        });\n      \
    \  auto sm = std::count_if(extension.begin(), extension.end(), [](char c) {\n\
    \            return std::tolower(c) == c;\n        });\n        \n        auto\
    \ strength = cap - sm;\n        \n        if(strength > 0) {\n            strongest_extension\
    \ += class_name + \".\" + extension;\n        }\n    }\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpzwzexw1l: /tmp/tmpzwzexw1l.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - 1;\n    }\n    int strength = cap_num - sm_num;\n \
    \   if (strength == 0) {\n        return class_name;\n    }\n    int max_strength\
    \ = 0;\n    for (auto &ext : extensions) {\n        int cur_strength = ext.length()\
    \ - 1;\n        if (cur_strength > max_strength) {\n            max_strength =\
    \ cur_strength;\n        }\n    }\n    int cur_strength = max_strength;\n    for\
    \ (auto &ext : extensions) {\n        if (cur_strength == ext.length() - 1) {\n\
    \            return class_name + \".\" + ext;\n        }\n        cur_strength--;\n\
    \    }\n    return class_name;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    }))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp9b_i4g26: /tmp/tmp9b_i4g26.cpp:46: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -8
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sml_num = 0;\n\
    \    for (auto &ext : extensions) {\n        cap_num += ext.size();\n        sml_num\
    \ += ext.size();\n    }\n    int cap_den = cap_num - sml_num;\n    int sml_den\
    \ = cap_num - cap_num;\n    int cap_frac = cap_num / cap_den;\n    int sml_frac\
    \ = sml_num / sml_den;\n    int cap_strength = cap_num - cap_den * cap_frac;\n\
    \    int sml_strength = sml_num - sml_den * sml_frac;\n    int strength = cap_strength\
    \ - sml_strength;\n    if (strength > 0) {\n        return class_name + \".\"\
    \ + extensions[0];\n    }\n    return class_name + \".\" + extensions[extensions.size()\
    \ - 1];\n}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n\
    \    \n    for (auto &extension : extensions) {\n        cap += extension.at(0)\
    \ - 'A';\n        sm += extension.at(1) - 'a';\n    }\n    \n    if (cap - sm\
    \ > 0)\n        strongest_extension = class_name + extensions[0];\n    else\n\
    \        strongest_extension = class_name + extensions[1];\n    \n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpxs71kuem: /tmp/tmpxs71kuem.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_num = 0, sm_num = 0;\n    for (auto\
    \ &ext : extensions) {\n        if (ext.size() > cap_num) {\n            cap_num\
    \ = ext.size();\n        }\n        if (ext.size() > sm_num) {\n            sm_num\
    \ = ext.size();\n        }\n    }\n    float cap_frac = cap_num - sm_num;\n  \
    \  if (cap_frac > 0)\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    else if (cap_frac < 0)\n        strongest_extension = class_name + \".\"\
    \ + extensions[extensions.size() - 1];\n    return strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpmh7pywh7: /tmp/tmpmh7pywh7.cpp:39: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = class_name;\n    int cap = class_name.size();\n    int\
    \ sm = class_name.size();\n    for (auto ext : extensions) {\n        cap -= ext.size();\n\
    \        sm -= ext.size();\n        if (cap > sm) {\n            strongest_extension\
    \ = class_name + ext;\n        }\n    }\n    return strongest_extension;\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp61bqs7bu: /tmp/tmp61bqs7bu.cpp:34: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_num = 0, sm_num = 0;\n    for (auto\
    \ &ext : extensions) {\n        if (ext.size() >= cap_num) {\n            cap_num\
    \ = ext.size();\n        }\n        if (ext.size() >= sm_num) {\n            sm_num\
    \ = ext.size();\n        }\n    }\n    float cap_frac = cap_num - sm_num;\n  \
    \  if (cap_frac > 0) {\n        cap_frac = cap_frac / cap_num;\n    }\n    float\
    \ sm_frac = sm_num - cap_num;\n    if (sm_frac > 0) {\n        sm_frac = sm_frac\
    \ / sm_num;\n    }\n    float strength = cap_frac - sm_frac;\n    if (strength\
    \ > 0) {\n        strength = strength / cap_num;\n    }\n    strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    for (auto &ext : extensions) {\n\
    \        if (ext.size() == cap_num) {\n            if (strength > 0) {\n     \
    \           strongest_extension = class_name + \".\" + ext;\n            }\n \
    \       }\n        if (ext.size() == sm_num) {\n            if (strength > 0)\
    \ {\n                strongest_extension = class_name + \".\" + ext;\n       \
    \     }\n        }\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n\
    \    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
    eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\"\
    , \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"\
    ), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"\
    __HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpri65hb2z: /tmp/tmpri65hb2z.cpp:59: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n        if (strength > 0) {\n            strongest_extension = class_name\
    \ + \".\" + extensions[i];\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmp532lsblc: /tmp/tmp532lsblc.cpp:40: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA',\
    \ 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap = 0;\n    int sm = 0;\n    for (auto &ext\
    \ : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    for (auto &ext : extensions)\
    \ {\n        if (ext.length() == strongest_extension.length()) {\n           \
    \ if (ext.compare(strongest_extension) == 0) {\n                strongest_extension\
    \ = class_name + \".\" + ext;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) ==\
    \ (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
    nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\"\
    , \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"\
    __YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"\
    Ta\", \"TAR\", \"t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"\
    __HAHA\"), (std::vector<std::string>({\"Tab\", \"123\", \"781345\", \"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"\
    ));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"\
    _\"), (std::vector<std::string>({\"Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"\
    Sp\"), (std::vector<std::string>({\"671235\", \"Bb\"}))) == (\"Sp.671235\"));\n\
    }\n"
  status: Exception
  stderr: 'tmpnqcuwiy8: /tmp/tmpnqcuwiy8.cpp:42: int main(): Assertion `candidate(("Watashi"),
    (std::vector<std::string>({"tEN", "niNE", "eIGHt8OKe"}))) == ("Watashi.eIGHt8OKe")''
    failed.

    '
  stdout: ''
  timestamp: 1660123330
